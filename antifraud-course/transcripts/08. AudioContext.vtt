WEBVTT

00:00.000 --> 00:01.940
Приветствую, с вами Вектор Т13.

00:02.460 --> 00:06.780
На прошлом уроке мы с вами рассмотрели тест производительности WebGL

00:06.780 --> 00:15.320
и каким образом с помощью данной технологии есть возможность определить использование виртуальных машин, антидетектов, ВПС и прочего.

00:16.320 --> 00:20.020
В этом уроке мы продолжим эту же серию экспериментов,

00:20.600 --> 00:24.460
однако уделим внимание совершенно противоположной технологии.

00:24.460 --> 00:29.800
Если раньше мы говорили по поводу видео, то сейчас мы будем говорить по поводу аудио.

00:30.000 --> 00:33.240
А именно, теста производительности аудио.

00:33.620 --> 00:37.440
Как мы видим сейчас на своих экранах, на реальном компьютере,

00:37.820 --> 00:42.240
производительность теста аудио составляет 2,30 миллисекунд.

00:42.920 --> 00:45.360
Но из чего состоит отпечаток аудио?

00:45.820 --> 00:53.180
Возможно, я вас удивлю, но отпечаток аудио практически не имеет отношения к отпечатку аудио.

00:54.580 --> 00:56.760
К аудиосистеме, я имею в виду.

00:57.480 --> 00:59.980
Что такое? Давайте немного поговорим.

01:00.000 --> 01:01.380
Вспомним историю.

01:02.020 --> 01:07.940
31 марта 2018 года данный сайт прекратил свое существование,

01:08.040 --> 01:12.820
но наверняка он знаком всем вам, потому что еще в далеком 2015 году

01:12.820 --> 01:16.260
группой студентов из Принстонского университета США

01:16.260 --> 01:24.520
был обнаружен непонятный отпечаток, непонятная технология на таких ресурсах, как Google и Facebook.

01:25.540 --> 01:28.860
Тогда все подумали, что это аудио отпечаток.

01:28.860 --> 01:29.860
Почему? Потому что...

01:30.000 --> 01:32.740
Он носит название аудиоконтекст.

01:32.740 --> 01:38.320
Давайте же найдем сейчас данный веб-ресурс и проверим наш отпечаток.

01:38.320 --> 01:43.320
Мы нажимаем кнопку Fingerprint Me и вот он, наш отпечаток.

01:43.320 --> 01:49.060
Чудесно, красиво, все хорошо, но что же он в себе хранит?

01:49.060 --> 01:55.400
Пользователи, также как и SwapGL, они хотят этот отпечаток менять.

01:55.400 --> 01:59.820
Давайте разберемся, почему это абсолютно непонятно.

02:00.420 --> 02:04.860
Глупое и, более того скажу, опасное занятие.

02:05.860 --> 02:06.260
Первое.

02:07.080 --> 02:12.000
Вот визуализация якобы нашего отпечатка, но давайте мы посмотрим на то,

02:12.080 --> 02:14.120
как выглядит он немного по-другому.

02:14.940 --> 02:18.460
По факту, вот наш аудио отпечаток.

02:18.760 --> 02:19.160
Вот он.

02:20.420 --> 02:23.360
Получен двумя различными методиками.

02:24.400 --> 02:28.000
Некоторые пользователи думают, что отпечаток...

02:28.000 --> 02:29.260
Вот он.

02:30.000 --> 02:36.000
Он более, скажем так, понятен, он больше похож на какой-нибудь хэш, например, на хэш MD5, что-нибудь такого плана.

02:36.000 --> 02:40.000
И, соответственно, людям более привычно это.

02:40.000 --> 02:52.500
Но, если вы воспользуетесь историей, а точнее воспользуетесь вашим компьютером и скачаете туда все последние, например, последние 100 версий браузера Chrome,

02:52.500 --> 02:57.960
то вы увидите, что данный отпечаток, к примеру, вот тот, который сейчас вы видите у себя на экране,

02:57.960 --> 02:59.880
он будет одинаковым.

02:59.880 --> 03:03.760
Он будет одинаков в браузере Chrome, в браузере Opera, в браузере Edge.

03:04.240 --> 03:06.960
На моем компьютере и на ваших компьютерах тоже.

03:08.120 --> 03:12.740
И если мы будем проверять с вами этот отпечаток на...

03:12.740 --> 03:14.880
Сейчас у нас 138-я версия Chrome.

03:15.540 --> 03:23.220
Если мы с вами будем скачивать по одной версии назад, то есть 137-ю, 136-ю, 135-ю,

03:23.420 --> 03:27.980
то мы с вами можем дойти аж до 98-й версии.

03:29.880 --> 03:34.280
С 98-й по 138-ю этот отпечаток нигде не будет меняться.

03:34.480 --> 03:40.880
В то же время на 98-й версии он изменится и будет изменяться аж до 92-й версии.

03:41.700 --> 03:46.140
Суть данный отпечаток, это отпечаток аудиодвижка.

03:47.160 --> 03:51.960
И если аудиодвижок не меняется, то и отпечаток этот меняться тоже не должен.

03:52.820 --> 03:57.000
К сожалению, некоторые владельцы сайтов-чекеров,

03:58.280 --> 03:59.000
они используют...

03:59.880 --> 04:02.260
данный отпечаток в своих маркетинговых целях,

04:02.320 --> 04:03.800
потому что его очень легко подменить.

04:04.240 --> 04:07.780
Подменяется он элементарно просто даже правкой реестра.

04:08.560 --> 04:11.040
Но делать этого, конечно же, не стоит.

04:11.040 --> 04:12.320
Объясню по какой причине.

04:12.920 --> 04:15.040
Дело в том, что если у этого отпечатка нет вариативности,

04:15.960 --> 04:18.300
то есть у него есть всего-навсего одно значение,

04:19.080 --> 04:21.040
то и подменять его является полным идиотизмом.

04:22.440 --> 04:26.860
Но в то же время на этот идиотизм некоторые пользователи с удовольствием клюют,

04:27.380 --> 04:29.620
не разобравшись в технологии самого...

04:29.880 --> 04:30.880
отпечатка.

04:31.380 --> 04:31.880
Но!

04:32.260 --> 04:35.700
Имеет ли данный отпечаток какое-либо отношение к аудио?

04:36.760 --> 04:37.760
Фактически не имеет.

04:39.480 --> 04:40.480
Объясню вам почему.

04:40.960 --> 04:42.960
Если вы возьмете компьютер,

04:43.760 --> 04:45.760
на котором нет аудиокарты,

04:46.980 --> 04:48.480
и выполните там этот тест,

04:49.480 --> 04:51.920
у вас этот тест будет завершен успешно.

04:52.420 --> 04:54.420
И там будут вот такого рода параметры.

04:55.720 --> 04:56.920
Почему же так происходит?

04:58.160 --> 04:59.120
Дело в том, что

04:59.120 --> 05:02.620
данный отпечаток не воспроизводит какой-либо звук.

05:03.060 --> 05:04.980
Он не записывает какой-либо звук.

05:05.740 --> 05:08.380
Он выполняется внутри самого браузера.

05:09.400 --> 05:13.000
И это, можно сказать, отпечаток,

05:13.440 --> 05:15.960
который формируется самим браузером.

05:17.040 --> 05:20.040
И практически, повторюсь, практически

05:20.040 --> 05:24.360
не имеет отношения к ПК-пользователю.

05:24.360 --> 05:28.760
Но все-таки определенная зависимость от ПК-пользователя

05:29.120 --> 05:30.120
есть.

05:30.120 --> 05:33.120
А именно, вот в этих двух отпечатках.

05:33.120 --> 05:37.120
Про вот этот и его аналог выше, вы можете забыть,

05:37.120 --> 05:40.120
они абсолютно бесполезны в нашем с вами деле.

05:40.120 --> 05:42.120
Но вот эти отпечатки,

05:42.120 --> 05:44.120
они хранят в себе намного больше секретов,

05:44.120 --> 05:46.120
чем вы можете себе представить.

05:46.120 --> 05:49.120
Дело в том, что данные отпечатки

05:49.120 --> 05:52.120
являются отпечатками процессора.

05:53.120 --> 05:55.120
Именно процессора.

05:55.120 --> 05:57.120
Поскольку они зависят

05:57.120 --> 05:58.120
от

05:58.120 --> 06:05.120
от скорости выполнения инструкций на вашем CPU.

06:06.120 --> 06:09.120
Вы когда-нибудь думали, что есть отпечаток процессора?

06:09.120 --> 06:11.120
Вот я вам его показываю.

06:11.120 --> 06:13.120
Конечно, сейчас некоторые люди могут возразить

06:13.120 --> 06:16.120
Вектор, ты говоришь полную чушь,

06:16.120 --> 06:19.120
потому что эти отпечатки можно изменить, например,

06:19.120 --> 06:23.120
путем изменения констант обработки аудио.

06:23.120 --> 06:26.120
И вы будете правы. Что я имею в виду?

06:26.120 --> 06:28.120
Например, у меня сейчас

06:28.120 --> 06:31.120
частота дискретизации 48000 Гц.

06:31.120 --> 06:34.120
Эта частота дискретизации выставлена

06:34.120 --> 06:38.120
в настройках звуковой карты на моем компьютере.

06:39.120 --> 06:41.120
Можно выставить другую частоту,

06:41.120 --> 06:43.120
можно выставить, например,

06:43.120 --> 06:45.120
192000 Гц,

06:45.120 --> 06:47.120
44100 Гц и так далее.

06:47.120 --> 06:49.120
Можно, в принципе, играться.

06:49.120 --> 06:52.120
Но на всех современных компьютерах,

06:52.120 --> 06:55.120
если мы берем семейство Windows,

06:55.120 --> 06:58.120
будет использоваться либо частота 48000 Гц,

06:58.120 --> 07:01.120
либо 44100 Гц.

07:01.120 --> 07:05.120
Другие частоты, они практически не используются.

07:05.120 --> 07:08.120
То есть шансы того, что они используются,

07:08.120 --> 07:11.120
0,0001.

07:11.120 --> 07:13.120
Да и если бы они использовались,

07:13.120 --> 07:16.120
таких частот существует всего-навсего,

07:16.120 --> 07:18.120
я имею в виду не интерполированных,

07:18.120 --> 07:21.120
всего-навсего 8 штук.

07:21.120 --> 07:23.120
При изменении этой частоты,

07:23.120 --> 07:25.120
при изменении частоты дискретизации,

07:25.120 --> 07:27.120
вы действительно можете получить

07:27.120 --> 07:29.120
другой отпечаток.

07:29.120 --> 07:31.120
Почему так происходит?

07:31.120 --> 07:33.120
А потому что инструкция, которая будет

07:33.120 --> 07:37.120
выполнять вычисление данного отпечатка

07:37.120 --> 07:39.120
внутри вашего браузера,

07:39.120 --> 07:41.120
будет выполнять его с другими

07:41.120 --> 07:43.120
исходными данными.

07:43.120 --> 07:45.120
То есть, иными словами,

07:45.120 --> 07:47.120
с другой частотой дискретизации.

07:47.120 --> 07:49.120
Именно это является причиной того,

07:49.120 --> 07:51.120
что ваш отпечаток будет изменен.

07:51.120 --> 07:53.120
Но по факту,

07:53.120 --> 07:56.120
это не играет абсолютно никакой роли.

07:57.120 --> 08:00.120
Дело в том, что количество данных отпечатков

08:00.120 --> 08:03.120
на вашем ПК и на всех ПК,

08:03.120 --> 08:05.120
которые существуют, оно ограничено.

08:05.120 --> 08:09.120
Иными словами, вы можете на своем компьютере,

08:09.120 --> 08:11.120
на своем физическом компьютере,

08:11.120 --> 08:15.120
можете сделать 2 разных отпечатка популярных

08:15.120 --> 08:18.120
и 8 отпечатков непопулярных.

08:18.120 --> 08:21.120
Точнее 6, прошу прощения.

08:21.120 --> 08:23.120
Что же делать дальше?

08:23.120 --> 08:25.120
С помощью вот этой технологии

08:25.120 --> 08:27.120
Audio Context можно, например, получить

08:27.120 --> 08:30.120
количество колонок,

08:30.120 --> 08:32.120
то есть устройств вывода.

08:32.120 --> 08:35.120
Можно здесь сделать одно устройство вывода,

08:35.120 --> 08:38.120
два, четыре, семь.

08:38.120 --> 08:40.120
Ну, это не имеет разницы.

08:40.120 --> 08:42.120
И абсолютно никаким образом

08:42.120 --> 08:45.120
не играет на формировании данного отпечатка.

08:45.120 --> 08:48.120
Можно изменить, например, битрейт.

08:48.120 --> 08:50.120
Его здесь, кстати, даже нету

08:50.120 --> 08:52.120
на данном чекере еще.

08:52.120 --> 08:54.120
Изменение битрейта воспроизведения

08:55.120 --> 08:57.120
точно также никаким образом

08:57.120 --> 09:00.120
не влияет на сам отпечаток.

09:00.120 --> 09:02.120
Но это мы сейчас поговорили с вами

09:02.120 --> 09:04.120
только лишь о отпечатках

09:04.120 --> 09:06.120
и их вариативности.

09:06.120 --> 09:08.120
Как вы думаете,

09:08.120 --> 09:10.120
есть ли смысл

09:10.120 --> 09:13.120
изменять данный отпечаток,

09:13.120 --> 09:16.120
если его выполнение,

09:16.120 --> 09:19.120
фактически формирование и выполнение

09:19.120 --> 09:21.120
на всех современных ПК

09:21.120 --> 09:23.120
будет плюс-минус одинаковое?

09:23.120 --> 09:24.120
То есть да, конечно,

09:24.120 --> 09:26.120
если вы возьмете, например,

09:26.120 --> 09:31.120
сейчас какой-нибудь 64-ядерный процессор

09:31.120 --> 09:34.120
современный и затем сравните его

09:34.120 --> 09:36.120
с двухядерным старым Intel,

09:36.120 --> 09:40.120
ну, здесь, очевидно, разница будет.

09:40.120 --> 09:42.120
Но если мы берем, например,

09:42.120 --> 09:44.120
то же самое более унифицированное

09:44.120 --> 09:47.120
семейство Intel, например, i7,

09:47.120 --> 09:51.120
отпечаток везде плюс-минус будет одинаковый.

09:51.120 --> 09:53.120
За исключением усеченных моделей.

09:53.120 --> 09:55.120
Точно так же в пятом семействе,

09:55.120 --> 09:58.120
точно так же в семействе Ryzen, например,

09:58.120 --> 09:59.120
и так далее.

09:59.120 --> 10:01.120
Можно приводить различного рода примеры.

10:01.120 --> 10:03.120
Тогда, когда он появился,

10:03.120 --> 10:08.120
в 2013 году он впервые был создан,

10:08.120 --> 10:11.120
замечен он был в 2015 году как рабочий.

10:11.120 --> 10:14.120
Он использовался действительно

10:14.120 --> 10:17.120
для определения ботов.

10:17.120 --> 10:20.120
Но каким образом он использовался?

10:20.120 --> 10:22.120
А я вам сейчас покажу.

10:23.120 --> 10:26.120
Точно так же, как использовался

10:26.120 --> 10:28.120
отпечаток WebGL,

10:28.120 --> 10:31.120
точно так же использовался и отпечаток аудио.

10:31.120 --> 10:33.120
Дело в том, что,

10:33.120 --> 10:37.120
выполняя процедуру получения данного отпечатка

10:37.120 --> 10:41.120
и выполняя процедуру получения производительности,

10:41.120 --> 10:43.120
которую вы видите сейчас на своих экранах,

10:43.120 --> 10:46.120
есть возможность определения, опять же,

10:46.120 --> 10:48.120
использования ботов.

10:48.120 --> 10:51.120
Насрать всем на то, какой у вас отпечаток.

10:51.120 --> 10:55.120
Можете его менять хоть 10 000 раз.

10:55.120 --> 10:59.120
В этом никакого эффекта вы не добьетесь.

10:59.120 --> 11:01.120
А вот производительность его,

11:01.120 --> 11:04.120
вот это уже совершенно другой и интересный момент.

11:04.120 --> 11:07.120
Но если в случае с WebGL

11:07.120 --> 11:09.120
количество кадров оно падало,

11:09.120 --> 11:12.120
то есть значение уменьшалось этого показателя,

11:12.120 --> 11:15.120
то в разрезе аудио отпечатка

11:15.120 --> 11:17.120
оно будет увеличиваться.

11:17.120 --> 11:20.120
Ведь поскольку, если ваш процессор,

11:21.120 --> 11:24.120
не является быстрым,

11:24.120 --> 11:28.120
либо же используется какая-либо виртуальная машина,

11:28.120 --> 11:33.120
то время на выполнение данного запроса

11:33.120 --> 11:36.120
и получение данного бенчмарка

11:36.120 --> 11:41.120
будет составлять примерно 45-50 миллисекунд.

11:41.120 --> 11:44.120
А соответственно, с помощью данной,

11:44.120 --> 11:46.120
опять же, элементарной технологии,

11:46.120 --> 11:49.120
такой же элементарной, как WebGL,

11:49.120 --> 11:52.120
в 2015 году

11:52.120 --> 11:55.120
Google не пытался идентифицировать пользователей.

11:55.120 --> 11:58.120
Он пытался отделить ботов

11:58.120 --> 12:00.120
от реальных пользователей.

12:00.120 --> 12:04.120
И в частности, данная технология, что интересно,

12:04.120 --> 12:08.120
являлась, скажем так, фундаментом

12:08.120 --> 12:12.120
для появления таких сервисов, как reCAPTCHA.

12:12.120 --> 12:16.120
Поскольку она действительно отличнейшим образом

12:16.120 --> 12:18.120
позволяла определить ботов.

12:18.120 --> 12:21.120
Ведь, давайте возьмем нашу табличку сравнения.

12:21.120 --> 12:27.120
Технология получения аудио-бенчмарка

12:27.120 --> 12:29.120
позволяет определить использование VPS.

12:29.120 --> 12:32.120
Как мы понимаем, на VPS используются

12:32.120 --> 12:37.120
не физические ядра, скажем так,

12:37.120 --> 12:39.120
а в основном это sharing ядер.

12:39.120 --> 12:41.120
Либо же, если мы вдруг найдем сервис,

12:41.120 --> 12:43.120
на котором будут действительно использоваться

12:43.120 --> 12:45.120
реальные ядра процессора,

12:45.120 --> 12:47.120
за счет того, что инструкции будут выполнять,

12:47.120 --> 12:49.120
не напрямую на процессоре,

12:49.120 --> 12:52.120
а будут выполняться в эмуляции,

12:52.120 --> 12:55.120
то значение аудио будет повышено

12:55.120 --> 12:58.120
до 45-50 миллисекунд за выполнение.

12:58.120 --> 13:02.120
В отличие от 1,5 или 2,5 секунд,

13:02.120 --> 13:05.120
которые будут затрачены на выполнение

13:05.120 --> 13:08.120
данной инструкции на реальном ПК.

13:08.120 --> 13:12.120
Также, с помощью данной технологии аудио-бенчмарка

13:12.120 --> 13:14.120
есть возможность вычислить

13:14.120 --> 13:16.120
использование виртуальных машин.

13:16.120 --> 13:19.120
Виртуалбокс, ВМВР, Проксмокс,

13:19.120 --> 13:21.120
Квему и всех остальных.

13:21.120 --> 13:23.120
Почему так происходит?

13:23.120 --> 13:25.120
Дело в том, что, опять же,

13:25.120 --> 13:27.120
данная инструкция будет сначала

13:27.120 --> 13:30.120
выполнена внутри виртуального компьютера,

13:30.120 --> 13:33.120
и только затем будет передана

13:33.120 --> 13:35.120
на выполнение на реальный ПК.

13:35.120 --> 13:39.120
И за счет вот этой разницы в передаче данных

13:39.120 --> 13:43.120
будет сформировано довольно долгое время

13:43.120 --> 13:45.120
отклика и долгое время выполнения.

13:45.120 --> 13:47.120
Что будет свидетельствовать о том,

13:47.120 --> 13:49.120
что перед нами используется либо ВПС,

13:49.120 --> 13:51.120
либо виртуальная машина,

13:51.120 --> 13:53.120
что по факту есть одно и то же.

13:53.120 --> 13:56.120
Соответственно, пункт номер три.

13:56.120 --> 13:58.120
Использование антидетект браузеров

13:58.120 --> 14:03.120
внутри ВПС является абсолютно глупым занятием.

14:03.120 --> 14:05.120
Потому что, даже если вы не будете

14:05.120 --> 14:07.120
включать подмену отпечатка аудио,

14:07.120 --> 14:10.120
что есть правильное действие,

14:10.120 --> 14:12.120
но вы будете все равно запускаться на ВПС,

14:12.120 --> 14:14.120
у вас будут видеть виртуальную машину.

14:15.120 --> 14:18.120
Это факт.

14:18.120 --> 14:20.120
И с ним не поспоришь.

14:20.120 --> 14:22.120
Далее.

14:22.120 --> 14:26.120
Удаленный сервер плюс антидетект браузер.

14:26.120 --> 14:28.120
У меня он дублирован здесь.

14:28.120 --> 14:33.120
Как в хорошем пункте, так же и в плохом.

14:33.120 --> 14:35.120
Теперь давайте включим немного логику.

14:35.120 --> 14:38.120
Почему же использование удаленного сервера

14:38.120 --> 14:41.120
и антидетект браузера может вызывать

14:41.120 --> 14:43.120
какого-либо рода проблемы.

14:43.120 --> 14:45.120
Дело в том, что

14:45.120 --> 14:49.120
по умолчанию при использовании удаленных серверов

14:49.120 --> 14:51.120
конечно же у нас есть возможность

14:51.120 --> 14:55.120
использовать ресурсы процессора напрямую.

14:55.120 --> 14:58.120
Это нормально, это хорошо.

14:58.120 --> 15:01.120
Но здесь есть одна очень важная деталь.

15:01.120 --> 15:03.120
Эта деталь заключается в том,

15:03.120 --> 15:06.120
что если вы запускаете,

15:06.120 --> 15:10.120
а точнее используете данную технологию

15:10.120 --> 15:13.120
на серверном оборудовании,

15:13.120 --> 15:17.120
время отклика у вас будет нечто среднее

15:17.120 --> 15:22.120
между реальным компьютером и виртуальной машиной.

15:22.120 --> 15:24.120
По какой причине?

15:24.120 --> 15:27.120
Дело в том, что на скорость выполнения данной операции

15:27.120 --> 15:30.120
влияет частота процессора.

15:30.120 --> 15:32.120
И в большинстве случаев,

15:32.120 --> 15:35.120
когда пользователи арендуют удаленные сервера,

15:35.120 --> 15:37.120
они обращают внимание почему-то

15:37.120 --> 15:39.120
только лишь на количество ядер,

15:39.120 --> 15:41.120
но не на тактовую частоту процессора.

15:41.120 --> 15:44.120
А соответственно, если вы будете выполнять данный тест

15:44.120 --> 15:48.120
на удаленном сервере с низкой тактовой частотой,

15:48.120 --> 15:50.120
например 2 ГГц,

15:50.120 --> 15:52.120
какой-нибудь старый Intel Xeon,

15:52.120 --> 15:55.120
то к сожалению антибот-система

15:55.120 --> 15:58.120
увидит, что используется серверное оборудование.

15:58.120 --> 15:59.120
Почему?

15:59.120 --> 16:01.120
Потому что вот этот вот бенчмарк

16:01.120 --> 16:03.120
он не будет соответствовать

16:03.120 --> 16:05.120
ни реальному компьютеру,

16:05.120 --> 16:07.120
ни ВПС,

16:07.120 --> 16:09.120
а будет соответствовать

16:09.120 --> 16:11.120
четко именно

16:11.120 --> 16:12.120
удаленным серверам.

16:12.120 --> 16:14.120
Конечно же, здесь можно сделать поправку,

16:14.120 --> 16:17.120
что такого бенчмарка можно добиться

16:17.120 --> 16:20.120
и при использовании очень старого оборудования.

16:20.120 --> 16:22.120
И да, действительно так и есть,

16:22.120 --> 16:24.120
но скажем так,

16:24.120 --> 16:26.120
в антибот-системах нет

16:26.120 --> 16:28.120
практически параметров,

16:28.120 --> 16:30.120
которые являлись бы абсолютными.

16:30.120 --> 16:32.120
То есть, иными словами,

16:32.120 --> 16:34.120
все складывается, общая картина

16:34.120 --> 16:36.120
и мнение пользователей складывается

16:36.120 --> 16:38.120
из различных параметров,

16:38.120 --> 16:40.120
из различных идентификаторов,

16:40.120 --> 16:42.120
каждый из которых имеет свой собственный вес.

16:42.120 --> 16:44.120
И поэтому,

16:44.120 --> 16:46.120
если есть возможность этого избежать,

16:46.120 --> 16:48.120
то лучше избежать.

16:48.120 --> 16:50.120
Но если вы будете использовать антидетект браузеры

16:50.120 --> 16:52.120
на

16:52.120 --> 16:54.120
низких

16:54.120 --> 16:57.120
на серверах с низкой тактовой частотой,

16:57.120 --> 16:59.120
вас смогут определить.

16:59.120 --> 17:01.120
Ну и конечно же,

17:01.120 --> 17:03.120
антидетект от Vector T13

17:03.120 --> 17:05.120
в версии до V

17:05.120 --> 17:07.120
есть возможность определить использование виртуальной машины,

17:07.120 --> 17:09.120
поскольку точно так же

17:09.120 --> 17:12.120
будет долгое время отклика процессора.

17:12.120 --> 17:14.120
Какие системы нельзя определить

17:14.120 --> 17:16.120
с помощью данного отпечатка,

17:16.120 --> 17:18.120
данного бенчмарка?

17:18.120 --> 17:21.120
Нельзя определить EFI спуферы,

17:21.120 --> 17:23.120
что это такое, я не буду сейчас рассказывать,

17:23.120 --> 17:26.120
в прошлом уроке, где был пример с WebGL,

17:26.120 --> 17:28.120
мы об этом конкретно поговорили.

17:28.120 --> 17:30.120
Дальше.

17:30.120 --> 17:32.120
Нельзя будет использовать данный бенчмарк

17:32.120 --> 17:34.120
для определения удаленного сервера,

17:34.120 --> 17:36.120
но только лишь,

17:36.120 --> 17:38.120
если этот сервер с высокой тактовой частотой.

17:39.120 --> 17:41.120
Не забывайте об этом.

17:41.120 --> 17:43.120
И соответственно, пункт номер 3.

17:43.120 --> 17:45.120
У меня их целых три.

17:45.120 --> 17:47.120
Удаленный сервер

17:47.120 --> 17:49.120
с антидетект браузером,

17:49.120 --> 17:51.120
точно так же, как можно использовать,

17:51.120 --> 17:53.120
так же его нельзя использовать.

17:53.120 --> 17:55.120
Нельзя, мы поняли, почему можно,

17:55.120 --> 17:57.120
если у нас высокая тактовая частота,

17:57.120 --> 17:59.120
то данный тест

17:59.120 --> 18:01.120
будет выполнен на отлично,

18:01.120 --> 18:03.120
никаких проблем не будет.

18:03.120 --> 18:05.120
Либо же, если антидетект браузер запущен

18:05.120 --> 18:07.120
на реальном компьютере,

18:07.120 --> 18:09.120
то тоже самое.

18:09.120 --> 18:11.120
Реальный ПК, реальная частота процессора,

18:11.120 --> 18:13.120
быстрое время отклика,

18:13.120 --> 18:15.120
все отлично.

18:15.120 --> 18:17.120
И также,

18:17.120 --> 18:19.120
если вы будете запускать данный тест

18:19.120 --> 18:21.120
на антидетекте с CPU Boost.

18:21.120 --> 18:23.120
Дело в том, что

18:23.120 --> 18:25.120
есть возможность

18:25.120 --> 18:27.120
практически во всех виртуальных машинах

18:27.120 --> 18:29.120
сделать CPU Boost.

18:29.120 --> 18:31.120
То есть, первый вариант

18:31.120 --> 18:33.120
это сделать трассировку

18:33.120 --> 18:35.120
таким образом,

18:35.120 --> 18:37.120
чтобы все инструкции выполнялись

18:37.120 --> 18:39.120
не на виртуальном процессоре,

18:39.120 --> 18:41.120
а на реальном процессоре.

18:41.120 --> 18:43.120
Такая возможность действительно есть.

18:43.120 --> 18:45.120
Либо же, второй вариант

18:45.120 --> 18:47.120
это выделение большого количества

18:47.120 --> 18:49.120
ресурсов

18:49.120 --> 18:51.120
и работа с таймингами

18:51.120 --> 18:53.120
внутри самого исходного кода

18:53.120 --> 18:55.120
виртуальной машины.

18:55.120 --> 18:57.120
Это уже очень сложная машинерия

18:57.120 --> 18:59.120
и доступно это только сейчас

18:59.120 --> 19:01.120
в антидетекте от Vector T13.

19:01.120 --> 19:03.120
Как же определить

19:03.120 --> 19:05.120
данный

19:05.120 --> 19:07.120
аудиоконтекст?

19:07.120 --> 19:09.120
Тест, который мы проводили

19:09.120 --> 19:11.120
с вами с помощью определения

19:11.120 --> 19:13.120
затрат на

19:13.120 --> 19:15.120
выполнение данного действия

19:15.120 --> 19:17.120
к сожалению, в данном случае

19:17.120 --> 19:19.120
не работает.

19:19.120 --> 19:21.120
Увы, потому что если мы попытаемся

19:21.120 --> 19:23.120
выполнить конкретно эту инструкцию

19:23.120 --> 19:25.120
на ее выполнение у нас уйдет

19:25.120 --> 19:27.120
те же самые 16-20

19:27.120 --> 19:29.120
миллисекунд. То есть, практически

19:29.120 --> 19:31.120
вы не сможете ее обнаружить.

19:31.120 --> 19:33.120
Однако, данная технология

19:33.120 --> 19:35.120
великолепно, простым образом

19:35.120 --> 19:37.120
определяется с помощью любого браузерного

19:37.120 --> 19:39.120
плагина для Firefox или Chrome,

19:39.120 --> 19:41.120
который позволяет определить

19:41.120 --> 19:43.120
использование аудиоконтекст

19:43.120 --> 19:45.120
на странице веб-ресурса.

19:45.120 --> 19:47.120
Поэтому, когда вы будете

19:47.120 --> 19:49.120
смотреть на необходимый вам

19:49.120 --> 19:51.120
веб-ресурс

19:51.120 --> 19:53.120
и увидите там аудиоконтекст

19:53.120 --> 19:55.120
не думайте,

19:55.120 --> 19:57.120
что данный

19:57.120 --> 19:59.120
веб-ресурс

19:59.120 --> 20:01.120
получает отпечаток аудио.

20:01.120 --> 20:03.120
Помните, что это

20:03.120 --> 20:05.120
в большинстве случаев

20:05.120 --> 20:07.120
является всего-навсего антибот

20:07.120 --> 20:09.120
проверкой на предмет

20:09.120 --> 20:11.120
производительности вашего

20:11.120 --> 20:13.120
компьютера и отделения средств

20:13.120 --> 20:15.120
автоматизации от реальных пользователей.

20:15.120 --> 20:17.120
На этом все.

20:17.120 --> 20:19.120
Спасибо за внимание.

20:19.120 --> 20:21.120
С вами был VectorT13.

