Приветствую, с вами Вектор Т13.
В этом уроке мы познакомимся с вами с самыми таинственными отпечатками,
которые используются антифрод-системами, а именно с сетевыми отпечатками.
Почему их называют таинственными?
Дело в том, что если мы рассмотрим тот же самый отпечаток Canvas, отпечаток WebGL и прочие,
они появились в 2013-2014 году, то есть им уже более 10 лет.
Количество чекеров, огромное количество информации, еще больше,
и поэтому людям эти технологии понятны.
Но, к сожалению, сетевые отпечатки намного сложнее.
Ведь для того, чтобы понять, что веб-ресурс использует, например, технологию Canvas,
необходимо быть просто каким-нибудь джуном всего-навсего и немного уметь в JavaScript.
Или же даже просто не в JavaScript, а в язык разметки HTML.
Но, если мы говорим о сетевых отпечатках,
обнаружить их невозможно благодаря анализу исходного кода веб-ресурса.
Соответственно, мы не можем нажать правой кнопкой мышки на интересующей нас веб-странице
и посмотреть, используется ли там Canvas или используется ли там WebGL.
По сути, сетевые отпечатки являются для юзера абсолютно невидимыми.
Но это добавляет им значимости,
потому что мы никогда не знаем,
с каким конкретно ресурсом мы работаем и что этот ресурс от нас хочет.
Но все же некоторые методы есть.
Я вас сегодня с ними познакомлю.
Итак, что вы знаете о сетевых отпечатках?
Стандартно, что знает каждый пользователь, это то, что есть какие-то отпечатки,
которые якобы позволяют узнать, какую операционную систему мы используем.
Есть несколько чекеров.
Вот проект, на котором базируются все,
текущие современные паблик-чекеры.
Без разницы, какой ресурс вы не откроете,
где красивая картинка, либо же покажет вам какие-нибудь дополнительные параметры вашего соединения,
не имеет абсолютно никакого значения.
Вот самый оригинал.
И мы, собственно говоря, находимся на странице автора данного проекта.
Но об этом чуть позже.
Что мы видим сейчас перед собой?
Мы видим, если мы не являемся сетевиками,
то фактически наши все знания,
закончатся на первом блоке.
Ну, может быть, еще вот здесь мы увидим знакомое слово Windows.
Больше ничего.
Что означает, например, вот этот параметр,
что означает этот параметр,
мы абсолютно не знаем, не понимаем,
и по факту оно нам не нужно.
Но, тем не менее,
если мы посмотрим на то, как называется этот блок,
мы, может быть, догадаемся,
что действительно это какое-то отношение к отпечатку имеет.
Теперь рассказываю популярно,
как это работает.
Перед вами так называемый проект Zarduxt.
Вы можете ознакомиться с ним
на его официальной странице
на веб-ресурсе GitHub.
Вот он.
Адрес вы можете увидеть
вверху данного видео.
Данный проект
и, собственно говоря, его автор
Николай
представлены здесь, на данной странице.
Данный проект был разработан
более двух лет назад,
то есть 2023 год,
и выполнял роль анализа
и определения операционной системы
благодаря анализу TCP заголовков.
Как вы знаете, мы общаемся с веб-ресурсами
благодаря TCP и UDP пакетам.
Это два самых основных протокола.
Конечно же, есть еще и протокол Quick.
Про него тоже не стоит забывать.
Так вот, когда происходит
TCP соединение,
инициализация TCP соединения,
происходит диалог
между клиентом и сервером.
Когда для оптимальной передачи данных
происходит обмен информацией,
иными словами,
веб-ресурс и клиент
идентифицируют друг друга.
То есть клиент говорит,
я принимаю такие-то и такие-то параметры.
Веб-ресурс говорит, окей,
я под тебя подстраиваюсь,
пожалуйста, вот тебе такие параметры
как параметры передачи данных,
как ты сообщил,
для того, чтобы у тебя была максимальная
эффективность твоей работы.
Все.
Вот, собственно говоря, отсюда
и начинается проблема.
Проблема заключается в том,
что параметры, которые используются
для того, чтобы коммуницировать
с веб-ресурсом,
то есть эти заголовки TCP пакетов,
которые определяют,
как будут переданы данные,
они могут использоваться
для идентификации пользователя.
Они могут использоваться, в первую очередь,
для идентификации операционной системы,
ну и, конечно же,
для того, чтобы понять,
кто стоит перед этим веб-ресурсом.
Раньше был проект,
который назывался POF,
Passive OS Fingerprint.
Данный проект входил
в еще более знаменитый проект
под названием NMAP.
И на тот момент идентификация
операционной системы
проходила очень просто.
Фактически она проходила
по параметрам TTL и MTU
.
То есть максимальный размер пакета
и время жизни пакета.
Поскольку, собрав определенную статистику
на момент появления проекта POF
в 2004 году,
можно было понять, что
про эти технологии передачи данных
никто фактически нормально не знает.
И, соответственно, у Windows, например,
параметр MTU,
который у нас представлен здесь
в качестве MSS,
всегда равен, например, 1500,
1440,
1280 и так далее.
То есть определенный набор
просто-напросто переменных.
У операционной системы Linux
этот набор другой,
у Android или macOS,
соответственно, тоже отличающийся.
Так было
на протяжении многих лет.
И проект
Zardust, который вы видите сейчас перед собой,
являлся
фактически, можно сказать,
публичным первопроходцем.
И благодаря этому проекту
мы сейчас можем понять,
как эта система функционирует
наглядно. Потому что, конечно же,
те знания, которые у нас есть в теории
в нашей голове, это одно.
Это все продемонстрировано на практике,
и это совершенно другое.
В частности, мы можем уже отойти
от данного веб-ресурса,
респект его автору, конечно же,
и перейти, например, на тот же самый
ресурс BrowserLix,
где более подробно это описано.
Если вдруг вы не знаете,
как увидеть эти заголовки TCP-пакетов,
вам необходимо перейти на вкладку IP
и затем нажать на
гиперссылку TCP IP Fingerprint.
Ну, вот здесь вы теперь
видите название полей,
то есть это более информативно
и более удобно.
И вы можете понять, какое поле
за что отвечает.
Фактически, и вот мы видим даже
здесь точно также Zardax OS scoring.
Фактически,
на этом все.
Больше сказать об этом проекте
нечего.
Ну, так на первый взгляд.
Откуда берутся вот эти данные?
Как вы думаете,
являются ли эти данные абсолютом?
То есть, что я имею в виду?
Я имею в виду, что
100% ли они правильные?
К сожалению, нет. Я объясню, почему.
Дело в том, что вот эти данные,
они мало того, что имеют
очень маленькую энтропию, во-вторых,
они собраны были
2 года назад, более чем 2 года назад.
И вы можете ознакомиться с этим
в самом проекте Zardax.
Если вы запустите данный проект
на своем сервере,
то вы будете видеть, что у вас он
не работает. Почему он не работает?
Потому что базы данных пустые.
И
самое ценное в данном проекте
это базы данных.
Автор оставил здесь все
базы данных, которые он использовал.
И самая основная база данных
называется newclinet.json
И вот мы можем
видеть, как
и какие параметры
отвечают за ту или
иную операционную систему.
Соответственно,
когда происходит ситуация,
при переходе на сайт
BrowserLeaks,
при переходе на сайт
оригинальный сайт Checker,
либо же на какой-нибудь другой красивый
раскрашенный веб-ресурс,
который является якобы
чекером TCP пакетов,
вы всегда будете работать
с этими базами данных.
И, соответственно, если вы соответствуете,
если ваши параметры данных
соответствуют данной
записи в базе данных,
будет выведено определенное значение
того, какую операционную систему
вы используете.
Это основная
фишка проекта Zardext.
И
к отпечатку, как таковому,
как вот написано здесь у нас
TCP IP Fingerprinting,
это практически не имеет
значения, потому что
здесь у нас не создается какой-то
сверхуникальный отпечаток.
Зачем же в таком случае
данный проект может
использоваться?
Данный проект
является всего-навсего
определенной запчастью,
но никак не полностью
самим механизмом.
Я вам сейчас расскажу то, что вы
еще не знаете. Кстати,
хотелось бы упомянуть, что откуда берутся
параметры передачи данных?
Вот если вы зайдете, например,
в свойства своей сетевой карты, вы можете
много здесь интересного найти.
И, в частности, изменив данные
параметры, вы можете
изменить свой
якобы отпечаток.
Но, по факту, всего-навсего вы можете
изменить операционную систему.
Что же такое?
Почему нам этот проект
важен? Почему нам
важен и каким образом он
работает? Дело в том, что
данный проект, он не
является в рамках антифрод
систем самостоятельным.
Почему так происходит?
Определение операционной системы действительно
важно. Действительно важно,
потому что мы можем, например,
с помощью проекта Zardex определить,
когда используется OpenVPN.
Это важно? Это да, это действительно
важно. Потому что, если мы
в нашем
юзер-агенте сообщаем, что мы
используем операционную систему Windows,
а, например, благодаря
TCP IP,
будем его называть, ладно, отпечатку,
у нас операционная система
Linux, то, соответственно,
мы можем добавить очков
фродо и таким образом
не пропустить пользователя
сделать то или иное действие.
В частности, проект, который
называется
TreatMetrix от
компании LexisNexis,
использовал данный продукт
для того, чтобы
определять использование VPN.
И используют его успешно
до сих пор. Но, как я
и говорил, есть определенная
комбинация параметров.
Эта комбинация состоит из
стека протоколов. Если TCP
протокол, это всего-навсего один протокол.
И по факту, ну вот
он вам даст, вот ваш отпечаток,
можно сказать так. Но вариативность
его довольно маленькая.
Вот операционная система.
Все, на этом его полномочия
заканчивается. Вам не нужно смотреть
и заморачиваться, что значит вот этот
флажок или что значит, например, этот флаг.
Забудьте и не забивайте
себе голову, если вы не сетевик, вы все равно
этого не запомните.
Сетевой
отпечаток
имеет два стека на
текущий момент.
Первый стек называется
M1D.
M1D это комбинация
протокола TCP,
получения заголовков из TCP пакетов,
который является очень информативным,
с
протоколом UDP.
То есть используется TCP UDP
стек.
Общее его название
в системах антифрода
называется M1D отпечаток.
M1D отпечаток
является намного
более информативным.
Дело в том, что сам UDP протокол,
если бы у нас был чекер, сейчас
публичных чекеров ни одного
не существует.
По крайней мере, мне они не известны.
А если бы
сейчас перед нами был не TCP
чекер,
а, например, UDP чекер,
количество параметров там можно было бы
сократить всего-навсего до 8.
Но,
благодаря тому, что мы можем
комбинировать эти параметры вместе с
протоколом TCP,
мы получаем отличную
вариативность данных,
которая приводит нас к
идентификации, первое,
к идентификации пользователя,
второе, к идентификации бота,
третье, к идентификации
сокса, четвертое,
к идентификации OpenVPN,
четвертое, к идентификации
WireGuard,
шестое, L2TP,
седьмое, PP2P и так далее.
Именно за счет стека
TCP и UDP
протокола, то есть
стека M1D, есть возможность
определить, когда пользователь использует
OpenVPN
соединение и когда он использует
прокси, то есть, например, тот же самый
SOCKS. Это очень важно
и антифрод-системы на текущий момент
начинают
использовать данный проект.
Если мы посмотрим,
например, год назад,
то фактически ThreatMetrix
являлся, скажем так,
пионером
в этом деле, потому что
они первые начали использовать
систему идентификации.
Ну, точнее нужно сказать,
первые публично, есть
неофициальные данные, что также это
использовал Google.
Но, к сожалению, если
к продукту ThreatMetrix
доступ есть и мы можем посмотреть, что
находится внутри, то что находится внутри Google
мы посмотреть практически
не можем. И есть
еще. Если этот
проект позволяет идентифицировать
использование прокси, то есть
еще один проект, который
позволяет сделать это с невероятной
точностью.
Если вам будет интересно,
я оставлю здесь
ссылку на исследование
из Корнеллского университета США
и, в частности, вы
можете ознакомиться с
другими исследованиями
от данных авторов.
Мы можем нажать здесь кнопку View PDF
и мы переходим
к анализу
Квик протокола.
Самый
на текущий момент важный
стек, который есть, который
включает в себя TCP протокол,
UDP протокол
и, как вы догадались, все
вариации протокола Квик.
Квик не имеет одной вариации,
у него есть несколько различных вариаций,
несколько ответвлений, скажем так.
И стек M1D1
позволяет идентифицировать
пользователя
с вероятностью
95%.
Именно я имею в виду сейчас
идентификацию, то есть не то,
что вы, например,
не только определение использования VPN,
прокси и так далее,
а именно идентификацию пользователя
в качестве отпечатка.
Если, например,
M1D, стек протокола
TCP, UDP обеспечивает
лишь 60% эффективности,
60%
точности, то
стек M1D1, когда
используется TCP протокол, UDP протокол
и Квик протокол, обеспечивает
уже более 95%
и более процентов,
плюс-минус пол процента,
если не ошибаюсь, чуть более
95% идентификации
пользователей. И здесь
кстати, по этому поводу уже мы
100% знаем, что компания
всем известная Google
использует данный протокол,
данный стек в своей
экосистеме. Как
можно это определить
и какие еще данные можно
подсмотреть под нашему
веб-ресурсу? На самом
деле, любой анализ
веб-ресурса в первую очередь
начинается с анализа
его сетевой активности.
Сделать это, в частности
очень просто. Нам не потребуются
для этого сейчас никакие другие инструменты,
кроме нашего браузера.
В нашем браузере
есть вкладка,
которая называется
NetExport.
Благодаря вкладке NetExport
мы можем полностью
запечатать лог сетевой
активности. И в частности
вот смотрите,
при
использовании данного
данного
штатного инструмента Chrome,
все, что нам нужно сделать, нам
необходимо выбрать вот этот
параметр include raw bytes,
то есть полностью видеть
сырым трафик наш
и выставить лог, например,
в размере 20 мегабайт.
Всего-навсего. После чего
все, что от нас требуется, нажать на кнопку
start logging to disk.
Затем, после того, как вы это
сделали, вам необходимо посетить
целевой веб-ресурс.
То есть, будь то, например, платежная система,
банковский ресурс, либо еще какой-то.
Выполнив там определенное
действие, совершать это все
нужно как можно быстрее.
Выполнив там определенное действие,
вам необходимо остановить лог
и затем
этот лог необходимо проанализировать.
Конечно же, можно
из лога извлечь
огромное количество информации,
но я вам сейчас покажу
и не буду оперировать какими-то
заумными терминами, буду называть
все по-простому. Я вам покажу сейчас
что нужно просто обратить внимание.
Итак, для того, чтобы расшифровать
лог, нам необходим вот такой
веб-ресурс. Вы можете увидеть его
вверху
данного видео.
Netlog Viewer.
Нам необходимо перейти
на вкладку import и загрузить
сюда наш лог.
После чего у нас появляются
восхитительные
возможности.
Первая восхитительная возможность
является определением использования
UDP и
Qwik протокола
веб-ресурсом. Второе
это использование, например,
проверки DNS.
Третье использование
веб-сокета. Четвертое это использование
кэша и так далее.
Вариантов есть масса. Мы, кстати, можем
даже определить использование
кросс-браузер фингерпринта.
Довольно редкий зверь в текущее
время, но тем не менее некоторые ресурсы
этим балуются. И, соответственно,
можно
благодаря этому,
этой технологии, можно
из браузера Chrome,
например, идентифицировать пользователя
в браузере Edge на одном и том же компьютере.
Но об этом не сейчас.
Что нам необходимо сделать?
Мы переходим на вкладку Qwik.
Вот наша вкладка Qwik.
Отдельная.
И то, что нам нужно посмотреть,
нам нужно посмотреть на какой-нибудь
веб-ресурс, который мы анализируем.
Ну вот, в частности, например,
я выберу YouTube.
Вот у меня YouTube.
А у YouTube была инициирована
такая сессия.
Нажимаем на нее. И у нас
сейчас перед нами полная расшифровка
Qwik протокола, а именно
общение с веб-ресурсом
YouTube. Почему для нас
это важно? Дело в том,
что благодаря использованию
вот этого простейшего инструмента
вы можете определить,
когда используются
антифрод-системы.
В частности, когда
вы переходите на веб-ресурс,
пусть это будет даже YouTube,
вы, например, не знаете,
какая там антифрод-система используется.
И не знаете, если мы
приводили пример, Trade Matrix
используется там или не используется.
То благодаря тому, что вы перейдете
на YouTube
и затем проанализируете трафик,
вы сможете в логах
отследить
коннект к
веб-ресурсам
Trade Matrix.
И, соответственно, можете отследить
использование, например, того же
самого Quick Protocol из стека
M1D1.
Как я и говорил ранее, я не буду
сейчас уделять этому большое
внимание, поскольку
здесь огромное количество параметров,
которые участвуют в нашей работе,
в нашем
общении с веб-ресурсом,
и они составляют
великолепнейшую энтропию,
просто прекрасную.
Благодаря
этим довольно четким данным,
которые можно получить с помощью Quick Protocol
и комбинации с другими протоколами
TCP и UDP, есть возможность
идентифицировать пользователя
с вероятностью 95%.
Ну, а если мы говорим
о, например, экосистеме
Google, то здесь у нас
есть, давайте найдем сейчас,
где у нас
довольно важные параметры.
Вот посмотрите, сколько различной здесь
интересной информации.
Если хотите, можете, кстати,
скормить чату GPT
данную информацию, и он будет
вам очень благодарен.
В частности, у нас есть
вот такой вот
блок
В данном случае у веб-ресурса
благодаря использованию Quick Protocol
есть даже возможность определить
использование какого юзер-агента,
какой юзер-агент
используется пользователем.
Ну, а в рамках экосистемы
Google, например, есть возможность
определить, конечно же, наши
два любимых параметра
xBrowserValidation и xClientData.
На всякий случай,
если кто-нибудь не смотрел мои
предыдущие вебинары,
рассказываю. Параметр
xBrowserValidation показывает
экосистеме Google
является ли наш браузер валидным,
то есть, когда он был установлен,
как он был скачан,
с какого IP-адреса он был скачан
и так далее. То есть максимум
информации, которая зашивается
автоматически при загрузке
браузера с
веб-страницы Google.
Если хотите это проверить, можете
загрузить браузер
с обычного режима,
браузер Google Chrome, я имею в виду,
и затем создать, например, новую сессию
либо же использовать режим инкогнито
и загрузить этот
инсталляционный файл еще раз.
И при проверке MD5 хэша вы увидите,
что они отличаются. Но об этом мы говорили
уже давным-давно.
Таким образом,
Google всегда знает,
что происходит в его ботнете.
А по факту это чисто технологии
ботнета и никакие другие.
Ну а xClientData
позволяет идентифицировать якобы
экспериментальные возможности,
на самом деле просто более четкий
идентификатор, который позволяет
определить,
идентифицировать пользователя
в сети, экосистеме Google.
Ну, об этом
будем уже разговаривать,
когда будем разбирать антифрод-систему Google.
Пока просто
данные параметры. Смотрим на них
и запоминаем,
что такая возможность есть.
Если вы скормите данный
лог чату GPT,
вы можете увидеть множество интересной
информации о себе
и своем компьютере.
Если хотите посмотреть, что такое
протокол UDP, где он у нас,
убираем фильтр, и вот мы видим
например UDP-соединение.
Вот наше UDP-соединение
и оно
отличается по своей структуре,
но
тем не менее,
давайте UDP-сокет,
UDP-сокет у нас здесь.
Что-нибудь бы
показать более
красивое, ну ладно,
можем остаться в принципе
на этом.
Просто запоминайте и
в суть вникать, как это
пользуется, вам не важно.
Что же со всей этой информацией делать?
Потому что я вот вам сейчас много всего
рассказал, мы знаем,
что оно существует, но надо
каким-то образом этому
противоборствовать, потому что наша задача
в первую очередь
работать с антифрауд-системами и обходить их.
То есть мы поняли, как это работает
в теории, как это работает на практике
теперь. И сейчас
самая важная информация
из данного урока.
Дело в том, что пользователи
не понимают, как
изменить параметры данных протоколов
и каким образом
есть возможность
ими манипулировать.
Рассказываю и показываю наглядно.
Итак, прошу обратить
внимание на данную схему.
Это схема фактически
классического подключения
к интересующему нас
веб-ресурсу. Итак,
вот у нас есть наш пользователь,
наш юзер. И этот
юзер
посещает
необходимый ему веб-ресурс.
Как мы понимаем, что если мы
не будем использовать никакие средства
проксификации, то все наши
данные, то есть наши данные
заголовков TCP пакетов,
UDP пакетов и QUIC
будут беспрепятственно переданы
на интересующий нас веб-ресурс.
Но реальность
немного другая. Какие
у нас есть виды прокси?
Ну, под прокси мы подразумеваем
тоже еще и VPN. Какие у нас есть
виды промежуточных сетевых ресурсов,
которые позволяют изменить наш IP-адрес?
У нас есть VPN
и у нас
есть SOCKS5.
Два самых популярных метода
изменения IP-адреса.
И что же будет происходить, когда
мы будем посещать интересующий нас
веб-ресурс? Дело в том,
что когда вы будете использовать
технологию VPN, например
стандартный OpenVPN,
то веб-ресурс
будет видеть, всегда будет видеть
ваши реальные данные.
То есть данные, которые
переданы с вашего родного компьютера.
И технология VPN
не будет никаким образом
их модифицировать.
А значит, что вы являетесь
уязвимым перед
стеком M1D
и
также перед стеком
M1D1.
Вот такая
вот у вас происходит идентификация
при использовании
VPN.
Здесь нужно отметить,
конечно же, что
убить эту идентификацию довольно просто.
Можно, например,
взять и в свойствах браузера
отключить Quick Protocol.
Да, это не очень элегантно.
Как это делается?
У нас на последней версии Chrome, давайте посмотрим.
Вот он Experimental Quick Protocol.
Мы ставим ему
значение Disabled и после этого
у нас один из наших детектов,
а именно детект M1D1
пропадает.
И у нас остается менее
эффективный, но тем не менее все равно
остается детект M1D.
Просто запоминаем. Что же будет,
когда мы будем использовать
SOCKS5 сервер?
Когда мы будем использовать SOCKS5 сервер,
то интересующий нас
целевой веб-ресурс получит
уже данные не нашего компьютера,
а он получит данные SOCKS5.
То есть в данном случае
будет уже проходить определенного
рода подмена.
И в этом кроется довольно-таки большая проблема.
Объясню почему.
Потому что если
в случае использования
VPN мы путем
манипуляции на компьютере пользователя
можем изменить
последующий отпечаток,
переданный на VPN и соответственно
на интересующий веб-ресурс,
то для того, чтобы изменить
отпечаток, который будет передан
следующий SOCKS5,
нам необходимо быть владельцем
этого SOCKS5 сервера.
Но поскольку мы таковым не являемся,
то в данном случае всегда
целевой веб-ресурс
получит информацию
о нашем
SOCKS5 сервере.
И если это
какой-нибудь публичный прокси,
прокси-сервер,
то вряд ли хозяева этого сервера
будут заморачиваться тем,
чтобы подменять на каждом из
созданных серверов свои данные.
А это значит что?
А это значит то, что у нас при работе
всегда будет
один и тот же отпечаток
в рамках
использования одного прокси-сервера,
прокси-сервиса.
А если используется какая-нибудь
очень публичная технология,
скажем так,
которую можно скачать с GitHub,
то такой
отпечаток, он будет
скажем так,
характерен для абсолютно
всех SOCKS-серверов,
хоть от одного сервиса,
хоть от другого, хоть от третьего.
И будет всегда идентифицировать
пользователя как пользователя
SOCKS-сервера. Почему? Потому что
этот
отпечаток будет
построен у нас на базе
TCP-протокола, мы знаем это уже,
поскольку SOCKS5
очень часто не поддерживает
UDP-протокол. А значит,
будет идентификация операционной
системы с помощью проекта
Zardext, и
дальше наступает еще немного
магии. Возможно ли
идентификация здесь далее
с помощью проекта M1D,
стека M1D или стека
M1D1?
Как вы думаете? Давайте подумаем.
Если
веб-ресурс использует
какой-то
из
этих технологий, соответственно,
у нас есть три протокола.
Протокол TCP будет
работать с SOCKS5-сервером? Будет.
Протокол UDP будет?
Нет. Значит,
M1D и M1D1
уже работать не могут.
Будет ли
работать протокол QUIC?
Тоже не будет, потому что QUIC
основан на UDP-протоколе и работать
тоже не будет. Соответственно,
у нас из всех наших
протоколов остается всего-навсего один
протокол TCP.
И, в частности, остальные протоколы
будут заблокированы.
Такое поведение
не характерно для
реального пользователя,
а значит, это приведет нас
к чему?
К детекту прокси с вероятностью
100%.
Вот эффективность проекта
M1D и M1D1.
Соответственно, идем дальше.
Несмотря на то, что данные проекты
все равно являются
немного еще экспериментальными,
но многие антифрод-системы,
в частности банки и
по непонятному
стечению обстоятельств
некоторые магазины,
которые занимаются продажей игрового
вооружения, то есть для онлайн-игр,
они используют
данные технологии для
определения использования прокси.
Каким образом можно
в данной ситуации выжить?
Это будущее.
То есть, если сейчас мы можем сказать,
что, например, у меня там нормально
все проходит с каким-нибудь сайтом,
например, типа PayPal,
у меня все хорошо, все работает
и мне эти отпечатки не нужны.
Ну, конечно, вы понимаете, что
если мы посмотрим
10 лет назад,
хватало всего-навсего
одного плагина для браузера
Firefox для того, чтобы можно было
работать с PayPal.
Сейчас, к сожалению, это невозможно.
Я не зря упомянул PayPal, потому что
PayPal официально на своем веб-ресурсе
показывает, что они используют
антифрод-систему Threat Matrix.
Давайте, если сейчас быстро
получится...
Может быть, нам...
Ну, вот.
Нам даже ИИ сообщает,
что PayPal использует систему
Threat Matrix.
А значит, это что?
Threat Matrix является невероятно гибкой системой,
поэтому то, что PayPal сейчас может
не полностью включать данный механизм,
абсолютно не означает того,
что они, например,
не включат его через месяц
или, может быть, через день.
Может быть, даже когда я записываю сейчас этот урок,
они уже его включили.
Кто знает.
Но, тем не менее, я прошу вас обратить внимание,
поскольку именно Threat Matrix,
как я говорил ранее, является пионером
данной схеме,
а именно в стеке протоколов
M1D
и M1D1,
которые позволяют идентифицировать
прокси с вероятностью 100%
и 95%,
даже чуть больше,
идентифицировать самого пользователя.
Но как нам в данной
ситуации быть?
То есть мы разобрались, как работают
при передаче сетевого отпечатка
такие ресурсы, как SOX5
и VPN. Мы понимаем, что SOX5
фактически в ближайшее время
просто перестанет
существовать как таковой.
Ну, либо же появятся,
не стоит об этом даже так
плохо думать, возможно, появятся
какие-то проекты на GitHub,
которые позволят, во-первых, изменять
сами
константы передачи трафика,
также, возможно, добавится
и нормальная поддержка, работа
с Quick Protocol и с протоколом UDP.
Но, как минимум,
в данном случае есть еще одна проблема,
это проксификация, но не будем сейчас
уходить в этот темный лес.
Каким образом можно изменить
данные отпечатки?
К сожалению,
что касается Quick Protocol,
вы фактически поменять
ничего не сможете.
То есть то, как он будет передаваться,
зависит от вашего браузера
и от вашего UDP протокола.
А UDP протокол, в частности,
и параметры
передачи данных,
зависит ровно от тех же ресурсов,
от которых зависит и передача
TCP протокола.
А что это за ресурсы,
как я вам уже показывал ранее?
Это у нас наша сетевая карта.
Ну, это,
в частности, частично это сетевая
карта и частично
это параметры передачи
трафика вашей операционной
системы.
В операционной системе Windows
есть несколько различных
механизмов, которые управляют
трафиком. И, в частности,
ваша сама операционная система может
настроиться на те или иные параметры,
которые вам
передаются вашим
провайдерам, например.
И, в частности,
это и трафик менеджер,
и трафик инспектор,
и множество-множество других компонентов,
которые, просто запомните, что они
существуют. Захотите,
спросите у официальной справки
Microsoft в интернете.
Как можно изменить это?
Если вы используете
какое-либо специфическое программное обеспечение,
как, например, мой антидетект,
например, там
эта система подмены, она уже встроена,
она уже есть. Если вы
используете браузерные
антидетекты, то там
реализовать такого рода систему
подмены крайне сложно. Я на текущий
момент не знаю ни одного проекта, который мог
бы это
реализовать все в полном стеке.
Да, конечно, подменить, отпечатать
например, вот здесь,
не совсем это отпечаток, и вместо
например Linux показать
Windows. Такой проект я
встречал. Такой, по крайней мере,
один браузерный антидетект я встречал.
Но как он работает с
UDP протоколом, конечно же, мы не знаем
и работает ли он вообще. Дело в том,
что браузерные антидетекты в большинстве
своем, они используют встроенную систему
проксификации из браузера
Chrome. Система проксификации
браузера Chrome не поддерживает
работу с UDP. Сделать это
самому, ну, довольно сложно. Поэтому
что же делать, если вы
хотите использовать браузерный антидетект,
но не хотите
и не хотите переходить на какой-то другой,
но хотите подменять вот этот сетевой отпечаток.
Я вам сейчас покажу
абсолютно идиотский
вариант, но тем не менее этот идиотский
вариант до сих пор работает.
Есть замечательная утилита
под названием TCP
optimizer. Вот вы видите ее
и официальный сайт, на котором вы можете ее скачать.
С помощью данной
утилиты вы можете изменить как
параметры передачи трафика
вашей сетевой карты,
так и параметры передачи трафика
вашей операционной системы.
И благодаря этому
есть возможность изменить
отпечаток TCP,
есть возможность изменить
отпечаток UDP, а
соответственно в нашей с вами схеме
в таком случае будет изменен
при использовании VPN, будет изменен
и отпечаток M1D, и
отпечаток M1D1.
Что является великолепным
вариантом.
В частности я почему рекомендую
например вот эту утилиту. Я не настаиваю,
то есть если вам не хочется ее использовать,
вы можете ее не использовать.
Но данная утилита чем хороша?
Она проста в использовании
и каждый человек может ее
установить себе. Есть еще
варианты подобные
на GitHub,
но работа с ними может
у некоторых пользователей вызывать
определенного рода сложности.
Поэтому для начала я бы
рекомендовал вам поиграться
с данной утилитой.
И после того как вы уже научитесь
работать с ней, поймете как
с каким веб-ресурсом
она работает, например.
Но после этого вы можете перейти уже
к более серьезным решениям.
По факту можно
изменить очень
многое и
быть независимым от
каких-либо других программных
продуктов, потому что по факту
можно часть изменить через
командную строку, часть изменить через
реестр и работать
с вашим любимым
браузерным антидетектом.
Фактически
на этом можно было бы закончить
наш сегодняшний урок.
Но есть еще один
подводный камень, о котором
некоторые пользователи
либо не знают, либо забывают.
Давайте посмотрим
на нашу схему еще раз.
А теперь
опустимся немного ниже.
Сценарий
номер два.
Что добавилось в этом сценарии?
Правильно.
Добавилась малинка, а именно
Raspberry Pi.
Raspberry Pi
этот уникальный
микрокомпьютер
очень часто используется
пользователями в качестве средства
проксификации.
Это удобно, можно сразу же
накатить на него
прокси или необходимый
нам сокс и не бояться
утечек, потому что многие пользователи
почему-то боятся утечек как раз.
Так вот, здесь кроется одна очень важная
деталь. Дело в том, что
если вы будете использовать
Raspberry Pi,
он имеет свои параметры передачи
трафика.
И поскольку он будет являться
управляющим ресурсом,
то есть ресурсом, который будет управлять
им сетью NAT,
то
далее будут переданы
непосредственно
его параметры
передачи трафика.
А значит, что при использовании
например, того же самого VPN,
какие бы манипуляции
вы не проводили на своем компьютере,
вот манипуляции
с этим программным обеспечением
либо с его аналогами,
вы не сможете ничего сделать,
вы не сможете никаким образом изменить
параметры передачи трафика,
потому что он будет перезаписан
благодаря использованию
Raspberry Pi,
которая будет диктовать свои параметры
передачи трафика.
Поэтому я рекомендую обратить на это внимание
и
если вы используете какую-либо
специфическую прошивку,
вы будете использовать ее в операционной
системе Linux.
Изменить параметры передачи трафика
в операционной системе Linux
очень просто.
И по факту вы можете сделать следующее.
Вы можете самостоятельно
для себя написать небольшой bash скрипт,
который при запуске
будет рандомизировать
максимально параметры передачи трафика
и маскироваться под
интересующую нас операционную
систему Windows,
поскольку, повторюсь еще раз,
на малинке вы будете использовать Linux
и это не очень хорошо.
Так что рекомендую обратить на это внимание.
Так что рекомендую обратить на это внимание.
Вот этот сложный
на первый взгляд стек протоколов
TCP, UDP и Quick
является сейчас одной
из самых ведущих технологий,
которая используется
для определения бот трафика,
для определения прокси.
И я рекомендую вам данное видео
просмотреть несколько раз
для того, чтобы вникнуть и понимать
с каким веб-ресурсом вы работаете.
Ну и в частности,
Давайте также еще про вот этот замечательный инструмент, с помощью которого вы сможете отследить, использует ли интересующий вас веб-ресурс UDP, использует ли он, например, тот же самый Quick Protocol, а также, если вы зайдете еще и на вкладку DNS, вы можете найти еще много интересного и определить даже, когда данный веб-ресурс использует систему определения вашего DNS.
Реального вашего DNS, как мы учили с вами в предыдущих уроках.
Спасибо за внимание, с вами был Вектор Т13.
