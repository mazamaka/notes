---
title: "FastAPI -- Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ñ"
description: "Ğ¡Ğ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ²Ñ‹ÑĞ¾ĞºĞ¾Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ²ĞµĞ±-Ñ„Ñ€ĞµĞ¹Ğ¼Ğ²Ğ¾Ñ€Ğº Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ API Ğ½Ğ° Python"
source: "https://fastapi.tiangolo.com"
---

 FastAPI framework, high performance, easy to learn, fast to code, ready for production

Test Coverage Package version Supported Python versions

Documentation: https://fastapi.tiangolo.com

Source Code: https://github.com/fastapi/fastapi

FastAPI is a modern, fast (high-performance), web framework for building APIs with Python based on standard Python type hints.

The key features are:

    Fast: Very high performance, on par with NodeJS and Go (thanks to Starlette and Pydantic). One of the fastest Python frameworks available.
    Fast to code: Increase the speed to develop features by about 200% to 300%. *
    Fewer bugs: Reduce about 40% of human (developer) induced errors. *
    Intuitive: Great editor support. Completion everywhere. Less time debugging.
    Easy: Designed to be easy to use and learn. Less time reading docs.
    Short: Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs.
    Robust: Get production-ready code. With automatic interactive documentation.
    Standards-based: Based on (and fully compatible with) the open standards for APIs: OpenAPI (previously known as Swagger) and JSON Schema.

* estimation based on tests on an internal development team, building production applications.
SponsorsÂ¶
Keystone SponsorÂ¶

Gold and Silver SponsorsÂ¶

Other sponsors
OpinionsÂ¶

"[...] I'm using FastAPI a ton these days. [...] I'm actually planning to use it for all of my team's ML services at Microsoft. Some of them are getting integrated into the core Windows product and some Office products."
Kabir Khan - Microsoft (ref)

"We adopted the FastAPI library to spawn a REST server that can be queried to obtain predictions. [for Ludwig]"
Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala - Uber (ref)

"Netflix is pleased to announce the open-source release of our crisis management orchestration framework: Dispatch! [built with FastAPI]"
Kevin Glisson, Marc Vilanova, Forest Monsen - Netflix (ref)

"Iâ€™m over the moon excited about FastAPI. Itâ€™s so fun!"
Brian Okken - Python Bytes podcast host (ref)

"Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted Hug to be - it's really inspiring to see someone build that."
Timothy Crosley - Hug creator (ref)

"If you're looking to learn one modern framework for building REST APIs, check out FastAPI [...] It's fast, easy to use and easy to learn [...]"

"We've switched over to FastAPI for our APIs [...] I think you'll like it [...]"
Ines Montani - Matthew Honnibal - Explosion AI founders - spaCy creators (ref) - (ref)

"If anyone is looking to build a production Python API, I would highly recommend FastAPI. It is beautifully designed, simple to use and highly scalable, it has become a key component in our API first development strategy and is driving many automations and services such as our Virtual TAC Engineer."
Deon Pillsbury - Cisco (ref)
Typer, the FastAPI of CLIsÂ¶

If you are building a CLI app to be used in the terminal instead of a web API, check out Typer.

Typer is FastAPI's little sibling. And it's intended to be the FastAPI of CLIs. âŒ¨ï¸ ğŸš€
RequirementsÂ¶

FastAPI stands on the shoulders of giants:

    Starlette for the web parts.
    Pydantic for the data parts.

InstallationÂ¶

Create and activate a virtual environment and then install FastAPI:

pip install "fastapi[standard]"
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100%
restart â†»

Note: Make sure you put "fastapi[standard]" in quotes to ensure it works in all terminals.
ExampleÂ¶
Create itÂ¶

Create a file main.py with:

from typing import Union

from fastapi import FastAPI

app = FastAPI()


@app.get("/")
def read_root():
    return {"Hello": "World"}


@app.get("/items/{item_id}")
def read_item(item_id: int, q: Union[str, None] = None):
    return {"item_id": item_id, "q": q}

Or use async def...

If your code uses async / await, use async def:

from typing import Union

from fastapi import FastAPI

app = FastAPI()


@app.get("/")
async def read_root():
    return {"Hello": "World"}


@app.get("/items/{item_id}")
async def read_item(item_id: int, q: Union[str, None] = None):
    return {"item_id": item_id, "q": q}

Note:

If you don't know, check the "In a hurry?" section about async and await in the docs.
Or use async def...

If your code uses async / await, use async def:

from typing import Union

from fastapi import FastAPI

app = FastAPI()


@app.get("/")
async def read_root():
    return {"Hello": "World"}


@app.get("/items/{item_id}")
async def read_item(item_id: int, q: Union[str, None] = None):
    return {"item_id": item_id, "q": q}

Note:

If you don't know, check the "In a hurry?" section about async and await in the docs.
Run itÂ¶

Run the server with:

fastapi dev main.py
 â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FastAPI CLI - Development mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
 â”‚                                                     â”‚
 â”‚  Serving at: http://127.0.0.1:8000                  â”‚
 â”‚                                                     â”‚
 â”‚  API docs: http://127.0.0.1:8000/docs               â”‚
 â”‚                                                     â”‚
 â”‚  Running in development mode, for production use:   â”‚
 â”‚                                                     â”‚
 â”‚  fastapi run                                        â”‚
 â”‚                                                     â”‚
 â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

INFO:     Will watch for changes in these directories: ['/home/user/code/awesomeapp']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [2248755] using WatchFiles
INFO:     Started server process [2248757]
INFO:     Waiting for application startup.
INFO:     Application startup complete.

restart â†»

About the command fastapi dev main.py...

The command fastapi dev reads your main.py file, detects the FastAPI app in it, and starts a server using Uvicorn.

By default, fastapi dev will start with auto-reload enabled for local development.

You can read more about it in the FastAPI CLI docs.
Check itÂ¶

Open your browser at http://127.0.0.1:8000/items/5?q=somequery.

You will see the JSON response as:

{"item_id": 5, "q": "somequery"}

You already created an API that:

    Receives HTTP requests in the paths / and /items/{item_id}.
    Both paths take GET operations (also known as HTTP methods).
    The path /items/{item_id} has a path parameter item_id that should be an int.
    The path /items/{item_id} has an optional str query parameter q.

Interactive API docsÂ¶

Now go to http://127.0.0.1:8000/docs.

You will see the automatic interactive API documentation (provided by Swagger UI):

Swagger UI
Alternative API docsÂ¶

And now, go to http://127.0.0.1:8000/redoc.

You will see the alternative automatic documentation (provided by ReDoc):

ReDoc
Example upgradeÂ¶

Now modify the file main.py to receive a body from a PUT request.

Declare the body using standard Python types, thanks to Pydantic.

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    price: float
    is_offer: Union[bool, None] = None


@app.get("/")
def read_root():
    return {"Hello": "World"}


@app.get("/items/{item_id}")
def read_item(item_id: int, q: Union[str, None] = None):
    return {"item_id": item_id, "q": q}


@app.put("/items/{item_id}")
def update_item(item_id: int, item: Item):
    return {"item_name": item.name, "item_id": item_id}

The fastapi dev server should reload automatically.
Interactive API docs upgradeÂ¶

Now go to http://127.0.0.1:8000/docs.

    The interactive API documentation will be automatically updated, including the new body:

Swagger UI

    Click on the button "Try it out", it allows you to fill the parameters and directly interact with the API:

Swagger UI interaction

    Then click on the "Execute" button, the user interface will communicate with your API, send the parameters, get the results and show them on the screen:

Swagger UI interaction
Alternative API docs upgradeÂ¶

And now, go to http://127.0.0.1:8000/redoc.

    The alternative documentation will also reflect the new query parameter and body:

ReDoc
RecapÂ¶

In summary, you declare once the types of parameters, body, etc. as function parameters.

You do that with standard modern Python types.

You don't have to learn a new syntax, the methods or classes of a specific library, etc.

Just standard Python.

For example, for an int:

item_id: int

or for a more complex Item model:

item: Item

...and with that single declaration you get:

    Editor support, including:
        Completion.
        Type checks.
    Validation of data:
        Automatic and clear errors when the data is invalid.
        Validation even for deeply nested JSON objects.
    Conversion of input data: coming from the network to Python data and types. Reading from:
        JSON.
        Path parameters.
        Query parameters.
        Cookies.
        Headers.
        Forms.
        Files.
    Conversion of output data: converting from Python data and types to network data (as JSON):
        Convert Python types (str, int, float, bool, list, etc).
        datetime objects.
        UUID objects.
        Database models.
        ...and many more.
    Automatic interactive API documentation, including 2 alternative user interfaces:
        Swagger UI.
        ReDoc.

Coming back to the previous code example, FastAPI will:

    Validate that there is an item_id in the path for GET and PUT requests.
    Validate that the item_id is of type int for GET and PUT requests.
        If it is not, the client will see a useful, clear error.
    Check if there is an optional query parameter named q (as in http://127.0.0.1:8000/items/foo?q=somequery) for GET requests.
        As the q parameter is declared with = None, it is optional.
        Without the None it would be required (as is the body in the case with PUT).
    For PUT requests to /items/{item_id}, read the body as JSON:
        Check that it has a required attribute name that should be a str.
        Check that it has a required attribute price that has to be a float.
        Check that it has an optional attribute is_offer, that should be a bool, if present.
        All this would also work for deeply nested JSON objects.
    Convert from and to JSON automatically.
    Document everything with OpenAPI, that can be used by:
        Interactive documentation systems.
        Automatic client code generation systems, for many languages.
    Provide 2 interactive documentation web interfaces directly.

We just scratched the surface, but you already get the idea of how it all works.

Try changing the line with:

    return {"item_name": item.name, "item_id": item_id}

...from:

        ... "item_name": item.name ...

...to:

        ... "item_price": item.price ...

...and see how your editor will auto-complete the attributes and know their types:

editor support

For a more complete example including more features, see the Tutorial - User Guide.

Spoiler alert: the tutorial - user guide includes:

    Declaration of parameters from other different places as: headers, cookies, form fields and files.
    How to set validation constraints as maximum_length or regex.
    A very powerful and easy to use Dependency Injection system.
    Security and authentication, including support for OAuth2 with JWT tokens and HTTP Basic auth.
    More advanced (but equally easy) techniques for declaring deeply nested JSON models (thanks to Pydantic).
    GraphQL integration with Strawberry and other libraries.
    Many extra features (thanks to Starlette) as:
        WebSockets
        extremely easy tests based on HTTPX and pytest
        CORS
        Cookie Sessions
        ...and more.

Deploy your app (optional)Â¶

You can optionally deploy your FastAPI app to FastAPI Cloud, go and join the waiting list if you haven't. ğŸš€

If you already have a FastAPI Cloud account (we invited you from the waiting list ğŸ˜‰), you can deploy your application with one command.

Before deploying, make sure you are logged in:

fastapi login
You are logged in to FastAPI Cloud ğŸš€

restart â†»

Then deploy your app:

fastapi deploy
Deploying to FastAPI Cloud...

âœ… Deployment successful!

ğŸ” Ready the chicken! Your app is ready at https://myapp.fastapicloud.dev

restart â†»

That's it! Now you can access your app at that URL. âœ¨
About FastAPI CloudÂ¶

FastAPI Cloud is built by the same author and team behind FastAPI.

It streamlines the process of building, deploying, and accessing an API with minimal effort.

It brings the same developer experience of building apps with FastAPI to deploying them to the cloud. ğŸ‰

FastAPI Cloud is the primary sponsor and funding provider for the FastAPI and friends open source projects. âœ¨
Deploy to other cloud providersÂ¶

FastAPI is open source and based on standards. You can deploy FastAPI apps to any cloud provider you choose.

Follow your cloud provider's guides to deploy FastAPI apps with them. ğŸ¤“
PerformanceÂ¶

Independent TechEmpower benchmarks show FastAPI applications running under Uvicorn as one of the fastest Python frameworks available, only below Starlette and Uvicorn themselves (used internally by FastAPI). (*)

To understand more about it, see the section Benchmarks.
DependenciesÂ¶

FastAPI depends on Pydantic and Starlette.
standard DependenciesÂ¶

When you install FastAPI with pip install "fastapi[standard]" it comes with the standard group of optional dependencies:

Used by Pydantic:

    email-validator - for email validation.

Used by Starlette:

    httpx - Required if you want to use the TestClient.
    jinja2 - Required if you want to use the default template configuration.
    python-multipart - Required if you want to support form "parsing", with request.form().

Used by FastAPI:

    uvicorn - for the server that loads and serves your application. This includes uvicorn[standard], which includes some dependencies (e.g. uvloop) needed for high performance serving.
    fastapi-cli[standard] - to provide the fastapi command.
        This includes fastapi-cloud-cli, which allows you to deploy your FastAPI application to FastAPI Cloud.

Without standard DependenciesÂ¶

If you don't want to include the standard optional dependencies, you can install with pip install fastapi instead of pip install "fastapi[standard]".
Without fastapi-cloud-cliÂ¶

If you want to install FastAPI with the standard dependencies but without the fastapi-cloud-cli, you can install with pip install "fastapi[standard-no-fastapi-cloud-cli]".
Additional Optional DependenciesÂ¶

There are some additional dependencies you might want to install.

Additional optional Pydantic dependencies:

    pydantic-settings - for settings management.
    pydantic-extra-types - for extra types to be used with Pydantic.

Additional optional FastAPI dependencies:

    orjson - Required if you want to use ORJSONResponse.
    ujson - Required if you want to use UJSONResponse.

LicenseÂ¶

This project is licensed under the terms of the MIT license.

FeaturesÂ¶
FastAPI featuresÂ¶

FastAPI gives you the following:
Based on open standardsÂ¶

    OpenAPI for API creation, including declarations of path operations, parameters, request bodies, security, etc.
    Automatic data model documentation with JSON Schema (as OpenAPI itself is based on JSON Schema).
    Designed around these standards, after a meticulous study. Instead of an afterthought layer on top.
    This also allows using automatic client code generation in many languages.

Automatic docsÂ¶

Interactive API documentation and exploration web user interfaces. As the framework is based on OpenAPI, there are multiple options, 2 included by default.

    Swagger UI, with interactive exploration, call and test your API directly from the browser.

Swagger UI interaction

    Alternative API documentation with ReDoc.

ReDoc
Just Modern PythonÂ¶

It's all based on standard Python type declarations (thanks to Pydantic). No new syntax to learn. Just standard modern Python.

If you need a 2 minute refresher of how to use Python types (even if you don't use FastAPI), check the short tutorial: Python Types.

You write standard Python with types:

from datetime import date

from pydantic import BaseModel

# Declare a variable as a str
# and get editor support inside the function
def main(user_id: str):
    return user_id


# A Pydantic model
class User(BaseModel):
    id: int
    name: str
    joined: date

That can then be used like:

my_user: User = User(id=3, name="John Doe", joined="2018-07-19")

second_user_data = {
    "id": 4,
    "name": "Mary",
    "joined": "2018-11-30",
}

my_second_user: User = User(**second_user_data)

Info

**second_user_data means:

Pass the keys and values of the second_user_data dict directly as key-value arguments, equivalent to: User(id=4, name="Mary", joined="2018-11-30")
Editor supportÂ¶

All the framework was designed to be easy and intuitive to use, all the decisions were tested on multiple editors even before starting development, to ensure the best development experience.

In the Python developer surveys, it's clear that one of the most used features is "autocompletion".

The whole FastAPI framework is based to satisfy that. Autocompletion works everywhere.

You will rarely need to come back to the docs.

Here's how your editor might help you:

    in Visual Studio Code:

editor support

    in PyCharm:

editor support

You will get completion in code you might even consider impossible before. As for example, the price key inside a JSON body (that could have been nested) that comes from a request.

No more typing the wrong key names, coming back and forth between docs, or scrolling up and down to find if you finally used username or user_name.
ShortÂ¶

It has sensible defaults for everything, with optional configurations everywhere. All the parameters can be fine-tuned to do what you need and to define the API you need.

But by default, it all "just works".
ValidationÂ¶

    Validation for most (or all?) Python data types, including:
        JSON objects (dict).
        JSON array (list) defining item types.
        String (str) fields, defining min and max lengths.
        Numbers (int, float) with min and max values, etc.

    Validation for more exotic types, like:
        URL.
        Email.
        UUID.
        ...and others.

All the validation is handled by the well-established and robust Pydantic.
Security and authenticationÂ¶

Security and authentication integrated. Without any compromise with databases or data models.

All the security schemes defined in OpenAPI, including:

    HTTP Basic.
    OAuth2 (also with JWT tokens). Check the tutorial on OAuth2 with JWT.
    API keys in:
        Headers.
        Query parameters.
        Cookies, etc.

Plus all the security features from Starlette (including session cookies).

All built as reusable tools and components that are easy to integrate with your systems, data stores, relational and NoSQL databases, etc.
Dependency InjectionÂ¶

FastAPI includes an extremely easy to use, but extremely powerful Dependency Injection system.

    Even dependencies can have dependencies, creating a hierarchy or "graph" of dependencies.
    All automatically handled by the framework.
    All the dependencies can require data from requests and augment the path operation constraints and automatic documentation.
    Automatic validation even for path operation parameters defined in dependencies.
    Support for complex user authentication systems, database connections, etc.
    No compromise with databases, frontends, etc. But easy integration with all of them.

Unlimited "plug-ins"Â¶

Or in other way, no need for them, import and use the code you need.

Any integration is designed to be so simple to use (with dependencies) that you can create a "plug-in" for your application in 2 lines of code using the same structure and syntax used for your path operations.
TestedÂ¶

    100% test coverage.
    100% type annotated code base.
    Used in production applications.

Starlette featuresÂ¶

FastAPI is fully compatible with (and based on) Starlette. So, any additional Starlette code you have, will also work.

FastAPI is actually a sub-class of Starlette. So, if you already know or use Starlette, most of the functionality will work the same way.

With FastAPI you get all of Starlette's features (as FastAPI is just Starlette on steroids):

    Seriously impressive performance. It is one of the fastest Python frameworks available, on par with NodeJS and Go.
    WebSocket support.
    In-process background tasks.
    Startup and shutdown events.
    Test client built on HTTPX.
    CORS, GZip, Static Files, Streaming responses.
    Session and Cookie support.
    100% test coverage.
    100% type annotated codebase.

Pydantic featuresÂ¶

FastAPI is fully compatible with (and based on) Pydantic. So, any additional Pydantic code you have, will also work.

Including external libraries also based on Pydantic, as ORMs, ODMs for databases.

This also means that in many cases you can pass the same object you get from a request directly to the database, as everything is validated automatically.

The same applies the other way around, in many cases you can just pass the object you get from the database directly to the client.

With FastAPI you get all of Pydantic's features (as FastAPI is based on Pydantic for all the data handling):

    No brainfuck:
        No new schema definition micro-language to learn.
        If you know Python types you know how to use Pydantic.
    Plays nicely with your IDE/linter/brain:
        Because pydantic data structures are just instances of classes you define; auto-completion, linting, mypy and your intuition should all work properly with your validated data.
    Validate complex structures:
        Use of hierarchical Pydantic models, Python typingâ€™s List and Dict, etc.
        And validators allow complex data schemas to be clearly and easily defined, checked and documented as JSON Schema.
        You can have deeply nested JSON objects and have them all validated and annotated.
    Extensible:
        Pydantic allows custom data types to be defined or you can extend validation with methods on a model decorated with the validator decorator.
    100% test coverage.



    FastAPI
    Learn

LearnÂ¶

Here are the introductory sections and the tutorials to learn FastAPI.

You could consider this a book, a course, the official and recommended way to learn FastAPI. ğŸ˜




    FastAPI
    Learn

Python Types IntroÂ¶

Python has support for optional "type hints" (also called "type annotations").

These "type hints" or annotations are a special syntax that allow declaring the type of a variable.

By declaring types for your variables, editors and tools can give you better support.

This is just a quick tutorial / refresher about Python type hints. It covers only the minimum necessary to use them with FastAPI... which is actually very little.

FastAPI is all based on these type hints, they give it many advantages and benefits.

But even if you never use FastAPI, you would benefit from learning a bit about them.

Note

If you are a Python expert, and you already know everything about type hints, skip to the next chapter.
MotivationÂ¶

Let's start with a simple example:
Python 3.8+

def get_full_name(first_name, last_name):
    full_name = first_name.title() + " " + last_name.title()
    return full_name


print(get_full_name("john", "doe"))

Calling this program outputs:

John Doe

The function does the following:

    Takes a first_name and last_name.
    Converts the first letter of each one to upper case with title().
    Concatenates them with a space in the middle.

Python 3.8+

def get_full_name(first_name, last_name):
    full_name = first_name.title() + " " + last_name.title()
    return full_name


print(get_full_name("john", "doe"))

Edit itÂ¶

It's a very simple program.

But now imagine that you were writing it from scratch.

At some point you would have started the definition of the function, you had the parameters ready...

But then you have to call "that method that converts the first letter to upper case".

Was it upper? Was it uppercase? first_uppercase? capitalize?

Then, you try with the old programmer's friend, editor autocompletion.

You type the first parameter of the function, first_name, then a dot (.) and then hit Ctrl+Space to trigger the completion.

But, sadly, you get nothing useful:

Add typesÂ¶

Let's modify a single line from the previous version.

We will change exactly this fragment, the parameters of the function, from:

    first_name, last_name

to:

    first_name: str, last_name: str

That's it.

Those are the "type hints":
Python 3.8+

def get_full_name(first_name: str, last_name: str):
    full_name = first_name.title() + " " + last_name.title()
    return full_name


print(get_full_name("john", "doe"))

That is not the same as declaring default values like would be with:

    first_name="john", last_name="doe"

It's a different thing.

We are using colons (:), not equals (=).

And adding type hints normally doesn't change what happens from what would happen without them.

But now, imagine you are again in the middle of creating that function, but with type hints.

At the same point, you try to trigger the autocomplete with Ctrl+Space and you see:

With that, you can scroll, seeing the options, until you find the one that "rings a bell":

More motivationÂ¶

Check this function, it already has type hints:
Python 3.8+

def get_name_with_age(name: str, age: int):
    name_with_age = name + " is this old: " + age
    return name_with_age

Because the editor knows the types of the variables, you don't only get completion, you also get error checks:

Now you know that you have to fix it, convert age to a string with str(age):
Python 3.8+

def get_name_with_age(name: str, age: int):
    name_with_age = name + " is this old: " + str(age)
    return name_with_age

Declaring typesÂ¶

You just saw the main place to declare type hints. As function parameters.

This is also the main place you would use them with FastAPI.
Simple typesÂ¶

You can declare all the standard Python types, not only str.

You can use, for example:

    int
    float
    bool
    bytes

Python 3.8+

def get_items(item_a: str, item_b: int, item_c: float, item_d: bool, item_e: bytes):
    return item_a, item_b, item_c, item_d, item_d, item_e

Generic types with type parametersÂ¶

There are some data structures that can contain other values, like dict, list, set and tuple. And the internal values can have their own type too.

These types that have internal types are called "generic" types. And it's possible to declare them, even with their internal types.

To declare those types and the internal types, you can use the standard Python module typing. It exists specifically to support these type hints.
Newer versions of PythonÂ¶

The syntax using typing is compatible with all versions, from Python 3.6 to the latest ones, including Python 3.9, Python 3.10, etc.

As Python advances, newer versions come with improved support for these type annotations and in many cases you won't even need to import and use the typing module to declare the type annotations.

If you can choose a more recent version of Python for your project, you will be able to take advantage of that extra simplicity.

In all the docs there are examples compatible with each version of Python (when there's a difference).

For example "Python 3.6+" means it's compatible with Python 3.6 or above (including 3.7, 3.8, 3.9, 3.10, etc). And "Python 3.9+" means it's compatible with Python 3.9 or above (including 3.10, etc).

If you can use the latest versions of Python, use the examples for the latest version, those will have the best and simplest syntax, for example, "Python 3.10+".
ListÂ¶

For example, let's define a variable to be a list of str.
Python 3.9+
Python 3.8+

Declare the variable, with the same colon (:) syntax.

As the type, put list.

As the list is a type that contains some internal types, you put them in square brackets:

def process_items(items: list[str]):
    for item in items:
        print(item)

Info

Those internal types in the square brackets are called "type parameters".

In this case, str is the type parameter passed to List (or list in Python 3.9 and above).

That means: "the variable items is a list, and each of the items in this list is a str".

Tip

If you use Python 3.9 or above, you don't have to import List from typing, you can use the same regular list type instead.

By doing that, your editor can provide support even while processing items from the list:

Without types, that's almost impossible to achieve.

Notice that the variable item is one of the elements in the list items.

And still, the editor knows it is a str, and provides support for that.
Tuple and SetÂ¶

You would do the same to declare tuples and sets:
Python 3.9+
Python 3.8+

def process_items(items_t: tuple[int, int, str], items_s: set[bytes]):
    return items_t, items_s

This means:

    The variable items_t is a tuple with 3 items, an int, another int, and a str.
    The variable items_s is a set, and each of its items is of type bytes.

DictÂ¶

To define a dict, you pass 2 type parameters, separated by commas.

The first type parameter is for the keys of the dict.

The second type parameter is for the values of the dict:
Python 3.9+
Python 3.8+

def process_items(prices: dict[str, float]):
    for item_name, item_price in prices.items():
        print(item_name)
        print(item_price)

This means:

    The variable prices is a dict:
        The keys of this dict are of type str (let's say, the name of each item).
        The values of this dict are of type float (let's say, the price of each item).

UnionÂ¶

You can declare that a variable can be any of several types, for example, an int or a str.

In Python 3.6 and above (including Python 3.10) you can use the Union type from typing and put inside the square brackets the possible types to accept.

In Python 3.10 there's also a new syntax where you can put the possible types separated by a vertical bar (|).
Python 3.10+
Python 3.8+

def process_item(item: int | str):
    print(item)

In both cases this means that item could be an int or a str.
Possibly NoneÂ¶

You can declare that a value could have a type, like str, but that it could also be None.

In Python 3.6 and above (including Python 3.10) you can declare it by importing and using Optional from the typing module.

from typing import Optional


def say_hi(name: Optional[str] = None):
    if name is not None:
        print(f"Hey {name}!")
    else:
        print("Hello World")

Using Optional[str] instead of just str will let the editor help you detect errors where you could be assuming that a value is always a str, when it could actually be None too.

Optional[Something] is actually a shortcut for Union[Something, None], they are equivalent.

This also means that in Python 3.10, you can use Something | None:
Python 3.10+
Python 3.8+
Python 3.8+ alternative

def say_hi(name: str | None = None):
    if name is not None:
        print(f"Hey {name}!")
    else:
        print("Hello World")

Using Union or OptionalÂ¶

If you are using a Python version below 3.10, here's a tip from my very subjective point of view:

    ğŸš¨ Avoid using Optional[SomeType]
    Instead âœ¨ use Union[SomeType, None] âœ¨.

Both are equivalent and underneath they are the same, but I would recommend Union instead of Optional because the word "optional" would seem to imply that the value is optional, and it actually means "it can be None", even if it's not optional and is still required.

I think Union[SomeType, None] is more explicit about what it means.

It's just about the words and names. But those words can affect how you and your teammates think about the code.

As an example, let's take this function:
Python 3.8+

from typing import Optional


def say_hi(name: Optional[str]):
    print(f"Hey {name}!")

def say_hi(name: str | None):
    print(f"Hey {name}!")

ğŸ¤“ Other versions and variants
Python 3.10+

def say_hi(name: str | None):
    print(f"Hey {name}!")

ğŸ¤“ Other versions and variants
Python 3.10+

def say_hi(name: str | None):
    print(f"Hey {name}!")

The parameter name is defined as Optional[str], but it is not optional, you cannot call the function without the parameter:

say_hi()  # Oh, no, this throws an error! ğŸ˜±

The name parameter is still required (not optional) because it doesn't have a default value. Still, name accepts None as the value:

say_hi(name=None)  # This works, None is valid ğŸ‰

The good news is, once you are on Python 3.10 you won't have to worry about that, as you will be able to simply use | to define unions of types:
Python 3.10+

def say_hi(name: str | None):
    print(f"Hey {name}!")

from typing import Optional


def say_hi(name: Optional[str]):
    print(f"Hey {name}!")

ğŸ¤“ Other versions and variants
Python 3.8+

from typing import Optional


def say_hi(name: Optional[str]):
    print(f"Hey {name}!")

ğŸ¤“ Other versions and variants
Python 3.8+

from typing import Optional


def say_hi(name: Optional[str]):
    print(f"Hey {name}!")

And then you won't have to worry about names like Optional and Union. ğŸ˜
Generic typesÂ¶

These types that take type parameters in square brackets are called Generic types or Generics, for example:
Python 3.10+
Python 3.9+
Python 3.8+

You can use the same builtin types as generics (with square brackets and types inside):

    list
    tuple
    set
    dict

And the same as with Python 3.8, from the typing module:

    Union
    Optional (the same as with Python 3.8)
    ...and others.

In Python 3.10, as an alternative to using the generics Union and Optional, you can use the vertical bar (|) to declare unions of types, that's a lot better and simpler.
Classes as typesÂ¶

You can also declare a class as the type of a variable.

Let's say you have a class Person, with a name:
Python 3.8+

class Person:
    def __init__(self, name: str):
        self.name = name


def get_person_name(one_person: Person):
    return one_person.name

Then you can declare a variable to be of type Person:
Python 3.8+

class Person:
    def __init__(self, name: str):
        self.name = name


def get_person_name(one_person: Person):
    return one_person.name

And then, again, you get all the editor support:

Notice that this means "one_person is an instance of the class Person".

It doesn't mean "one_person is the class called Person".
Pydantic modelsÂ¶

Pydantic is a Python library to perform data validation.

You declare the "shape" of the data as classes with attributes.

And each attribute has a type.

Then you create an instance of that class with some values and it will validate the values, convert them to the appropriate type (if that's the case) and give you an object with all the data.

And you get all the editor support with that resulting object.

An example from the official Pydantic docs:
Python 3.10+
Python 3.9+
Python 3.8+

from datetime import datetime

from pydantic import BaseModel


class User(BaseModel):
    id: int
    name: str = "John Doe"
    signup_ts: datetime | None = None
    friends: list[int] = []


external_data = {
    "id": "123",
    "signup_ts": "2017-06-01 12:22",
    "friends": [1, "2", b"3"],
}
user = User(**external_data)
print(user)
# > User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]
print(user.id)
# > 123

Info

To learn more about Pydantic, check its docs.

FastAPI is all based on Pydantic.

You will see a lot more of all this in practice in the Tutorial - User Guide.

Tip

Pydantic has a special behavior when you use Optional or Union[Something, None] without a default value, you can read more about it in the Pydantic docs about Required Optional fields.
Type Hints with Metadata AnnotationsÂ¶

Python also has a feature that allows putting additional metadata in these type hints using Annotated.
Python 3.9+
Python 3.8+

In Python 3.9, Annotated is part of the standard library, so you can import it from typing.

from typing import Annotated


def say_hello(name: Annotated[str, "this is just metadata"]) -> str:
    return f"Hello {name}"

Python itself doesn't do anything with this Annotated. And for editors and other tools, the type is still str.

But you can use this space in Annotated to provide FastAPI with additional metadata about how you want your application to behave.

The important thing to remember is that the first type parameter you pass to Annotated is the actual type. The rest, is just metadata for other tools.

For now, you just need to know that Annotated exists, and that it's standard Python. ğŸ˜

Later you will see how powerful it can be.

Tip

The fact that this is standard Python means that you will still get the best possible developer experience in your editor, with the tools you use to analyze and refactor your code, etc. âœ¨

And also that your code will be very compatible with many other Python tools and libraries. ğŸš€
Type hints in FastAPIÂ¶

FastAPI takes advantage of these type hints to do several things.

With FastAPI you declare parameters with type hints and you get:

    Editor support.
    Type checks.

...and FastAPI uses the same declarations to:

    Define requirements: from request path parameters, query parameters, headers, bodies, dependencies, etc.
    Convert data: from the request to the required type.
    Validate data: coming from each request:
        Generating automatic errors returned to the client when the data is invalid.
    Document the API using OpenAPI:
        which is then used by the automatic interactive documentation user interfaces.

This might all sound abstract. Don't worry. You'll see all this in action in the Tutorial - User Guide.

The important thing is that by using standard Python types, in a single place (instead of adding more classes, decorators, etc), FastAPI will do a lot of the work for you.

Info

If you already went through all the tutorial and came back to see more about types, a good resource is the "cheat sheet" from mypy.



    FastAPI
    Learn

Concurrency and async / awaitÂ¶

Details about the async def syntax for path operation functions and some background about asynchronous code, concurrency, and parallelism.
In a hurry?Â¶

TL;DR:

If you are using third party libraries that tell you to call them with await, like:

results = await some_library()

Then, declare your path operation functions with async def like:

@app.get('/')
async def read_results():
    results = await some_library()
    return results

Note

You can only use await inside of functions created with async def.

If you are using a third party library that communicates with something (a database, an API, the file system, etc.) and doesn't have support for using await, (this is currently the case for most database libraries), then declare your path operation functions as normally, with just def, like:

@app.get('/')
def results():
    results = some_library()
    return results

If your application (somehow) doesn't have to communicate with anything else and wait for it to respond, use async def, even if you don't need to use await inside.

If you just don't know, use normal def.

Note: You can mix def and async def in your path operation functions as much as you need and define each one using the best option for you. FastAPI will do the right thing with them.

Anyway, in any of the cases above, FastAPI will still work asynchronously and be extremely fast.

But by following the steps above, it will be able to do some performance optimizations.
Technical DetailsÂ¶

Modern versions of Python have support for "asynchronous code" using something called "coroutines", with async and await syntax.

Let's see that phrase by parts in the sections below:

    Asynchronous Code
    async and await
    Coroutines

Asynchronous CodeÂ¶

Asynchronous code just means that the language ğŸ’¬ has a way to tell the computer / program ğŸ¤– that at some point in the code, it ğŸ¤– will have to wait for something else to finish somewhere else. Let's say that something else is called "slow-file" ğŸ“.

So, during that time, the computer can go and do some other work, while "slow-file" ğŸ“ finishes.

Then the computer / program ğŸ¤– will come back every time it has a chance because it's waiting again, or whenever it ğŸ¤– finished all the work it had at that point. And it ğŸ¤– will see if any of the tasks it was waiting for have already finished, doing whatever it had to do.

Next, it ğŸ¤– takes the first task to finish (let's say, our "slow-file" ğŸ“) and continues whatever it had to do with it.

That "wait for something else" normally refers to I/O operations that are relatively "slow" (compared to the speed of the processor and the RAM memory), like waiting for:

    the data from the client to be sent through the network
    the data sent by your program to be received by the client through the network
    the contents of a file in the disk to be read by the system and given to your program
    the contents your program gave to the system to be written to disk
    a remote API operation
    a database operation to finish
    a database query to return the results
    etc.

As the execution time is consumed mostly by waiting for I/O operations, they call them "I/O bound" operations.

It's called "asynchronous" because the computer / program doesn't have to be "synchronized" with the slow task, waiting for the exact moment that the task finishes, while doing nothing, to be able to take the task result and continue the work.

Instead of that, by being an "asynchronous" system, once finished, the task can wait in line a little bit (some microseconds) for the computer / program to finish whatever it went to do, and then come back to take the results and continue working with them.

For "synchronous" (contrary to "asynchronous") they commonly also use the term "sequential", because the computer / program follows all the steps in sequence before switching to a different task, even if those steps involve waiting.
Concurrency and BurgersÂ¶

This idea of asynchronous code described above is also sometimes called "concurrency". It is different from "parallelism".

Concurrency and parallelism both relate to "different things happening more or less at the same time".

But the details between concurrency and parallelism are quite different.

To see the difference, imagine the following story about burgers:
Concurrent BurgersÂ¶

You go with your crush to get fast food, you stand in line while the cashier takes the orders from the people in front of you. ğŸ˜

Then it's your turn, you place your order of 2 very fancy burgers for your crush and you. ğŸ”ğŸ”

The cashier says something to the cook in the kitchen so they know they have to prepare your burgers (even though they are currently preparing the ones for the previous clients).

You pay. ğŸ’¸

The cashier gives you the number of your turn.

While you are waiting, you go with your crush and pick a table, you sit and talk with your crush for a long time (as your burgers are very fancy and take some time to prepare).

As you are sitting at the table with your crush, while you wait for the burgers, you can spend that time admiring how awesome, cute and smart your crush is âœ¨ğŸ˜âœ¨.

While waiting and talking to your crush, from time to time, you check the number displayed on the counter to see if it's your turn already.

Then at some point, it finally is your turn. You go to the counter, get your burgers and come back to the table.

You and your crush eat the burgers and have a nice time. âœ¨

Info

Beautiful illustrations by Ketrina Thompson. ğŸ¨

Imagine you are the computer / program ğŸ¤– in that story.

While you are at the line, you are just idle ğŸ˜´, waiting for your turn, not doing anything very "productive". But the line is fast because the cashier is only taking the orders (not preparing them), so that's fine.

Then, when it's your turn, you do actual "productive" work, you process the menu, decide what you want, get your crush's choice, pay, check that you give the correct bill or card, check that you are charged correctly, check that the order has the correct items, etc.

But then, even though you still don't have your burgers, your work with the cashier is "on pause" â¸, because you have to wait ğŸ•™ for your burgers to be ready.

But as you go away from the counter and sit at the table with a number for your turn, you can switch ğŸ”€ your attention to your crush, and "work" â¯ ğŸ¤“ on that. Then you are again doing something very "productive" as is flirting with your crush ğŸ˜.

Then the cashier ğŸ’ says "I'm finished with doing the burgers" by putting your number on the counter's display, but you don't jump like crazy immediately when the displayed number changes to your turn number. You know no one will steal your burgers because you have the number of your turn, and they have theirs.

So you wait for your crush to finish the story (finish the current work â¯ / task being processed ğŸ¤“), smile gently and say that you are going for the burgers â¸.

Then you go to the counter ğŸ”€, to the initial task that is now finished â¯, pick the burgers, say thanks and take them to the table. That finishes that step / task of interaction with the counter â¹. That in turn, creates a new task, of "eating burgers" ğŸ”€ â¯, but the previous one of "getting burgers" is finished â¹.
Parallel BurgersÂ¶

Now let's imagine these aren't "Concurrent Burgers", but "Parallel Burgers".

You go with your crush to get parallel fast food.

You stand in line while several (let's say 8) cashiers that at the same time are cooks take the orders from the people in front of you.

Everyone before you is waiting for their burgers to be ready before leaving the counter because each of the 8 cashiers goes and prepares the burger right away before getting the next order.

Then it's finally your turn, you place your order of 2 very fancy burgers for your crush and you.

You pay ğŸ’¸.

The cashier goes to the kitchen.

You wait, standing in front of the counter ğŸ•™, so that no one else takes your burgers before you do, as there are no numbers for turns.

As you and your crush are busy not letting anyone get in front of you and take your burgers whenever they arrive, you cannot pay attention to your crush. ğŸ˜

This is "synchronous" work, you are "synchronized" with the cashier/cook ğŸ‘¨â€ğŸ³. You have to wait ğŸ•™ and be there at the exact moment that the cashier/cook ğŸ‘¨â€ğŸ³ finishes the burgers and gives them to you, or otherwise, someone else might take them.

Then your cashier/cook ğŸ‘¨â€ğŸ³ finally comes back with your burgers, after a long time waiting ğŸ•™ there in front of the counter.

You take your burgers and go to the table with your crush.

You just eat them, and you are done. â¹

There was not much talk or flirting as most of the time was spent waiting ğŸ•™ in front of the counter. ğŸ˜

Info

Beautiful illustrations by Ketrina Thompson. ğŸ¨

In this scenario of the parallel burgers, you are a computer / program ğŸ¤– with two processors (you and your crush), both waiting ğŸ•™ and dedicating their attention â¯ to be "waiting on the counter" ğŸ•™ for a long time.

The fast food store has 8 processors (cashiers/cooks). While the concurrent burgers store might have had only 2 (one cashier and one cook).

But still, the final experience is not the best. ğŸ˜

This would be the parallel equivalent story for burgers. ğŸ”

For a more "real life" example of this, imagine a bank.

Up to recently, most of the banks had multiple cashiers ğŸ‘¨â€ğŸ’¼ğŸ‘¨â€ğŸ’¼ğŸ‘¨â€ğŸ’¼ğŸ‘¨â€ğŸ’¼ and a big line ğŸ•™ğŸ•™ğŸ•™ğŸ•™ğŸ•™ğŸ•™ğŸ•™ğŸ•™.

All of the cashiers doing all the work with one client after the other ğŸ‘¨â€ğŸ’¼â¯.

And you have to wait ğŸ•™ in the line for a long time or you lose your turn.

You probably wouldn't want to take your crush ğŸ˜ with you to run errands at the bank ğŸ¦.
Burger ConclusionÂ¶

In this scenario of "fast food burgers with your crush", as there is a lot of waiting ğŸ•™, it makes a lot more sense to have a concurrent system â¸ğŸ”€â¯.

This is the case for most of the web applications.

Many, many users, but your server is waiting ğŸ•™ for their not-so-good connection to send their requests.

And then waiting ğŸ•™ again for the responses to come back.

This "waiting" ğŸ•™ is measured in microseconds, but still, summing it all, it's a lot of waiting in the end.

That's why it makes a lot of sense to use asynchronous â¸ğŸ”€â¯ code for web APIs.

This kind of asynchronicity is what made NodeJS popular (even though NodeJS is not parallel) and that's the strength of Go as a programming language.

And that's the same level of performance you get with FastAPI.

And as you can have parallelism and asynchronicity at the same time, you get higher performance than most of the tested NodeJS frameworks and on par with Go, which is a compiled language closer to C (all thanks to Starlette).
Is concurrency better than parallelism?Â¶

Nope! That's not the moral of the story.

Concurrency is different than parallelism. And it is better on specific scenarios that involve a lot of waiting. Because of that, it generally is a lot better than parallelism for web application development. But not for everything.

So, to balance that out, imagine the following short story:

    You have to clean a big, dirty house.

Yep, that's the whole story.

There's no waiting ğŸ•™ anywhere, just a lot of work to be done, on multiple places of the house.

You could have turns as in the burgers example, first the living room, then the kitchen, but as you are not waiting ğŸ•™ for anything, just cleaning and cleaning, the turns wouldn't affect anything.

It would take the same amount of time to finish with or without turns (concurrency) and you would have done the same amount of work.

But in this case, if you could bring the 8 ex-cashier/cooks/now-cleaners, and each one of them (plus you) could take a zone of the house to clean it, you could do all the work in parallel, with the extra help, and finish much sooner.

In this scenario, each one of the cleaners (including you) would be a processor, doing their part of the job.

And as most of the execution time is taken by actual work (instead of waiting), and the work in a computer is done by a CPU, they call these problems "CPU bound".

Common examples of CPU bound operations are things that require complex math processing.

For example:

    Audio or image processing.
    Computer vision: an image is composed of millions of pixels, each pixel has 3 values / colors, processing that normally requires computing something on those pixels, all at the same time.
    Machine Learning: it normally requires lots of "matrix" and "vector" multiplications. Think of a huge spreadsheet with numbers and multiplying all of them together at the same time.
    Deep Learning: this is a sub-field of Machine Learning, so, the same applies. It's just that there is not a single spreadsheet of numbers to multiply, but a huge set of them, and in many cases, you use a special processor to build and / or use those models.

Concurrency + Parallelism: Web + Machine LearningÂ¶

With FastAPI you can take advantage of concurrency that is very common for web development (the same main attraction of NodeJS).

But you can also exploit the benefits of parallelism and multiprocessing (having multiple processes running in parallel) for CPU bound workloads like those in Machine Learning systems.

That, plus the simple fact that Python is the main language for Data Science, Machine Learning and especially Deep Learning, make FastAPI a very good match for Data Science / Machine Learning web APIs and applications (among many others).

To see how to achieve this parallelism in production see the section about Deployment.
async and awaitÂ¶

Modern versions of Python have a very intuitive way to define asynchronous code. This makes it look just like normal "sequential" code and do the "awaiting" for you at the right moments.

When there is an operation that will require waiting before giving the results and has support for these new Python features, you can code it like:

burgers = await get_burgers(2)

The key here is the await. It tells Python that it has to wait â¸ for get_burgers(2) to finish doing its thing ğŸ•™ before storing the results in burgers. With that, Python will know that it can go and do something else ğŸ”€ â¯ in the meanwhile (like receiving another request).

For await to work, it has to be inside a function that supports this asynchronicity. To do that, you just declare it with async def:

async def get_burgers(number: int):
    # Do some asynchronous stuff to create the burgers
    return burgers

...instead of def:

# This is not asynchronous
def get_sequential_burgers(number: int):
    # Do some sequential stuff to create the burgers
    return burgers

With async def, Python knows that, inside that function, it has to be aware of await expressions, and that it can "pause" â¸ the execution of that function and go do something else ğŸ”€ before coming back.

When you want to call an async def function, you have to "await" it. So, this won't work:

# This won't work, because get_burgers was defined with: async def
burgers = get_burgers(2)

So, if you are using a library that tells you that you can call it with await, you need to create the path operation functions that uses it with async def, like in:

@app.get('/burgers')
async def read_burgers():
    burgers = await get_burgers(2)
    return burgers

More technical detailsÂ¶

You might have noticed that await can only be used inside of functions defined with async def.

But at the same time, functions defined with async def have to be "awaited". So, functions with async def can only be called inside of functions defined with async def too.

So, about the egg and the chicken, how do you call the first async function?

If you are working with FastAPI you don't have to worry about that, because that "first" function will be your path operation function, and FastAPI will know how to do the right thing.

But if you want to use async / await without FastAPI, you can do it as well.
Write your own async codeÂ¶

Starlette (and FastAPI) are based on AnyIO, which makes it compatible with both Python's standard library asyncio and Trio.

In particular, you can directly use AnyIO for your advanced concurrency use cases that require more advanced patterns in your own code.

And even if you were not using FastAPI, you could also write your own async applications with AnyIO to be highly compatible and get its benefits (e.g. structured concurrency).

I created another library on top of AnyIO, as a thin layer on top, to improve a bit the type annotations and get better autocompletion, inline errors, etc. It also has a friendly introduction and tutorial to help you understand and write your own async code: Asyncer. It would be particularly useful if you need to combine async code with regular (blocking/synchronous) code.
Other forms of asynchronous codeÂ¶

This style of using async and await is relatively new in the language.

But it makes working with asynchronous code a lot easier.

This same syntax (or almost identical) was also included recently in modern versions of JavaScript (in Browser and NodeJS).

But before that, handling asynchronous code was quite more complex and difficult.

In previous versions of Python, you could have used threads or Gevent. But the code is way more complex to understand, debug, and think about.

In previous versions of NodeJS / Browser JavaScript, you would have used "callbacks". Which leads to "callback hell".
CoroutinesÂ¶

Coroutine is just the very fancy term for the thing returned by an async def function. Python knows that it is something like a function, that it can start and that it will end at some point, but that it might be paused â¸ internally too, whenever there is an await inside of it.

But all this functionality of using asynchronous code with async and await is many times summarized as using "coroutines". It is comparable to the main key feature of Go, the "Goroutines".
ConclusionÂ¶

Let's see the same phrase from above:

    Modern versions of Python have support for "asynchronous code" using something called "coroutines", with async and await syntax.

That should make more sense now. âœ¨

All that is what powers FastAPI (through Starlette) and what makes it have such an impressive performance.
Very Technical DetailsÂ¶

Warning

You can probably skip this.

These are very technical details of how FastAPI works underneath.

If you have quite some technical knowledge (coroutines, threads, blocking, etc.) and are curious about how FastAPI handles async def vs normal def, go ahead.
Path operation functionsÂ¶

When you declare a path operation function with normal def instead of async def, it is run in an external threadpool that is then awaited, instead of being called directly (as it would block the server).

If you are coming from another async framework that does not work in the way described above and you are used to defining trivial compute-only path operation functions with plain def for a tiny performance gain (about 100 nanoseconds), please note that in FastAPI the effect would be quite opposite. In these cases, it's better to use async def unless your path operation functions use code that performs blocking I/O.

Still, in both situations, chances are that FastAPI will still be faster than (or at least comparable to) your previous framework.
DependenciesÂ¶

The same applies for dependencies. If a dependency is a standard def function instead of async def, it is run in the external threadpool.
Sub-dependenciesÂ¶

You can have multiple dependencies and sub-dependencies requiring each other (as parameters of the function definitions), some of them might be created with async def and some with normal def. It would still work, and the ones created with normal def would be called on an external thread (from the threadpool) instead of being "awaited".
Other utility functionsÂ¶

Any other utility function that you call directly can be created with normal def or async def and FastAPI won't affect the way you call it.

This is in contrast to the functions that FastAPI calls for you: path operation functions and dependencies.

If your utility function is a normal function with def, it will be called directly (as you write it in your code), not in a threadpool, if the function is created with async def then you should await for that function when you call it in your code.

Again, these are very technical details that would probably be useful if you came searching for them.

Otherwise, you should be good with the guidelines from the section above: In a hurry?.



    FastAPI
    Learn

Environment VariablesÂ¶

Tip

If you already know what "environment variables" are and how to use them, feel free to skip this.

An environment variable (also known as "env var") is a variable that lives outside of the Python code, in the operating system, and could be read by your Python code (or by other programs as well).

Environment variables could be useful for handling application settings, as part of the installation of Python, etc.
Create and Use Env VarsÂ¶

You can create and use environment variables in the shell (terminal), without needing Python:
Linux, macOS, Windows Bash
Windows PowerShell

ğŸ’¬ You could create an env var MY_NAME withexport MY_NAME="Wade Wilson"
ğŸ’¬ Then you could use it with other programs, likeecho "Hello $MY_NAME"
Hello Wade Wilson

restart â†»

Read env vars in PythonÂ¶

You could also create environment variables outside of Python, in the terminal (or with any other method), and then read them in Python.

For example you could have a file main.py with:

import os

name = os.getenv("MY_NAME", "World")
print(f"Hello {name} from Python")

Tip

The second argument to os.getenv() is the default value to return.

If not provided, it's None by default, here we provide "World" as the default value to use.

Then you could call that Python program:
Linux, macOS, Windows Bash
Windows PowerShell

fast â†’
ğŸ’¬ Here we don't set the env var yetpython main.py
ğŸ’¬ As we didn't set the env var, we get the default value
Hello World from Python

ğŸ’¬ But if we create an environment variable firstexport MY_NAME="Wade Wilson"
ğŸ’¬ And then call the program againpytho

As environment variables can be set outside of the code, but can be read by the code, and don't have to be stored (committed to git) with the rest of the files, it's common to use them for configurations or settings.

You can also create an environment variable only for a specific program invocation, that is only available to that program, and only for its duration.

To do that, create it right before the program itself, on the same line:

fast â†’
ğŸ’¬ Create an env var MY_NAME in line for this program callMY_NAME="Wade Wilson" python main.py
ğŸ’¬ Now it can read the environment variable
Hello Wade Wilson from Python

ğŸ’¬ The env var no longer exists afterwardspython main

Tip

You can read more about it at The Twelve-Factor App: Config.
Types and ValidationÂ¶

These environment variables can only handle text strings, as they are external to Python and have to be compatible with other programs and the rest of the system (and even with different operating systems, as Linux, Windows, macOS).

That means that any value read in Python from an environment variable will be a str, and any conversion to a different type or any validation has to be done in code.

You will learn more about using environment variables for handling application settings in the Advanced User Guide - Settings and Environment Variables.
PATH Environment VariableÂ¶

There is a special environment variable called PATH that is used by the operating systems (Linux, macOS, Windows) to find programs to run.

The value of the variable PATH is a long string that is made of directories separated by a colon : on Linux and macOS, and by a semicolon ; on Windows.

For example, the PATH environment variable could look like this:
Linux, macOS
Windows

/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin

This means that the system should look for programs in the directories:

    /usr/local/bin
    /usr/bin
    /bin
    /usr/sbin
    /sbin

When you type a command in the terminal, the operating system looks for the program in each of those directories listed in the PATH environment variable.

For example, when you type python in the terminal, the operating system looks for a program called python in the first directory in that list.

If it finds it, then it will use it. Otherwise it keeps looking in the other directories.
Installing Python and Updating the PATHÂ¶

When you install Python, you might be asked if you want to update the PATH environment variable.
Linux, macOS
Windows

Let's say you install Python and it ends up in a directory /opt/custompython/bin.

If you say yes to update the PATH environment variable, then the installer will add /opt/custompython/bin to the PATH environment variable.

It could look like this:

/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/custompython/bin

This way, when you type python in the terminal, the system will find the Python program in /opt/custompython/bin (the last directory) and use that one.

So, if you type:

python
restart â†»

Linux, macOS
Windows

The system will find the python program in /opt/custompython/bin and run it.

It would be roughly equivalent to typing:

/opt/custompython/bin/python
restart â†»

This information will be useful when learning about Virtual Environments.
ConclusionÂ¶

With this you should have a basic understanding of what environment variables are and how to use them in Python.

You can also read more about them in the Wikipedia for Environment Variable.

In many cases it's not very obvious how environment variables would be useful and applicable right away. But they keep showing up in many different scenarios when you are developing, so it's good to know about them.

For example, you will need this information in the next section, about Virtual Environments.

pip install "harry==3"
restart â†»

And then you would end up with harry version 3 installed in your global Python environment.

And if you try to run philosophers-stone again, there's a chance it would not work because it needs harry version 1.
prisoner-of-azkaban project
philosophers-stone project
global env
â›”ï¸
requires
prisoner-of-azkaban
philosophers-stone
harry v1
harry v3

Tip

It's very common in Python packages to try the best to avoid breaking changes in new versions, but it's better to be safe, and install newer versions intentionally and when you can run the tests to check everything is working correctly.

Now, imagine that with many other packages that all your projects depend on. That's very difficult to manage. And you would probably end up running some projects with some incompatible versions of the packages, and not knowing why something isn't working.

Also, depending on your operating system (e.g. Linux, Windows, macOS), it could have come with Python already installed. And in that case it probably had some packages pre-installed with some specific versions needed by your system. If you install packages in the global Python environment, you could end up breaking some of the programs that came with your operating system.
Where are Packages InstalledÂ¶

When you install Python, it creates some directories with some files in your computer.

Some of these directories are the ones in charge of having all the packages you install.

When you run:

ğŸ’¬ Don't run this now, it's just an example ğŸ¤“pip install "fastapi[standard]"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100%
restart â†»

That will download a compressed file with the FastAPI code, normally from PyPI.

It will also download files for other packages that FastAPI depends on.

Then it will extract all those files and put them in a directory in your computer.

By default, it will put those files downloaded and extracted in the directory that comes with your Python installation, that's the global environment.
What are Virtual EnvironmentsÂ¶

The solution to the problems of having all the packages in the global environment is to use a virtual environment for each project you work on.

A virtual environment is a directory, very similar to the global one, where you can install the packages for a project.

This way, each project will have its own virtual environment (.venv directory) with its own packages.
prisoner-of-azkaban project
.venv
requires
prisoner-of-azkaban
harry v3
philosophers-stone project
.venv
requires
philosophers-stone
harry v1
What Does Activating a Virtual Environment MeanÂ¶

When you activate a virtual environment, for example with:
Linux, macOS
Windows PowerShell
Windows Bash

source .venv/bin/activate
restart â†»

That command will create or modify some environment variables that will be available for the next commands.

One of those variables is the PATH variable.

Tip

You can learn more about the PATH environment variable in the Environment Variables section.

Activating a virtual environment adds its path .venv/bin (on Linux and macOS) or .venv\Scripts (on Windows) to the PATH environment variable.

Let's say that before activating the environment, the PATH variable looked like this:
Linux, macOS
Windows

/usr/bin:/bin:/usr/sbin:/sbin

That means that the system would look for programs in:

    /usr/bin
    /bin
    /usr/sbin
    /sbin

After activating the virtual environment, the PATH variable would look something like this:
Linux, macOS
Windows

/home/user/code/awesome-project/.venv/bin:/usr/bin:/bin:/usr/sbin:/sbin

That means that the system will now start looking first for programs in:

/home/user/code/awesome-project/.venv/bin

before looking in the other directories.

So, when you type python in the terminal, the system will find the Python program in

/home/user/code/awesome-project/.venv/bin/python

and use that one.

An important detail is that it will put the virtual environment path at the beginning of the PATH variable. The system will find it before finding any other Python available. This way, when you run python, it will use the Python from the virtual environment instead of any other python (for example, a python from a global environment).

Activating a virtual environment also changes a couple of other things, but this is one of the most important things it does.
Checking a Virtual EnvironmentÂ¶

When you check if a virtual environment is active, for example with:
Linux, macOS, Windows Bash
Windows PowerShell

which python
/home/user/code/awesome-project/.venv/bin/python

restart â†»

That means that the python program that will be used is the one in the virtual environment.

You use which in Linux and macOS and Get-Command in Windows PowerShell.

The way that command works is that it will go and check in the PATH environment variable, going through each path in order, looking for the program called python. Once it finds it, it will show you the path to that program.

The most important part is that when you call python, that is the exact "python" that will be executed.

So, you can confirm if you are in the correct virtual environment.

Tip

It's easy to activate one virtual environment, get one Python, and then go to another project.

And the second project wouldn't work because you are using the incorrect Python, from a virtual environment for another project.

It's useful being able to check what python is being used. ğŸ¤“
Why Deactivate a Virtual EnvironmentÂ¶

For example, you could be working on a project philosophers-stone, activate that virtual environment, install packages and work with that environment.

And then you want to work on another project prisoner-of-azkaban.

You go to that project:

cd ~/code/prisoner-of-azkaban
restart â†»

If you don't deactivate the virtual environment for philosophers-stone, when you run python in the terminal, it will try to use the Python from philosophers-stone.

cd ~/code/prisoner-of-azkaban
python main.py
ğŸ’¬ Error importing sirius, it's not installed ğŸ˜±Traceback (most recent call last):
    File "main.py", line 1, in 
        import sirius

restart â†»

But if you deactivate the virtual environment and activate the new one for prisoner-of-askaban then when you run python it will use the Python from the virtual environment in prisoner-of-azkaban.

cd ~/code/prisoner-of-azkaban
ğŸ’¬ You don't need to be in the old directory to deactivate, you can do it wherever you are, even after going to the other project ğŸ˜deactivate
ğŸ’¬ Activate the virtual environment in prisoner-of-azkaban/.venv ğŸš€source .venv/bin/activate
ğŸ’¬ Now when you run python, it will find the package sirius installed in this virtual environment âœ¨python main.py
I solemnly swear ğŸº

restart â†»

AlternativesÂ¶

This is a simple guide to get you started and teach you how everything works underneath.

There are many alternatives to managing virtual environments, package dependencies (requirements), projects.

Once you are ready and want to use a tool to manage the entire project, packages dependencies, virtual environments, etc. I would suggest you try uv.

uv can do a lot of things, it can:

    Install Python for you, including different versions
    Manage the virtual environment for your projects
    Install packages
    Manage package dependencies and versions for your project
    Make sure you have an exact set of packages and versions to install, including their dependencies, so that you can be sure that you can run your project in production exactly the same as in your computer while developing, this is called locking
    And many other things

ConclusionÂ¶

If you read and understood all this, now you know much more about virtual environments than many developers out there. ğŸ¤“

Knowing these details will most probably be useful in a future time when you are debugging something that seems complex, but you will know how it all works underneath. ğŸ˜



    FastAPI
    Learn
    Tutorial - User Guide

Tutorial - User GuideÂ¶

This tutorial shows you how to use FastAPI with most of its features, step by step.

Each section gradually builds on the previous ones, but it's structured to separate topics, so that you can go directly to any specific one to solve your specific API needs.

It is also built to work as a future reference so you can come back and see exactly what you need.
Run the codeÂ¶

All the code blocks can be copied and used directly (they are actually tested Python files).

To run any of the examples, copy the code to a file main.py, and start fastapi dev with:

fastapi dev main.py
   FastAPI   Starting development server ğŸš€

             Searching for package file structure from directories
             with __init__.py files
             Importing from /home/user/code/awesomeapp

    module   ğŸ main.py

      code   Importing the FastAPI app object from the module with
             the following code:

             from main import app

       app   Using import string: main:app

    server   Server started at http://127.0.0.1:8000
    server   Documentation at http://127.0.0.1:8000/docs

       tip   Running in development mode, for production use:
             fastapi run

             Logs:

      INFO   Will watch for changes in these directories:
             ['/home/user/code/awesomeapp']
      INFO   Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C
             to quit)
      INFO   Started reloader process [383138] using WatchFiles
      INFO   Started server process [383153]
      INFO   Waiting for application startup.
      INFO   Application startup complete.

restart â†»

It is HIGHLY encouraged that you write or copy the code, edit it and run it locally.

Using it in your editor is what really shows you the benefits of FastAPI, seeing how little code you have to write, all the type checks, autocompletion, etc.
Install FastAPIÂ¶

The first step is to install FastAPI.

Make sure you create a virtual environment, activate it, and then install FastAPI:

fast â†’
pip install "

Note

When you install with pip install "fastapi[standard]" it comes with some default optional standard dependencies, including fastapi-cloud-cli, which allows you to deploy to FastAPI Cloud.

If you don't want to have those optional dependencies, you can instead install pip install fastapi.

If you want to install the standard dependencies but without the fastapi-cloud-cli, you can install with pip install "fastapi[standard-no-fastapi-cloud-cli]".
Advanced User GuideÂ¶

There is also an Advanced User Guide that you can read later after this Tutorial - User guide.

The Advanced User Guide builds on this one, uses the same concepts, and teaches you some extra features.

But you should first read the Tutorial - User Guide (what you are reading right now).

It's designed so that you can build a complete application with just the Tutorial - User Guide, and then extend it in different ways, depending on your needs, using some of the additional ideas from the Advanced User Guide.



    FastAPI
    Learn
    Tutorial - User Guide

First StepsÂ¶

The simplest FastAPI file could look like this:
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/")
async def root():
    return {"message": "Hello World"}

Copy that to a file main.py.

Run the live server:

fastapi dev main.py
   FastAPI   Starting development server ğŸš€

             Searching for package file structure from directories
             with __init__.py files
             Importing from /home/user/code/awesomeapp

    module   ğŸ main.py

      code   Importing the FastAPI app object from the module with
             the following code:

             from main import app

       app   Using import string: main:app

    server   Server started at http://127.0.0.1:8000
    server   Documentation at http://127.0.0.1:8000/docs

       tip   Running in development mode, for production use:
             fastapi run

             Logs:

      INFO   Will watch for changes in these directories:
             ['/home/user/code/awesomeapp']
      INFO   Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C
             to quit)
      INFO   Started reloader process [383138] using WatchFiles
      INFO   Started server process [383153]
      INFO   Waiting for application startup.
      INFO   Application startup complete.

restart â†»

In the output, there's a line with something like:

INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)

That line shows the URL where your app is being served, in your local machine.
Check itÂ¶

Open your browser at http://127.0.0.1:8000.

You will see the JSON response as:

{"message": "Hello World"}

Interactive API docsÂ¶

Now go to http://127.0.0.1:8000/docs.

You will see the automatic interactive API documentation (provided by Swagger UI):

Swagger UI
Alternative API docsÂ¶

And now, go to http://127.0.0.1:8000/redoc.

You will see the alternative automatic documentation (provided by ReDoc):

ReDoc
OpenAPIÂ¶

FastAPI generates a "schema" with all your API using the OpenAPI standard for defining APIs.
"Schema"Â¶

A "schema" is a definition or description of something. Not the code that implements it, but just an abstract description.
API "schema"Â¶

In this case, OpenAPI is a specification that dictates how to define a schema of your API.

This schema definition includes your API paths, the possible parameters they take, etc.
Data "schema"Â¶

The term "schema" might also refer to the shape of some data, like a JSON content.

In that case, it would mean the JSON attributes, and data types they have, etc.
OpenAPI and JSON SchemaÂ¶

OpenAPI defines an API schema for your API. And that schema includes definitions (or "schemas") of the data sent and received by your API using JSON Schema, the standard for JSON data schemas.
Check the openapi.jsonÂ¶

If you are curious about how the raw OpenAPI schema looks like, FastAPI automatically generates a JSON (schema) with the descriptions of all your API.

You can see it directly at: http://127.0.0.1:8000/openapi.json.

It will show a JSON starting with something like:

{
    "openapi": "3.1.0",
    "info": {
        "title": "FastAPI",
        "version": "0.1.0"
    },
    "paths": {
        "/items/": {
            "get": {
                "responses": {
                    "200": {
                        "description": "Successful Response",
                        "content": {
                            "application/json": {



...

What is OpenAPI forÂ¶

The OpenAPI schema is what powers the two interactive documentation systems included.

And there are dozens of alternatives, all based on OpenAPI. You could easily add any of those alternatives to your application built with FastAPI.

You could also use it to generate code automatically, for clients that communicate with your API. For example, frontend, mobile or IoT applications.
Deploy your app (optional)Â¶

You can optionally deploy your FastAPI app to FastAPI Cloud, go and join the waiting list if you haven't. ğŸš€

If you already have a FastAPI Cloud account (we invited you from the waiting list ğŸ˜‰), you can deploy your application with one command.

Before deploying, make sure you are logged in:

fast â†’
fastapi login

Then deploy your app:

fast â†’
fastapi deploy

That's it! Now you can access your app at that URL. âœ¨
Recap, step by stepÂ¶
Step 1: import FastAPIÂ¶
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/")
async def root():
    return {"message": "Hello World"}

FastAPI is a Python class that provides all the functionality for your API.

Technical Details

FastAPI is a class that inherits directly from Starlette.

You can use all the Starlette functionality with FastAPI too.
Step 2: create a FastAPI "instance"Â¶
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/")
async def root():
    return {"message": "Hello World"}

Here the app variable will be an "instance" of the class FastAPI.

This will be the main point of interaction to create all your API.
Step 3: create a path operationÂ¶
PathÂ¶

"Path" here refers to the last part of the URL starting from the first /.

So, in a URL like:

https://example.com/items/foo

...the path would be:

/items/foo

Info

A "path" is also commonly called an "endpoint" or a "route".

While building an API, the "path" is the main way to separate "concerns" and "resources".
OperationÂ¶

"Operation" here refers to one of the HTTP "methods".

One of:

    POST
    GET
    PUT
    DELETE

...and the more exotic ones:

    OPTIONS
    HEAD
    PATCH
    TRACE

In the HTTP protocol, you can communicate to each path using one (or more) of these "methods".

When building APIs, you normally use these specific HTTP methods to perform a specific action.

Normally you use:

    POST: to create data.
    GET: to read data.
    PUT: to update data.
    DELETE: to delete data.

So, in OpenAPI, each of the HTTP methods is called an "operation".

We are going to call them "operations" too.
Define a path operation decoratorÂ¶
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/")
async def root():
    return {"message": "Hello World"}

The @app.get("/") tells FastAPI that the function right below is in charge of handling requests that go to:

    the path /
    using a get operation

@decorator Info

That @something syntax in Python is called a "decorator".

You put it on top of a function. Like a pretty decorative hat (I guess that's where the term came from).

A "decorator" takes the function below and does something with it.

In our case, this decorator tells FastAPI that the function below corresponds to the path / with an operation get.

It is the "path operation decorator".

You can also use the other operations:

    @app.post()
    @app.put()
    @app.delete()

And the more exotic ones:

    @app.options()
    @app.head()
    @app.patch()
    @app.trace()

Tip

You are free to use each operation (HTTP method) as you wish.

FastAPI doesn't enforce any specific meaning.

The information here is presented as a guideline, not a requirement.

For example, when using GraphQL you normally perform all the actions using only POST operations.
Step 4: define the path operation functionÂ¶

This is our "path operation function":

    path: is /.
    operation: is get.
    function: is the function below the "decorator" (below @app.get("/")).

Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/")
async def root():
    return {"message": "Hello World"}

This is a Python function.

It will be called by FastAPI whenever it receives a request to the URL "/" using a GET operation.

In this case, it is an async function.

You could also define it as a normal function instead of async def:
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/")
def root():
    return {"message": "Hello World"}

Note

If you don't know the difference, check the Async: "In a hurry?".
Step 5: return the contentÂ¶
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/")
async def root():
    return {"message": "Hello World"}

You can return a dict, list, singular values as str, int, etc.

You can also return Pydantic models (you'll see more about that later).

There are many other objects and models that will be automatically converted to JSON (including ORMs, etc). Try using your favorite ones, it's highly probable that they are already supported.
Step 6: Deploy itÂ¶

Deploy your app to FastAPI Cloud with one command: fastapi deploy. ğŸ‰
About FastAPI CloudÂ¶

FastAPI Cloud is built by the same author and team behind FastAPI.

It streamlines the process of building, deploying, and accessing an API with minimal effort.

It brings the same developer experience of building apps with FastAPI to deploying them to the cloud. ğŸ‰

FastAPI Cloud is the primary sponsor and funding provider for the FastAPI and friends open source projects. âœ¨
Deploy to other cloud providersÂ¶

FastAPI is open source and based on standards. You can deploy FastAPI apps to any cloud provider you choose.

Follow your cloud provider's guides to deploy FastAPI apps with them. ğŸ¤“
RecapÂ¶

    Import FastAPI.
    Create an app instance.
    Write a path operation decorator using decorators like @app.get("/").
    Define a path operation function; for example, def root(): ....
    Run the development server using the command fastapi dev.
    Optionally deploy your app with fastapi deploy.



    FastAPI
    Learn
    Tutorial - User Guide

Path ParametersÂ¶

You can declare path "parameters" or "variables" with the same syntax used by Python format strings:
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/items/{item_id}")
async def read_item(item_id):
    return {"item_id": item_id}

The value of the path parameter item_id will be passed to your function as the argument item_id.

So, if you run this example and go to http://127.0.0.1:8000/items/foo, you will see a response of:

{"item_id":"foo"}

Path parameters with typesÂ¶

You can declare the type of a path parameter in the function, using standard Python type annotations:
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/items/{item_id}")
async def read_item(item_id: int):
    return {"item_id": item_id}

In this case, item_id is declared to be an int.

Check

This will give you editor support inside of your function, with error checks, completion, etc.
Data conversionÂ¶

If you run this example and open your browser at http://127.0.0.1:8000/items/3, you will see a response of:

{"item_id":3}

Check

Notice that the value your function received (and returned) is 3, as a Python int, not a string "3".

So, with that type declaration, FastAPI gives you automatic request "parsing".
Data validationÂ¶

But if you go to the browser at http://127.0.0.1:8000/items/foo, you will see a nice HTTP error of:

{
  "detail": [
    {
      "type": "int_parsing",
      "loc": [
        "path",
        "item_id"
      ],
      "msg": "Input should be a valid integer, unable to parse string as an integer",
      "input": "foo"
    }
  ]
}

because the path parameter item_id had a value of "foo", which is not an int.

The same error would appear if you provided a float instead of an int, as in: http://127.0.0.1:8000/items/4.2

Check

So, with the same Python type declaration, FastAPI gives you data validation.

Notice that the error also clearly states exactly the point where the validation didn't pass.

This is incredibly helpful while developing and debugging code that interacts with your API.
DocumentationÂ¶

And when you open your browser at http://127.0.0.1:8000/docs, you will see an automatic, interactive, API documentation like:

Check

Again, just with that same Python type declaration, FastAPI gives you automatic, interactive documentation (integrating Swagger UI).

Notice that the path parameter is declared to be an integer.
Standards-based benefits, alternative documentationÂ¶

And because the generated schema is from the OpenAPI standard, there are many compatible tools.

Because of this, FastAPI itself provides an alternative API documentation (using ReDoc), which you can access at http://127.0.0.1:8000/redoc:

The same way, there are many compatible tools. Including code generation tools for many languages.
PydanticÂ¶

All the data validation is performed under the hood by Pydantic, so you get all the benefits from it. And you know you are in good hands.

You can use the same type declarations with str, float, bool and many other complex data types.

Several of these are explored in the next chapters of the tutorial.
Order mattersÂ¶

When creating path operations, you can find situations where you have a fixed path.

Like /users/me, let's say that it's to get data about the current user.

And then you can also have a path /users/{user_id} to get data about a specific user by some user ID.

Because path operations are evaluated in order, you need to make sure that the path for /users/me is declared before the one for /users/{user_id}:
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/users/me")
async def read_user_me():
    return {"user_id": "the current user"}


@app.get("/users/{user_id}")
async def read_user(user_id: str):
    return {"user_id": user_id}

Otherwise, the path for /users/{user_id} would match also for /users/me, "thinking" that it's receiving a parameter user_id with a value of "me".

Similarly, you cannot redefine a path operation:
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/users")
async def read_users():
    return ["Rick", "Morty"]


@app.get("/users")
async def read_users2():
    return ["Bean", "Elfo"]

The first one will always be used since the path matches first.
Predefined valuesÂ¶

If you have a path operation that receives a path parameter, but you want the possible valid path parameter values to be predefined, you can use a standard Python Enum.
Create an Enum classÂ¶

Import Enum and create a sub-class that inherits from str and from Enum.

By inheriting from str the API docs will be able to know that the values must be of type string and will be able to render correctly.

Then create class attributes with fixed values, which will be the available valid values:
Python 3.8+

from enum import Enum

from fastapi import FastAPI


class ModelName(str, Enum):
    alexnet = "alexnet"
    resnet = "resnet"
    lenet = "lenet"


app = FastAPI()


@app.get("/models/{model_name}")
async def get_model(model_name: ModelName):
    if model_name is ModelName.alexnet:
        return {"model_name": model_name, "message": "Deep Learning FTW!"}

    if model_name.value == "lenet":
        return {"model_name": model_name, "message": "LeCNN all the images"}

    return {"model_name": model_name, "message": "Have some residuals"}

Info

Enumerations (or enums) are available in Python since version 3.4.

Tip

If you are wondering, "AlexNet", "ResNet", and "LeNet" are just names of Machine Learning models.
Declare a path parameterÂ¶

Then create a path parameter with a type annotation using the enum class you created (ModelName):
Python 3.8+

from enum import Enum

from fastapi import FastAPI


class ModelName(str, Enum):
    alexnet = "alexnet"
    resnet = "resnet"
    lenet = "lenet"


app = FastAPI()


@app.get("/models/{model_name}")
async def get_model(model_name: ModelName):
    if model_name is ModelName.alexnet:
        return {"model_name": model_name, "message": "Deep Learning FTW!"}

    if model_name.value == "lenet":
        return {"model_name": model_name, "message": "LeCNN all the images"}

    return {"model_name": model_name, "message": "Have some residuals"}

Check the docsÂ¶

Because the available values for the path parameter are predefined, the interactive docs can show them nicely:

Working with Python enumerationsÂ¶

The value of the path parameter will be an enumeration member.
Compare enumeration membersÂ¶

You can compare it with the enumeration member in your created enum ModelName:
Python 3.8+

from enum import Enum

from fastapi import FastAPI


class ModelName(str, Enum):
    alexnet = "alexnet"
    resnet = "resnet"
    lenet = "lenet"


app = FastAPI()


@app.get("/models/{model_name}")
async def get_model(model_name: ModelName):
    if model_name is ModelName.alexnet:
        return {"model_name": model_name, "message": "Deep Learning FTW!"}

    if model_name.value == "lenet":
        return {"model_name": model_name, "message": "LeCNN all the images"}

    return {"model_name": model_name, "message": "Have some residuals"}

Get the enumeration valueÂ¶

You can get the actual value (a str in this case) using model_name.value, or in general, your_enum_member.value:
Python 3.8+

from enum import Enum

from fastapi import FastAPI


class ModelName(str, Enum):
    alexnet = "alexnet"
    resnet = "resnet"
    lenet = "lenet"


app = FastAPI()


@app.get("/models/{model_name}")
async def get_model(model_name: ModelName):
    if model_name is ModelName.alexnet:
        return {"model_name": model_name, "message": "Deep Learning FTW!"}

    if model_name.value == "lenet":
        return {"model_name": model_name, "message": "LeCNN all the images"}

    return {"model_name": model_name, "message": "Have some residuals"}

Tip

You could also access the value "lenet" with ModelName.lenet.value.
Return enumeration membersÂ¶

You can return enum members from your path operation, even nested in a JSON body (e.g. a dict).

They will be converted to their corresponding values (strings in this case) before returning them to the client:
Python 3.8+

from enum import Enum

from fastapi import FastAPI


class ModelName(str, Enum):
    alexnet = "alexnet"
    resnet = "resnet"
    lenet = "lenet"


app = FastAPI()


@app.get("/models/{model_name}")
async def get_model(model_name: ModelName):
    if model_name is ModelName.alexnet:
        return {"model_name": model_name, "message": "Deep Learning FTW!"}

    if model_name.value == "lenet":
        return {"model_name": model_name, "message": "LeCNN all the images"}

    return {"model_name": model_name, "message": "Have some residuals"}

In your client you will get a JSON response like:

{
  "model_name": "alexnet",
  "message": "Deep Learning FTW!"
}

Path parameters containing pathsÂ¶

Let's say you have a path operation with a path /files/{file_path}.

But you need file_path itself to contain a path, like home/johndoe/myfile.txt.

So, the URL for that file would be something like: /files/home/johndoe/myfile.txt.
OpenAPI supportÂ¶

OpenAPI doesn't support a way to declare a path parameter to contain a path inside, as that could lead to scenarios that are difficult to test and define.

Nevertheless, you can still do it in FastAPI, using one of the internal tools from Starlette.

And the docs would still work, although not adding any documentation telling that the parameter should contain a path.
Path convertorÂ¶

Using an option directly from Starlette you can declare a path parameter containing a path using a URL like:

/files/{file_path:path}

In this case, the name of the parameter is file_path, and the last part, :path, tells it that the parameter should match any path.

So, you can use it with:
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/files/{file_path:path}")
async def read_file(file_path: str):
    return {"file_path": file_path}

Tip

You might need the parameter to contain /home/johndoe/myfile.txt, with a leading slash (/).

In that case, the URL would be: /files//home/johndoe/myfile.txt, with a double slash (//) between files and home.
RecapÂ¶

With FastAPI, by using short, intuitive and standard Python type declarations, you get:

    Editor support: error checks, autocompletion, etc.
    Data "parsing"
    Data validation
    API annotation and automatic documentation

And you only have to declare them once.

That's probably the main visible advantage of FastAPI compared to alternative frameworks (apart from the raw performance).


(for now, we have only seen query parameters), then it is not required.

If you don't want to add a specific value but just make it optional, set the default as None.

But when you want to make a query parameter required, you can just not declare any default value:
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/items/{item_id}")
async def read_user_item(item_id: str, needy: str):
    item = {"item_id": item_id, "needy": needy}
    return item

Here the query parameter needy is a required query parameter of type str.

If you open in your browser a URL like:

http://127.0.0.1:8000/items/foo-item

...without adding the required parameter needy, you will see an error like:

{
  "detail": [
    {
      "type": "missing",
      "loc": [
        "query",
        "needy"
      ],
      "msg": "Field required",
      "input": null
    }
  ]
}

As needy is a required parameter, you would need to set it in the URL:

http://127.0.0.1:8000/items/foo-item?needy=sooooneedy

...this would work:

{
    "item_id": "foo-item",
    "needy": "sooooneedy"
}

And of course, you can define some parameters as required, some as having a default value, and some entirely optional:
Python 3.10+

from fastapi import FastAPI

app = FastAPI()


@app.get("/items/{item_id}")
async def read_user_item(
    item_id: str, needy: str, skip: int = 0, limit: int | None = None
):
    item = {"item_id": item_id, "needy": needy, "skip": skip, "limit": limit}
    return item

from typing import Union

from fastapi import FastAPI

app = FastAPI()


@app.get("/items/{item_id}")
async def read_user_item(
    item_id: str, needy: str, skip: int = 0, limit: Union[int, None] = None
):
    item = {"item_id": item_id, "needy": needy, "skip": skip, "limit": limit}
    return item

ğŸ¤“ Other versions and variants
Python 3.8+

from typing import Union

from fastapi import FastAPI

app = FastAPI()


@app.get("/items/{item_id}")
async def read_user_item(
    item_id: str, needy: str, skip: int = 0, limit: Union[int, None] = None
):
    item = {"item_id": item_id, "needy": needy, "skip": skip, "limit": limit}
    return item

ğŸ¤“ Other versions and variants
Python 3.8+

from typing import Union

from fastapi import FastAPI

app = FastAPI()


@app.get("/items/{item_id}")
async def read_user_item(
    item_id: str, needy: str, skip: int = 0, limit: Union[int, None] = None
):
    item = {"item_id": item_id, "needy": needy, "skip": skip, "limit": limit}
    return item

In this case, there are 3 query parameters:

    needy, a required str.
    skip, an int with a default value of 0.
    limit, an optional int.

Tip

You could also use Enums the same way as with Path Parameters.



In Pydantic v1 the method was called .dict(), it was deprecated (but still supported) in Pydantic v2, and renamed to .model_dump().

The examples here use .dict() for compatibility with Pydantic v1, but you should use .model_dump() instead if you can use Pydantic v2.
Request body + path parametersÂ¶

You can declare path parameters and request body at the same time.

FastAPI will recognize that the function parameters that match path parameters should be taken from the path, and that function parameters that are declared to be Pydantic models should be taken from the request body.
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


app = FastAPI()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    return {"item_id": item_id, **item.dict()}

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    return {"item_id": item_id, **item.dict()}

ğŸ¤“ Other versions and variants
Python 3.8+

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    return {"item_id": item_id, **item.dict()}

ğŸ¤“ Other versions and variants
Python 3.8+

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    return {"item_id": item_id, **item.dict()}

Request body + path + query parametersÂ¶

You can also declare body, path and query parameters, all at the same time.

FastAPI will recognize each of them and take the data from the correct place.
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


app = FastAPI()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item, q: str | None = None):
    result = {"item_id": item_id, **item.dict()}
    if q:
        result.update({"q": q})
    return result

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item, q: Union[str, None] = None):
    result = {"item_id": item_id, **item.dict()}
    if q:
        result.update({"q": q})
    return result

ğŸ¤“ Other versions and variants
Python 3.8+

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item, q: Union[str, None] = None):
    result = {"item_id": item_id, **item.dict()}
    if q:
        result.update({"q": q})
    return result

ğŸ¤“ Other versions and variants
Python 3.8+

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item, q: Union[str, None] = None):
    result = {"item_id": item_id, **item.dict()}
    if q:
        result.update({"q": q})
    return result

The function parameters will be recognized as follows:

    If the parameter is also declared in the path, it will be used as a path parameter.
    If the parameter is of a singular type (like int, float, str, bool, etc) it will be interpreted as a query parameter.
    If the parameter is declared to be of the type of a Pydantic model, it will be interpreted as a request body.

Note

FastAPI will know that the value of q is not required because of the default value = None.

The str | None (Python 3.10+) or Union in Union[str, None] (Python 3.8+) is not used by FastAPI to determine that the value is not required, it will know it's not required because it has a default value of = None.

But adding the type annotations will allow your editor to give you better support and detect errors.
Without PydanticÂ¶

If you don't want to use Pydantic models, you can also use Body parameters. See the docs for Body - Multiple Parameters: Singular values in body.



    FastAPI
    Learn
    Tutorial - User Guide

Request BodyÂ¶

When you need to send data from a client (let's say, a browser) to your API, you send it as a request body.

A request body is data sent by the client to your API. A response body is the data your API sends to the client.

Your API almost always has to send a response body. But clients don't necessarily need to send request bodies all the time, sometimes they only request a path, maybe with some query parameters, but don't send a body.

To declare a request body, you use Pydantic models with all their power and benefits.

Info

To send data, you should use one of: POST (the more common), PUT, DELETE or PATCH.

Sending a body with a GET request has an undefined behavior in the specifications, nevertheless, it is supported by FastAPI, only for very complex/extreme use cases.

As it is discouraged, the interactive docs with Swagger UI won't show the documentation for the body when using GET, and proxies in the middle might not support it.
Import Pydantic's BaseModelÂ¶

First, you need to import BaseModel from pydantic:
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    return item

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    return item

ğŸ¤“ Other versions and variants
Python 3.8+

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    return item

ğŸ¤“ Other versions and variants
Python 3.8+

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    return item

Create your data modelÂ¶

Then you declare your data model as a class that inherits from BaseModel.

Use standard Python types for all the attributes:
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    return item

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    return item

ğŸ¤“ Other versions and variants
Python 3.8+

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    return item

ğŸ¤“ Other versions and variants
Python 3.8+

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    return item

The same as when declaring query parameters, when a model attribute has a default value, it is not required. Otherwise, it is required. Use None to make it just optional.

For example, this model above declares a JSON "object" (or Python dict) like:

{
    "name": "Foo",
    "description": "An optional description",
    "price": 45.2,
    "tax": 3.5
}

...as description and tax are optional (with a default value of None), this JSON "object" would also be valid:

{
    "name": "Foo",
    "price": 45.2
}

Declare it as a parameterÂ¶

To add it to your path operation, declare it the same way you declared path and query parameters:
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    return item

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    return item

ğŸ¤“ Other versions and variants
Python 3.8+

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    return item

ğŸ¤“ Other versions and variants
Python 3.8+

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    return item

...and declare its type as the model you created, Item.
ResultsÂ¶

With just that Python type declaration, FastAPI will:

    Read the body of the request as JSON.
    Convert the corresponding types (if needed).
    Validate the data.
        If the data is invalid, it will return a nice and clear error, indicating exactly where and what was the incorrect data.
    Give you the received data in the parameter item.
        As you declared it in the function to be of type Item, you will also have all the editor support (completion, etc) for all of the attributes and their types.
    Generate JSON Schema definitions for your model, you can also use them anywhere else you like if it makes sense for your project.
    Those schemas will be part of the generated OpenAPI schema, and used by the automatic documentation UIs.

Automatic docsÂ¶

The JSON Schemas of your models will be part of your OpenAPI generated schema, and will be shown in the interactive API docs:

And will also be used in the API docs inside each path operation that needs them:

Editor supportÂ¶

In your editor, inside your function you will get type hints and completion everywhere (this wouldn't happen if you received a dict instead of a Pydantic model):

You also get error checks for incorrect type operations:

This is not by chance, the whole framework was built around that design.

And it was thoroughly tested at the design phase, before any implementation, to ensure it would work with all the editors.

There were even some changes to Pydantic itself to support this.

The previous screenshots were taken with Visual Studio Code.

But you would get the same editor support with PyCharm and most of the other Python editors:

Tip

If you use PyCharm as your editor, you can use the Pydantic PyCharm Plugin.

It improves editor support for Pydantic models, with:

    auto-completion
    type checks
    refactoring
    searching
    inspections

Use the modelÂ¶

Inside of the function, you can access all the attributes of the model object directly:
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    item_dict = item.dict()
    if item.tax is not None:
        price_with_tax = item.price + item.tax
        item_dict.update({"price_with_tax": price_with_tax})
    return item_dict

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    item_dict = item.dict()
    if item.tax is not None:
        price_with_tax = item.price + item.tax
        item_dict.update({"price_with_tax": price_with_tax})
    return item_dict

ğŸ¤“ Other versions and variants
Python 3.8+

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    item_dict = item.dict()
    if item.tax is not None:
        price_with_tax = item.price + item.tax
        item_dict.update({"price_with_tax": price_with_tax})
    return item_dict

ğŸ¤“ Other versions and variants
Python 3.8+

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    item_dict = item.dict()
    if item.tax is not None:
        price_with_tax = item.price + item.tax
        item_dict.update({"price_with_tax": price_with_tax})
    return item_dict

Info

In Pydantic v1 the method was called .dict(), it was deprecated (but still supported) in Pydantic v2, and renamed to .model_dump().

The examples here use .dict() for compatibility with Pydantic v1, but you should use .model_dump() instead if you can use Pydantic v2.
Request body + path parametersÂ¶

You can declare path parameters and request body at the same time.

FastAPI will recognize that the function parameters that match path parameters should be taken from the path, and that function parameters that are declared to be Pydantic models should be taken from the request body.
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


app = FastAPI()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    return {"item_id": item_id, **item.dict()}

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    return {"item_id": item_id, **item.dict()}

ğŸ¤“ Other versions and variants
Python 3.8+

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    return {"item_id": item_id, **item.dict()}

ğŸ¤“ Other versions and variants
Python 3.8+

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    return {"item_id": item_id, **item.dict()}

Request body + path + query parametersÂ¶

You can also declare body, path and query parameters, all at the same time.

FastAPI will recognize each of them and take the data from the correct place.
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


app = FastAPI()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item, q: str | None = None):
    result = {"item_id": item_id, **item.dict()}
    if q:
        result.update({"q": q})
    return result

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item, q: Union[str, None] = None):
    result = {"item_id": item_id, **item.dict()}
    if q:
        result.update({"q": q})
    return result

ğŸ¤“ Other versions and variants
Python 3.8+

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item, q: Union[str, None] = None):
    result = {"item_id": item_id, **item.dict()}
    if q:
        result.update({"q": q})
    return result

ğŸ¤“ Other versions and variants
Python 3.8+

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None


app = FastAPI()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item, q: Union[str, None] = None):
    result = {"item_id": item_id, **item.dict()}
    if q:
        result.update({"q": q})
    return result

The function parameters will be recognized as follows:

    If the parameter is also declared in the path, it will be used as a path parameter.
    If the parameter is of a singular type (like int, float, str, bool, etc) it will be interpreted as a query parameter.
    If the parameter is declared to be of the type of a Pydantic model, it will be interpreted as a request body.

Note

FastAPI will know that the value of q is not required because of the default value = None.

The str | None (Python 3.10+) or Union in Union[str, None] (Python 3.8+) is not used by FastAPI to determine that the value is not required, it will know it's not required because it has a default value of = None.

But adding the type annotations will allow your editor to give you better support and detect errors.
Without PydanticÂ¶

If you don't want to use Pydantic models, you can also use Body parameters. See the docs for Body - Multiple Parameters: Singular values in body.


We convert this iterable object into a proper list with list(data.items()).

Then with random.choice() we can get a random value from the list, so, we get a tuple with (id, name). It will be something like ("imdb-tt0371724", "The Hitchhiker's Guide to the Galaxy").

Then we assign those two values of the tuple to the variables id and name.

So, if the user didn't provide an item ID, they will still receive a random suggestion.

...we do all this in a single simple line. ğŸ¤¯ Don't you love Python? ğŸ
Python 3.10+

# Code above omitted ğŸ‘†

@app.get("/items/")
async def read_items(
    id: Annotated[str | None, AfterValidator(check_valid_id)] = None,
):
    if id:
        item = data.get(id)
    else:
        id, item = random.choice(list(data.items()))
    return {"id": id, "name": item}

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

RecapÂ¶

You can declare additional validations and metadata for your parameters.

Generic validations and metadata:

    alias
    title
    description
    deprecated

Validations specific for strings:

    min_length
    max_length
    pattern

Custom validations using AfterValidator.

In these examples you saw how to declare validations for str values.

See the next chapters to learn how to declare validations for other types, like numbers.





    FastAPI
    Learn
    Tutorial - User Guide

Path Parameters and Numeric ValidationsÂ¶

In the same way that you can declare more validations and metadata for query parameters with Query, you can declare the same type of validations and metadata for path parameters with Path.
Import PathÂ¶

First, import Path from fastapi, and import Annotated:
Python 3.10+

from typing import Annotated

from fastapi import FastAPI, Path, Query

app = FastAPI()


@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get")],
    q: Annotated[str | None, Query(alias="item-query")] = None,
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Info

FastAPI added support for Annotated (and started recommending it) in version 0.95.0.

If you have an older version, you would get errors when trying to use Annotated.

Make sure you Upgrade the FastAPI version to at least 0.95.1 before using Annotated.
Declare metadataÂ¶

You can declare all the same parameters as for Query.

For example, to declare a title metadata value for the path parameter item_id you can type:
Python 3.10+

from typing import Annotated

from fastapi import FastAPI, Path, Query

app = FastAPI()


@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get")],
    q: Annotated[str | None, Query(alias="item-query")] = None,
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Note

A path parameter is always required as it has to be part of the path. Even if you declared it with None or set a default value, it would not affect anything, it would still be always required.
Order the parameters as you needÂ¶

Tip

This is probably not as important or necessary if you use Annotated.

Let's say that you want to declare the query parameter q as a required str.

And you don't need to declare anything else for that parameter, so you don't really need to use Query.

But you still need to use Path for the item_id path parameter. And you don't want to use Annotated for some reason.

Python will complain if you put a value with a "default" before a value that doesn't have a "default".

But you can re-order them, and have the value without a default (the query parameter q) first.

It doesn't matter for FastAPI. It will detect the parameters by their names, types and default declarations (Query, Path, etc), it doesn't care about the order.

So, you can declare your function as:
Python 3.8+ - non-Annotated

from fastapi import FastAPI, Path

app = FastAPI()


@app.get("/items/{item_id}")
async def read_items(q: str, item_id: int = Path(title="The ID of the item to get")):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

But keep in mind that if you use Annotated, you won't have this problem, it won't matter as you're not using the function parameter default values for Query() or Path().
Python 3.9+

from typing import Annotated

from fastapi import FastAPI, Path

app = FastAPI()


@app.get("/items/{item_id}")
async def read_items(
    q: str, item_id: Annotated[int, Path(title="The ID of the item to get")]
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Order the parameters as you need, tricksÂ¶

Tip

This is probably not as important or necessary if you use Annotated.

Here's a small trick that can be handy, but you won't need it often.

If you want to:

    declare the q query parameter without a Query nor any default value
    declare the path parameter item_id using Path
    have them in a different order
    not use Annotated

...Python has a little special syntax for that.

Pass *, as the first parameter of the function.

Python won't do anything with that *, but it will know that all the following parameters should be called as keyword arguments (key-value pairs), also known as kwargs. Even if they don't have a default value.
Python 3.8+ - non-Annotated

from fastapi import FastAPI, Path

app = FastAPI()


@app.get("/items/{item_id}")
async def read_items(*, item_id: int = Path(title="The ID of the item to get"), q: str):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Better with AnnotatedÂ¶

Keep in mind that if you use Annotated, as you are not using function parameter default values, you won't have this problem, and you probably won't need to use *.
Python 3.9+

from typing import Annotated

from fastapi import FastAPI, Path

app = FastAPI()


@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get")], q: str
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Number validations: greater than or equalÂ¶

With Query and Path (and others you'll see later) you can declare number constraints.

Here, with ge=1, item_id will need to be an integer number "greater than or equal" to 1.
Python 3.9+

from typing import Annotated

from fastapi import FastAPI, Path

app = FastAPI()


@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get", ge=1)], q: str
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Number validations: greater than and less than or equalÂ¶

The same applies for:

    gt: greater than
    le: less than or equal

Python 3.9+

from typing import Annotated

from fastapi import FastAPI, Path

app = FastAPI()


@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get", gt=0, le=1000)],
    q: str,
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    return results

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Number validations: floats, greater than and less thanÂ¶

Number validations also work for float values.

Here's where it becomes important to be able to declare gt and not just ge. As with it you can require, for example, that a value must be greater than 0, even if it is less than 1.

So, 0.5 would be a valid value. But 0.0 or 0 would not.

And the same for lt.
Python 3.9+

from typing import Annotated

from fastapi import FastAPI, Path, Query

app = FastAPI()


@app.get("/items/{item_id}")
async def read_items(
    *,
    item_id: Annotated[int, Path(title="The ID of the item to get", ge=0, le=1000)],
    q: str,
    size: Annotated[float, Query(gt=0, lt=10.5)],
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    if size:
        results.update({"size": size})
    return results

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

RecapÂ¶

With Query, Path (and others you haven't seen yet) you can declare metadata and string validations in the same ways as with Query Parameters and String Validations.

And you can also declare numeric validations:

    gt: greater than
    ge: greater than or equal
    lt: less than
    le: less than or equal

Info

Query, Path, and other classes you will see later are subclasses of a common Param class.

All of them share the same parameters for additional validation and metadata you have seen.

Technical Details

When you import Query, Path and others from fastapi, they are actually functions.

That when called, return instances of classes of the same name.

So, you import Query, which is a function. And when you call it, it returns an instance of a class also named Query.

These functions are there (instead of just using the classes directly) so that your editor doesn't mark errors about their types.

That way you can use your normal editor and coding tools without having to add custom configurations to disregard those errors.



    FastAPI
    Learn
    Tutorial - User Guide

Query Parameter ModelsÂ¶

If you have a group of query parameters that are related, you can create a Pydantic model to declare them.

This would allow you to re-use the model in multiple places and also to declare validations and metadata for all the parameters at once. ğŸ˜

Note

This is supported since FastAPI version 0.115.0. ğŸ¤“
Query Parameters with a Pydantic ModelÂ¶

Declare the query parameters that you need in a Pydantic model, and then declare the parameter as Query:
Python 3.10+

from typing import Annotated, Literal

from fastapi import FastAPI, Query
from pydantic import BaseModel, Field

app = FastAPI()


class FilterParams(BaseModel):
    limit: int = Field(100, gt=0, le=100)
    offset: int = Field(0, ge=0)
    order_by: Literal["created_at", "updated_at"] = "created_at"
    tags: list[str] = []


@app.get("/items/")
async def read_items(filter_query: Annotated[FilterParams, Query()]):
    return filter_query

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

FastAPI will extract the data for each field from the query parameters in the request and give you the Pydantic model you defined.
Check the DocsÂ¶

You can see the query parameters in the docs UI at /docs:
Forbid Extra Query ParametersÂ¶

In some special use cases (probably not very common), you might want to restrict the query parameters that you want to receive.

You can use Pydantic's model configuration to forbid any extra fields:
Python 3.10+

from typing import Annotated, Literal

from fastapi import FastAPI, Query
from pydantic import BaseModel, Field

app = FastAPI()


class FilterParams(BaseModel):
    model_config = {"extra": "forbid"}

    limit: int = Field(100, gt=0, le=100)
    offset: int = Field(0, ge=0)
    order_by: Literal["created_at", "updated_at"] = "created_at"
    tags: list[str] = []


@app.get("/items/")
async def read_items(filter_query: Annotated[FilterParams, Query()]):
    return filter_query

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

If a client tries to send some extra data in the query parameters, they will receive an error response.

For example, if the client tries to send a tool query parameter with a value of plumbus, like:

https://example.com/items/?limit=10&tool=plumbus

They will receive an error response telling them that the query parameter tool is not allowed:

{
    "detail": [
        {
            "type": "extra_forbidden",
            "loc": ["query", "tool"],
            "msg": "Extra inputs are not permitted",
            "input": "plumbus"
        }
    ]
}

SummaryÂ¶

You can use Pydantic models to declare query parameters in FastAPI. ğŸ˜

Tip

Spoiler alert: you can also use Pydantic models to declare cookies and headers, but you will read about that later in the tutorial. ğŸ¤«



    FastAPI
    Learn
    Tutorial - User Guide

Body - Multiple ParametersÂ¶

Now that we have seen how to use Path and Query, let's see more advanced uses of request body declarations.
Mix Path, Query and body parametersÂ¶

First, of course, you can mix Path, Query and request body parameter declarations freely and FastAPI will know what to do.

And you can also declare body parameters as optional, by setting the default to None:
Python 3.10+

from typing import Annotated

from fastapi import FastAPI, Path
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


@app.put("/items/{item_id}")
async def update_item(
    item_id: Annotated[int, Path(title="The ID of the item to get", ge=0, le=1000)],
    q: str | None = None,
    item: Item | None = None,
):
    results = {"item_id": item_id}
    if q:
        results.update({"q": q})
    if item:
        results.update({"item": item})
    return results

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Note

Notice that, in this case, the item that would be taken from the body is optional. As it has a None default value.
Multiple body parametersÂ¶

In the previous example, the path operations would expect a JSON body with the attributes of an Item, like:

{
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2
}

But you can also declare multiple body parameters, e.g. item and user:
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


class User(BaseModel):
    username: str
    full_name: str | None = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item, user: User):
    results = {"item_id": item_id, "item": item, "user": user}
    return results

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

In this case, FastAPI will notice that there is more than one body parameter in the function (there are two parameters that are Pydantic models).

So, it will then use the parameter names as keys (field names) in the body, and expect a body like:

{
    "item": {
        "name": "Foo",
        "description": "The pretender",
        "price": 42.0,
        "tax": 3.2
    },
    "user": {
        "username": "dave",
        "full_name": "Dave Grohl"
    }
}

Note

Notice that even though the item was declared the same way as before, it is now expected to be inside of the body with a key item.

FastAPI will do the automatic conversion from the request, so that the parameter item receives its specific content and the same for user.

It will perform the validation of the compound data, and will document it like that for the OpenAPI schema and automatic docs.
Singular values in bodyÂ¶

The same way there is a Query and Path to define extra data for query and path parameters, FastAPI provides an equivalent Body.

For example, extending the previous model, you could decide that you want to have another key importance in the same body, besides the item and user.

If you declare it as is, because it is a singular value, FastAPI will assume that it is a query parameter.

But you can instruct FastAPI to treat it as another body key using Body:
Python 3.10+

from typing import Annotated

from fastapi import Body, FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


class User(BaseModel):
    username: str
    full_name: str | None = None


@app.put("/items/{item_id}")
async def update_item(
    item_id: int, item: Item, user: User, importance: Annotated[int, Body()]
):
    results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
    return results

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

In this case, FastAPI will expect a body like:

{
    "item": {
        "name": "Foo",
        "description": "The pretender",
        "price": 42.0,
        "tax": 3.2
    },
    "user": {
        "username": "dave",
        "full_name": "Dave Grohl"
    },
    "importance": 5
}

Again, it will convert the data types, validate, document, etc.
Multiple body params and queryÂ¶

Of course, you can also declare additional query parameters whenever you need, additional to any body parameters.

As, by default, singular values are interpreted as query parameters, you don't have to explicitly add a Query, you can just do:

q: Union[str, None] = None

Or in Python 3.10 and above:

q: str | None = None

For example:
Python 3.10+

from typing import Annotated

from fastapi import Body, FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


class User(BaseModel):
    username: str
    full_name: str | None = None


@app.put("/items/{item_id}")
async def update_item(
    *,
    item_id: int,
    item: Item,
    user: User,
    importance: Annotated[int, Body(gt=0)],
    q: str | None = None,
):
    results = {"item_id": item_id, "item": item, "user": user, "importance": importance}
    if q:
        results.update({"q": q})
    return results

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Info

Body also has all the same extra validation and metadata parameters as Query, Path and others you will see later.
Embed a single body parameterÂ¶

Let's say you only have a single item body parameter from a Pydantic model Item.

By default, FastAPI will then expect its body directly.

But if you want it to expect a JSON with a key item and inside of it the model contents, as it does when you declare extra body parameters, you can use the special Body parameter embed:

item: Item = Body(embed=True)

as in:
Python 3.10+

from typing import Annotated

from fastapi import Body, FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):
    results = {"item_id": item_id, "item": item}
    return results

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

In this case FastAPI will expect a body like:

{
    "item": {
        "name": "Foo",
        "description": "The pretender",
        "price": 42.0,
        "tax": 3.2
    }
}

instead of:

{
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2
}

RecapÂ¶

You can add multiple body parameters to your path operation function, even though a request can only have a single body.

But FastAPI will handle it, give you the correct data in your function, and validate and document the correct schema in the path operation.

You can also declare singular values to be received as part of the body.

And you can instruct FastAPI to embed the body in a key even when there is only a single parameter declared.





    FastAPI
    Learn
    Tutorial - User Guide

Body - FieldsÂ¶

The same way you can declare additional validation and metadata in path operation function parameters with Query, Path and Body, you can declare validation and metadata inside of Pydantic models using Pydantic's Field.
Import FieldÂ¶

First, you have to import it:
Python 3.10+

from typing import Annotated

from fastapi import Body, FastAPI
from pydantic import BaseModel, Field

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = Field(
        default=None, title="The description of the item", max_length=300
    )
    price: float = Field(gt=0, description="The price must be greater than zero")
    tax: float | None = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):
    results = {"item_id": item_id, "item": item}
    return results

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Warning

Notice that Field is imported directly from pydantic, not from fastapi as are all the rest (Query, Path, Body, etc).
Declare model attributesÂ¶

You can then use Field with model attributes:
Python 3.10+

from typing import Annotated

from fastapi import Body, FastAPI
from pydantic import BaseModel, Field

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = Field(
        default=None, title="The description of the item", max_length=300
    )
    price: float = Field(gt=0, description="The price must be greater than zero")
    tax: float | None = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]):
    results = {"item_id": item_id, "item": item}
    return results

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Field works the same way as Query, Path and Body, it has all the same parameters, etc.

Technical Details

Actually, Query, Path and others you'll see next create objects of subclasses of a common Param class, which is itself a subclass of Pydantic's FieldInfo class.

And Pydantic's Field returns an instance of FieldInfo as well.

Body also returns objects of a subclass of FieldInfo directly. And there are others you will see later that are subclasses of the Body class.

Remember that when you import Query, Path, and others from fastapi, those are actually functions that return special classes.

Tip

Notice how each model's attribute with a type, default value and Field has the same structure as a path operation function's parameter, with Field instead of Path, Query and Body.
Add extra informationÂ¶

You can declare extra information in Field, Query, Body, etc. And it will be included in the generated JSON Schema.

You will learn more about adding extra information later in the docs, when learning to declare examples.

Warning

Extra keys passed to Field will also be present in the resulting OpenAPI schema for your application. As these keys may not necessarily be part of the OpenAPI specification, some OpenAPI tools, for example the OpenAPI validator, may not work with your generated schema.
RecapÂ¶

You can use Pydantic's Field to declare extra validations and metadata for model attributes.

You can also use the extra keyword arguments to pass additional JSON Schema metadata.


Attributes with lists of submodelsÂ¶

You can also use Pydantic models as subtypes of list, set, etc.:
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    images: list[Image] | None = None


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

This will expect (convert, validate, document, etc.) a JSON body like:

{
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2,
    "tags": [
        "rock",
        "metal",
        "bar"
    ],
    "images": [
        {
            "url": "http://example.com/baz.jpg",
            "name": "The Foo live"
        },
        {
            "url": "http://example.com/dave.jpg",
            "name": "The Baz"
        }
    ]
}

Info

Notice how the images key now has a list of image objects.
Deeply nested modelsÂ¶

You can define arbitrarily deeply nested models:
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    images: list[Image] | None = None


class Offer(BaseModel):
    name: str
    description: str | None = None
    price: float
    items: list[Item]


@app.post("/offers/")
async def create_offer(offer: Offer):
    return offer

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Info

Notice how Offer has a list of Items, which in turn have an optional list of Images
Bodies of pure listsÂ¶

If the top level value of the JSON body you expect is a JSON array (a Python list), you can declare the type in the parameter of the function, the same as in Pydantic models:

images: List[Image]

or in Python 3.9 and above:

images: list[Image]

as in:
Python 3.9+

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Image(BaseModel):
    url: HttpUrl
    name: str


@app.post("/images/multiple/")
async def create_multiple_images(images: list[Image]):
    return images

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Editor support everywhereÂ¶

And you get editor support everywhere.

Even for items inside of lists:

You couldn't get this kind of editor support if you were working directly with dict instead of Pydantic models.

But you don't have to worry about them either, incoming dicts are converted automatically and your output is converted automatically to JSON too.
Bodies of arbitrary dictsÂ¶

You can also declare a body as a dict with keys of some type and values of some other type.

This way, you don't have to know beforehand what the valid field/attribute names are (as would be the case with Pydantic models).

This would be useful if you want to receive keys that you don't already know.

Another useful case is when you want to have keys of another type (e.g., int).

That's what we are going to see here.

In this case, you would accept any dict as long as it has int keys with float values:
Python 3.9+

from fastapi import FastAPI

app = FastAPI()


@app.post("/index-weights/")
async def create_index_weights(weights: dict[int, float]):
    return weights

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Tip

Keep in mind that JSON only supports str as keys.

But Pydantic has automatic data conversion.

This means that, even though your API clients can only send strings as keys, as long as those strings contain pure integers, Pydantic will convert them and validate them.

And the dict you receive as weights will actually have int keys and float values.
RecapÂ¶

With FastAPI you have the maximum flexibility provided by Pydantic models, while keeping your code simple, short and elegant.

But with all the benefits:

    Editor support (completion everywhere!)
    Data conversion (a.k.a. parsing / serialization)
    Data validation
    Schema documentation
    Automatic docs



    Query()
    Header()
    Cookie()
    Body()
    Form()
    File()

you can also declare a group of examples with additional information that will be added to their JSON Schemas inside of OpenAPI.
Body with examplesÂ¶

Here we pass examples containing one example of the data expected in Body():
Python 3.10+

from typing import Annotated

from fastapi import Body, FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


@app.put("/items/{item_id}")
async def update_item(
    item_id: int,
    item: Annotated[
        Item,
        Body(
            examples=[
                {
                    "name": "Foo",
                    "description": "A very nice Item",
                    "price": 35.4,
                    "tax": 3.2,
                }
            ],
        ),
    ],
):
    results = {"item_id": item_id, "item": item}
    return results

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Example in the docs UIÂ¶

With any of the methods above it would look like this in the /docs:

Body with multiple examplesÂ¶

You can of course also pass multiple examples:
Python 3.10+

from typing import Annotated

from fastapi import Body, FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


@app.put("/items/{item_id}")
async def update_item(
    *,
    item_id: int,
    item: Annotated[
        Item,
        Body(
            examples=[
                {
                    "name": "Foo",
                    "description": "A very nice Item",
                    "price": 35.4,
                    "tax": 3.2,
                },
                {
                    "name": "Bar",
                    "price": "35.4",
                },
                {
                    "name": "Baz",
                    "price": "thirty five point four",
                },
            ],
        ),
    ],
):
    results = {"item_id": item_id, "item": item}
    return results

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

When you do this, the examples will be part of the internal JSON Schema for that body data.

Nevertheless, at the time of writing this, Swagger UI, the tool in charge of showing the docs UI, doesn't support showing multiple examples for the data in JSON Schema. But read below for a workaround.
OpenAPI-specific examplesÂ¶

Since before JSON Schema supported examples OpenAPI had support for a different field also called examples.

This OpenAPI-specific examples goes in another section in the OpenAPI specification. It goes in the details for each path operation, not inside each JSON Schema.

And Swagger UI has supported this particular examples field for a while. So, you can use it to show different examples in the docs UI.

The shape of this OpenAPI-specific field examples is a dict with multiple examples (instead of a list), each with extra information that will be added to OpenAPI too.

This doesn't go inside of each JSON Schema contained in OpenAPI, this goes outside, in the path operation directly.
Using the openapi_examples ParameterÂ¶

You can declare the OpenAPI-specific examples in FastAPI with the parameter openapi_examples for:

    Path()
    Query()
    Header()
    Cookie()
    Body()
    Form()
    File()

The keys of the dict identify each example, and each value is another dict.

Each specific example dict in the examples can contain:

    summary: Short description for the example.
    description: A long description that can contain Markdown text.
    value: This is the actual example shown, e.g. a dict.
    externalValue: alternative to value, a URL pointing to the example. Although this might not be supported by as many tools as value.

You can use it like this:
Python 3.10+

from typing import Annotated

from fastapi import Body, FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


@app.put("/items/{item_id}")
async def update_item(
    *,
    item_id: int,
    item: Annotated[
        Item,
        Body(
            openapi_examples={
                "normal": {
                    "summary": "A normal example",
                    "description": "A **normal** item works correctly.",
                    "value": {
                        "name": "Foo",
                        "description": "A very nice Item",
                        "price": 35.4,
                        "tax": 3.2,
                    },
                },
                "converted": {
                    "summary": "An example with converted data",
                    "description": "FastAPI can convert price `strings` to actual `numbers` automatically",
                    "value": {
                        "name": "Bar",
                        "price": "35.4",
                    },
                },
                "invalid": {
                    "summary": "Invalid data is rejected with an error",
                    "value": {
                        "name": "Baz",
                        "price": "thirty five point four",
                    },
                },
            },
        ),
    ],
):
    results = {"item_id": item_id, "item": item}
    return results

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

OpenAPI Examples in the Docs UIÂ¶

With openapi_examples added to Body() the /docs would look like:

Technical DetailsÂ¶

Tip

If you are already using FastAPI version 0.99.0 or above, you can probably skip these details.

They are more relevant for older versions, before OpenAPI 3.1.0 was available.

You can consider this a brief OpenAPI and JSON Schema history lesson. ğŸ¤“

Warning

These are very technical details about the standards JSON Schema and OpenAPI.

If the ideas above already work for you, that might be enough, and you probably don't need these details, feel free to skip them.

Before OpenAPI 3.1.0, OpenAPI used an older and modified version of JSON Schema.

JSON Schema didn't have examples, so OpenAPI added its own example field to its own modified version.

OpenAPI also added example and examples fields to other parts of the specification:

    Parameter Object (in the specification) that was used by FastAPI's:
        Path()
        Query()
        Header()
        Cookie()
    Request Body Object, in the field content, on the Media Type Object (in the specification) that was used by FastAPI's:
        Body()
        File()
        Form()

Info

This old OpenAPI-specific examples parameter is now openapi_examples since FastAPI 0.103.0.
JSON Schema's examples fieldÂ¶

But then JSON Schema added an examples field to a new version of the specification.

And then the new OpenAPI 3.1.0 was based on the latest version (JSON Schema 2020-12) that included this new field examples.

And now this new examples field takes precedence over the old single (and custom) example field, that is now deprecated.

This new examples field in JSON Schema is just a list of examples, not a dict with extra metadata as in the other places in OpenAPI (described above).

Info

Even after OpenAPI 3.1.0 was released with this new simpler integration with JSON Schema, for a while, Swagger UI, the tool that provides the automatic docs, didn't support OpenAPI 3.1.0 (it does since version 5.0.0 ğŸ‰).

Because of that, versions of FastAPI previous to 0.99.0 still used versions of OpenAPI lower than 3.1.0.
Pydantic and FastAPI examplesÂ¶

When you add examples inside a Pydantic model, using schema_extra or Field(examples=["something"]) that example is added to the JSON Schema for that Pydantic model.

And that JSON Schema of the Pydantic model is included in the OpenAPI of your API, and then it's used in the docs UI.

In versions of FastAPI before 0.99.0 (0.99.0 and above use the newer OpenAPI 3.1.0) when you used example or examples with any of the other utilities (Query(), Body(), etc.) those examples were not added to the JSON Schema that describes that data (not even to OpenAPI's own version of JSON Schema), they were added directly to the path operation declaration in OpenAPI (outside the parts of OpenAPI that use JSON Schema).

But now that FastAPI 0.99.0 and above uses OpenAPI 3.1.0, that uses JSON Schema 2020-12, and Swagger UI 5.0.0 and above, everything is more consistent and the examples are included in JSON Schema.
Swagger UI and OpenAPI-specific examplesÂ¶

Now, as Swagger UI didn't support multiple JSON Schema examples (as of 2023-08-26), users didn't have a way to show multiple examples in the docs.

To solve that, FastAPI 0.103.0 added support for declaring the same old OpenAPI-specific examples field with the new parameter openapi_examples. ğŸ¤“
SummaryÂ¶

I used to say I didn't like history that much... and look at me now giving "tech history" lessons. ğŸ˜…

In short, upgrade to FastAPI 0.99.0 or above, and things are much simpler, consistent, and intuitive, and you don't have to know all these historic details. ğŸ˜



    FastAPI
    Learn
    Tutorial - User Guide

Extra Data TypesÂ¶

Up to now, you have been using common data types, like:

    int
    float
    str
    bool

But you can also use more complex data types.

And you will still have the same features as seen up to now:

    Great editor support.
    Data conversion from incoming requests.
    Data conversion for response data.
    Data validation.
    Automatic annotation and documentation.

Other data typesÂ¶

Here are some of the additional data types you can use:

    UUID:
        A standard "Universally Unique Identifier", common as an ID in many databases and systems.
        In requests and responses will be represented as a str.
    datetime.datetime:
        A Python datetime.datetime.
        In requests and responses will be represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.
    datetime.date:
        Python datetime.date.
        In requests and responses will be represented as a str in ISO 8601 format, like: 2008-09-15.
    datetime.time:
        A Python datetime.time.
        In requests and responses will be represented as a str in ISO 8601 format, like: 14:23:55.003.
    datetime.timedelta:
        A Python datetime.timedelta.
        In requests and responses will be represented as a float of total seconds.
        Pydantic also allows representing it as a "ISO 8601 time diff encoding", see the docs for more info.
    frozenset:
        In requests and responses, treated the same as a set:
            In requests, a list will be read, eliminating duplicates and converting it to a set.
            In responses, the set will be converted to a list.
            The generated schema will specify that the set values are unique (using JSON Schema's uniqueItems).
    bytes:
        Standard Python bytes.
        In requests and responses will be treated as str.
        The generated schema will specify that it's a str with binary "format".
    Decimal:
        Standard Python Decimal.
        In requests and responses, handled the same as a float.
    You can check all the valid Pydantic data types here: Pydantic data types.

ExampleÂ¶

Here's an example path operation with parameters using some of the above types.
Python 3.10+

from datetime import datetime, time, timedelta
from typing import Annotated
from uuid import UUID

from fastapi import Body, FastAPI

app = FastAPI()


@app.put("/items/{item_id}")
async def read_items(
    item_id: UUID,
    start_datetime: Annotated[datetime, Body()],
    end_datetime: Annotated[datetime, Body()],
    process_after: Annotated[timedelta, Body()],
    repeat_at: Annotated[time | None, Body()] = None,
):
    start_process = start_datetime + process_after
    duration = end_datetime - start_process
    return {
        "item_id": item_id,
        "start_datetime": start_datetime,
        "end_datetime": end_datetime,
        "process_after": process_after,
        "repeat_at": repeat_at,
        "start_process": start_process,
        "duration": duration,
    }

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Note that the parameters inside the function have their natural data type, and you can, for example, perform normal date manipulations, like:
Python 3.10+

from datetime import datetime, time, timedelta
from typing import Annotated
from uuid import UUID

from fastapi import Body, FastAPI

app = FastAPI()


@app.put("/items/{item_id}")
async def read_items(
    item_id: UUID,
    start_datetime: Annotated[datetime, Body()],
    end_datetime: Annotated[datetime, Body()],
    process_after: Annotated[timedelta, Body()],
    repeat_at: Annotated[time | None, Body()] = None,
):
    start_process = start_datetime + process_after
    duration = end_datetime - start_process
    return {
        "item_id": item_id,
        "start_datetime": start_datetime,
        "end_datetime": end_datetime,
        "process_after": process_after,
        "repeat_at": repeat_at,
        "start_process": start_process,
        "duration": duration,
    }

ğŸ¤“ Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated

from datetime import datetime, time, timedelta
from typing import Annotated, Union
from uuid import UUID

from fastapi import Body, FastAPI

app = FastAPI()


@app.put("/items/{item_id}")
async def read_items(
    item_id: UUID,
    start_datetime: Annotated[datetime, Body()],
    end_datetime: Annotated[datetime, Body()],
    process_after: Annotated[timedelta, Body()],
    repeat_at: Annotated[Union[time, None], Body()] = None,
):
    start_process = start_datetime + process_after
    duration = end_datetime - start_process
    return {
        "item_id": item_id,
        "start_datetime": start_datetime,
        "end_datetime": end_datetime,
        "process_after": process_after,
        "repeat_at": repeat_at,
        "start_process": start_process,
        "duration": duration,
    }



    FastAPI
    Learn
    Tutorial - User Guide

Cookie ParametersÂ¶

You can define Cookie parameters the same way you define Query and Path parameters.
Import CookieÂ¶

First import Cookie:
Python 3.10+

from typing import Annotated

from fastapi import Cookie, FastAPI

app = FastAPI()


@app.get("/items/")
async def read_items(ads_id: Annotated[str | None, Cookie()] = None):
    return {"ads_id": ads_id}

from typing import Annotated, Union

from fastapi import Cookie, FastAPI

app = FastAPI()


@app.get("/items/")
async def read_items(ads_id: Annotated[Union[str, None], Cookie()] = None):
    return {"ads_id": ads_id}

ğŸ¤“ Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated

from typing import Annotated, Union

from fastapi import Cookie, FastAPI

app = FastAPI()


@app.get("/items/")
async def read_items(ads_id: Annotated[Union[str, None], Cookie()] = None):
    return {"ads_id": ads_id}

ğŸ¤“ Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.8+ - non-Annotated

from typing import Annotated, Union

from fastapi import Cookie, FastAPI

app = FastAPI()


@app.get("/items/")
async def read_items(ads_id: Annotated[Union[str, None], Cookie()] = None):
    return {"ads_id": ads_id}

Declare Cookie parametersÂ¶

Then declare the cookie parameters using the same structure as with Path and Query.

You can define the default value as well as all the extra validation or annotation parameters:
Python 3.10+

from typing import Annotated

from fastapi import Cookie, FastAPI

app = FastAPI()


@app.get("/items/")
async def read_items(ads_id: Annotated[str | None, Cookie()] = None):
    return {"ads_id": ads_id}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Technical Details

Cookie is a "sister" class of Path and Query. It also inherits from the same common Param class.

But remember that when you import Query, Path, Cookie and others from fastapi, those are actually functions that return special classes.

Info

To declare cookies, you need to use Cookie, because otherwise the parameters would be interpreted as query parameters.

Info

Have in mind that, as browsers handle cookies in special ways and behind the scenes, they don't easily allow JavaScript to touch them.

If you go to the API docs UI at /docs you will be able to see the documentation for cookies for your path operations.

But even if you fill the data and click "Execute", because the docs UI works with JavaScript, the cookies won't be sent, and you will see an error message as if you didn't write any values.
RecapÂ¶

Declare cookies with Cookie, using the same common pattern as Query and Path.




Info

To declare headers, you need to use Header, because otherwise the parameters would be interpreted as query parameters.
Automatic conversionÂ¶

Header has a little extra functionality on top of what Path, Query and Cookie provide.

Most of the standard headers are separated by a "hyphen" character, also known as the "minus symbol" (-).

But a variable like user-agent is invalid in Python.

So, by default, Header will convert the parameter names characters from underscore (_) to hyphen (-) to extract and document the headers.

Also, HTTP headers are case-insensitive, so, you can declare them with standard Python style (also known as "snake_case").

So, you can use user_agent as you normally would in Python code, instead of needing to capitalize the first letters as User_Agent or something similar.

If for some reason you need to disable automatic conversion of underscores to hyphens, set the parameter convert_underscores of Header to False:
Python 3.10+

from typing import Annotated

from fastapi import FastAPI, Header

app = FastAPI()


@app.get("/items/")
async def read_items(
    strange_header: Annotated[str | None, Header(convert_underscores=False)] = None,
):
    return {"strange_header": strange_header}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Warning

Before setting convert_underscores to False, bear in mind that some HTTP proxies and servers disallow the usage of headers with underscores.
Duplicate headersÂ¶

It is possible to receive duplicate headers. That means, the same header with multiple values.

You can define those cases using a list in the type declaration.

You will receive all the values from the duplicate header as a Python list.

For example, to declare a header of X-Token that can appear more than once, you can write:
Python 3.10+

from typing import Annotated

from fastapi import FastAPI, Header

app = FastAPI()


@app.get("/items/")
async def read_items(x_token: Annotated[list[str] | None, Header()] = None):
    return {"X-Token values": x_token}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

If you communicate with that path operation sending two HTTP headers like:

X-Token: foo
X-Token: bar

The response would be like:

{
    "X-Token values": [
        "bar",
        "foo"
    ]
}

RecapÂ¶

Declare headers with Header, using the same common pattern as Query, Path and Cookie.

And don't worry about underscores in your variables, FastAPI will take care of converting them.



    FastAPI
    Learn
    Tutorial - User Guide

Cookie Parameter ModelsÂ¶

If you have a group of cookies that are related, you can create a Pydantic model to declare them. ğŸª

This would allow you to re-use the model in multiple places and also to declare validations and metadata for all the parameters at once. ğŸ˜

Note

This is supported since FastAPI version 0.115.0. ğŸ¤“

Tip

This same technique applies to Query, Cookie, and Header. ğŸ˜
Cookies with a Pydantic ModelÂ¶

Declare the cookie parameters that you need in a Pydantic model, and then declare the parameter as Cookie:
Python 3.10+

from typing import Annotated

from fastapi import Cookie, FastAPI
from pydantic import BaseModel

app = FastAPI()


class Cookies(BaseModel):
    session_id: str
    fatebook_tracker: str | None = None
    googall_tracker: str | None = None


@app.get("/items/")
async def read_items(cookies: Annotated[Cookies, Cookie()]):
    return cookies

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

FastAPI will extract the data for each field from the cookies received in the request and give you the Pydantic model you defined.
Check the DocsÂ¶

You can see the defined cookies in the docs UI at /docs:

Info

Have in mind that, as browsers handle cookies in special ways and behind the scenes, they don't easily allow JavaScript to touch them.

If you go to the API docs UI at /docs you will be able to see the documentation for cookies for your path operations.

But even if you fill the data and click "Execute", because the docs UI works with JavaScript, the cookies won't be sent, and you will see an error message as if you didn't write any values.
Forbid Extra CookiesÂ¶

In some special use cases (probably not very common), you might want to restrict the cookies that you want to receive.

Your API now has the power to control its own cookie consent. ğŸ¤ªğŸª

You can use Pydantic's model configuration to forbid any extra fields:
Python 3.9+

from typing import Annotated, Union

from fastapi import Cookie, FastAPI
from pydantic import BaseModel

app = FastAPI()


class Cookies(BaseModel):
    model_config = {"extra": "forbid"}

    session_id: str
    fatebook_tracker: Union[str, None] = None
    googall_tracker: Union[str, None] = None


@app.get("/items/")
async def read_items(cookies: Annotated[Cookies, Cookie()]):
    return cookies

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

If a client tries to send some extra cookies, they will receive an error response.

Poor cookie banners with all their effort to get your consent for the API to reject it. ğŸª

For example, if the client tries to send a santa_tracker cookie with a value of good-list-please, the client will receive an error response telling them that the santa_tracker cookie is not allowed:

{
    "detail": [
        {
            "type": "extra_forbidden",
            "loc": ["cookie", "santa_tracker"],
            "msg": "Extra inputs are not permitted",
            "input": "good-list-please",
        }
    ]
}

SummaryÂ¶

You can use Pydantic models to declare cookies in FastAPI. ğŸ˜



    FastAPI
    Learn
    Tutorial - User Guide

Header Parameter ModelsÂ¶

If you have a group of related header parameters, you can create a Pydantic model to declare them.

This would allow you to re-use the model in multiple places and also to declare validations and metadata for all the parameters at once. ğŸ˜

Note

This is supported since FastAPI version 0.115.0. ğŸ¤“
Header Parameters with a Pydantic ModelÂ¶

Declare the header parameters that you need in a Pydantic model, and then declare the parameter as Header:
Python 3.10+

from typing import Annotated

from fastapi import FastAPI, Header
from pydantic import BaseModel

app = FastAPI()


class CommonHeaders(BaseModel):
    host: str
    save_data: bool
    if_modified_since: str | None = None
    traceparent: str | None = None
    x_tag: list[str] = []


@app.get("/items/")
async def read_items(headers: Annotated[CommonHeaders, Header()]):
    return headers

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

FastAPI will extract the data for each field from the headers in the request and give you the Pydantic model you defined.
Check the DocsÂ¶

You can see the required headers in the docs UI at /docs:
Forbid Extra HeadersÂ¶

In some special use cases (probably not very common), you might want to restrict the headers that you want to receive.

You can use Pydantic's model configuration to forbid any extra fields:
Python 3.10+

from typing import Annotated

from fastapi import FastAPI, Header
from pydantic import BaseModel

app = FastAPI()


class CommonHeaders(BaseModel):
    model_config = {"extra": "forbid"}

    host: str
    save_data: bool
    if_modified_since: str | None = None
    traceparent: str | None = None
    x_tag: list[str] = []


@app.get("/items/")
async def read_items(headers: Annotated[CommonHeaders, Header()]):
    return headers

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

If a client tries to send some extra headers, they will receive an error response.

For example, if the client tries to send a tool header with a value of plumbus, they will receive an error response telling them that the header parameter tool is not allowed:

{
    "detail": [
        {
            "type": "extra_forbidden",
            "loc": ["header", "tool"],
            "msg": "Extra inputs are not permitted",
            "input": "plumbus",
        }
    ]
}

Disable Convert UnderscoresÂ¶

The same way as with regular header parameters, when you have underscore characters in the parameter names, they are automatically converted to hyphens.

For example, if you have a header parameter save_data in the code, the expected HTTP header will be save-data, and it will show up like that in the docs.

If for some reason you need to disable this automatic conversion, you can do it as well for Pydantic models for header parameters.
Python 3.10+

from typing import Annotated

from fastapi import FastAPI, Header
from pydantic import BaseModel

app = FastAPI()


class CommonHeaders(BaseModel):
    host: str
    save_data: bool
    if_modified_since: str | None = None
    traceparent: str | None = None
    x_tag: list[str] = []


@app.get("/items/")
async def read_items(
    headers: Annotated[CommonHeaders, Header(convert_underscores=False)],
):
    return headers

from typing import Annotated, Union

from fastapi import FastAPI, Header
from pydantic import BaseModel

app = FastAPI()


class CommonHeaders(BaseModel):
    host: str
    save_data: bool
    if_modified_since: Union[str, None] = None
    traceparent: Union[str, None] = None
    x_tag: list[str] = []


@app.get("/items/")
async def read_items(
    headers: Annotated[CommonHeaders, Header(convert_underscores=False)],
):
    return headers

ğŸ¤“ Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated

from typing import Annotated, Union

from fastapi import FastAPI, Header
from pydantic import BaseModel

app = FastAPI()


class CommonHeaders(BaseModel):
    host: str
    save_data: bool
    if_modified_since: Union[str, None] = None
    traceparent: Union[str, None] = None
    x_tag: list[str] = []


@app.get("/items/")
async def read_items(
    headers: Annotated[CommonHeaders, Header(convert_underscores=False)],
):
    return headers

ğŸ¤“ Other versions and variants
Python 3.9+
Python 3.8+
Python 3.10+ - non-Annotated
Python 3.9+ - non-Annotated
Python 3.8+ - non-Annotated

from typing import Annotated, Union

from fastapi import FastAPI, Header
from pydantic import BaseModel

app = FastAPI()


class CommonHeaders(BaseModel):
    host: str
    save_data: bool
    if_modified_since: Union[str, None] = None
    traceparent: Union[str, None] = None
    x_tag: list[str] = []


@app.get("/items/")
async def read_items(
    headers: Annotated[CommonHeaders, Header(convert_underscores=False)],
):
    return headers

Warning

Before setting convert_underscores to False, bear in mind that some HTTP proxies and servers disallow the usage of headers with underscores.
SummaryÂ¶

You can use Pydantic models to declare headers in FastAPI. ğŸ˜



    FastAPI
    Learn
    Tutorial - User Guide

Response Model - Return TypeÂ¶

You can declare the type used for the response by annotating the path operation function return type.

You can use type annotations the same way you would for input data in function parameters, you can use Pydantic models, lists, dictionaries, scalar values like integers, booleans, etc.
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: list[str] = []


@app.post("/items/")
async def create_item(item: Item) -> Item:
    return item


@app.get("/items/")
async def read_items() -> list[Item]:
    return [
        Item(name="Portal Gun", price=42.0),
        Item(name="Plumbus", price=32.0),
    ]

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: list[str] = []


@app.post("/items/")
async def create_item(item: Item) -> Item:
    return item


@app.get("/items/")
async def read_items() -> list[Item]:
    return [
        Item(name="Portal Gun", price=42.0),
        Item(name="Plumbus", price=32.0),
    ]

ğŸ¤“ Other versions and variants
Python 3.9+
Python 3.8+

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: list[str] = []


@app.post("/items/")
async def create_item(item: Item) -> Item:
    return item


@app.get("/items/")
async def read_items() -> list[Item]:
    return [
        Item(name="Portal Gun", price=42.0),
        Item(name="Plumbus", price=32.0),
    ]

ğŸ¤“ Other versions and variants
Python 3.9+
Python 3.8+

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: list[str] = []


@app.post("/items/")
async def create_item(item: Item) -> Item:
    return item


@app.get("/items/")
async def read_items() -> list[Item]:
    return [
        Item(name="Portal Gun", price=42.0),
        Item(name="Plumbus", price=32.0),
    ]

FastAPI will use this return type to:

    Validate the returned data.
        If the data is invalid (e.g. you are missing a field), it means that your app code is broken, not returning what it should, and it will return a server error instead of returning incorrect data. This way you and your clients can be certain that they will receive the data and the data shape expected.
    Add a JSON Schema for the response, in the OpenAPI path operation.
        This will be used by the automatic docs.
        It will also be used by automatic client code generation tools.

But most importantly:

    It will limit and filter the output data to what is defined in the return type.
        This is particularly important for security, we'll see more of that below.

response_model ParameterÂ¶

There are some cases where you need or want to return some data that is not exactly what the type declares.

For example, you could want to return a dictionary or a database object, but declare it as a Pydantic model. This way the Pydantic model would do all the data documentation, validation, etc. for the object that you returned (e.g. a dictionary or database object).

If you added the return type annotation, tools and editors would complain with a (correct) error telling you that your function is returning a type (e.g. a dict) that is different from what you declared (e.g. a Pydantic model).

In those cases, you can use the path operation decorator parameter response_model instead of the return type.

You can use the response_model parameter in any of the path operations:

    @app.get()
    @app.post()
    @app.put()
    @app.delete()
    etc.

Python 3.10+

from typing import Any

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: list[str] = []


@app.post("/items/", response_model=Item)
async def create_item(item: Item) -> Any:
    return item


@app.get("/items/", response_model=list[Item])
async def read_items() -> Any:
    return [
        {"name": "Portal Gun", "price": 42.0},
        {"name": "Plumbus", "price": 32.0},
    ]

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Note

Notice that response_model is a parameter of the "decorator" method (get, post, etc). Not of your path operation function, like all the parameters and body.

response_model receives the same type you would declare for a Pydantic model field, so, it can be a Pydantic model, but it can also be, e.g. a list of Pydantic models, like List[Item].

FastAPI will use this response_model to do all the data documentation, validation, etc. and also to convert and filter the output data to its type declaration.

Tip

If you have strict type checks in your editor, mypy, etc, you can declare the function return type as Any.

That way you tell the editor that you are intentionally returning anything. But FastAPI will still do the data documentation, validation, filtering, etc. with the response_model.
response_model PriorityÂ¶

If you declare both a return type and a response_model, the response_model will take priority and be used by FastAPI.

This way you can add correct type annotations to your functions even when you are returning a type different than the response model, to be used by the editor and tools like mypy. And still you can have FastAPI do the data validation, documentation, etc. using the response_model.

You can also use response_model=None to disable creating a response model for that path operation, you might need to do it if you are adding type annotations for things that are not valid Pydantic fields, you will see an example of that in one of the sections below.
Return the same input dataÂ¶

Here we are declaring a UserIn model, it will contain a plaintext password:
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

app = FastAPI()


class UserIn(BaseModel):
    username: str
    password: str
    email: EmailStr
    full_name: str | None = None


# Don't do this in production!
@app.post("/user/")
async def create_user(user: UserIn) -> UserIn:
    return user

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Info

To use EmailStr, first install email-validator.

Make sure you create a virtual environment, activate it, and then install it, for example:

$ pip install email-validator

or with:

$ pip install "pydantic[email]"

And we are using this model to declare our input and the same model to declare our output:
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

app = FastAPI()


class UserIn(BaseModel):
    username: str
    password: str
    email: EmailStr
    full_name: str | None = None


# Don't do this in production!
@app.post("/user/")
async def create_user(user: UserIn) -> UserIn:
    return user

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Now, whenever a browser is creating a user with a password, the API will return the same password in the response.

In this case, it might not be a problem, because it's the same user sending the password.

But if we use the same model for another path operation, we could be sending our user's passwords to every client.

Danger

Never store the plain password of a user or send it in a response like this, unless you know all the caveats and you know what you are doing.
Add an output modelÂ¶

We can instead create an input model with the plaintext password and an output model without it:
Python 3.10+

from typing import Any

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

app = FastAPI()


class UserIn(BaseModel):
    username: str
    password: str
    email: EmailStr
    full_name: str | None = None


class UserOut(BaseModel):
    username: str
    email: EmailStr
    full_name: str | None = None


@app.post("/user/", response_model=UserOut)
async def create_user(user: UserIn) -> Any:
    return user

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Here, even though our path operation function is returning the same input user that contains the password:
Python 3.10+

from typing import Any

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

app = FastAPI()


class UserIn(BaseModel):
    username: str
    password: str
    email: EmailStr
    full_name: str | None = None


class UserOut(BaseModel):
    username: str
    email: EmailStr
    full_name: str | None = None


@app.post("/user/", response_model=UserOut)
async def create_user(user: UserIn) -> Any:
    return user

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

...we declared the response_model to be our model UserOut, that doesn't include the password:
Python 3.10+

from typing import Any

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

app = FastAPI()


class UserIn(BaseModel):
    username: str
    password: str
    email: EmailStr
    full_name: str | None = None


class UserOut(BaseModel):
    username: str
    email: EmailStr
    full_name: str | None = None


@app.post("/user/", response_model=UserOut)
async def create_user(user: UserIn) -> Any:
    return user

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

So, FastAPI will take care of filtering out all the data that is not declared in the output model (using Pydantic).
response_model or Return TypeÂ¶

In this case, because the two models are different, if we annotated the function return type as UserOut, the editor and tools would complain that we are returning an invalid type, as those are different classes.

That's why in this example we have to declare it in the response_model parameter.

...but continue reading below to see how to overcome that.
Return Type and Data FilteringÂ¶

Let's continue from the previous example. We wanted to annotate the function with one type, but we wanted to be able to return from the function something that actually includes more data.

We want FastAPI to keep filtering the data using the response model. So that even though the function returns more data, the response will only include the fields declared in the response model.

In the previous example, because the classes were different, we had to use the response_model parameter. But that also means that we don't get the support from the editor and tools checking the function return type.

But in most of the cases where we need to do something like this, we want the model just to filter/remove some of the data as in this example.

And in those cases, we can use classes and inheritance to take advantage of function type annotations to get better support in the editor and tools, and still get the FastAPI data filtering.
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

app = FastAPI()


class BaseUser(BaseModel):
    username: str
    email: EmailStr
    full_name: str | None = None


class UserIn(BaseUser):
    password: str


@app.post("/user/")
async def create_user(user: UserIn) -> BaseUser:
    return user

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

With this, we get tooling support, from editors and mypy as this code is correct in terms of types, but we also get the data filtering from FastAPI.

How does this work? Let's check that out. ğŸ¤“
Type Annotations and ToolingÂ¶

First let's see how editors, mypy and other tools would see this.

BaseUser has the base fields. Then UserIn inherits from BaseUser and adds the password field, so, it will include all the fields from both models.

We annotate the function return type as BaseUser, but we are actually returning a UserIn instance.

The editor, mypy, and other tools won't complain about this because, in typing terms, UserIn is a subclass of BaseUser, which means it's a valid type when what is expected is anything that is a BaseUser.
FastAPI Data FilteringÂ¶

Now, for FastAPI, it will see the return type and make sure that what you return includes only the fields that are declared in the type.

FastAPI does several things internally with Pydantic to make sure that those same rules of class inheritance are not used for the returned data filtering, otherwise you could end up returning much more data than what you expected.

This way, you can get the best of both worlds: type annotations with tooling support and data filtering.
See it in the docsÂ¶

When you see the automatic docs, you can check that the input model and output model will both have their own JSON Schema:

And both models will be used for the interactive API documentation:

Other Return Type AnnotationsÂ¶

There might be cases where you return something that is not a valid Pydantic field and you annotate it in the function, only to get the support provided by tooling (the editor, mypy, etc).
Return a Response DirectlyÂ¶

The most common case would be returning a Response directly as explained later in the advanced docs.
Python 3.8+

from fastapi import FastAPI, Response
from fastapi.responses import JSONResponse, RedirectResponse

app = FastAPI()


@app.get("/portal")
async def get_portal(teleport: bool = False) -> Response:
    if teleport:
        return RedirectResponse(url="https://www.youtube.com/watch?v=dQw4w9WgXcQ")
    return JSONResponse(content={"message": "Here's your interdimensional portal."})

This simple case is handled automatically by FastAPI because the return type annotation is the class (or a subclass of) Response.

And tools will also be happy because both RedirectResponse and JSONResponse are subclasses of Response, so the type annotation is correct.
Annotate a Response SubclassÂ¶

You can also use a subclass of Response in the type annotation:
Python 3.8+

from fastapi import FastAPI
from fastapi.responses import RedirectResponse

app = FastAPI()


@app.get("/teleport")
async def get_teleport() -> RedirectResponse:
    return RedirectResponse(url="https://www.youtube.com/watch?v=dQw4w9WgXcQ")

This will also work because RedirectResponse is a subclass of Response, and FastAPI will automatically handle this simple case.
Invalid Return Type AnnotationsÂ¶

But when you return some other arbitrary object that is not a valid Pydantic type (e.g. a database object) and you annotate it like that in the function, FastAPI will try to create a Pydantic response model from that type annotation, and will fail.

The same would happen if you had something like a union between different types where one or more of them are not valid Pydantic types, for example this would fail ğŸ’¥:
Python 3.10+

from fastapi import FastAPI, Response
from fastapi.responses import RedirectResponse

app = FastAPI()


@app.get("/portal")
async def get_portal(teleport: bool = False) -> Response | dict:
    if teleport:
        return RedirectResponse(url="https://www.youtube.com/watch?v=dQw4w9WgXcQ")
    return {"message": "Here's your interdimensional portal."}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

...this fails because the type annotation is not a Pydantic type and is not just a single Response class or subclass, it's a union (any of the two) between a Response and a dict.
Disable Response ModelÂ¶

Continuing from the example above, you might not want to have the default data validation, documentation, filtering, etc. that is performed by FastAPI.

But you might want to still keep the return type annotation in the function to get the support from tools like editors and type checkers (e.g. mypy).

In this case, you can disable the response model generation by setting response_model=None:
Python 3.10+

from fastapi import FastAPI, Response
from fastapi.responses import RedirectResponse

app = FastAPI()


@app.get("/portal", response_model=None)
async def get_portal(teleport: bool = False) -> Response | dict:
    if teleport:
        return RedirectResponse(url="https://www.youtube.com/watch?v=dQw4w9WgXcQ")
    return {"message": "Here's your interdimensional portal."}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

This will make FastAPI skip the response model generation and that way you can have any return type annotations you need without it affecting your FastAPI application. ğŸ¤“
Response Model encoding parametersÂ¶

Your response model could have default values, like:
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float = 10.5
    tags: list[str] = []


items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
}


@app.get("/items/{item_id}", response_model=Item, response_model_exclude_unset=True)
async def read_item(item_id: str):
    return items[item_id]

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

    description: Union[str, None] = None (or str | None = None in Python 3.10) has a default of None.
    tax: float = 10.5 has a default of 10.5.
    tags: List[str] = [] has a default of an empty list: [].

but you might want to omit them from the result if they were not actually stored.

For example, if you have models with many optional attributes in a NoSQL database, but you don't want to send very long JSON responses full of default values.
Use the response_model_exclude_unset parameterÂ¶

You can set the path operation decorator parameter response_model_exclude_unset=True:
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float = 10.5
    tags: list[str] = []


items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
}


@app.get("/items/{item_id}", response_model=Item, response_model_exclude_unset=True)
async def read_item(item_id: str):
    return items[item_id]

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

and those default values won't be included in the response, only the values actually set.

So, if you send a request to that path operation for the item with ID foo, the response (not including default values) will be:

{
    "name": "Foo",
    "price": 50.2
}

Info

In Pydantic v1 the method was called .dict(), it was deprecated (but still supported) in Pydantic v2, and renamed to .model_dump().

The examples here use .dict() for compatibility with Pydantic v1, but you should use .model_dump() instead if you can use Pydantic v2.

Info

FastAPI uses Pydantic model's .dict() with its exclude_unset parameter to achieve this.

Info

You can also use:

    response_model_exclude_defaults=True
    response_model_exclude_none=True

as described in the Pydantic docs for exclude_defaults and exclude_none.
Data with values for fields with defaultsÂ¶

But if your data has values for the model's fields with default values, like the item with ID bar:

{
    "name": "Bar",
    "description": "The bartenders",
    "price": 62,
    "tax": 20.2
}

they will be included in the response.
Data with the same values as the defaultsÂ¶

If the data has the same values as the default ones, like the item with ID baz:

{
    "name": "Baz",
    "description": None,
    "price": 50.2,
    "tax": 10.5,
    "tags": []
}

FastAPI is smart enough (actually, Pydantic is smart enough) to realize that, even though description, tax, and tags have the same values as the defaults, they were set explicitly (instead of taken from the defaults).

So, they will be included in the JSON response.

Tip

Notice that the default values can be anything, not only None.

They can be a list ([]), a float of 10.5, etc.
response_model_include and response_model_excludeÂ¶

You can also use the path operation decorator parameters response_model_include and response_model_exclude.

They take a set of str with the name of the attributes to include (omitting the rest) or to exclude (including the rest).

This can be used as a quick shortcut if you have only one Pydantic model and want to remove some data from the output.

Tip

But it is still recommended to use the ideas above, using multiple classes, instead of these parameters.

This is because the JSON Schema generated in your app's OpenAPI (and the docs) will still be the one for the complete model, even if you use response_model_include or response_model_exclude to omit some attributes.

This also applies to response_model_by_alias that works similarly.
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float = 10.5


items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The Bar fighters", "price": 62, "tax": 20.2},
    "baz": {
        "name": "Baz",
        "description": "There goes my baz",
        "price": 50.2,
        "tax": 10.5,
    },
}


@app.get(
    "/items/{item_id}/name",
    response_model=Item,
    response_model_include={"name", "description"},
)
async def read_item_name(item_id: str):
    return items[item_id]


@app.get("/items/{item_id}/public", response_model=Item, response_model_exclude={"tax"})
async def read_item_public_data(item_id: str):
    return items[item_id]

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Tip

The syntax {"name", "description"} creates a set with those two values.

It is equivalent to set(["name", "description"]).
Using lists instead of setsÂ¶

If you forget to use a set and use a list or tuple instead, FastAPI will still convert it to a set and it will work correctly:
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float = 10.5


items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The Bar fighters", "price": 62, "tax": 20.2},
    "baz": {
        "name": "Baz",
        "description": "There goes my baz",
        "price": 50.2,
        "tax": 10.5,
    },
}


@app.get(
    "/items/{item_id}/name",
    response_model=Item,
    response_model_include=["name", "description"],
)
async def read_item_name(item_id: str):
    return items[item_id]


@app.get("/items/{item_id}/public", response_model=Item, response_model_exclude=["tax"])
async def read_item_public_data(item_id: str):
    return items[item_id]

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

RecapÂ¶

Use the path operation decorator's parameter response_model to define response models and especially to ensure private data is filtered out.

Use response_model_exclude_unset to return only the values explicitly set.



    FastAPI
    Learn
    Tutorial - User Guide

Extra ModelsÂ¶

Continuing with the previous example, it will be common to have more than one related model.

This is especially the case for user models, because:

    The input model needs to be able to have a password.
    The output model should not have a password.
    The database model would probably need to have a hashed password.

Danger

Never store user's plaintext passwords. Always store a "secure hash" that you can then verify.

If you don't know, you will learn what a "password hash" is in the security chapters.
Multiple modelsÂ¶

Here's a general idea of how the models could look like with their password fields and the places where they are used:
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

app = FastAPI()


class UserIn(BaseModel):
    username: str
    password: str
    email: EmailStr
    full_name: str | None = None


class UserOut(BaseModel):
    username: str
    email: EmailStr
    full_name: str | None = None


class UserInDB(BaseModel):
    username: str
    hashed_password: str
    email: EmailStr
    full_name: str | None = None


def fake_password_hasher(raw_password: str):
    return "supersecret" + raw_password


def fake_save_user(user_in: UserIn):
    hashed_password = fake_password_hasher(user_in.password)
    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)
    print("User saved! ..not really")
    return user_in_db


@app.post("/user/", response_model=UserOut)
async def create_user(user_in: UserIn):
    user_saved = fake_save_user(user_in)
    return user_saved

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Info

In Pydantic v1 the method was called .dict(), it was deprecated (but still supported) in Pydantic v2, and renamed to .model_dump().

The examples here use .dict() for compatibility with Pydantic v1, but you should use .model_dump() instead if you can use Pydantic v2.
About **user_in.dict()Â¶
Pydantic's .dict()Â¶

user_in is a Pydantic model of class UserIn.

Pydantic models have a .dict() method that returns a dict with the model's data.

So, if we create a Pydantic object user_in like:

user_in = UserIn(username="john", password="secret", email="john.doe@example.com")

and then we call:

user_dict = user_in.dict()

we now have a dict with the data in the variable user_dict (it's a dict instead of a Pydantic model object).

And if we call:

print(user_dict)

we would get a Python dict with:

{
    'username': 'john',
    'password': 'secret',
    'email': 'john.doe@example.com',
    'full_name': None,
}

Unpacking a dictÂ¶

If we take a dict like user_dict and pass it to a function (or class) with **user_dict, Python will "unpack" it. It will pass the keys and values of the user_dict directly as key-value arguments.

So, continuing with the user_dict from above, writing:

UserInDB(**user_dict)

would result in something equivalent to:

UserInDB(
    username="john",
    password="secret",
    email="john.doe@example.com",
    full_name=None,
)

Or more exactly, using user_dict directly, with whatever contents it might have in the future:

UserInDB(
    username = user_dict["username"],
    password = user_dict["password"],
    email = user_dict["email"],
    full_name = user_dict["full_name"],
)

A Pydantic model from the contents of anotherÂ¶

As in the example above we got user_dict from user_in.dict(), this code:

user_dict = user_in.dict()
UserInDB(**user_dict)

would be equivalent to:

UserInDB(**user_in.dict())

...because user_in.dict() is a dict, and then we make Python "unpack" it by passing it to UserInDB prefixed with **.

So, we get a Pydantic model from the data in another Pydantic model.
Unpacking a dict and extra keywordsÂ¶

And then adding the extra keyword argument hashed_password=hashed_password, like in:

UserInDB(**user_in.dict(), hashed_password=hashed_password)

...ends up being like:

UserInDB(
    username = user_dict["username"],
    password = user_dict["password"],
    email = user_dict["email"],
    full_name = user_dict["full_name"],
    hashed_password = hashed_password,
)

Warning

The supporting additional functions fake_password_hasher and fake_save_user are just to demo a possible flow of the data, but they of course are not providing any real security.
Reduce duplicationÂ¶

Reducing code duplication is one of the core ideas in FastAPI.

As code duplication increments the chances of bugs, security issues, code desynchronization issues (when you update in one place but not in the others), etc.

And these models are all sharing a lot of the data and duplicating attribute names and types.

We could do better.

We can declare a UserBase model that serves as a base for our other models. And then we can make subclasses of that model that inherit its attributes (type declarations, validation, etc).

All the data conversion, validation, documentation, etc. will still work as normally.

That way, we can declare just the differences between the models (with plaintext password, with hashed_password and without password):
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

app = FastAPI()


class UserBase(BaseModel):
    username: str
    email: EmailStr
    full_name: str | None = None


class UserIn(UserBase):
    password: str


class UserOut(UserBase):
    pass


class UserInDB(UserBase):
    hashed_password: str


def fake_password_hasher(raw_password: str):
    return "supersecret" + raw_password


def fake_save_user(user_in: UserIn):
    hashed_password = fake_password_hasher(user_in.password)
    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)
    print("User saved! ..not really")
    return user_in_db


@app.post("/user/", response_model=UserOut)
async def create_user(user_in: UserIn):
    user_saved = fake_save_user(user_in)
    return user_saved

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Union or anyOfÂ¶

You can declare a response to be the Union of two or more types, that means, that the response would be any of them.

It will be defined in OpenAPI with anyOf.

To do that, use the standard Python type hint typing.Union:

Note

When defining a Union, include the most specific type first, followed by the less specific type. In the example below, the more specific PlaneItem comes before CarItem in Union[PlaneItem, CarItem].
Python 3.10+

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class BaseItem(BaseModel):
    description: str
    type: str


class CarItem(BaseItem):
    type: str = "car"


class PlaneItem(BaseItem):
    type: str = "plane"
    size: int


items = {
    "item1": {"description": "All my friends drive a low rider", "type": "car"},
    "item2": {
        "description": "Music is my aeroplane, it's my aeroplane",
        "type": "plane",
        "size": 5,
    },
}


@app.get("/items/{item_id}", response_model=Union[PlaneItem, CarItem])
async def read_item(item_id: str):
    return items[item_id]

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Union in Python 3.10Â¶

In this example we pass Union[PlaneItem, CarItem] as the value of the argument response_model.

Because we are passing it as a value to an argument instead of putting it in a type annotation, we have to use Union even in Python 3.10.

If it was in a type annotation we could have used the vertical bar, as:

some_variable: PlaneItem | CarItem

But if we put that in the assignment response_model=PlaneItem | CarItem we would get an error, because Python would try to perform an invalid operation between PlaneItem and CarItem instead of interpreting that as a type annotation.
List of modelsÂ¶

The same way, you can declare responses of lists of objects.

For that, use the standard Python typing.List (or just list in Python 3.9 and above):
Python 3.9+

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str


items = [
    {"name": "Foo", "description": "There comes my hero"},
    {"name": "Red", "description": "It's my aeroplane"},
]


@app.get("/items/", response_model=list[Item])
async def read_items():
    return items

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Response with arbitrary dictÂ¶

You can also declare a response using a plain arbitrary dict, declaring just the type of the keys and values, without using a Pydantic model.

This is useful if you don't know the valid field/attribute names (that would be needed for a Pydantic model) beforehand.

In this case, you can use typing.Dict (or just dict in Python 3.9 and above):
Python 3.9+

from fastapi import FastAPI

app = FastAPI()


@app.get("/keyword-weights/", response_model=dict[str, float])
async def read_keyword_weights():
    return {"foo": 2.3, "bar": 3.4}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

RecapÂ¶

Use multiple Pydantic models and inherit freely for each case.

You don't need to have a single data model per entity if that entity must be able to have different "states". As the case with the user "entity" with a state including password, password_hash and no password.



    FastAPI
    Learn
    Tutorial - User Guide

Response Status CodeÂ¶

The same way you can specify a response model, you can also declare the HTTP status code used for the response with the parameter status_code in any of the path operations:

    @app.get()
    @app.post()
    @app.put()
    @app.delete()
    etc.

Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.post("/items/", status_code=201)
async def create_item(name: str):
    return {"name": name}

Note

Notice that status_code is a parameter of the "decorator" method (get, post, etc). Not of your path operation function, like all the parameters and body.

The status_code parameter receives a number with the HTTP status code.

Info

status_code can alternatively also receive an IntEnum, such as Python's http.HTTPStatus.

It will:

    Return that status code in the response.
    Document it as such in the OpenAPI schema (and so, in the user interfaces):

Note

Some response codes (see the next section) indicate that the response does not have a body.

FastAPI knows this, and will produce OpenAPI docs that state there is no response body.
About HTTP status codesÂ¶

Note

If you already know what HTTP status codes are, skip to the next section.

In HTTP, you send a numeric status code of 3 digits as part of the response.

These status codes have a name associated to recognize them, but the important part is the number.

In short:

    100 - 199 are for "Information". You rarely use them directly. Responses with these status codes cannot have a body.
    200 - 299 are for "Successful" responses. These are the ones you would use the most.
        200 is the default status code, which means everything was "OK".
        Another example would be 201, "Created". It is commonly used after creating a new record in the database.
        A special case is 204, "No Content". This response is used when there is no content to return to the client, and so the response must not have a body.
    300 - 399 are for "Redirection". Responses with these status codes may or may not have a body, except for 304, "Not Modified", which must not have one.
    400 - 499 are for "Client error" responses. These are the second type you would probably use the most.
        An example is 404, for a "Not Found" response.
        For generic errors from the client, you can just use 400.
    500 - 599 are for server errors. You almost never use them directly. When something goes wrong at some part in your application code, or server, it will automatically return one of these status codes.

Tip

To know more about each status code and which code is for what, check the MDN documentation about HTTP status codes.
Shortcut to remember the namesÂ¶

Let's see the previous example again:
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.post("/items/", status_code=201)
async def create_item(name: str):
    return {"name": name}

201 is the status code for "Created".

But you don't have to memorize what each of these codes mean.

You can use the convenience variables from fastapi.status.
Python 3.8+

from fastapi import FastAPI, status

app = FastAPI()


@app.post("/items/", status_code=status.HTTP_201_CREATED)
async def create_item(name: str):
    return {"name": name}

They are just a convenience, they hold the same number, but that way you can use the editor's autocomplete to find them:

Technical Details

You could also use from starlette import status.

FastAPI provides the same starlette.status as fastapi.status just as a convenience for you, the developer. But it comes directly from Starlette.
Changing the defaultÂ¶

Later, in the Advanced User Guide, you will see how to return a different status code than the default you are declaring here.



    FastAPI
    Learn
    Tutorial - User Guide

Form DataÂ¶

When you need to receive form fields instead of JSON, you can use Form.

Info

To use forms, first install python-multipart.

Make sure you create a virtual environment, activate it, and then install it, for example:

$ pip install python-multipart

Import FormÂ¶

Import Form from fastapi:
Python 3.9+

from typing import Annotated

from fastapi import FastAPI, Form

app = FastAPI()


@app.post("/login/")
async def login(username: Annotated[str, Form()], password: Annotated[str, Form()]):
    return {"username": username}

from fastapi import FastAPI, Form
from typing_extensions import Annotated

app = FastAPI()


@app.post("/login/")
async def login(username: Annotated[str, Form()], password: Annotated[str, Form()]):
    return {"username": username}

ğŸ¤“ Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated

from fastapi import FastAPI, Form
from typing_extensions import Annotated

app = FastAPI()


@app.post("/login/")
async def login(username: Annotated[str, Form()], password: Annotated[str, Form()]):
    return {"username": username}

ğŸ¤“ Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated

from fastapi import FastAPI, Form
from typing_extensions import Annotated

app = FastAPI()


@app.post("/login/")
async def login(username: Annotated[str, Form()], password: Annotated[str, Form()]):
    return {"username": username}

Define Form parametersÂ¶

Create form parameters the same way you would for Body or Query:
Python 3.9+

from typing import Annotated

from fastapi import FastAPI, Form

app = FastAPI()


@app.post("/login/")
async def login(username: Annotated[str, Form()], password: Annotated[str, Form()]):
    return {"username": username}

from fastapi import FastAPI, Form
from typing_extensions import Annotated

app = FastAPI()


@app.post("/login/")
async def login(username: Annotated[str, Form()], password: Annotated[str, Form()]):
    return {"username": username}

ğŸ¤“ Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated

from fastapi import FastAPI, Form
from typing_extensions import Annotated

app = FastAPI()


@app.post("/login/")
async def login(username: Annotated[str, Form()], password: Annotated[str, Form()]):
    return {"username": username}

ğŸ¤“ Other versions and variants
Python 3.8+
Python 3.8+ - non-Annotated

from fastapi import FastAPI, Form
from typing_extensions import Annotated

app = FastAPI()


@app.post("/login/")
async def login(username: Annotated[str, Form()], password: Annotated[str, Form()]):
    return {"username": username}

For example, in one of the ways the OAuth2 specification can be used (called "password flow") it is required to send a username and password as form fields.

The spec requires the fields to be exactly named username and password, and to be sent as form fields, not JSON.

With Form you can declare the same configurations as with Body (and Query, Path, Cookie), including validation, examples, an alias (e.g. user-name instead of username), etc.

Info

Form is a class that inherits directly from Body.

Tip

To declare form bodies, you need to use Form explicitly, because without it the parameters would be interpreted as query parameters or body (JSON) parameters.
About "Form Fields"Â¶

The way HTML forms (<form></form>) sends the data to the server normally uses a "special" encoding for that data, it's different from JSON.

FastAPI will make sure to read that data from the right place instead of JSON.

Technical Details

Data from forms is normally encoded using the "media type" application/x-www-form-urlencoded.

But when the form includes files, it is encoded as multipart/form-data. You'll read about handling files in the next chapter.

If you want to read more about these encodings and form fields, head to the MDN web docs for POST.

Warning

You can declare multiple Form parameters in a path operation, but you can't also declare Body fields that you expect to receive as JSON, as the request will have the body encoded using application/x-www-form-urlencoded instead of application/json.

This is not a limitation of FastAPI, it's part of the HTTP protocol.
RecapÂ¶

Use Form to declare form data input parameters.



    FastAPI
    Learn
    Tutorial - User Guide

Form ModelsÂ¶

You can use Pydantic models to declare form fields in FastAPI.

Info

To use forms, first install python-multipart.

Make sure you create a virtual environment, activate it, and then install it, for example:

$ pip install python-multipart

Note

This is supported since FastAPI version 0.113.0. ğŸ¤“
Pydantic Models for FormsÂ¶

You just need to declare a Pydantic model with the fields you want to receive as form fields, and then declare the parameter as Form:
Python 3.9+

from typing import Annotated

from fastapi import FastAPI, Form
from pydantic import BaseModel

app = FastAPI()


class FormData(BaseModel):
    username: str
    password: str


@app.post("/login/")
async def login(data: Annotated[FormData, Form()]):
    return data

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

FastAPI will extract the data for each field from the form data in the request and give you the Pydantic model you defined.
Check the DocsÂ¶

You can verify it in the docs UI at /docs:
Forbid Extra Form FieldsÂ¶

In some special use cases (probably not very common), you might want to restrict the form fields to only those declared in the Pydantic model. And forbid any extra fields.

Note

This is supported since FastAPI version 0.114.0. ğŸ¤“

You can use Pydantic's model configuration to forbid any extra fields:
Python 3.9+

from typing import Annotated

from fastapi import FastAPI, Form
from pydantic import BaseModel

app = FastAPI()


class FormData(BaseModel):
    username: str
    password: str
    model_config = {"extra": "forbid"}


@app.post("/login/")
async def login(data: Annotated[FormData, Form()]):
    return data

ğŸ¤“ Other versions and variants


If a client tries to send some extra data, they will receive an error response.

For example, if the client tries to send the form fields:

    username: Rick
    password: Portal Gun
    extra: Mr. Poopybutthole

They will receive an error response telling them that the field extra is not allowed:

{
    "detail": [
        {
            "type": "extra_forbidden",
            "loc": ["body", "extra"],
            "msg": "Extra inputs are not permitted",
            "input": "Mr. Poopybutthole"
        }
    ]
}

SummaryÂ¶

You can use Pydantic models to declare form fields in FastAPI. ğŸ˜



    FastAPI
    Learn
    Tutorial - User Guide

Request FilesÂ¶

You can define files to be uploaded by the client using File.

Info

To receive uploaded files, first install python-multipart.

Make sure you create a virtual environment, activate it, and then install it, for example:

$ pip install python-multipart

This is because uploaded files are sent as "form data".
Import FileÂ¶

Import File and UploadFile from fastapi:
Python 3.9+

from typing import Annotated

from fastapi import FastAPI, File, UploadFile

app = FastAPI()


@app.post("/files/")
async def create_file(file: Annotated[bytes, File()]):
    return {"file_size": len(file)}


@app.post("/uploadfile/")
async def create_upload_file(file: UploadFile):
    return {"filename": file.filename}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Define File ParametersÂ¶

Create file parameters the same way you would for Body or Form:
Python 3.9+

from typing import Annotated

from fastapi import FastAPI, File, UploadFile

app = FastAPI()


@app.post("/files/")
async def create_file(file: Annotated[bytes, File()]):
    return {"file_size": len(file)}


@app.post("/uploadfile/")
async def create_upload_file(file: UploadFile):
    return {"filename": file.filename}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Info

File is a class that inherits directly from Form.

But remember that when you import Query, Path, File and others from fastapi, those are actually functions that return special classes.

Tip

To declare File bodies, you need to use File, because otherwise the parameters would be interpreted as query parameters or body (JSON) parameters.

The files will be uploaded as "form data".

If you declare the type of your path operation function parameter as bytes, FastAPI will read the file for you and you will receive the contents as bytes.

Keep in mind that this means that the whole contents will be stored in memory. This will work well for small files.

But there are several cases in which you might benefit from using UploadFile.
File Parameters with UploadFileÂ¶

Define a file parameter with a type of UploadFile:
Python 3.9+

from typing import Annotated

from fastapi import FastAPI, File, UploadFile

app = FastAPI()


@app.post("/files/")
async def create_file(file: Annotated[bytes, File()]):
    return {"file_size": len(file)}


@app.post("/uploadfile/")
async def create_upload_file(file: UploadFile):
    return {"filename": file.filename}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Using UploadFile has several advantages over bytes:

    You don't have to use File() in the default value of the parameter.
    It uses a "spooled" file:
        A file stored in memory up to a maximum size limit, and after passing this limit it will be stored in disk.
    This means that it will work well for large files like images, videos, large binaries, etc. without consuming all the memory.
    You can get metadata from the uploaded file.
    It has a file-like async interface.
    It exposes an actual Python SpooledTemporaryFile object that you can pass directly to other libraries that expect a file-like object.

UploadFileÂ¶

UploadFile has the following attributes:

    filename: A str with the original file name that was uploaded (e.g. myimage.jpg).
    content_type: A str with the content type (MIME type / media type) (e.g. image/jpeg).
    file: A SpooledTemporaryFile (a file-like object). This is the actual Python file object that you can pass directly to other functions or libraries that expect a "file-like" object.

UploadFile has the following async methods. They all call the corresponding file methods underneath (using the internal SpooledTemporaryFile).

    write(data): Writes data (str or bytes) to the file.
    read(size): Reads size (int) bytes/characters of the file.
    seek(offset): Goes to the byte position offset (int) in the file.
        E.g., await myfile.seek(0) would go to the start of the file.
        This is especially useful if you run await myfile.read() once and then need to read the contents again.
    close(): Closes the file.

As all these methods are async methods, you need to "await" them.

For example, inside of an async path operation function you can get the contents with:

contents = await myfile.read()

If you are inside of a normal def path operation function, you can access the UploadFile.file directly, for example:

contents = myfile.file.read()

async Technical Details

When you use the async methods, FastAPI runs the file methods in a threadpool and awaits for them.

Starlette Technical Details

FastAPI's UploadFile inherits directly from Starlette's UploadFile, but adds some necessary parts to make it compatible with Pydantic and the other parts of FastAPI.
What is "Form Data"Â¶

The way HTML forms (<form></form>) sends the data to the server normally uses a "special" encoding for that data, it's different from JSON.

FastAPI will make sure to read that data from the right place instead of JSON.

Technical Details

Data from forms is normally encoded using the "media type" application/x-www-form-urlencoded when it doesn't include files.

But when the form includes files, it is encoded as multipart/form-data. If you use File, FastAPI will know it has to get the files from the correct part of the body.

If you want to read more about these encodings and form fields, head to the MDN web docs for POST.

Warning

You can declare multiple File and Form parameters in a path operation, but you can't also declare Body fields that you expect to receive as JSON, as the request will have the body encoded using multipart/form-data instead of application/json.

This is not a limitation of FastAPI, it's part of the HTTP protocol.
Optional File UploadÂ¶

You can make a file optional by using standard type annotations and setting a default value of None:
Python 3.10+

from typing import Annotated

from fastapi import FastAPI, File, UploadFile

app = FastAPI()


@app.post("/files/")
async def create_file(file: Annotated[bytes | None, File()] = None):
    if not file:
        return {"message": "No file sent"}
    else:
        return {"file_size": len(file)}


@app.post("/uploadfile/")
async def create_upload_file(file: UploadFile | None = None):
    if not file:
        return {"message": "No upload file sent"}
    else:
        return {"filename": file.filename}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

UploadFile with Additional MetadataÂ¶

You can also use File() with UploadFile, for example, to set additional metadata:
Python 3.9+

from typing import Annotated

from fastapi import FastAPI, File, UploadFile

app = FastAPI()


@app.post("/files/")
async def create_file(file: Annotated[bytes, File(description="A file read as bytes")]):
    return {"file_size": len(file)}


@app.post("/uploadfile/")
async def create_upload_file(
    file: Annotated[UploadFile, File(description="A file read as UploadFile")],
):
    return {"filename": file.filename}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Multiple File UploadsÂ¶

It's possible to upload several files at the same time.

They would be associated to the same "form field" sent using "form data".

To use that, declare a list of bytes or UploadFile:
Python 3.9+

from typing import Annotated

from fastapi import FastAPI, File, UploadFile
from fastapi.responses import HTMLResponse

app = FastAPI()


@app.post("/files/")
async def create_files(files: Annotated[list[bytes], File()]):
    return {"file_sizes": [len(file) for file in files]}


@app.post("/uploadfiles/")
async def create_upload_files(files: list[UploadFile]):
    return {"filenames": [file.filename for file in files]}


@app.get("/")
async def main():
    content = """
<body>
<form action="/files/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
<form action="/uploadfiles/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
</body>
    """
    return HTMLResponse(content=content)

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

You will receive, as declared, a list of bytes or UploadFiles.

Technical Details

You could also use from starlette.responses import HTMLResponse.

FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette.
Multiple File Uploads with Additional MetadataÂ¶

And the same way as before, you can use File() to set additional parameters, even for UploadFile:
Python 3.9+

from typing import Annotated

from fastapi import FastAPI, File, UploadFile
from fastapi.responses import HTMLResponse

app = FastAPI()


@app.post("/files/")
async def create_files(
    files: Annotated[list[bytes], File(description="Multiple files as bytes")],
):
    return {"file_sizes": [len(file) for file in files]}


@app.post("/uploadfiles/")
async def create_upload_files(
    files: Annotated[
        list[UploadFile], File(description="Multiple files as UploadFile")
    ],
):
    return {"filenames": [file.filename for file in files]}


@app.get("/")
async def main():
    content = """
<body>
<form action="/files/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
<form action="/uploadfiles/" enctype="multipart/form-data" method="post">
<input name="files" type="file" multiple>
<input type="submit">
</form>
</body>
    """
    return HTMLResponse(content=content)

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

RecapÂ¶

Use File, bytes, and UploadFile to declare files to be uploaded in the request, sent as form data.
 Body or Query:
Python 3.9+

from typing import Annotated

from fastapi import FastAPI, File, Form, UploadFile

app = FastAPI()


@app.post("/files/")
async def create_file(
    file: Annotated[bytes, File()],
    fileb: Annotated[UploadFile, File()],
    token: Annotated[str, Form()],
):
    return {
        "file_size": len(file),
        "token": token,
        "fileb_content_type": fileb.content_type,
    }

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

The files and form fields will be uploaded as form data and you will receive the files and form fields.

And you can declare some of the files as bytes and some as UploadFile.

Warning

You can declare multiple File and Form parameters in a path operation, but you can't also declare Body fields that you expect to receive as JSON, as the request will have the body encoded using multipart/form-data instead of application/json.

This is not a limitation of FastAPI, it's part of the HTTP protocol.
RecapÂ¶

Use File and Form together when you need to receive data and files in the same request.



    FastAPI
    Learn
    Tutorial - User Guide

Handling ErrorsÂ¶

There are many situations in which you need to notify an error to a client that is using your API.

This client could be a browser with a frontend, a code from someone else, an IoT device, etc.

You could need to tell the client that:

    The client doesn't have enough privileges for that operation.
    The client doesn't have access to that resource.
    The item the client was trying to access doesn't exist.
    etc.

In these cases, you would normally return an HTTP status code in the range of 400 (from 400 to 499).

This is similar to the 200 HTTP status codes (from 200 to 299). Those "200" status codes mean that somehow there was a "success" in the request.

The status codes in the 400 range mean that there was an error from the client.

Remember all those "404 Not Found" errors (and jokes)?
Use HTTPExceptionÂ¶

To return HTTP responses with errors to the client you use HTTPException.
Import HTTPExceptionÂ¶
Python 3.8+

from fastapi import FastAPI, HTTPException

app = FastAPI()

items = {"foo": "The Foo Wrestlers"}


@app.get("/items/{item_id}")
async def read_item(item_id: str):
    if item_id not in items:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"item": items[item_id]}

Raise an HTTPException in your codeÂ¶

HTTPException is a normal Python exception with additional data relevant for APIs.

Because it's a Python exception, you don't return it, you raise it.

This also means that if you are inside a utility function that you are calling inside of your path operation function, and you raise the HTTPException from inside of that utility function, it won't run the rest of the code in the path operation function, it will terminate that request right away and send the HTTP error from the HTTPException to the client.

The benefit of raising an exception over returning a value will be more evident in the section about Dependencies and Security.

In this example, when the client requests an item by an ID that doesn't exist, raise an exception with a status code of 404:
Python 3.8+

from fastapi import FastAPI, HTTPException

app = FastAPI()

items = {"foo": "The Foo Wrestlers"}


@app.get("/items/{item_id}")
async def read_item(item_id: str):
    if item_id not in items:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"item": items[item_id]}

The resulting responseÂ¶

If the client requests http://example.com/items/foo (an item_id "foo"), that client will receive an HTTP status code of 200, and a JSON response of:

{
  "item": "The Foo Wrestlers"
}

But if the client requests http://example.com/items/bar (a non-existent item_id "bar"), that client will receive an HTTP status code of 404 (the "not found" error), and a JSON response of:

{
  "detail": "Item not found"
}

Tip

When raising an HTTPException, you can pass any value that can be converted to JSON as the parameter detail, not only str.

You could pass a dict, a list, etc.

They are handled automatically by FastAPI and converted to JSON.
Add custom headersÂ¶

There are some situations in where it's useful to be able to add custom headers to the HTTP error. For example, for some types of security.

You probably won't need to use it directly in your code.

But in case you needed it for an advanced scenario, you can add custom headers:
Python 3.8+

from fastapi import FastAPI, HTTPException

app = FastAPI()

items = {"foo": "The Foo Wrestlers"}


@app.get("/items-header/{item_id}")
async def read_item_header(item_id: str):
    if item_id not in items:
        raise HTTPException(
            status_code=404,
            detail="Item not found",
            headers={"X-Error": "There goes my error"},
        )
    return {"item": items[item_id]}

Install custom exception handlersÂ¶

You can add custom exception handlers with the same exception utilities from Starlette.

Let's say you have a custom exception UnicornException that you (or a library you use) might raise.

And you want to handle this exception globally with FastAPI.

You could add a custom exception handler with @app.exception_handler():
Python 3.8+

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse


class UnicornException(Exception):
    def __init__(self, name: str):
        self.name = name


app = FastAPI()


@app.exception_handler(UnicornException)
async def unicorn_exception_handler(request: Request, exc: UnicornException):
    return JSONResponse(
        status_code=418,
        content={"message": f"Oops! {exc.name} did something. There goes a rainbow..."},
    )


@app.get("/unicorns/{name}")
async def read_unicorn(name: str):
    if name == "yolo":
        raise UnicornException(name=name)
    return {"unicorn_name": name}

Here, if you request /unicorns/yolo, the path operation will raise a UnicornException.

But it will be handled by the unicorn_exception_handler.

So, you will receive a clean error, with an HTTP status code of 418 and a JSON content of:

{"message": "Oops! yolo did something. There goes a rainbow..."}

Technical Details

You could also use from starlette.requests import Request and from starlette.responses import JSONResponse.

FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with Request.
Override the default exception handlersÂ¶

FastAPI has some default exception handlers.

These handlers are in charge of returning the default JSON responses when you raise an HTTPException and when the request has invalid data.

You can override these exception handlers with your own.
Override request validation exceptionsÂ¶

When a request contains invalid data, FastAPI internally raises a RequestValidationError.

And it also includes a default exception handler for it.

To override it, import the RequestValidationError and use it with @app.exception_handler(RequestValidationError) to decorate the exception handler.

The exception handler will receive a Request and the exception.
Python 3.8+

from fastapi import FastAPI, HTTPException
from fastapi.exceptions import RequestValidationError
from fastapi.responses import PlainTextResponse
from starlette.exceptions import HTTPException as StarletteHTTPException

app = FastAPI()


@app.exception_handler(StarletteHTTPException)
async def http_exception_handler(request, exc):
    return PlainTextResponse(str(exc.detail), status_code=exc.status_code)


@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc):
    return PlainTextResponse(str(exc), status_code=400)


@app.get("/items/{item_id}")
async def read_item(item_id: int):
    if item_id == 3:
        raise HTTPException(status_code=418, detail="Nope! I don't like 3.")
    return {"item_id": item_id}

Now, if you go to /items/foo, instead of getting the default JSON error with:

{
    "detail": [
        {
            "loc": [
                "path",
                "item_id"
            ],
            "msg": "value is not a valid integer",
            "type": "type_error.integer"
        }
    ]
}

you will get a text version, with:

1 validation error
path -> item_id
  value is not a valid integer (type=type_error.integer)

RequestValidationError vs ValidationErrorÂ¶

Warning

These are technical details that you might skip if it's not important for you now.

RequestValidationError is a sub-class of Pydantic's ValidationError.

FastAPI uses it so that, if you use a Pydantic model in response_model, and your data has an error, you will see the error in your log.

But the client/user will not see it. Instead, the client will receive an "Internal Server Error" with an HTTP status code 500.

It should be this way because if you have a Pydantic ValidationError in your response or anywhere in your code (not in the client's request), it's actually a bug in your code.

And while you fix it, your clients/users shouldn't have access to internal information about the error, as that could expose a security vulnerability.
Override the HTTPException error handlerÂ¶

The same way, you can override the HTTPException handler.

For example, you could want to return a plain text response instead of JSON for these errors:
Python 3.8+

from fastapi import FastAPI, HTTPException
from fastapi.exceptions import RequestValidationError
from fastapi.responses import PlainTextResponse
from starlette.exceptions import HTTPException as StarletteHTTPException

app = FastAPI()


@app.exception_handler(StarletteHTTPException)
async def http_exception_handler(request, exc):
    return PlainTextResponse(str(exc.detail), status_code=exc.status_code)


@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc):
    return PlainTextResponse(str(exc), status_code=400)


@app.get("/items/{item_id}")
async def read_item(item_id: int):
    if item_id == 3:
        raise HTTPException(status_code=418, detail="Nope! I don't like 3.")
    return {"item_id": item_id}

Technical Details

You could also use from starlette.responses import PlainTextResponse.

FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette.
Use the RequestValidationError bodyÂ¶

The RequestValidationError contains the body it received with invalid data.

You could use it while developing your app to log the body and debug it, return it to the user, etc.
Python 3.8+

from fastapi import FastAPI, Request
from fastapi.encoders import jsonable_encoder
from fastapi.exceptions import RequestValidationError
from fastapi.responses import JSONResponse
from pydantic import BaseModel

app = FastAPI()


@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    return JSONResponse(
        status_code=422,
        content=jsonable_encoder({"detail": exc.errors(), "body": exc.body}),
    )


class Item(BaseModel):
    title: str
    size: int


@app.post("/items/")
async def create_item(item: Item):
    return item

Now try sending an invalid item like:

{
  "title": "towel",
  "size": "XL"
}

You will receive a response telling you that the data is invalid containing the received body:

{
  "detail": [
    {
      "loc": [
        "body",
        "size"
      ],
      "msg": "value is not a valid integer",
      "type": "type_error.integer"
    }
  ],
  "body": {
    "title": "towel",
    "size": "XL"
  }
}

FastAPI's HTTPException vs Starlette's HTTPExceptionÂ¶

FastAPI has its own HTTPException.

And FastAPI's HTTPException error class inherits from Starlette's HTTPException error class.

The only difference is that FastAPI's HTTPException accepts any JSON-able data for the detail field, while Starlette's HTTPException only accepts strings for it.

So, you can keep raising FastAPI's HTTPException as normally in your code.

But when you register an exception handler, you should register it for Starlette's HTTPException.

This way, if any part of Starlette's internal code, or a Starlette extension or plug-in, raises a Starlette HTTPException, your handler will be able to catch and handle it.

In this example, to be able to have both HTTPExceptions in the same code, Starlette's exceptions is renamed to StarletteHTTPException:

from starlette.exceptions import HTTPException as StarletteHTTPException

Reuse FastAPI's exception handlersÂ¶

If you want to use the exception along with the same default exception handlers from FastAPI, you can import and reuse the default exception handlers from fastapi.exception_handlers:
Python 3.8+

from fastapi import FastAPI, HTTPException
from fastapi.exception_handlers import (
    http_exception_handler,
    request_validation_exception_handler,
)
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException

app = FastAPI()


@app.exception_handler(StarletteHTTPException)
async def custom_http_exception_handler(request, exc):
    print(f"OMG! An HTTP error!: {repr(exc)}")
    return await http_exception_handler(request, exc)


@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc):
    print(f"OMG! The client sent invalid data!: {exc}")
    return await request_validation_exception_handler(request, exc)


@app.get("/items/{item_id}")
async def read_item(item_id: int):
    if item_id == 3:
        raise HTTPException(status_code=418, detail="Nope! I don't like 3.")
    return {"item_id": item_id}

In this example you are just printing the error with a very expressive message, but you get the idea. You can use the exception and then just reuse the default exception handlers.



    FastAPI
    Learn
    Tutorial - User Guide

Path Operation ConfigurationÂ¶

There are several parameters that you can pass to your path operation decorator to configure it.

Warning

Notice that these parameters are passed directly to the path operation decorator, not to your path operation function.
Response Status CodeÂ¶

You can define the (HTTP) status_code to be used in the response of your path operation.

You can pass directly the int code, like 404.

But if you don't remember what each number code is for, you can use the shortcut constants in status:
Python 3.10+

from fastapi import FastAPI, status
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()


@app.post("/items/", response_model=Item, status_code=status.HTTP_201_CREATED)
async def create_item(item: Item):
    return item

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

That status code will be used in the response and will be added to the OpenAPI schema.

Technical Details

You could also use from starlette import status.

FastAPI provides the same starlette.status as fastapi.status just as a convenience for you, the developer. But it comes directly from Starlette.
TagsÂ¶

You can add tags to your path operation, pass the parameter tags with a list of str (commonly just one str):
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()


@app.post("/items/", response_model=Item, tags=["items"])
async def create_item(item: Item):
    return item


@app.get("/items/", tags=["items"])
async def read_items():
    return [{"name": "Foo", "price": 42}]


@app.get("/users/", tags=["users"])
async def read_users():
    return [{"username": "johndoe"}]

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

They will be added to the OpenAPI schema and used by the automatic documentation interfaces:

Tags with EnumsÂ¶

If you have a big application, you might end up accumulating several tags, and you would want to make sure you always use the same tag for related path operations.

In these cases, it could make sense to store the tags in an Enum.

FastAPI supports that the same way as with plain strings:
Python 3.8+

from enum import Enum

from fastapi import FastAPI

app = FastAPI()


class Tags(Enum):
    items = "items"
    users = "users"


@app.get("/items/", tags=[Tags.items])
async def get_items():
    return ["Portal gun", "Plumbus"]


@app.get("/users/", tags=[Tags.users])
async def read_users():
    return ["Rick", "Morty"]

Summary and descriptionÂ¶

You can add a summary and description:
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()


@app.post(
    "/items/",
    response_model=Item,
    summary="Create an item",
    description="Create an item with all the information, name, description, price, tax and a set of unique tags",
)
async def create_item(


Response descriptionÂ¶

You can specify the response description with the parameter response_description:
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()


@app.post(
    "/items/",
    response_model=Item,
    summary="Create an item",
    response_description="The created item",
)
async def create_item(item: Item):
    """
    Create an item with all the information:

    - **name**: each item must have a name
    - **description**: a long description
    - **price**: required
    - **tax**: if the item doesn't have tax, you can omit this
    - **tags**: a set of unique tag strings for this item
    """
    return item

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Info

Notice that response_description refers specifically to the response, the description refers to the path operation in general.

Check

OpenAPI specifies that each path operation requires a response description.

So, if you don't provide one, FastAPI will automatically generate one of "Successful response".

Deprecate a path operationÂ¶

If you need to mark a path operation as deprecated, but without removing it, pass the parameter deprecated:
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/items/", tags=["items"])
async def read_items():
    return [{"name": "Foo", "price": 42}]


@app.get("/users/", tags=["users"])
async def read_users():
    return [{"username": "johndoe"}]


@app.get("/elements/", tags=["items"], deprecated=True)
async def read_elements():
    return [{"item_id": "Foo"}]

It will be clearly marked as deprecated in the interactive docs:

Check how deprecated and non-deprecated path operations look like:

RecapÂ¶

You can configure and add metadata for your path operations easily by passing parameters to the path operation decorators.



    FastAPI
    Learn
    Tutorial - User Guide

JSON Compatible EncoderÂ¶

There are some cases where you might need to convert a data type (like a Pydantic model) to something compatible with JSON (like a dict, list, etc).

For example, if you need to store it in a database.

For that, FastAPI provides a jsonable_encoder() function.
Using the jsonable_encoderÂ¶

Let's imagine that you have a database fake_db that only receives JSON compatible data.

For example, it doesn't receive datetime objects, as those are not compatible with JSON.

So, a datetime object would have to be converted to a str containing the data in ISO format.

The same way, this database wouldn't receive a Pydantic model (an object with attributes), only a dict.

You can use jsonable_encoder for that.

It receives an object, like a Pydantic model, and returns a JSON compatible version:
Python 3.10+

from datetime import datetime

from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel

fake_db = {}


class Item(BaseModel):
    title: str
    timestamp: datetime
    description: str | None = None


app = FastAPI()


@app.put("/items/{id}")
def update_item(id: str, item: Item):
    json_compatible_item_data = jsonable_encoder(item)
    fake_db[id] = json_compatible_item_data

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

In this example, it would convert the Pydantic model to a dict, and the datetime to a str.

The result of calling it is something that can be encoded with the Python standard json.dumps().

It doesn't return a large str containing the data in JSON format (as a string). It returns a Python standard data structure (e.g. a dict) with values and sub-values that are all compatible with JSON.

Note

jsonable_encoder is actually used by FastAPI internally to convert data. But it is useful in many other scenarios.


Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Body - Updates

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
            Security
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Update replacing with PUT
        Warning about replacing
    Partial updates with PATCH
        Using Pydantic's exclude_unset parameter
        Using Pydantic's update parameter
        Partial updates recap

    FastAPI
    Learn
    Tutorial - User Guide

Body - UpdatesÂ¶
Update replacing with PUTÂ¶

To update an item you can use the HTTP PUT operation.

You can use the jsonable_encoder to convert the input data to data that can be stored as JSON (e.g. with a NoSQL database). For example, converting datetime to str.
Python 3.10+

from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str | None = None
    description: str | None = None
    price: float | None = None
    tax: float = 10.5
    tags: list[str] = []


items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
}


@app.get("/items/{item_id}", response_model=Item)
async def read_item(item_id: str):
    return items[item_id]


@app.put("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item: Item):
    update_item_encoded = jsonable_encoder(item)
    items[item_id] = update_item_encoded
    return update_item_encoded

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

PUT is used to receive data that should replace the existing data.
Warning about replacingÂ¶

That means that if you want to update the item bar using PUT with a body containing:

{
    "name": "Barz",
    "price": 3,
    "description": None,
}

because it doesn't include the already stored attribute "tax": 20.2, the input model would take the default value of "tax": 10.5.

And the data would be saved with that "new" tax of 10.5.
Partial updates with PATCHÂ¶

You can also use the HTTP PATCH operation to partially update data.

This means that you can send only the data that you want to update, leaving the rest intact.

Note

PATCH is less commonly used and known than PUT.

And many teams use only PUT, even for partial updates.

You are free to use them however you want, FastAPI doesn't impose any restrictions.

But this guide shows you, more or less, how they are intended to be used.
Using Pydantic's exclude_unset parameterÂ¶

If you want to receive partial updates, it's very useful to use the parameter exclude_unset in Pydantic's model's .model_dump().

Like item.model_dump(exclude_unset=True).

Info

In Pydantic v1 the method was called .dict(), it was deprecated (but still supported) in Pydantic v2, and renamed to .model_dump().

The examples here use .dict() for compatibility with Pydantic v1, but you should use .model_dump() instead if you can use Pydantic v2.

That would generate a dict with only the data that was set when creating the item model, excluding default values.

Then you can use this to generate a dict with only the data that was set (sent in the request), omitting default values:
Python 3.10+

from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str | None = None
    description: str | None = None
    price: float | None = None
    tax: float = 10.5
    tags: list[str] = []


items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
}


@app.get("/items/{item_id}", response_model=Item)
async def read_item(item_id: str):
    return items[item_id]


@app.patch("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item: Item):
    stored_item_data = items[item_id]
    stored_item_model = Item(**stored_item_data)
    update_data = item.dict(exclude_unset=True)
    updated_item = stored_item_model.copy(update=update_data)
    items[item_id] = jsonable_encoder(updated_item)
    return updated_item

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Using Pydantic's update parameterÂ¶

Now, you can create a copy of the existing model using .model_copy(), and pass the update parameter with a dict containing the data to update.

Info

In Pydantic v1 the method was called .copy(), it was deprecated (but still supported) in Pydantic v2, and renamed to .model_copy().

The examples here use .copy() for compatibility with Pydantic v1, but you should use .model_copy() instead if you can use Pydantic v2.

Like stored_item_model.model_copy(update=update_data):
Python 3.10+

from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str | None = None
    description: str | None = None
    price: float | None = None
    tax: float = 10.5
    tags: list[str] = []


items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
}


@app.get("/items/{item_id}", response_model=Item)
async def read_item(item_id: str):
    return items[item_id]


@app.patch("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item: Item):
    stored_item_data = items[item_id]
    stored_item_model = Item(**stored_item_data)
    update_data = item.dict(exclude_unset=True)
    updated_item = stored_item_model.copy(update=update_data)
    items[item_id] = jsonable_encoder(updated_item)
    return updated_item

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Partial updates recapÂ¶

In summary, to apply partial updates you would:

    (Optionally) use PATCH instead of PUT.
    Retrieve the stored data.
    Put that data in a Pydantic model.
    Generate a dict without default values from the input model (using exclude_unset).
        This way you can update only the values actually set by the user, instead of overriding values already stored with default values in your model.
    Create a copy of the stored model, updating its attributes with the received partial updates (using the update parameter).
    Convert the copied model to something that can be stored in your DB (for example, using the jsonable_encoder).
        This is comparable to using the model's .model_dump() method again, but it makes sure (and converts) the values to data types that can be converted to JSON, for example, datetime to str.
    Save the data to your DB.
    Return the updated model.

Python 3.10+

from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str | None = None
    description: str | None = None
    price: float | None = None
    tax: float = 10.5
    tags: list[str] = []


items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
}


@app.get("/items/{item_id}", response_model=Item)
async def read_item(item_id: str):
    return items[item_id]


@app.patch("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item: Item):
    stored_item_data = items[item_id]
    stored_item_model = Item(**stored_item_data)
    update_data = item.dict(exclude_unset=True)
    updated_item = stored_item_model.copy(update=update_data)
    items[item_id] = jsonable_encoder(updated_item)
    return updated_item

from typing import Union

from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: Union[str, None] = None
    description: Union[str, None] = None
    price: Union[float, None] = None
    tax: float = 10.5
    tags: list[str] = []


items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
}


@app.get("/items/{item_id}", response_model=Item)
async def read_item(item_id: str):
    return items[item_id]


@app.patch("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item: Item):
    stored_item_data = items[item_id]
    stored_item_model = Item(**stored_item_data)
    update_data = item.dict(exclude_unset=True)
    updated_item = stored_item_model.copy(update=update_data)
    items[item_id] = jsonable_encoder(updated_item)
    return updated_item

ğŸ¤“ Other versions and variants
Python 3.9+
Python 3.8+

from typing import Union

from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: Union[str, None] = None
    description: Union[str, None] = None
    price: Union[float, None] = None
    tax: float = 10.5
    tags: list[str] = []


items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
}


@app.get("/items/{item_id}", response_model=Item)
async def read_item(item_id: str):
    return items[item_id]


@app.patch("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item: Item):
    stored_item_data = items[item_id]
    stored_item_model = Item(**stored_item_data)
    update_data = item.dict(exclude_unset=True)
    updated_item = stored_item_model.copy(update=update_data)
    items[item_id] = jsonable_encoder(updated_item)
    return updated_item

ğŸ¤“ Other versions and variants
Python 3.9+
Python 3.8+

from typing import Union

from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: Union[str, None] = None
    description: Union[str, None] = None
    price: Union[float, None] = None
    tax: float = 10.5
    tags: list[str] = []


items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
}


@app.get("/items/{item_id}", response_model=Item)
async def read_item(item_id: str):
    return items[item_id]


@app.patch("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item: Item):
    stored_item_data = items[item_id]
    stored_item_model = Item(**stored_item_data)
    update_data = item.dict(exclude_unset=True)
    updated_item = stored_item_model.copy(update=update_data)
    items[item_id] = jsonable_encoder(updated_item)
    return updated_item

Tip

You can actually use this same technique with an HTTP PUT operation.

But the example here uses PATCH because it was created for these use cases.

Note

Notice that the input model is still validated.

So, if you want to receive partial updates that can omit all the attributes, you need to have a model with all the attributes marked as optional (with default values or None).

To distinguish from the models with all optional values for updates and models with required values for creation, you can use the ideas described in Extra Models.
Previous
JSON Compatible Encoder
Next
Dependencies
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Dependencies

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
                Classes as Dependencies
                Sub-dependencies
                Dependencies in path operation decorators
                Global Dependencies
                Dependencies with yield
            Security
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    What is "Dependency Injection"
    First Steps
        Create a dependency, or "dependable"
        Import Depends
        Declare the dependency, in the "dependant"
    Share Annotated dependencies
    To async or not to async
    Integrated with OpenAPI
    Simple usage
    FastAPI plug-ins
    FastAPI compatibility
    Simple and Powerful
    Integrated with OpenAPI

    FastAPI
    Learn
    Tutorial - User Guide
    Dependencies

DependenciesÂ¶

FastAPI has a very powerful but intuitive Dependency Injection system.

It is designed to be very simple to use, and to make it very easy for any developer to integrate other components with FastAPI.
What is "Dependency Injection"Â¶

"Dependency Injection" means, in programming, that there is a way for your code (in this case, your path operation functions) to declare things that it requires to work and use: "dependencies".

And then, that system (in this case FastAPI) will take care of doing whatever is needed to provide your code with those needed dependencies ("inject" the dependencies).

This is very useful when you need to:

    Have shared logic (the same code logic again and again).
    Share database connections.
    Enforce security, authentication, role requirements, etc.
    And many other things...

All these, while minimizing code repetition.
First StepsÂ¶

Let's see a very simple example. It will be so simple that it is not very useful, for now.

But this way we can focus on how the Dependency Injection system works.
Create a dependency, or "dependable"Â¶

Let's first focus on the dependency.

It is just a function that can take all the same parameters that a path operation function can take:
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}


@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    return commons


@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    return commons

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

That's it.

2 lines.

And it has the same shape and structure that all your path operation functions have.

You can think of it as a path operation function without the "decorator" (without the @app.get("/some-path")).

And it can return anything you want.

In this case, this dependency expects:

    An optional query parameter q that is a str.
    An optional query parameter skip that is an int, and by default is 0.
    An optional query parameter limit that is an int, and by default is 100.

And then it just returns a dict containing those values.

Info

FastAPI added support for Annotated (and started recommending it) in version 0.95.0.

If you have an older version, you would get errors when trying to use Annotated.

Make sure you Upgrade the FastAPI version to at least 0.95.1 before using Annotated.
Import DependsÂ¶
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}


@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    return commons


@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    return commons

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Declare the dependency, in the "dependant"Â¶

The same way you use Body, Query, etc. with your path operation function parameters, use Depends with a new parameter:
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}


@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    return commons


@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    return commons

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Although you use Depends in the parameters of your function the same way you use Body, Query, etc, Depends works a bit differently.

You only give Depends a single parameter.

This parameter must be something like a function.

You don't call it directly (don't add the parenthesis at the end), you just pass it as a parameter to Depends().

And that function takes parameters in the same way that path operation functions do.

Tip

You'll see what other "things", apart from functions, can be used as dependencies in the next chapter.

Whenever a new request arrives, FastAPI will take care of:

    Calling your dependency ("dependable") function with the correct parameters.
    Get the result from your function.
    Assign that result to the parameter in your path operation function.

common_parameters
/items/
/users/

This way you write shared code once and FastAPI takes care of calling it for your path operations.

Check

Notice that you don't have to create a special class and pass it somewhere to FastAPI to "register" it or anything similar.

You just pass it to Depends and FastAPI knows how to do the rest.
Share Annotated dependenciesÂ¶

In the examples above, you see that there's a tiny bit of code duplication.

When you need to use the common_parameters() dependency, you have to write the whole parameter with the type annotation and Depends():

commons: Annotated[dict, Depends(common_parameters)]

But because we are using Annotated, we can store that Annotated value in a variable and use it in multiple places:
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}


CommonsDep = Annotated[dict, Depends(common_parameters)]


@app.get("/items/")
async def read_items(commons: CommonsDep):
    return commons


@app.get("/users/")
async def read_users(commons: CommonsDep):
    return commons

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Tip

This is just standard Python, it's called a "type alias", it's actually not specific to FastAPI.

But because FastAPI is based on the Python standards, including Annotated, you can use this trick in your code. ğŸ˜

The dependencies will keep working as expected, and the best part is that the type information will be preserved, which means that your editor will be able to keep providing you with autocompletion, inline errors, etc. The same for other tools like mypy.

This will be especially useful when you use it in a large code base where you use the same dependencies over and over again in many path operations.
To async or not to asyncÂ¶

As dependencies will also be called by FastAPI (the same as your path operation functions), the same rules apply while defining your functions.

You can use async def or normal def.

And you can declare dependencies with async def inside of normal def path operation functions, or def dependencies inside of async def path operation functions, etc.

It doesn't matter. FastAPI will know what to do.

Note

If you don't know, check the Async: "In a hurry?" section about async and await in the docs.
Integrated with OpenAPIÂ¶

All the request declarations, validations and requirements of your dependencies (and sub-dependencies) will be integrated in the same OpenAPI schema.

So, the interactive docs will have all the information from these dependencies too:

Simple usageÂ¶

If you look at it, path operation functions are declared to be used whenever a path and operation matches, and then FastAPI takes care of calling the function with the correct parameters, extracting the data from the request.

Actually, all (or most) of the web frameworks work in this same way.

You never call those functions directly. They are called by your framework (in this case, FastAPI).

With the Dependency Injection system, you can also tell FastAPI that your path operation function also "depends" on something else that should be executed before your path operation function, and FastAPI will take care of executing it and "injecting" the results.

Other common terms for this same idea of "dependency injection" are:

    resources
    providers
    services
    injectables
    components

FastAPI plug-insÂ¶

Integrations and "plug-ins" can be built using the Dependency Injection system. But in fact, there is actually no need to create "plug-ins", as by using dependencies it's possible to declare an infinite number of integrations and interactions that become available to your path operation functions.

And dependencies can be created in a very simple and intuitive way that allows you to just import the Python packages you need, and integrate them with your API functions in a couple of lines of code, literally.

You will see examples of this in the next chapters, about relational and NoSQL databases, security, etc.
FastAPI compatibilityÂ¶

The simplicity of the dependency injection system makes FastAPI compatible with:

    all the relational databases
    NoSQL databases
    external packages
    external APIs
    authentication and authorization systems
    API usage monitoring systems
    response data injection systems
    etc.

Simple and PowerfulÂ¶

Although the hierarchical dependency injection system is very simple to define and use, it's still very powerful.

You can define dependencies that in turn can define dependencies themselves.

In the end, a hierarchical tree of dependencies is built, and the Dependency Injection system takes care of solving all these dependencies for you (and their sub-dependencies) and providing (injecting) the results at each step.

For example, let's say you have 4 API endpoints (path operations):

    /items/public/
    /items/private/
    /users/{user_id}/activate
    /items/pro/

then you could add different permission requirements for each of them just with dependencies and sub-dependencies:
current_user
active_user
admin_user
paying_user
/items/public/
/items/private/
/users/{user_id}/activate
/items/pro/
Integrated with OpenAPIÂ¶

All these dependencies, while declaring their requirements, also add parameters, validations, etc. to your path operations.

FastAPI will take care of adding it all to the OpenAPI schema, so that it is shown in the interactive documentation systems.
Previous
Body - Updates
Next
Classes as Dependencies
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Classes as Dependencies

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
                Classes as Dependencies
                Sub-dependencies
                Dependencies in path operation decorators
                Global Dependencies
                Dependencies with yield
            Security
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    A dict from the previous example
    What makes a dependency
    Classes as dependencies
    Use it
    Type annotation vs Depends
    Shortcut

    FastAPI
    Learn
    Tutorial - User Guide
    Dependencies

Classes as DependenciesÂ¶

Before diving deeper into the Dependency Injection system, let's upgrade the previous example.
A dict from the previous exampleÂ¶

In the previous example, we were returning a dict from our dependency ("dependable"):
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}


@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    return commons


@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    return commons

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

But then we get a dict in the parameter commons of the path operation function.

And we know that editors can't provide a lot of support (like completion) for dicts, because they can't know their keys and value types.

We can do better...
What makes a dependencyÂ¶

Up to now you have seen dependencies declared as functions.

But that's not the only way to declare dependencies (although it would probably be the more common).

The key factor is that a dependency should be a "callable".

A "callable" in Python is anything that Python can "call" like a function.

So, if you have an object something (that might not be a function) and you can "call" it (execute it) like:

something()

or

something(some_argument, some_keyword_argument="foo")

then it is a "callable".
Classes as dependenciesÂ¶

You might notice that to create an instance of a Python class, you use that same syntax.

For example:

class Cat:
    def __init__(self, name: str):
        self.name = name


fluffy = Cat(name="Mr Fluffy")

In this case, fluffy is an instance of the class Cat.

And to create fluffy, you are "calling" Cat.

So, a Python class is also a callable.

Then, in FastAPI, you could use a Python class as a dependency.

What FastAPI actually checks is that it is a "callable" (function, class or anything else) and the parameters defined.

If you pass a "callable" as a dependency in FastAPI, it will analyze the parameters for that "callable", and process them in the same way as the parameters for a path operation function. Including sub-dependencies.

That also applies to callables with no parameters at all. The same as it would be for path operation functions with no parameters.

Then, we can change the dependency "dependable" common_parameters from above to the class CommonQueryParams:
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]


class CommonQueryParams:
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit


@app.get("/items/")
async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
    response = {}
    if commons.q:
        response.update({"q": commons.q})
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    response.update({"items": items})
    return response

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Pay attention to the __init__ method used to create the instance of the class:
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]


class CommonQueryParams:
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit


@app.get("/items/")
async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
    response = {}
    if commons.q:
        response.update({"q": commons.q})
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    response.update({"items": items})
    return response

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

...it has the same parameters as our previous common_parameters:
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}


@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    return commons


@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    return commons

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Those parameters are what FastAPI will use to "solve" the dependency.

In both cases, it will have:

    An optional q query parameter that is a str.
    A skip query parameter that is an int, with a default of 0.
    A limit query parameter that is an int, with a default of 100.

In both cases the data will be converted, validated, documented on the OpenAPI schema, etc.
Use itÂ¶

Now you can declare your dependency using this class.
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]


class CommonQueryParams:
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit


@app.get("/items/")
async def read_items(commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]):
    response = {}
    if commons.q:
        response.update({"q": commons.q})
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    response.update({"items": items})
    return response

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

FastAPI calls the CommonQueryParams class. This creates an "instance" of that class and the instance will be passed as the parameter commons to your function.
Type annotation vs DependsÂ¶

Notice how we write CommonQueryParams twice in the above code:
Python 3.8+
Python 3.8+ non-Annotated

commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]

The last CommonQueryParams, in:

... Depends(CommonQueryParams)

...is what FastAPI will actually use to know what is the dependency.

It is from this one that FastAPI will extract the declared parameters and that is what FastAPI will actually call.

In this case, the first CommonQueryParams, in:
Python 3.8+
Python 3.8+ non-Annotated

commons: Annotated[CommonQueryParams, ...

...doesn't have any special meaning for FastAPI. FastAPI won't use it for data conversion, validation, etc. (as it is using the Depends(CommonQueryParams) for that).

You could actually write just:
Python 3.8+
Python 3.8+ non-Annotated

commons: Annotated[Any, Depends(CommonQueryParams)]

...as in:
Python 3.10+

from typing import Annotated, Any

from fastapi import Depends, FastAPI

app = FastAPI()


fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]


class CommonQueryParams:
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit


@app.get("/items/")
async def read_items(commons: Annotated[Any, Depends(CommonQueryParams)]):
    response = {}
    if commons.q:
        response.update({"q": commons.q})
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    response.update({"items": items})
    return response

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

But declaring the type is encouraged as that way your editor will know what will be passed as the parameter commons, and then it can help you with code completion, type checks, etc:

ShortcutÂ¶

But you see that we are having some code repetition here, writing CommonQueryParams twice:
Python 3.8+
Python 3.8+ non-Annotated

commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]

FastAPI provides a shortcut for these cases, in where the dependency is specifically a class that FastAPI will "call" to create an instance of the class itself.

For those specific cases, you can do the following:

Instead of writing:
Python 3.8+
Python 3.8+ non-Annotated

commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]

...you write:
Python 3.8+
Python 3.8 non-Annotated

commons: Annotated[CommonQueryParams, Depends()]

You declare the dependency as the type of the parameter, and you use Depends() without any parameter, instead of having to write the full class again inside of Depends(CommonQueryParams).

The same example would then look like:
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]


class CommonQueryParams:
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit


@app.get("/items/")
async def read_items(commons: Annotated[CommonQueryParams, Depends()]):
    response = {}
    if commons.q:
        response.update({"q": commons.q})
    items = fake_items_db[commons.skip : commons.skip + commons.limit]
    response.update({"items": items})
    return response

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

...and FastAPI will know what to do.

Tip

If that seems more confusing than helpful, disregard it, you don't need it.

It is just a shortcut. Because FastAPI cares about helping you minimize code repetition.
Previous
Dependencies
Next
Sub-dependencies
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Sub-dependencies

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
                Classes as Dependencies
                Sub-dependencies
                Dependencies in path operation decorators
                Global Dependencies
                Dependencies with yield
            Security
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    First dependency "dependable"
    Second dependency, "dependable" and "dependant"
    Use the dependency
    Using the same dependency multiple times
    Recap

    FastAPI
    Learn
    Tutorial - User Guide
    Dependencies

Sub-dependenciesÂ¶

You can create dependencies that have sub-dependencies.

They can be as deep as you need them to be.

FastAPI will take care of solving them.
First dependency "dependable"Â¶

You could create a first dependency ("dependable") like:
Python 3.10+

from typing import Annotated

from fastapi import Cookie, Depends, FastAPI

app = FastAPI()


def query_extractor(q: str | None = None):
    return q


def query_or_cookie_extractor(
    q: Annotated[str, Depends(query_extractor)],
    last_query: Annotated[str | None, Cookie()] = None,
):
    if not q:
        return last_query
    return q


@app.get("/items/")
async def read_query(
    query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
):
    return {"q_or_cookie": query_or_default}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

It declares an optional query parameter q as a str, and then it just returns it.

This is quite simple (not very useful), but will help us focus on how the sub-dependencies work.
Second dependency, "dependable" and "dependant"Â¶

Then you can create another dependency function (a "dependable") that at the same time declares a dependency of its own (so it is a "dependant" too):
Python 3.10+

from typing import Annotated

from fastapi import Cookie, Depends, FastAPI

app = FastAPI()


def query_extractor(q: str | None = None):
    return q


def query_or_cookie_extractor(
    q: Annotated[str, Depends(query_extractor)],
    last_query: Annotated[str | None, Cookie()] = None,
):
    if not q:
        return last_query
    return q


@app.get("/items/")
async def read_query(
    query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
):
    return {"q_or_cookie": query_or_default}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Let's focus on the parameters declared:

    Even though this function is a dependency ("dependable") itself, it also declares another dependency (it "depends" on something else).
        It depends on the query_extractor, and assigns the value returned by it to the parameter q.
    It also declares an optional last_query cookie, as a str.
        If the user didn't provide any query q, we use the last query used, which we saved to a cookie before.

Use the dependencyÂ¶

Then we can use the dependency with:
Python 3.10+

from typing import Annotated

from fastapi import Cookie, Depends, FastAPI

app = FastAPI()


def query_extractor(q: str | None = None):
    return q


def query_or_cookie_extractor(
    q: Annotated[str, Depends(query_extractor)],
    last_query: Annotated[str | None, Cookie()] = None,
):
    if not q:
        return last_query
    return q


@app.get("/items/")
async def read_query(
    query_or_default: Annotated[str, Depends(query_or_cookie_extractor)],
):
    return {"q_or_cookie": query_or_default}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Info

Notice that we are only declaring one dependency in the path operation function, the query_or_cookie_extractor.

But FastAPI will know that it has to solve query_extractor first, to pass the results of that to query_or_cookie_extractor while calling it.
query_extractor
query_or_cookie_extractor
/items/
Using the same dependency multiple timesÂ¶

If one of your dependencies is declared multiple times for the same path operation, for example, multiple dependencies have a common sub-dependency, FastAPI will know to call that sub-dependency only once per request.

And it will save the returned value in a "cache" and pass it to all the "dependants" that need it in that specific request, instead of calling the dependency multiple times for the same request.

In an advanced scenario where you know you need the dependency to be called at every step (possibly multiple times) in the same request instead of using the "cached" value, you can set the parameter use_cache=False when using Depends:
Python 3.8+
Python 3.8+ non-Annotated

async def needy_dependency(fresh_value: Annotated[str, Depends(get_value, use_cache=False)]):
    return {"fresh_value": fresh_value}

RecapÂ¶

Apart from all the fancy words used here, the Dependency Injection system is quite simple.

Just functions that look the same as the path operation functions.

But still, it is very powerful, and allows you to declare arbitrarily deeply nested dependency "graphs" (trees).

Tip

All this might not seem as useful with these simple examples.

But you will see how useful it is in the chapters about security.

And you will also see the amounts of code it will save you.
Previous
Classes as Dependencies
Next
Dependencies in path operation decorators
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Dependencies in path operation decorators

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
                Classes as Dependencies
                Sub-dependencies
                Dependencies in path operation decorators
                Global Dependencies
                Dependencies with yield
            Security
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Add dependencies to the path operation decorator
    Dependencies errors and return values
        Dependency requirements
        Raise exceptions
        Return values
    Dependencies for a group of path operations
    Global Dependencies

    FastAPI
    Learn
    Tutorial - User Guide
    Dependencies

Dependencies in path operation decoratorsÂ¶

In some cases you don't really need the return value of a dependency inside your path operation function.

Or the dependency doesn't return a value.

But you still need it to be executed/solved.

For those cases, instead of declaring a path operation function parameter with Depends, you can add a list of dependencies to the path operation decorator.
Add dependencies to the path operation decoratorÂ¶

The path operation decorator receives an optional argument dependencies.

It should be a list of Depends():
Python 3.9+

from typing import Annotated

from fastapi import Depends, FastAPI, Header, HTTPException

app = FastAPI()


async def verify_token(x_token: Annotated[str, Header()]):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")


async def verify_key(x_key: Annotated[str, Header()]):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key


@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

These dependencies will be executed/solved the same way as normal dependencies. But their value (if they return any) won't be passed to your path operation function.

Tip

Some editors check for unused function parameters, and show them as errors.

Using these dependencies in the path operation decorator you can make sure they are executed while avoiding editor/tooling errors.

It might also help avoid confusion for new developers that see an unused parameter in your code and could think it's unnecessary.

Info

In this example we use invented custom headers X-Key and X-Token.

But in real cases, when implementing security, you would get more benefits from using the integrated Security utilities (the next chapter).
Dependencies errors and return valuesÂ¶

You can use the same dependency functions you use normally.
Dependency requirementsÂ¶

They can declare request requirements (like headers) or other sub-dependencies:
Python 3.9+

from typing import Annotated

from fastapi import Depends, FastAPI, Header, HTTPException

app = FastAPI()


async def verify_token(x_token: Annotated[str, Header()]):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")


async def verify_key(x_key: Annotated[str, Header()]):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key


@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Raise exceptionsÂ¶

These dependencies can raise exceptions, the same as normal dependencies:
Python 3.9+

from typing import Annotated

from fastapi import Depends, FastAPI, Header, HTTPException

app = FastAPI()


async def verify_token(x_token: Annotated[str, Header()]):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")


async def verify_key(x_key: Annotated[str, Header()]):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key


@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Return valuesÂ¶

And they can return values or not, the values won't be used.

So, you can reuse a normal dependency (that returns a value) you already use somewhere else, and even though the value won't be used, the dependency will be executed:
Python 3.9+

from typing import Annotated

from fastapi import Depends, FastAPI, Header, HTTPException

app = FastAPI()


async def verify_token(x_token: Annotated[str, Header()]):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")


async def verify_key(x_key: Annotated[str, Header()]):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key


@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Dependencies for a group of path operationsÂ¶

Later, when reading about how to structure bigger applications (Bigger Applications - Multiple Files), possibly with multiple files, you will learn how to declare a single dependencies parameter for a group of path operations.
Global DependenciesÂ¶

Next we will see how to add dependencies to the whole FastAPI application, so that they apply to each path operation.
Previous
Sub-dependencies
Next
Global Dependencies
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
Global Dependencies

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
                Classes as Dependencies
                Sub-dependencies
                Dependencies in path operation decorators
                Global Dependencies
                Dependencies with yield
            Security
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Dependencies for groups of path operations

    FastAPI
    Learn
    Tutorial - User Guide
    Dependencies

Global DependenciesÂ¶

For some types of applications you might want to add dependencies to the whole application.

Similar to the way you can add dependencies to the path operation decorators, you can add them to the FastAPI application.

In that case, they will be applied to all the path operations in the application:
Python 3.9+

from fastapi import Depends, FastAPI, Header, HTTPException
from typing_extensions import Annotated


async def verify_token(x_token: Annotated[str, Header()]):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")


async def verify_key(x_key: Annotated[str, Header()]):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key


app = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)])


@app.get("/items/")
async def read_items():
    return [{"item": "Portal Gun"}, {"item": "Plumbus"}]


@app.get("/users/")
async def read_users():
    return [{"username": "Rick"}, {"username": "Morty"}]

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

And all the ideas in the section about adding dependencies to the path operation decorators still apply, but in this case, to all of the path operations in the app.
Dependencies for groups of path operationsÂ¶

Later, when reading about how to structure bigger applications (Bigger Applications - Multiple Files), possibly with multiple files, you will learn how to declare a single dependencies parameter for a group of path operations.
Previous
Dependencies in path operation decorators
Next
Dependencies with yield
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Dependencies with yield

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
                Classes as Dependencies
                Sub-dependencies
                Dependencies in path operation decorators
                Global Dependencies
                Dependencies with yield
            Security
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    A database dependency with yield
    A dependency with yield and try
    Sub-dependencies with yield
    Dependencies with yield and HTTPException
    Dependencies with yield and except
        Always raise in Dependencies with yield and except
    Execution of dependencies with yield
    Early exit and scope
        scope for sub-dependencies
    Dependencies with yield, HTTPException, except and Background Tasks
    Context Managers
        What are "Context Managers"
        Using context managers in dependencies with yield

    FastAPI
    Learn
    Tutorial - User Guide
    Dependencies

Dependencies with yieldÂ¶

FastAPI supports dependencies that do some extra steps after finishing.

To do this, use yield instead of return, and write the extra steps (code) after.

Tip

Make sure to use yield one single time per dependency.

Technical Details

Any function that is valid to use with:

    @contextlib.contextmanager or
    @contextlib.asynccontextmanager

would be valid to use as a FastAPI dependency.

In fact, FastAPI uses those two decorators internally.
A database dependency with yieldÂ¶

For example, you could use this to create a database session and close it after finishing.

Only the code prior to and including the yield statement is executed before creating a response:
Python 3.8+

async def get_db():
    db = DBSession()
    try:
        yield db
    finally:
        db.close()

The yielded value is what is injected into path operations and other dependencies:
Python 3.8+

async def get_db():
    db = DBSession()
    try:
        yield db
    finally:
        db.close()

The code following the yield statement is executed after the response:
Python 3.8+

async def get_db():
    db = DBSession()
    try:
        yield db
    finally:
        db.close()

Tip

You can use async or regular functions.

FastAPI will do the right thing with each, the same as with normal dependencies.
A dependency with yield and tryÂ¶

If you use a try block in a dependency with yield, you'll receive any exception that was thrown when using the dependency.

For example, if some code at some point in the middle, in another dependency or in a path operation, made a database transaction "rollback" or created any other exception, you would receive the exception in your dependency.

So, you can look for that specific exception inside the dependency with except SomeException.

In the same way, you can use finally to make sure the exit steps are executed, no matter if there was an exception or not.
Python 3.8+

async def get_db():
    db = DBSession()
    try:
        yield db
    finally:
        db.close()

Sub-dependencies with yieldÂ¶

You can have sub-dependencies and "trees" of sub-dependencies of any size and shape, and any or all of them can use yield.

FastAPI will make sure that the "exit code" in each dependency with yield is run in the correct order.

For example, dependency_c can have a dependency on dependency_b, and dependency_b on dependency_a:
Python 3.9+

from typing import Annotated

from fastapi import Depends


async def dependency_a():
    dep_a = generate_dep_a()
    try:
        yield dep_a
    finally:
        dep_a.close()


async def dependency_b(dep_a: Annotated[DepA, Depends(dependency_a)]):
    dep_b = generate_dep_b()
    try:
        yield dep_b
    finally:
        dep_b.close(dep_a)


async def dependency_c(dep_b: Annotated[DepB, Depends(dependency_b)]):
    dep_c = generate_dep_c()
    try:
        yield dep_c
    finally:
        dep_c.close(dep_b)

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

And all of them can use yield.

In this case dependency_c, to execute its exit code, needs the value from dependency_b (here named dep_b) to still be available.

And, in turn, dependency_b needs the value from dependency_a (here named dep_a) to be available for its exit code.
Python 3.9+

from typing import Annotated

from fastapi import Depends


async def dependency_a():
    dep_a = generate_dep_a()
    try:
        yield dep_a
    finally:
        dep_a.close()


async def dependency_b(dep_a: Annotated[DepA, Depends(dependency_a)]):
    dep_b = generate_dep_b()
    try:
        yield dep_b
    finally:
        dep_b.close(dep_a)


async def dependency_c(dep_b: Annotated[DepB, Depends(dependency_b)]):
    dep_c = generate_dep_c()
    try:
        yield dep_c
    finally:
        dep_c.close(dep_b)

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

The same way, you could have some dependencies with yield and some other dependencies with return, and have some of those depend on some of the others.

And you could have a single dependency that requires several other dependencies with yield, etc.

You can have any combinations of dependencies that you want.

FastAPI will make sure everything is run in the correct order.

Technical Details

This works thanks to Python's Context Managers.

FastAPI uses them internally to achieve this.
Dependencies with yield and HTTPExceptionÂ¶

You saw that you can use dependencies with yield and have try blocks that try to execute some code and then run some exit code after finally.

You can also use except to catch the exception that was raised and do something with it.

For example, you can raise a different exception, like HTTPException.

Tip

This is a somewhat advanced technique, and in most of the cases you won't really need it, as you can raise exceptions (including HTTPException) from inside of the rest of your application code, for example, in the path operation function.

But it's there for you if you need it. ğŸ¤“
Python 3.9+

from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException

app = FastAPI()


data = {
    "plumbus": {"description": "Freshly pickled plumbus", "owner": "Morty"},
    "portal-gun": {"description": "Gun to create portals", "owner": "Rick"},
}


class OwnerError(Exception):
    pass


def get_username():
    try:
        yield "Rick"
    except OwnerError as e:
        raise HTTPException(status_code=400, detail=f"Owner error: {e}")


@app.get("/items/{item_id}")
def get_item(item_id: str, username: Annotated[str, Depends(get_username)]):
    if item_id not in data:
        raise HTTPException(status_code=404, detail="Item not found")
    item = data[item_id]
    if item["owner"] != username:
        raise OwnerError(username)
    return item

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

If you want to catch exceptions and create a custom response based on that, create a Custom Exception Handler.
Dependencies with yield and exceptÂ¶

If you catch an exception using except in a dependency with yield and you don't raise it again (or raise a new exception), FastAPI won't be able to notice there was an exception, the same way that would happen with regular Python:
Python 3.9+

from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException

app = FastAPI()


class InternalError(Exception):
    pass


def get_username():
    try:
        yield "Rick"
    except InternalError:
        print("Oops, we didn't raise again, Britney ğŸ˜±")


@app.get("/items/{item_id}")
def get_item(item_id: str, username: Annotated[str, Depends(get_username)]):
    if item_id == "portal-gun":
        raise InternalError(
            f"The portal gun is too dangerous to be owned by {username}"
        )
    if item_id != "plumbus":
        raise HTTPException(
            status_code=404, detail="Item not found, there's only a plumbus here"
        )
    return item_id

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

In this case, the client will see an HTTP 500 Internal Server Error response as it should, given that we are not raising an HTTPException or similar, but the server will not have any logs or any other indication of what was the error. ğŸ˜±
Always raise in Dependencies with yield and exceptÂ¶

If you catch an exception in a dependency with yield, unless you are raising another HTTPException or similar, you should re-raise the original exception.

You can re-raise the same exception using raise:
Python 3.9+

from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException

app = FastAPI()


class InternalError(Exception):
    pass


def get_username():
    try:
        yield "Rick"
    except InternalError:
        print("We don't swallow the internal error here, we raise again ğŸ˜")
        raise


@app.get("/items/{item_id}")
def get_item(item_id: str, username: Annotated[str, Depends(get_username)]):
    if item_id == "portal-gun":
        raise InternalError(
            f"The portal gun is too dangerous to be owned by {username}"
        )
    if item_id != "plumbus":
        raise HTTPException(
            status_code=404, detail="Item not found, there's only a plumbus here"
        )
    return item_id

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Now the client will get the same HTTP 500 Internal Server Error response, but the server will have our custom InternalError in the logs. ğŸ˜
Execution of dependencies with yieldÂ¶

The sequence of execution is more or less like this diagram. Time flows from top to bottom. And each column is one of the parts interacting or executing code.
Background tasksPath OperationDep with yieldException handlerClientBackground tasksPath OperationDep with yieldException handlerClientCan raise exceptions, including HTTPExceptionRun code up to yieldopt[raise Exception]opt[handle]opt[raise]Response is already sent, can't change it anymoreopt[Tasks]opt[Raise other exception]Start requestRaise ExceptionHTTP error responseRun dependency, e.g. DB sessionRaise Exception (e.g. HTTPException)Can catch exception, raise a new HTTPException, raise other exceptionHTTP error responseReturn response to clientSend background tasksHandle exceptions in the background task code

Info

Only one response will be sent to the client. It might be one of the error responses or it will be the response from the path operation.

After one of those responses is sent, no other response can be sent.

Tip

If you raise any exception in the code from the path operation function, it will be passed to the dependencies with yield, including HTTPException. In most cases you will want to re-raise that same exception or a new one from the dependency with yield to make sure it's properly handled.
Early exit and scopeÂ¶

Normally the exit code of dependencies with yield is executed after the response is sent to the client.

But if you know that you won't need to use the dependency after returning from the path operation function, you can use Depends(scope="function") to tell FastAPI that it should close the dependency after the path operation function returns, but before the response is sent.
Python 3.9+

from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


def get_username():
    try:
        yield "Rick"
    finally:
        print("Cleanup up before response is sent")


@app.get("/users/me")
def get_user_me(username: Annotated[str, Depends(get_username, scope="function")]):
    return username

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Depends() receives a scope parameter that can be:

    "function": start the dependency before the path operation function that handles the request, end the dependency after the path operation function ends, but before the response is sent back to the client. So, the dependency function will be executed around the path operation function.
    "request": start the dependency before the path operation function that handles the request (similar to when using "function"), but end after the response is sent back to the client. So, the dependency function will be executed around the request and response cycle.

If not specified and the dependency has yield, it will have a scope of "request" by default.
scope for sub-dependenciesÂ¶

When you declare a dependency with a scope="request" (the default), any sub-dependency needs to also have a scope of "request".

But a dependency with scope of "function" can have dependencies with scope of "function" and scope of "request".

This is because any dependency needs to be able to run its exit code before the sub-dependencies, as it might need to still use them during its exit code.
Path OperationDep scope="function"Dep scope="request"ClientPath OperationDep scope="function"Dep scope="request"ClientRun code up to yieldRun code up to yieldRun code after yieldâœ… Dependency closedResponse sentRun code after yieldâœ… Dependency closedStart requestPass dependencyRun path operation with dependencyReturn from path operationSend response to client
Dependencies with yield, HTTPException, except and Background TasksÂ¶

Dependencies with yield have evolved over time to cover different use cases and fix some issues.

If you want to see what has changed in different versions of FastAPI, you can read more about it in the advanced guide, in Advanced Dependencies - Dependencies with yield, HTTPException, except and Background Tasks.
Context ManagersÂ¶
What are "Context Managers"Â¶

"Context Managers" are any of those Python objects that you can use in a with statement.

For example, you can use with to read a file:

with open("./somefile.txt") as f:
    contents = f.read()
    print(contents)

Underneath, the open("./somefile.txt") creates an object that is called a "Context Manager".

When the with block finishes, it makes sure to close the file, even if there were exceptions.

When you create a dependency with yield, FastAPI will internally create a context manager for it, and combine it with some other related tools.
Using context managers in dependencies with yieldÂ¶

Warning

This is, more or less, an "advanced" idea.

If you are just starting with FastAPI you might want to skip it for now.

In Python, you can create Context Managers by creating a class with two methods: __enter__() and __exit__().

You can also use them inside of FastAPI dependencies with yield by using with or async with statements inside of the dependency function:
Python 3.8+

class MySuperContextManager:
    def __init__(self):
        self.db = DBSession()

    def __enter__(self):
        return self.db

    def __exit__(self, exc_type, exc_value, traceback):
        self.db.close()


async def get_db():
    with MySuperContextManager() as db:
        yield db

Tip

Another way to create a context manager is with:

    @contextlib.contextmanager or
    @contextlib.asynccontextmanager

using them to decorate a function with a single yield.

That's what FastAPI uses internally for dependencies with yield.

But you don't have to use the decorators for FastAPI dependencies (and you shouldn't).

FastAPI will do it for you internally.
Previous
Global Dependencies
Next
Security
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Security

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
            Security
                Security - First Steps
                Get Current User
                Simple OAuth2 with Password and Bearer
                OAuth2 with Password (and hashing), Bearer with JWT tokens
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    In a hurry?
    OAuth2
        OAuth 1
    OpenID Connect
        OpenID (not "OpenID Connect")
    OpenAPI
    FastAPI utilities

    FastAPI
    Learn
    Tutorial - User Guide
    Security

SecurityÂ¶

There are many ways to handle security, authentication and authorization.

And it normally is a complex and "difficult" topic.

In many frameworks and systems just handling security and authentication takes a big amount of effort and code (in many cases it can be 50% or more of all the code written).

FastAPI provides several tools to help you deal with Security easily, rapidly, in a standard way, without having to study and learn all the security specifications.

But first, let's check some small concepts.
In a hurry?Â¶

If you don't care about any of these terms and you just need to add security with authentication based on username and password right now, skip to the next chapters.
OAuth2Â¶

OAuth2 is a specification that defines several ways to handle authentication and authorization.

It is quite an extensive specification and covers several complex use cases.

It includes ways to authenticate using a "third party".

That's what all the systems with "login with Facebook, Google, X (Twitter), GitHub" use underneath.
OAuth 1Â¶

There was an OAuth 1, which is very different from OAuth2, and more complex, as it included direct specifications on how to encrypt the communication.

It is not very popular or used nowadays.

OAuth2 doesn't specify how to encrypt the communication, it expects you to have your application served with HTTPS.

Tip

In the section about deployment you will see how to set up HTTPS for free, using Traefik and Let's Encrypt.
OpenID ConnectÂ¶

OpenID Connect is another specification, based on OAuth2.

It just extends OAuth2 specifying some things that are relatively ambiguous in OAuth2, to try to make it more interoperable.

For example, Google login uses OpenID Connect (which underneath uses OAuth2).

But Facebook login doesn't support OpenID Connect. It has its own flavor of OAuth2.
OpenID (not "OpenID Connect")Â¶

There was also an "OpenID" specification. That tried to solve the same thing as OpenID Connect, but was not based on OAuth2.

So, it was a complete additional system.

It is not very popular or used nowadays.
OpenAPIÂ¶

OpenAPI (previously known as Swagger) is the open specification for building APIs (now part of the Linux Foundation).

FastAPI is based on OpenAPI.

That's what makes it possible to have multiple automatic interactive documentation interfaces, code generation, etc.

OpenAPI has a way to define multiple security "schemes".

By using them, you can take advantage of all these standard-based tools, including these interactive documentation systems.

OpenAPI defines the following security schemes:

    apiKey: an application specific key that can come from:
        A query parameter.
        A header.
        A cookie.
    http: standard HTTP authentication systems, including:
        bearer: a header Authorization with a value of Bearer plus a token. This is inherited from OAuth2.
        HTTP Basic authentication.
        HTTP Digest, etc.
    oauth2: all the OAuth2 ways to handle security (called "flows").
        Several of these flows are appropriate for building an OAuth 2.0 authentication provider (like Google, Facebook, X (Twitter), GitHub, etc):
            implicit
            clientCredentials
            authorizationCode
        But there is one specific "flow" that can be perfectly used for handling authentication in the same application directly:
            password: some next chapters will cover examples of this.
    openIdConnect: has a way to define how to discover OAuth2 authentication data automatically.
        This automatic discovery is what is defined in the OpenID Connect specification.

Tip

Integrating other authentication/authorization providers like Google, Facebook, X (Twitter), GitHub, etc. is also possible and relatively easy.

The most complex problem is building an authentication/authorization provider like those, but FastAPI gives you the tools to do it easily, while doing the heavy lifting for you.
FastAPI utilitiesÂ¶

FastAPI provides several tools for each of these security schemes in the fastapi.security module that simplify using these security mechanisms.

In the next chapters you will see how to add security to your API using those tools provided by FastAPI.

And you will also see how it gets automatically integrated into the interactive documentation system.
Previous
Dependencies with yield
Next
Security - First Steps
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Security - First Steps

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
            Security
                Security - First Steps
                Get Current User
                Simple OAuth2 with Password and Bearer
                OAuth2 with Password (and hashing), Bearer with JWT tokens
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    How it looks
    Create main.py
    Run it
    Check it
    The password flow
    FastAPI's OAuth2PasswordBearer
        Use it
    What it does
    Recap

    FastAPI
    Learn
    Tutorial - User Guide
    Security

Security - First StepsÂ¶

Let's imagine that you have your backend API in some domain.

And you have a frontend in another domain or in a different path of the same domain (or in a mobile application).

And you want to have a way for the frontend to authenticate with the backend, using a username and password.

We can use OAuth2 to build that with FastAPI.

But let's save you the time of reading the full long specification just to find those little pieces of information you need.

Let's use the tools provided by FastAPI to handle security.
How it looksÂ¶

Let's first just use the code and see how it works, and then we'll come back to understand what's happening.
Create main.pyÂ¶

Copy the example in a file main.py:
Python 3.9+

from typing import Annotated

from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer

app = FastAPI()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


@app.get("/items/")
async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):
    return {"token": token}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Run itÂ¶

Info

The python-multipart package is automatically installed with FastAPI when you run the pip install "fastapi[standard]" command.

However, if you use the pip install fastapi command, the python-multipart package is not included by default.

To install it manually, make sure you create a virtual environment, activate it, and then install it with:

$ pip install python-multipart

This is because OAuth2 uses "form data" for sending the username and password.

Run the example with:




Check itÂ¶

Go to the interactive docs at: http://127.0.0.1:8000/docs.

You will see something like this:

Authorize button!

You already have a shiny new "Authorize" button.

And your path operation has a little lock in the top-right corner that you can click.

And if you click it, you have a little authorization form to type a username and password (and other optional fields):

Note

It doesn't matter what you type in the form, it won't work yet. But we'll get there.

This is of course not the frontend for the final users, but it's a great automatic tool to document interactively all your API.

It can be used by the frontend team (that can also be yourself).

It can be used by third party applications and systems.

And it can also be used by yourself, to debug, check and test the same application.
The password flowÂ¶

Now let's go back a bit and understand what is all that.

The password "flow" is one of the ways ("flows") defined in OAuth2, to handle security and authentication.

OAuth2 was designed so that the backend or API could be independent of the server that authenticates the user.

But in this case, the same FastAPI application will handle the API and the authentication.

So, let's review it from that simplified point of view:

    The user types the username and password in the frontend, and hits Enter.
    The frontend (running in the user's browser) sends that username and password to a specific URL in our API (declared with tokenUrl="token").
    The API checks that username and password, and responds with a "token" (we haven't implemented any of this yet).
        A "token" is just a string with some content that we can use later to verify this user.
        Normally, a token is set to expire after some time.
            So, the user will have to log in again at some point later.
            And if the token is stolen, the risk is less. It is not like a permanent key that will work forever (in most of the cases).
    The frontend stores that token temporarily somewhere.
    The user clicks in the frontend to go to another section of the frontend web app.
    The frontend needs to fetch some more data from the API.
        But it needs authentication for that specific endpoint.
        So, to authenticate with our API, it sends a header Authorization with a value of Bearer plus the token.
        If the token contains foobar, the content of the Authorization header would be: Bearer foobar.

FastAPI's OAuth2PasswordBearerÂ¶

FastAPI provides several tools, at different levels of abstraction, to implement these security features.

In this example we are going to use OAuth2, with the Password flow, using a Bearer token. We do that using the OAuth2PasswordBearer class.

Info

A "bearer" token is not the only option.

But it's the best one for our use case.

And it might be the best for most use cases, unless you are an OAuth2 expert and know exactly why there's another option that better suits your needs.

In that case, FastAPI also provides you with the tools to build it.

When we create an instance of the OAuth2PasswordBearer class we pass in the tokenUrl parameter. This parameter contains the URL that the client (the frontend running in the user's browser) will use to send the username and password in order to get a token.
Python 3.9+

from typing import Annotated

from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer

app = FastAPI()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


@app.get("/items/")
async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):
    return {"token": token}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Tip

Here tokenUrl="token" refers to a relative URL token that we haven't created yet. As it's a relative URL, it's equivalent to ./token.

Because we are using a relative URL, if your API was located at https://example.com/, then it would refer to https://example.com/token. But if your API was located at https://example.com/api/v1/, then it would refer to https://example.com/api/v1/token.

Using a relative URL is important to make sure your application keeps working even in an advanced use case like Behind a Proxy.

This parameter doesn't create that endpoint / path operation, but declares that the URL /token will be the one that the client should use to get the token. That information is used in OpenAPI, and then in the interactive API documentation systems.

We will soon also create the actual path operation.

Info

If you are a very strict "Pythonista" you might dislike the style of the parameter name tokenUrl instead of token_url.

That's because it is using the same name as in the OpenAPI spec. So that if you need to investigate more about any of these security schemes you can just copy and paste it to find more information about it.

The oauth2_scheme variable is an instance of OAuth2PasswordBearer, but it is also a "callable".

It could be called as:

oauth2_scheme(some, parameters)

So, it can be used with Depends.
Use itÂ¶

Now you can pass that oauth2_scheme in a dependency with Depends.
Python 3.9+

from typing import Annotated

from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer

app = FastAPI()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


@app.get("/items/")
async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):
    return {"token": token}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

This dependency will provide a str that is assigned to the parameter token of the path operation function.

FastAPI will know that it can use this dependency to define a "security scheme" in the OpenAPI schema (and the automatic API docs).

Technical Details

FastAPI will know that it can use the class OAuth2PasswordBearer (declared in a dependency) to define the security scheme in OpenAPI because it inherits from fastapi.security.oauth2.OAuth2, which in turn inherits from fastapi.security.base.SecurityBase.

All the security utilities that integrate with OpenAPI (and the automatic API docs) inherit from SecurityBase, that's how FastAPI can know how to integrate them in OpenAPI.
What it doesÂ¶

It will go and look in the request for that Authorization header, check if the value is Bearer plus some token, and will return the token as a str.

If it doesn't see an Authorization header, or the value doesn't have a Bearer token, it will respond with a 401 status code error (UNAUTHORIZED) directly.

You don't even have to check if the token exists to return an error. You can be sure that if your function is executed, it will have a str in that token.

You can try it already in the interactive docs:

We are not verifying the validity of the token yet, but that's a start already.
RecapÂ¶

So, in just 3 or 4 extra lines, you already have some primitive form of security.
Previous
Security
Next
Get Current User
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Get Current User

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
            Security
                Security - First Steps
                Get Current User
                Simple OAuth2 with Password and Bearer
                OAuth2 with Password (and hashing), Bearer with JWT tokens
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Create a user model
    Create a get_current_user dependency
    Get the user
    Inject the current user
    Other models
    Code size
    Recap

    FastAPI
    Learn
    Tutorial - User Guide
    Security

Get Current UserÂ¶

In the previous chapter the security system (which is based on the dependency injection system) was giving the path operation function a token as a str:
Python 3.9+

from typing import Annotated

from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer

app = FastAPI()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


@app.get("/items/")
async def read_items(token: Annotated[str, Depends(oauth2_scheme)]):
    return {"token": token}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

But that is still not that useful.

Let's make it give us the current user.
Create a user modelÂ¶

First, let's create a Pydantic user model.

The same way we use Pydantic to declare bodies, we can use it anywhere else:
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer
from pydantic import BaseModel

app = FastAPI()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


def fake_decode_token(token):
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )


async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    user = fake_decode_token(token)
    return user


@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    return current_user

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Create a get_current_user dependencyÂ¶

Let's create a dependency get_current_user.

Remember that dependencies can have sub-dependencies?

get_current_user will have a dependency with the same oauth2_scheme we created before.

The same as we were doing before in the path operation directly, our new dependency get_current_user will receive a token as a str from the sub-dependency oauth2_scheme:
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer
from pydantic import BaseModel

app = FastAPI()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


def fake_decode_token(token):
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )


async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    user = fake_decode_token(token)
    return user


@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    return current_user

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Get the userÂ¶

get_current_user will use a (fake) utility function we created, that takes a token as a str and returns our Pydantic User model:
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer
from pydantic import BaseModel

app = FastAPI()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


def fake_decode_token(token):
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )


async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    user = fake_decode_token(token)
    return user


@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    return current_user

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Inject the current userÂ¶

So now we can use the same Depends with our get_current_user in the path operation:
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer
from pydantic import BaseModel

app = FastAPI()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


def fake_decode_token(token):
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )


async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    user = fake_decode_token(token)
    return user


@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    return current_user

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Notice that we declare the type of current_user as the Pydantic model User.

This will help us inside of the function with all the completion and type checks.

Tip

You might remember that request bodies are also declared with Pydantic models.

Here FastAPI won't get confused because you are using Depends.

Check

The way this dependency system is designed allows us to have different dependencies (different "dependables") that all return a User model.

We are not restricted to having only one dependency that can return that type of data.
Other modelsÂ¶

You can now get the current user directly in the path operation functions and deal with the security mechanisms at the Dependency Injection level, using Depends.

And you can use any model or data for the security requirements (in this case, a Pydantic model User).

But you are not restricted to using some specific data model, class or type.

Do you want to have an id and email and not have any username in your model? Sure. You can use these same tools.

Do you want to just have a str? Or just a dict? Or a database class model instance directly? It all works the same way.

You actually don't have users that log in to your application but robots, bots, or other systems, that have just an access token? Again, it all works the same.

Just use any kind of model, any kind of class, any kind of database that you need for your application. FastAPI has you covered with the dependency injection system.
Code sizeÂ¶

This example might seem verbose. Keep in mind that we are mixing security, data models, utility functions and path operations in the same file.

But here's the key point.

The security and dependency injection stuff is written once.

And you can make it as complex as you want. And still, have it written only once, in a single place. With all the flexibility.

But you can have thousands of endpoints (path operations) using the same security system.

And all of them (or any portion of them that you want) can take advantage of re-using these dependencies or any other dependencies you create.

And all these thousands of path operations can be as small as 3 lines:
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer
from pydantic import BaseModel

app = FastAPI()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


def fake_decode_token(token):
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )


async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    user = fake_decode_token(token)
    return user


@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    return current_user

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

RecapÂ¶

You can now get the current user directly in your path operation function.

We are already halfway there.

We just need to add a path operation for the user/client to actually send the username and password.

That comes next.
Previous
Security - First Steps
Next
Simple OAuth2 with Password and Bearer
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Simple OAuth2 with Password and Bearer

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
            Security
                Security - First Steps
                Get Current User
                Simple OAuth2 with Password and Bearer
                OAuth2 with Password (and hashing), Bearer with JWT tokens
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Get the username and password
        scope
    Code to get the username and password
        OAuth2PasswordRequestForm
        Use the form data
        Check the password
            Password hashing
                Why use password hashing
            About **user_dict
    Return the token
    Update the dependencies
    See it in action
        Authenticate
        Get your own user data
        Inactive user
    Recap

    FastAPI
    Learn
    Tutorial - User Guide
    Security

Simple OAuth2 with Password and BearerÂ¶

Now let's build from the previous chapter and add the missing parts to have a complete security flow.
Get the username and passwordÂ¶

We are going to use FastAPI security utilities to get the username and password.

OAuth2 specifies that when using the "password flow" (that we are using) the client/user must send a username and password fields as form data.

And the spec says that the fields have to be named like that. So user-name or email wouldn't work.

But don't worry, you can show it as you wish to your final users in the frontend.

And your database models can use any other names you want.

But for the login path operation, we need to use these names to be compatible with the spec (and be able to, for example, use the integrated API documentation system).

The spec also states that the username and password must be sent as form data (so, no JSON here).
scopeÂ¶

The spec also says that the client can send another form field "scope".

The form field name is scope (in singular), but it is actually a long string with "scopes" separated by spaces.

Each "scope" is just a string (without spaces).

They are normally used to declare specific security permissions, for example:

    users:read or users:write are common examples.
    instagram_basic is used by Facebook / Instagram.
    https://www.googleapis.com/auth/drive is used by Google.

Info

In OAuth2 a "scope" is just a string that declares a specific permission required.

It doesn't matter if it has other characters like : or if it is a URL.

Those details are implementation specific.

For OAuth2 they are just strings.
Code to get the username and passwordÂ¶

Now let's use the utilities provided by FastAPI to handle this.
OAuth2PasswordRequestFormÂ¶

First, import OAuth2PasswordRequestForm, and use it as a dependency with Depends in the path operation for /token:
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel

fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "fakehashedsecret",
        "disabled": False,
    },
    "alice": {
        "username": "alice",
        "full_name": "Alice Wonderson",
        "email": "alice@example.com",
        "hashed_password": "fakehashedsecret2",
        "disabled": True,
    },
}

app = FastAPI()


def fake_hash_password(password: str):
    return "fakehashed" + password


oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    hashed_password: str


def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)


def fake_decode_token(token):
    # This doesn't provide any security at all
    # Check the next version
    user = get_user(fake_users_db, token)
    return user


async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    user = fake_decode_token(token)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return user


async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)],
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


@app.post("/token")
async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
    user_dict = fake_users_db.get(form_data.username)
    if not user_dict:
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    user = UserInDB(**user_dict)
    hashed_password = fake_hash_password(form_data.password)
    if not hashed_password == user.hashed_password:
        raise HTTPException(status_code=400, detail="Incorrect username or password")

    return {"access_token": user.username, "token_type": "bearer"}


@app.get("/users/me")
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return current_user

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

OAuth2PasswordRequestForm is a class dependency that declares a form body with:

    The username.
    The password.
    An optional scope field as a big string, composed of strings separated by spaces.
    An optional grant_type.

Tip

The OAuth2 spec actually requires a field grant_type with a fixed value of password, but OAuth2PasswordRequestForm doesn't enforce it.

If you need to enforce it, use OAuth2PasswordRequestFormStrict instead of OAuth2PasswordRequestForm.

    An optional client_id (we don't need it for our example).
    An optional client_secret (we don't need it for our example).

Info

The OAuth2PasswordRequestForm is not a special class for FastAPI as is OAuth2PasswordBearer.

OAuth2PasswordBearer makes FastAPI know that it is a security scheme. So it is added that way to OpenAPI.

But OAuth2PasswordRequestForm is just a class dependency that you could have written yourself, or you could have declared Form parameters directly.

But as it's a common use case, it is provided by FastAPI directly, just to make it easier.
Use the form dataÂ¶

Tip

The instance of the dependency class OAuth2PasswordRequestForm won't have an attribute scope with the long string separated by spaces, instead, it will have a scopes attribute with the actual list of strings for each scope sent.

We are not using scopes in this example, but the functionality is there if you need it.

Now, get the user data from the (fake) database, using the username from the form field.

If there is no such user, we return an error saying "Incorrect username or password".

For the error, we use the exception HTTPException:
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel

fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "fakehashedsecret",
        "disabled": False,
    },
    "alice": {
        "username": "alice",
        "full_name": "Alice Wonderson",
        "email": "alice@example.com",
        "hashed_password": "fakehashedsecret2",
        "disabled": True,
    },
}

app = FastAPI()


def fake_hash_password(password: str):
    return "fakehashed" + password


oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    hashed_password: str


def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)


def fake_decode_token(token):
    # This doesn't provide any security at all
    # Check the next version
    user = get_user(fake_users_db, token)
    return user


async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    user = fake_decode_token(token)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return user


async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)],
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


@app.post("/token")
async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
    user_dict = fake_users_db.get(form_data.username)
    if not user_dict:
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    user = UserInDB(**user_dict)
    hashed_password = fake_hash_password(form_data.password)
    if not hashed_password == user.hashed_password:
        raise HTTPException(status_code=400, detail="Incorrect username or password")

    return {"access_token": user.username, "token_type": "bearer"}


@app.get("/users/me")
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return current_user

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Check the passwordÂ¶

At this point we have the user data from our database, but we haven't checked the password.

Let's put that data in the Pydantic UserInDB model first.

You should never save plaintext passwords, so, we'll use the (fake) password hashing system.

If the passwords don't match, we return the same error.
Password hashingÂ¶

"Hashing" means: converting some content (a password in this case) into a sequence of bytes (just a string) that looks like gibberish.

Whenever you pass exactly the same content (exactly the same password) you get exactly the same gibberish.

But you cannot convert from the gibberish back to the password.
Why use password hashingÂ¶

If your database is stolen, the thief won't have your users' plaintext passwords, only the hashes.

So, the thief won't be able to try to use those same passwords in another system (as many users use the same password everywhere, this would be dangerous).
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel

fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "fakehashedsecret",
        "disabled": False,
    },
    "alice": {
        "username": "alice",
        "full_name": "Alice Wonderson",
        "email": "alice@example.com",
        "hashed_password": "fakehashedsecret2",
        "disabled": True,
    },
}

app = FastAPI()


def fake_hash_password(password: str):
    return "fakehashed" + password


oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    hashed_password: str


def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)


def fake_decode_token(token):
    # This doesn't provide any security at all
    # Check the next version
    user = get_user(fake_users_db, token)
    return user


async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    user = fake_decode_token(token)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return user


async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)],
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


@app.post("/token")
async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
    user_dict = fake_users_db.get(form_data.username)
    if not user_dict:
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    user = UserInDB(**user_dict)
    hashed_password = fake_hash_password(form_data.password)
    if not hashed_password == user.hashed_password:
        raise HTTPException(status_code=400, detail="Incorrect username or password")

    return {"access_token": user.username, "token_type": "bearer"}


@app.get("/users/me")
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return current_user

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

About **user_dictÂ¶

UserInDB(**user_dict) means:

Pass the keys and values of the user_dict directly as key-value arguments, equivalent to:

UserInDB(
    username = user_dict["username"],
    email = user_dict["email"],
    full_name = user_dict["full_name"],
    disabled = user_dict["disabled"],
    hashed_password = user_dict["hashed_password"],
)

Info

For a more complete explanation of **user_dict check back in the documentation for Extra Models.
Return the tokenÂ¶

The response of the token endpoint must be a JSON object.

It should have a token_type. In our case, as we are using "Bearer" tokens, the token type should be "bearer".

And it should have an access_token, with a string containing our access token.

For this simple example, we are going to just be completely insecure and return the same username as the token.

Tip

In the next chapter, you will see a real secure implementation, with password hashing and JWT tokens.

But for now, let's focus on the specific details we need.
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel

fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "fakehashedsecret",
        "disabled": False,
    },
    "alice": {
        "username": "alice",
        "full_name": "Alice Wonderson",
        "email": "alice@example.com",
        "hashed_password": "fakehashedsecret2",
        "disabled": True,
    },
}

app = FastAPI()


def fake_hash_password(password: str):
    return "fakehashed" + password


oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    hashed_password: str


def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)


def fake_decode_token(token):
    # This doesn't provide any security at all
    # Check the next version
    user = get_user(fake_users_db, token)
    return user


async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    user = fake_decode_token(token)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return user


async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)],
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


@app.post("/token")
async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
    user_dict = fake_users_db.get(form_data.username)
    if not user_dict:
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    user = UserInDB(**user_dict)
    hashed_password = fake_hash_password(form_data.password)
    if not hashed_password == user.hashed_password:
        raise HTTPException(status_code=400, detail="Incorrect username or password")

    return {"access_token": user.username, "token_type": "bearer"}


@app.get("/users/me")
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return current_user

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Tip

By the spec, you should return a JSON with an access_token and a token_type, the same as in this example.

This is something that you have to do yourself in your code, and make sure you use those JSON keys.

It's almost the only thing that you have to remember to do correctly yourself, to be compliant with the specifications.

For the rest, FastAPI handles it for you.
Update the dependenciesÂ¶

Now we are going to update our dependencies.

We want to get the current_user only if this user is active.

So, we create an additional dependency get_current_active_user that in turn uses get_current_user as a dependency.

Both of these dependencies will just return an HTTP error if the user doesn't exist, or if is inactive.

So, in our endpoint, we will only get a user if the user exists, was correctly authenticated, and is active:
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel

fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "fakehashedsecret",
        "disabled": False,
    },
    "alice": {
        "username": "alice",
        "full_name": "Alice Wonderson",
        "email": "alice@example.com",
        "hashed_password": "fakehashedsecret2",
        "disabled": True,
    },
}

app = FastAPI()


def fake_hash_password(password: str):
    return "fakehashed" + password


oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    hashed_password: str


def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)


def fake_decode_token(token):
    # This doesn't provide any security at all
    # Check the next version
    user = get_user(fake_users_db, token)
    return user


async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    user = fake_decode_token(token)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return user


async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)],
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


@app.post("/token")
async def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
    user_dict = fake_users_db.get(form_data.username)
    if not user_dict:
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    user = UserInDB(**user_dict)
    hashed_password = fake_hash_password(form_data.password)
    if not hashed_password == user.hashed_password:
        raise HTTPException(status_code=400, detail="Incorrect username or password")

    return {"access_token": user.username, "token_type": "bearer"}


@app.get("/users/me")
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return current_user

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Info

The additional header WWW-Authenticate with value Bearer we are returning here is also part of the spec.

Any HTTP (error) status code 401 "UNAUTHORIZED" is supposed to also return a WWW-Authenticate header.

In the case of bearer tokens (our case), the value of that header should be Bearer.

You can actually skip that extra header and it would still work.

But it's provided here to be compliant with the specifications.

Also, there might be tools that expect and use it (now or in the future) and that might be useful for you or your users, now or in the future.

That's the benefit of standards...
See it in actionÂ¶

Open the interactive docs: http://127.0.0.1:8000/docs.
AuthenticateÂ¶

Click the "Authorize" button.

Use the credentials:

User: johndoe

Password: secret

After authenticating in the system, you will see it like:

Get your own user dataÂ¶

Now use the operation GET with the path /users/me.

You will get your user's data, like:

{
  "username": "johndoe",
  "email": "johndoe@example.com",
  "full_name": "John Doe",
  "disabled": false,
  "hashed_password": "fakehashedsecret"
}

If you click the lock icon and logout, and then try the same operation again, you will get an HTTP 401 error of:

{
  "detail": "Not authenticated"
}

Inactive userÂ¶

Now try with an inactive user, authenticate with:

User: alice

Password: secret2

And try to use the operation GET with the path /users/me.

You will get an "Inactive user" error, like:

{
  "detail": "Inactive user"
}

RecapÂ¶

You now have the tools to implement a complete security system based on username and password for your API.

Using these tools, you can make the security system compatible with any database and with any user or data model.

The only detail missing is that it is not actually "secure" yet.

In the next chapter you'll see how to use a secure password hashing library and JWT tokens.
Previous
Get Current User
Next
OAuth2 with Password (and hashing), Bearer with JWT tokens
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs





Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
OAuth2 with Password (and hashing), Bearer with JWT tokens

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
            Security
                Security - First Steps
                Get Current User
                Simple OAuth2 with Password and Bearer
                OAuth2 with Password (and hashing), Bearer with JWT tokens
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    About JWT
    Install PyJWT
    Password hashing
        Why use password hashing
    Install pwdlib
    Hash and verify the passwords
    Handle JWT tokens
    Update the dependencies
    Update the /token path operation
        Technical details about the JWT "subject" sub
    Check it
    Advanced usage with scopes
    Recap

    FastAPI
    Learn
    Tutorial - User Guide
    Security

OAuth2 with Password (and hashing), Bearer with JWT tokensÂ¶

Now that we have all the security flow, let's make the application actually secure, using JWT tokens and secure password hashing.

This code is something you can actually use in your application, save the password hashes in your database, etc.

We are going to start from where we left in the previous chapter and increment it.
About JWTÂ¶

JWT means "JSON Web Tokens".

It's a standard to codify a JSON object in a long dense string without spaces. It looks like this:

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

It is not encrypted, so, anyone could recover the information from the contents.

But it's signed. So, when you receive a token that you emitted, you can verify that you actually emitted it.

That way, you can create a token with an expiration of, let's say, 1 week. And then when the user comes back the next day with the token, you know that user is still logged in to your system.

After a week, the token will be expired and the user will not be authorized and will have to sign in again to get a new token. And if the user (or a third party) tried to modify the token to change the expiration, you would be able to discover it, because the signatures would not match.

If you want to play with JWT tokens and see how they work, check https://jwt.io.
Install PyJWTÂ¶

We need to install PyJWT to generate and verify the JWT tokens in Python.

Make sure you create a virtual environment, activate it, and then install pyjwt:



Info

If you are planning to use digital signature algorithms like RSA or ECDSA, you should install the cryptography library dependency pyjwt[crypto].

You can read more about it in the PyJWT Installation docs.
Password hashingÂ¶

"Hashing" means converting some content (a password in this case) into a sequence of bytes (just a string) that looks like gibberish.

Whenever you pass exactly the same content (exactly the same password) you get exactly the same gibberish.

But you cannot convert from the gibberish back to the password.
Why use password hashingÂ¶

If your database is stolen, the thief won't have your users' plaintext passwords, only the hashes.

So, the thief won't be able to try to use that password in another system (as many users use the same password everywhere, this would be dangerous).
Install pwdlibÂ¶

pwdlib is a great Python package to handle password hashes.

It supports many secure hashing algorithms and utilities to work with them.

The recommended algorithm is "Argon2".

Make sure you create a virtual environment, activate it, and then install pwdlib with Argon2:



Tip

With pwdlib, you could even configure it to be able to read passwords created by Django, a Flask security plug-in or many others.

So, you would be able to, for example, share the same data from a Django application in a database with a FastAPI application. Or gradually migrate a Django application using the same database.

And your users would be able to login from your Django app or from your FastAPI app, at the same time.
Hash and verify the passwordsÂ¶

Import the tools we need from pwdlib.

Create a PasswordHash instance with recommended settings - it will be used for hashing and verifying passwords.

Tip

pwdlib also supports the bcrypt hashing algorithm but does not include legacy algorithms - for working with outdated hashes, it is recommended to use the passlib library.

For example, you could use it to read and verify passwords generated by another system (like Django) but hash any new passwords with a different algorithm like Argon2 or Bcrypt.

And be compatible with all of them at the same time.

Create a utility function to hash a password coming from the user.

And another utility to verify if a received password matches the hash stored.

And another one to authenticate and return a user.
Python 3.10+

from datetime import datetime, timedelta, timezone
from typing import Annotated

import jwt
from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jwt.exceptions import InvalidTokenError
from pwdlib import PasswordHash
from pydantic import BaseModel

# to get a string like this run:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30


fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
        "disabled": False,
    }
}


class Token(BaseModel):
    access_token: str
    token_type: str


class TokenData(BaseModel):
    username: str | None = None


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    hashed_password: str


password_hash = PasswordHash.recommended()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

app = FastAPI()


def verify_password(plain_password, hashed_password):
    return password_hash.verify(plain_password, hashed_password)


def get_password_hash(password):
    return password_hash.hash(password)


def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)


def authenticate_user(fake_db, username: str, password: str):
    user = get_user(fake_db, username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user


def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except InvalidTokenError:
        raise credentials_exception
    user = get_user(fake_users_db, username=token_data.username)
    if user is None:
        raise credentials_exception
    return user


async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)],
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


@app.post("/token")
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
) -> Token:
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    return Token(access_token=access_token, token_type="bearer")


@app.get("/users/me/", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return current_user


@app.get("/users/me/items/")
async def read_own_items(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return [{"item_id": "Foo", "owner": current_user.username}]

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Note

If you check the new (fake) database fake_users_db, you will see how the hashed password looks like now: "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc".
Handle JWT tokensÂ¶

Import the modules installed.

Create a random secret key that will be used to sign the JWT tokens.

To generate a secure random secret key use the command:




And copy the output to the variable SECRET_KEY (don't use the one in the example).

Create a variable ALGORITHM with the algorithm used to sign the JWT token and set it to "HS256".

Create a variable for the expiration of the token.

Define a Pydantic Model that will be used in the token endpoint for the response.

Create a utility function to generate a new access token.
Python 3.10+

from datetime import datetime, timedelta, timezone
from typing import Annotated

import jwt
from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jwt.exceptions import InvalidTokenError
from pwdlib import PasswordHash
from pydantic import BaseModel

# to get a string like this run:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30


fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
        "disabled": False,
    }
}


class Token(BaseModel):
    access_token: str
    token_type: str


class TokenData(BaseModel):
    username: str | None = None


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    hashed_password: str


password_hash = PasswordHash.recommended()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

app = FastAPI()


def verify_password(plain_password, hashed_password):
    return password_hash.verify(plain_password, hashed_password)


def get_password_hash(password):
    return password_hash.hash(password)


def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)


def authenticate_user(fake_db, username: str, password: str):
    user = get_user(fake_db, username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user


def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except InvalidTokenError:
        raise credentials_exception
    user = get_user(fake_users_db, username=token_data.username)
    if user is None:
        raise credentials_exception
    return user


async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)],
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


@app.post("/token")
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
) -> Token:
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    return Token(access_token=access_token, token_type="bearer")


@app.get("/users/me/", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return current_user


@app.get("/users/me/items/")
async def read_own_items(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return [{"item_id": "Foo", "owner": current_user.username}]

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Update the dependenciesÂ¶

Update get_current_user to receive the same token as before, but this time, using JWT tokens.

Decode the received token, verify it, and return the current user.

If the token is invalid, return an HTTP error right away.
Python 3.10+

from datetime import datetime, timedelta, timezone
from typing import Annotated

import jwt
from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jwt.exceptions import InvalidTokenError
from pwdlib import PasswordHash
from pydantic import BaseModel

# to get a string like this run:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30


fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
        "disabled": False,
    }
}


class Token(BaseModel):
    access_token: str
    token_type: str


class TokenData(BaseModel):
    username: str | None = None


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    hashed_password: str


password_hash = PasswordHash.recommended()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

app = FastAPI()


def verify_password(plain_password, hashed_password):
    return password_hash.verify(plain_password, hashed_password)


def get_password_hash(password):
    return password_hash.hash(password)


def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)


def authenticate_user(fake_db, username: str, password: str):
    user = get_user(fake_db, username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user


def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except InvalidTokenError:
        raise credentials_exception
    user = get_user(fake_users_db, username=token_data.username)
    if user is None:
        raise credentials_exception
    return user


async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)],
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


@app.post("/token")
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
) -> Token:
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    return Token(access_token=access_token, token_type="bearer")


@app.get("/users/me/", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return current_user


@app.get("/users/me/items/")
async def read_own_items(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return [{"item_id": "Foo", "owner": current_user.username}]

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Update the /token path operationÂ¶

Create a timedelta with the expiration time of the token.

Create a real JWT access token and return it.
Python 3.10+

from datetime import datetime, timedelta, timezone
from typing import Annotated

import jwt
from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jwt.exceptions import InvalidTokenError
from pwdlib import PasswordHash
from pydantic import BaseModel

# to get a string like this run:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30


fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
        "disabled": False,
    }
}


class Token(BaseModel):
    access_token: str
    token_type: str


class TokenData(BaseModel):
    username: str | None = None


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    hashed_password: str


password_hash = PasswordHash.recommended()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

app = FastAPI()


def verify_password(plain_password, hashed_password):
    return password_hash.verify(plain_password, hashed_password)


def get_password_hash(password):
    return password_hash.hash(password)


def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)


def authenticate_user(fake_db, username: str, password: str):
    user = get_user(fake_db, username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user


def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except InvalidTokenError:
        raise credentials_exception
    user = get_user(fake_users_db, username=token_data.username)
    if user is None:
        raise credentials_exception
    return user


async def get_current_active_user(
    current_user: Annotated[User, Depends(get_current_user)],
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


@app.post("/token")
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
) -> Token:
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    return Token(access_token=access_token, token_type="bearer")


@app.get("/users/me/", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return current_user


@app.get("/users/me/items/")
async def read_own_items(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return [{"item_id": "Foo", "owner": current_user.username}]

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Technical details about the JWT "subject" subÂ¶

The JWT specification says that there's a key sub, with the subject of the token.

It's optional to use it, but that's where you would put the user's identification, so we are using it here.

JWT might be used for other things apart from identifying a user and allowing them to perform operations directly on your API.

For example, you could identify a "car" or a "blog post".

Then you could add permissions about that entity, like "drive" (for the car) or "edit" (for the blog).

And then, you could give that JWT token to a user (or bot), and they could use it to perform those actions (drive the car, or edit the blog post) without even needing to have an account, just with the JWT token your API generated for that.

Using these ideas, JWT can be used for way more sophisticated scenarios.

In those cases, several of those entities could have the same ID, let's say foo (a user foo, a car foo, and a blog post foo).

So, to avoid ID collisions, when creating the JWT token for the user, you could prefix the value of the sub key, e.g. with username:. So, in this example, the value of sub could have been: username:johndoe.

The important thing to keep in mind is that the sub key should have a unique identifier across the entire application, and it should be a string.
Check itÂ¶

Run the server and go to the docs: http://127.0.0.1:8000/docs.

You'll see the user interface like:

Authorize the application the same way as before.

Using the credentials:

Username: johndoe Password: secret

Check

Notice that nowhere in the code is the plaintext password "secret", we only have the hashed version.

Call the endpoint /users/me/, you will get the response as:

{
  "username": "johndoe",
  "email": "johndoe@example.com",
  "full_name": "John Doe",
  "disabled": false
}

If you open the developer tools, you could see how the data sent only includes the token, the password is only sent in the first request to authenticate the user and get that access token, but not afterwards:

Note

Notice the header Authorization, with a value that starts with Bearer.
Advanced usage with scopesÂ¶

OAuth2 has the notion of "scopes".

You can use them to add a specific set of permissions to a JWT token.

Then you can give this token to a user directly or a third party, to interact with your API with a set of restrictions.

You can learn how to use them and how they are integrated into FastAPI later in the Advanced User Guide.
RecapÂ¶

With what you have seen up to now, you can set up a secure FastAPI application using standards like OAuth2 and JWT.

In almost any framework handling the security becomes a rather complex subject quite quickly.

Many packages that simplify it a lot have to make many compromises with the data model, database, and available features. And some of these packages that simplify things too much actually have security flaws underneath.

FastAPI doesn't make any compromise with any database, data model or tool.

It gives you all the flexibility to choose the ones that fit your project the best.

And you can use directly many well maintained and widely used packages like pwdlib and PyJWT, because FastAPI doesn't require any complex mechanisms to integrate external packages.

But it provides you the tools to simplify the process as much as possible without compromising flexibility, robustness, or security.

And you can use and implement secure, standard protocols, like OAuth2 in a relatively simple way.

You can learn more in the Advanced User Guide about how to use OAuth2 "scopes", for a more fine-grained permission system, following these same standards. OAuth2 with scopes is the mechanism used by many big authentication providers, like Facebook, Google, GitHub, Microsoft, X (Twitter), etc. to authorize third party applications to interact with their APIs on behalf of their users.
Previous
Simple OAuth2 with Password and Bearer
Next
Middleware
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
Middleware

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
            Security
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Create a middleware
        Before and after the response
    Multiple middleware execution order
    Other middlewares

    FastAPI
    Learn
    Tutorial - User Guide

MiddlewareÂ¶

You can add middleware to FastAPI applications.

A "middleware" is a function that works with every request before it is processed by any specific path operation. And also with every response before returning it.

    It takes each request that comes to your application.
    It can then do something to that request or run any needed code.
    Then it passes the request to be processed by the rest of the application (by some path operation).
    It then takes the response generated by the application (by some path operation).
    It can do something to that response or run any needed code.
    Then it returns the response.

Technical Details

If you have dependencies with yield, the exit code will run after the middleware.

If there were any background tasks (covered in the Background Tasks section, you will see it later), they will run after all the middleware.
Create a middlewareÂ¶

To create a middleware you use the decorator @app.middleware("http") on top of a function.

The middleware function receives:

    The request.
    A function call_next that will receive the request as a parameter.
        This function will pass the request to the corresponding path operation.
        Then it returns the response generated by the corresponding path operation.
    You can then further modify the response before returning it.

Python 3.8+

import time

from fastapi import FastAPI, Request

app = FastAPI()


@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    start_time = time.perf_counter()
    response = await call_next(request)
    process_time = time.perf_counter() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response

Tip

Keep in mind that custom proprietary headers can be added using the X- prefix.

But if you have custom headers that you want a client in a browser to be able to see, you need to add them to your CORS configurations (CORS (Cross-Origin Resource Sharing)) using the parameter expose_headers documented in Starlette's CORS docs.

Technical Details

You could also use from starlette.requests import Request.

FastAPI provides it as a convenience for you, the developer. But it comes directly from Starlette.
Before and after the responseÂ¶

You can add code to be run with the request, before any path operation receives it.

And also after the response is generated, before returning it.

For example, you could add a custom header X-Process-Time containing the time in seconds that it took to process the request and generate a response:
Python 3.8+

import time

from fastapi import FastAPI, Request

app = FastAPI()


@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    start_time = time.perf_counter()
    response = await call_next(request)
    process_time = time.perf_counter() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response

Tip

Here we use time.perf_counter() instead of time.time() because it can be more precise for these use cases. ğŸ¤“
Multiple middleware execution orderÂ¶

When you add multiple middlewares using either @app.middleware() decorator or app.add_middleware() method, each new middleware wraps the application, forming a stack. The last middleware added is the outermost, and the first is the innermost.

On the request path, the outermost middleware runs first.

On the response path, it runs last.

For example:

app.add_middleware(MiddlewareA)
app.add_middleware(MiddlewareB)

This results in the following execution order:

    Request: MiddlewareB â†’ MiddlewareA â†’ route

    Response: route â†’ MiddlewareA â†’ MiddlewareB

This stacking behavior ensures that middlewares are executed in a predictable and controllable order.
Other middlewaresÂ¶

You can later read more about other middlewares in the Advanced User Guide: Advanced Middleware.

You will read about how to handle CORS with a middleware in the next section.
Previous
OAuth2 with Password (and hashing), Bearer with JWT tokens
Next
CORS (Cross-Origin Resource Sharing)
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
CORS (Cross-Origin Resource Sharing)

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
            Security
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Origin
    Steps
    Wildcards
    Use CORSMiddleware
        CORS preflight requests
        Simple requests
    More info

    FastAPI
    Learn
    Tutorial - User Guide

CORS (Cross-Origin Resource Sharing)Â¶

CORS or "Cross-Origin Resource Sharing" refers to the situations when a frontend running in a browser has JavaScript code that communicates with a backend, and the backend is in a different "origin" than the frontend.
OriginÂ¶

An origin is the combination of protocol (http, https), domain (myapp.com, localhost, localhost.tiangolo.com), and port (80, 443, 8080).

So, all these are different origins:

    http://localhost
    https://localhost
    http://localhost:8080

Even if they are all in localhost, they use different protocols or ports, so, they are different "origins".
StepsÂ¶

So, let's say you have a frontend running in your browser at http://localhost:8080, and its JavaScript is trying to communicate with a backend running at http://localhost (because we don't specify a port, the browser will assume the default port 80).

Then, the browser will send an HTTP OPTIONS request to the :80-backend, and if the backend sends the appropriate headers authorizing the communication from this different origin (http://localhost:8080) then the :8080-browser will let the JavaScript in the frontend send its request to the :80-backend.

To achieve this, the :80-backend must have a list of "allowed origins".

In this case, the list would have to include http://localhost:8080 for the :8080-frontend to work correctly.
WildcardsÂ¶

It's also possible to declare the list as "*" (a "wildcard") to say that all are allowed.

But that will only allow certain types of communication, excluding everything that involves credentials: Cookies, Authorization headers like those used with Bearer Tokens, etc.

So, for everything to work correctly, it's better to specify explicitly the allowed origins.
Use CORSMiddlewareÂ¶

You can configure it in your FastAPI application using the CORSMiddleware.

    Import CORSMiddleware.
    Create a list of allowed origins (as strings).
    Add it as a "middleware" to your FastAPI application.

You can also specify whether your backend allows:

    Credentials (Authorization headers, Cookies, etc).
    Specific HTTP methods (POST, PUT) or all of them with the wildcard "*".
    Specific HTTP headers or all of them with the wildcard "*".

Python 3.8+

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

origins = [
    "http://localhost.tiangolo.com",
    "https://localhost.tiangolo.com",
    "http://localhost",
    "http://localhost:8080",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/")
async def main():
    return {"message": "Hello World"}

The default parameters used by the CORSMiddleware implementation are restrictive by default, so you'll need to explicitly enable particular origins, methods, or headers, in order for browsers to be permitted to use them in a Cross-Domain context.

The following arguments are supported:

    allow_origins - A list of origins that should be permitted to make cross-origin requests. E.g. ['https://example.org', 'https://www.example.org']. You can use ['*'] to allow any origin.
    allow_origin_regex - A regex string to match against origins that should be permitted to make cross-origin requests. e.g. 'https://.*\.example\.org'.
    allow_methods - A list of HTTP methods that should be allowed for cross-origin requests. Defaults to ['GET']. You can use ['*'] to allow all standard methods.
    allow_headers - A list of HTTP request headers that should be supported for cross-origin requests. Defaults to []. You can use ['*'] to allow all headers. The Accept, Accept-Language, Content-Language and Content-Type headers are always allowed for simple CORS requests.

    allow_credentials - Indicate that cookies should be supported for cross-origin requests. Defaults to False.

    None of allow_origins, allow_methods and allow_headers can be set to ['*'] if allow_credentials is set to True. All of them must be explicitly specified.

    expose_headers - Indicate any response headers that should be made accessible to the browser. Defaults to [].
    max_age - Sets a maximum time in seconds for browsers to cache CORS responses. Defaults to 600.

The middleware responds to two particular types of HTTP request...
CORS preflight requestsÂ¶

These are any OPTIONS request with Origin and Access-Control-Request-Method headers.

In this case the middleware will intercept the incoming request and respond with appropriate CORS headers, and either a 200 or 400 response for informational purposes.
Simple requestsÂ¶

Any request with an Origin header. In this case the middleware will pass the request through as normal, but will include appropriate CORS headers on the response.
More infoÂ¶

For more info about CORS, check the Mozilla CORS documentation.

Technical Details

You could also use from starlette.middleware.cors import CORSMiddleware.

FastAPI provides several middlewares in fastapi.middleware just as a convenience for you, the developer. But most of the available middlewares come directly from Starlette.
Previous
Middleware
Next
SQL (Relational) Databases
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
SQL (Relational) Databases

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
            Security
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Install SQLModel
    Create the App with a Single Model
        Create Models
        Create an Engine
        Create the Tables
        Create a Session Dependency
        Create Database Tables on Startup
        Create a Hero
        Read Heroes
        Read One Hero
        Delete a Hero
        Run the App
    Update the App with Multiple Models
        Create Multiple Models
            HeroBase - the base class
            Hero - the table model
            HeroPublic - the public data model
            HeroCreate - the data model to create a hero
            HeroUpdate - the data model to update a hero
        Create with HeroCreate and return a HeroPublic
        Read Heroes with HeroPublic
        Read One Hero with HeroPublic
        Update a Hero with HeroUpdate
        Delete a Hero Again
        Run the App Again
    Recap

    FastAPI
    Learn
    Tutorial - User Guide

SQL (Relational) DatabasesÂ¶

FastAPI doesn't require you to use a SQL (relational) database. But you can use any database that you want.

Here we'll see an example using SQLModel.

SQLModel is built on top of SQLAlchemy and Pydantic. It was made by the same author of FastAPI to be the perfect match for FastAPI applications that need to use SQL databases.

Tip

You could use any other SQL or NoSQL database library you want (in some cases called "ORMs"), FastAPI doesn't force you to use anything. ğŸ˜

As SQLModel is based on SQLAlchemy, you can easily use any database supported by SQLAlchemy (which makes them also supported by SQLModel), like:

    PostgreSQL
    MySQL
    SQLite
    Oracle
    Microsoft SQL Server, etc.

In this example, we'll use SQLite, because it uses a single file and Python has integrated support. So, you can copy this example and run it as is.

Later, for your production application, you might want to use a database server like PostgreSQL.

Tip

There is an official project generator with FastAPI and PostgreSQL including a frontend and more tools: https://github.com/fastapi/full-stack-fastapi-template

This is a very simple and short tutorial, if you want to learn about databases in general, about SQL, or more advanced features, go to the SQLModel docs.
Install SQLModelÂ¶

First, make sure you create your virtual environment, activate it, and then install sqlmodel:


Create the App with a Single ModelÂ¶

We'll create the simplest first version of the app with a single SQLModel model first.

Later we'll improve it increasing security and versatility with multiple models below. ğŸ¤“
Create ModelsÂ¶

Import SQLModel and create a database model:
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, Query
from sqlmodel import Field, Session, SQLModel, create_engine, select


class Hero(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)
    secret_name: str

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

The Hero class is very similar to a Pydantic model (in fact, underneath, it actually is a Pydantic model).

There are a few differences:

    table=True tells SQLModel that this is a table model, it should represent a table in the SQL database, it's not just a data model (as would be any other regular Pydantic class).

    Field(primary_key=True) tells SQLModel that the id is the primary key in the SQL database (you can learn more about SQL primary keys in the SQLModel docs).

    By having the type as int | None, SQLModel will know that this column should be an INTEGER in the SQL database and that it should be NULLABLE.

    Field(index=True) tells SQLModel that it should create a SQL index for this column, that would allow faster lookups in the database when reading data filtered by this column.

    SQLModel will know that something declared as str will be a SQL column of type TEXT (or VARCHAR, depending on the database).

Create an EngineÂ¶

A SQLModel engine (underneath it's actually a SQLAlchemy engine) is what holds the connections to the database.

You would have one single engine object for all your code to connect to the same database.
Python 3.10+

# Code above omitted ğŸ‘†

sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///{sqlite_file_name}"

connect_args = {"check_same_thread": False}
engine = create_engine(sqlite_url, connect_args=connect_args)

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Using check_same_thread=False allows FastAPI to use the same SQLite database in different threads. This is necessary as one single request could use more than one thread (for example in dependencies).

Don't worry, with the way the code is structured, we'll make sure we use a single SQLModel session per request later, this is actually what the check_same_thread is trying to achieve.
Create the TablesÂ¶

We then add a function that uses SQLModel.metadata.create_all(engine) to create the tables for all the table models.
Python 3.10+

# Code above omitted ğŸ‘†

def create_db_and_tables():
    SQLModel.metadata.create_all(engine)

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Create a Session DependencyÂ¶

A Session is what stores the objects in memory and keeps track of any changes needed in the data, then it uses the engine to communicate with the database.

We will create a FastAPI dependency with yield that will provide a new Session for each request. This is what ensures that we use a single session per request. ğŸ¤“

Then we create an Annotated dependency SessionDep to simplify the rest of the code that will use this dependency.
Python 3.10+

# Code above omitted ğŸ‘†

def get_session():
    with Session(engine) as session:
        yield session


SessionDep = Annotated[Session, Depends(get_session)]

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Create Database Tables on StartupÂ¶

We will create the database tables when the application starts.
Python 3.10+

# Code above omitted ğŸ‘†

app = FastAPI()


@app.on_event("startup")
def on_startup():
    create_db_and_tables()

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Here we create the tables on an application startup event.

For production you would probably use a migration script that runs before you start your app. ğŸ¤“

Tip

SQLModel will have migration utilities wrapping Alembic, but for now, you can use Alembic directly.
Create a HeroÂ¶

Because each SQLModel model is also a Pydantic model, you can use it in the same type annotations that you could use Pydantic models.

For example, if you declare a parameter of type Hero, it will be read from the JSON body.

The same way, you can declare it as the function's return type, and then the shape of the data will show up in the automatic API docs UI.
Python 3.10+

# Code above omitted ğŸ‘†

@app.post("/heroes/")
def create_hero(hero: Hero, session: SessionDep) -> Hero:
    session.add(hero)
    session.commit()
    session.refresh(hero)
    return hero

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Here we use the SessionDep dependency (a Session) to add the new Hero to the Session instance, commit the changes to the database, refresh the data in the hero, and then return it.
Read HeroesÂ¶

We can read Heros from the database using a select(). We can include a limit and offset to paginate the results.
Python 3.10+

# Code above omitted ğŸ‘†

@app.get("/heroes/")
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
) -> list[Hero]:
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Read One HeroÂ¶

We can read a single Hero.
Python 3.10+

# Code above omitted ğŸ‘†

@app.get("/heroes/{hero_id}")
def read_hero(hero_id: int, session: SessionDep) -> Hero:
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Delete a HeroÂ¶

We can also delete a Hero.
Python 3.10+

# Code above omitted ğŸ‘†

@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Run the AppÂ¶

You can run the app:




Then go to the /docs UI, you will see that FastAPI is using these models to document the API, and it will use them to serialize and validate the data too.
Update the App with Multiple ModelsÂ¶

Now let's refactor this app a bit to increase security and versatility.

If you check the previous app, in the UI you can see that, up to now, it lets the client decide the id of the Hero to create. ğŸ˜±

We shouldn't let that happen, they could overwrite an id we already have assigned in the DB. Deciding the id should be done by the backend or the database, not by the client.

Additionally, we create a secret_name for the hero, but so far, we are returning it everywhere, that's not very secret... ğŸ˜…

We'll fix these things by adding a few extra models. Here's where SQLModel will shine. âœ¨
Create Multiple ModelsÂ¶

In SQLModel, any model class that has table=True is a table model.

And any model class that doesn't have table=True is a data model, these ones are actually just Pydantic models (with a couple of small extra features). ğŸ¤“

With SQLModel, we can use inheritance to avoid duplicating all the fields in all the cases.
HeroBase - the base classÂ¶

Let's start with a HeroBase model that has all the fields that are shared by all the models:

    name
    age

Python 3.10+

# Code above omitted ğŸ‘†

class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Hero - the table modelÂ¶

Then let's create Hero, the actual table model, with the extra fields that are not always in the other models:

    id
    secret_name

Because Hero inherits form HeroBase, it also has the fields declared in HeroBase, so all the fields for Hero are:

    id
    name
    age
    secret_name

Python 3.10+

# Code above omitted ğŸ‘†

class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

HeroPublic - the public data modelÂ¶

Next, we create a HeroPublic model, this is the one that will be returned to the clients of the API.

It has the same fields as HeroBase, so it won't include secret_name.

Finally, the identity of our heroes is protected! ğŸ¥·

It also re-declares id: int. By doing this, we are making a contract with the API clients, so that they can always expect the id to be there and to be an int (it will never be None).

Tip

Having the return model ensure that a value is always available and always int (not None) is very useful for the API clients, they can write much simpler code having this certainty.

Also, automatically generated clients will have simpler interfaces, so that the developers communicating with your API can have a much better time working with your API. ğŸ˜

All the fields in HeroPublic are the same as in HeroBase, with id declared as int (not None):

    id
    name
    age

Python 3.10+

# Code above omitted ğŸ‘†

class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

HeroCreate - the data model to create a heroÂ¶

Now we create a HeroCreate model, this is the one that will validate the data from the clients.

It has the same fields as HeroBase, and it also has secret_name.

Now, when the clients create a new hero, they will send the secret_name, it will be stored in the database, but those secret names won't be returned in the API to the clients.

Tip

This is how you would handle passwords. Receive them, but don't return them in the API.

You would also hash the values of the passwords before storing them, never store them in plain text.

The fields of HeroCreate are:

    name
    age
    secret_name

Python 3.10+

# Code above omitted ğŸ‘†

class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

HeroUpdate - the data model to update a heroÂ¶

We didn't have a way to update a hero in the previous version of the app, but now with multiple models, we can do it. ğŸ‰

The HeroUpdate data model is somewhat special, it has all the same fields that would be needed to create a new hero, but all the fields are optional (they all have a default value). This way, when you update a hero, you can send just the fields that you want to update.

Because all the fields actually change (the type now includes None and they now have a default value of None), we need to re-declare them.

We don't really need to inherit from HeroBase because we are re-declaring all the fields. I'll leave it inheriting just for consistency, but this is not necessary. It's more a matter of personal taste. ğŸ¤·

The fields of HeroUpdate are:

    name
    age
    secret_name

Python 3.10+

# Code above omitted ğŸ‘†

class HeroBase(SQLModel):
    name: str = Field(index=True)
    age: int | None = Field(default=None, index=True)


class Hero(HeroBase, table=True):
    id: int | None = Field(default=None, primary_key=True)
    secret_name: str


class HeroPublic(HeroBase):
    id: int


class HeroCreate(HeroBase):
    secret_name: str


class HeroUpdate(HeroBase):
    name: str | None = None
    age: int | None = None
    secret_name: str | None = None

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Create with HeroCreate and return a HeroPublicÂ¶

Now that we have multiple models, we can update the parts of the app that use them.

We receive in the request a HeroCreate data model, and from it, we create a Hero table model.

This new table model Hero will have the fields sent by the client, and will also have an id generated by the database.

Then we return the same table model Hero as is from the function. But as we declare the response_model with the HeroPublic data model, FastAPI will use HeroPublic to validate and serialize the data.
Python 3.10+

# Code above omitted ğŸ‘†

@app.post("/heroes/", response_model=HeroPublic)
def create_hero(hero: HeroCreate, session: SessionDep):
    db_hero = Hero.model_validate(hero)
    session.add(db_hero)
    session.commit()
    session.refresh(db_hero)
    return db_hero

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Tip

Now we use response_model=HeroPublic instead of the return type annotation -> HeroPublic because the value that we are returning is actually not a HeroPublic.

If we had declared -> HeroPublic, your editor and linter would complain (rightfully so) that you are returning a Hero instead of a HeroPublic.

By declaring it in response_model we are telling FastAPI to do its thing, without interfering with the type annotations and the help from your editor and other tools.
Read Heroes with HeroPublicÂ¶

We can do the same as before to read Heros, again, we use response_model=list[HeroPublic] to ensure that the data is validated and serialized correctly.
Python 3.10+

# Code above omitted ğŸ‘†

@app.get("/heroes/", response_model=list[HeroPublic])
def read_heroes(
    session: SessionDep,
    offset: int = 0,
    limit: Annotated[int, Query(le=100)] = 100,
):
    heroes = session.exec(select(Hero).offset(offset).limit(limit)).all()
    return heroes

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Read One Hero with HeroPublicÂ¶

We can read a single hero:
Python 3.10+

# Code above omitted ğŸ‘†

@app.get("/heroes/{hero_id}", response_model=HeroPublic)
def read_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    return hero

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Update a Hero with HeroUpdateÂ¶

We can update a hero. For this we use an HTTP PATCH operation.

And in the code, we get a dict with all the data sent by the client, only the data sent by the client, excluding any values that would be there just for being the default values. To do it we use exclude_unset=True. This is the main trick. ğŸª„

Then we use hero_db.sqlmodel_update(hero_data) to update the hero_db with the data from hero_data.
Python 3.10+

# Code above omitted ğŸ‘†

@app.patch("/heroes/{hero_id}", response_model=HeroPublic)
def update_hero(hero_id: int, hero: HeroUpdate, session: SessionDep):
    hero_db = session.get(Hero, hero_id)
    if not hero_db:
        raise HTTPException(status_code=404, detail="Hero not found")
    hero_data = hero.model_dump(exclude_unset=True)
    hero_db.sqlmodel_update(hero_data)
    session.add(hero_db)
    session.commit()
    session.refresh(hero_db)
    return hero_db

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Delete a Hero AgainÂ¶

Deleting a hero stays pretty much the same.

We won't satisfy the desire to refactor everything in this one. ğŸ˜…
Python 3.10+

# Code above omitted ğŸ‘†

@app.delete("/heroes/{hero_id}")
def delete_hero(hero_id: int, session: SessionDep):
    hero = session.get(Hero, hero_id)
    if not hero:
        raise HTTPException(status_code=404, detail="Hero not found")
    session.delete(hero)
    session.commit()
    return {"ok": True}

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Run the App AgainÂ¶

You can run the app again:




If you go to the /docs API UI, you will see that it is now updated, and it won't expect to receive the id from the client when creating a hero, etc.
RecapÂ¶

You can use SQLModel to interact with a SQL database and simplify the code with data models and table models.

You can learn a lot more at the SQLModel docs, there's a longer mini tutorial on using SQLModel with FastAPI. ğŸš€
Previous
CORS (Cross-Origin Resource Sharing)
Next
Bigger Applications - Multiple Files
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
Bigger Applications - Multiple Files

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
            Security
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    An example file structure
    APIRouter
        Import APIRouter
        Path operations with APIRouter
    Dependencies
    Another module with APIRouter
        Import the dependencies
            How relative imports work
        Add some custom tags, responses, and dependencies
    The main FastAPI
        Import FastAPI
        Import the APIRouter
        How the importing works
        Avoid name collisions
        Include the APIRouters for users and items
        Include an APIRouter with a custom prefix, tags, responses, and dependencies
        Include a path operation
    Check the automatic API docs
    Include the same router multiple times with different prefix
    Include an APIRouter in another

    FastAPI
    Learn
    Tutorial - User Guide

Bigger Applications - Multiple FilesÂ¶

If you are building an application or a web API, it's rarely the case that you can put everything in a single file.

FastAPI provides a convenience tool to structure your application while keeping all the flexibility.

Info

If you come from Flask, this would be the equivalent of Flask's Blueprints.
An example file structureÂ¶

Let's say you have a file structure like this:

.
â”œâ”€â”€ app
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py
â”‚   â”œâ”€â”€ dependencies.py
â”‚   â””â”€â”€ routers
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ items.py
â”‚   â”‚   â””â”€â”€ users.py
â”‚   â””â”€â”€ internal
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ admin.py

Tip

There are several __init__.py files: one in each directory or subdirectory.

This is what allows importing code from one file into another.

For example, in app/main.py you could have a line like:

from app.routers import items

    The app directory contains everything. And it has an empty file app/__init__.py, so it is a "Python package" (a collection of "Python modules"): app.
    It contains an app/main.py file. As it is inside a Python package (a directory with a file __init__.py), it is a "module" of that package: app.main.
    There's also an app/dependencies.py file, just like app/main.py, it is a "module": app.dependencies.
    There's a subdirectory app/routers/ with another file __init__.py, so it's a "Python subpackage": app.routers.
    The file app/routers/items.py is inside a package, app/routers/, so, it's a submodule: app.routers.items.
    The same with app/routers/users.py, it's another submodule: app.routers.users.
    There's also a subdirectory app/internal/ with another file __init__.py, so it's another "Python subpackage": app.internal.
    And the file app/internal/admin.py is another submodule: app.internal.admin.

The same file structure with comments:

.
â”œâ”€â”€ app                  # "app" is a Python package
â”‚   â”œâ”€â”€ __init__.py      # this file makes "app" a "Python package"
â”‚   â”œâ”€â”€ main.py          # "main" module, e.g. import app.main
â”‚   â”œâ”€â”€ dependencies.py  # "dependencies" module, e.g. import app.dependencies
â”‚   â””â”€â”€ routers          # "routers" is a "Python subpackage"
â”‚   â”‚   â”œâ”€â”€ __init__.py  # makes "routers" a "Python subpackage"
â”‚   â”‚   â”œâ”€â”€ items.py     # "items" submodule, e.g. import app.routers.items
â”‚   â”‚   â””â”€â”€ users.py     # "users" submodule, e.g. import app.routers.users
â”‚   â””â”€â”€ internal         # "internal" is a "Python subpackage"
â”‚       â”œâ”€â”€ __init__.py  # makes "internal" a "Python subpackage"
â”‚       â””â”€â”€ admin.py     # "admin" submodule, e.g. import app.internal.admin

APIRouterÂ¶

Let's say the file dedicated to handling just users is the submodule at /app/routers/users.py.

You want to have the path operations related to your users separated from the rest of the code, to keep it organized.

But it's still part of the same FastAPI application/web API (it's part of the same "Python Package").

You can create the path operations for that module using APIRouter.
Import APIRouterÂ¶

You import it and create an "instance" the same way you would with the class FastAPI:
app/routers/users.py

from fastapi import APIRouter

router = APIRouter()


@router.get("/users/", tags=["users"])
async def read_users():
    return [{"username": "Rick"}, {"username": "Morty"}]


@router.get("/users/me", tags=["users"])
async def read_user_me():
    return {"username": "fakecurrentuser"}


@router.get("/users/{username}", tags=["users"])
async def read_user(username: str):
    return {"username": username}

Path operations with APIRouterÂ¶

And then you use it to declare your path operations.

Use it the same way you would use the FastAPI class:
app/routers/users.py

from fastapi import APIRouter

router = APIRouter()


@router.get("/users/", tags=["users"])
async def read_users():
    return [{"username": "Rick"}, {"username": "Morty"}]


@router.get("/users/me", tags=["users"])
async def read_user_me():
    return {"username": "fakecurrentuser"}


@router.get("/users/{username}", tags=["users"])
async def read_user(username: str):
    return {"username": username}

You can think of APIRouter as a "mini FastAPI" class.

All the same options are supported.

All the same parameters, responses, dependencies, tags, etc.

Tip

In this example, the variable is called router, but you can name it however you want.

We are going to include this APIRouter in the main FastAPI app, but first, let's check the dependencies and another APIRouter.
DependenciesÂ¶

We see that we are going to need some dependencies used in several places of the application.

So we put them in their own dependencies module (app/dependencies.py).

We will now use a simple dependency to read a custom X-Token header:
Python 3.9+
Python 3.8+
Python 3.8+ non-Annotated
app/dependencies.py

from typing import Annotated

from fastapi import Header, HTTPException


async def get_token_header(x_token: Annotated[str, Header()]):
    if x_token != "fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")


async def get_query_token(token: str):
    if token != "jessica":
        raise HTTPException(status_code=400, detail="No Jessica token provided")

Tip

We are using an invented header to simplify this example.

But in real cases you will get better results using the integrated Security utilities.
Another module with APIRouterÂ¶

Let's say you also have the endpoints dedicated to handling "items" from your application in the module at app/routers/items.py.

You have path operations for:

    /items/
    /items/{item_id}

It's all the same structure as with app/routers/users.py.

But we want to be smarter and simplify the code a bit.

We know all the path operations in this module have the same:

    Path prefix: /items.
    tags: (just one tag: items).
    Extra responses.
    dependencies: they all need that X-Token dependency we created.

So, instead of adding all that to each path operation, we can add it to the APIRouter.
app/routers/items.py

from fastapi import APIRouter, Depends, HTTPException

from ..dependencies import get_token_header

router = APIRouter(
    prefix="/items",
    tags=["items"],
    dependencies=[Depends(get_token_header)],
    responses={404: {"description": "Not found"}},
)


fake_items_db = {"plumbus": {"name": "Plumbus"}, "gun": {"name": "Portal Gun"}}


@router.get("/")
async def read_items():
    return fake_items_db


@router.get("/{item_id}")
async def read_item(item_id: str):
    if item_id not in fake_items_db:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"name": fake_items_db[item_id]["name"], "item_id": item_id}


@router.put(
    "/{item_id}",
    tags=["custom"],
    responses={403: {"description": "Operation forbidden"}},
)
async def update_item(item_id: str):
    if item_id != "plumbus":
        raise HTTPException(
            status_code=403, detail="You can only update the item: plumbus"
        )
    return {"item_id": item_id, "name": "The great Plumbus"}

As the path of each path operation has to start with /, like in:

@router.get("/{item_id}")
async def read_item(item_id: str):
    ...

...the prefix must not include a final /.

So, the prefix in this case is /items.

We can also add a list of tags and extra responses that will be applied to all the path operations included in this router.

And we can add a list of dependencies that will be added to all the path operations in the router and will be executed/solved for each request made to them.

Tip

Note that, much like dependencies in path operation decorators, no value will be passed to your path operation function.

The end result is that the item paths are now:

    /items/
    /items/{item_id}

...as we intended.

    They will be marked with a list of tags that contain a single string "items".
        These "tags" are especially useful for the automatic interactive documentation systems (using OpenAPI).
    All of them will include the predefined responses.
    All these path operations will have the list of dependencies evaluated/executed before them.
        If you also declare dependencies in a specific path operation, they will be executed too.
        The router dependencies are executed first, then the dependencies in the decorator, and then the normal parameter dependencies.
        You can also add Security dependencies with scopes.

Tip

Having dependencies in the APIRouter can be used, for example, to require authentication for a whole group of path operations. Even if the dependencies are not added individually to each one of them.

Check

The prefix, tags, responses, and dependencies parameters are (as in many other cases) just a feature from FastAPI to help you avoid code duplication.
Import the dependenciesÂ¶

This code lives in the module app.routers.items, the file app/routers/items.py.

And we need to get the dependency function from the module app.dependencies, the file app/dependencies.py.

So we use a relative import with .. for the dependencies:
app/routers/items.py

from fastapi import APIRouter, Depends, HTTPException

from ..dependencies import get_token_header

router = APIRouter(
    prefix="/items",
    tags=["items"],
    dependencies=[Depends(get_token_header)],
    responses={404: {"description": "Not found"}},
)


fake_items_db = {"plumbus": {"name": "Plumbus"}, "gun": {"name": "Portal Gun"}}


@router.get("/")
async def read_items():
    return fake_items_db


@router.get("/{item_id}")
async def read_item(item_id: str):
    if item_id not in fake_items_db:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"name": fake_items_db[item_id]["name"], "item_id": item_id}


@router.put(
    "/{item_id}",
    tags=["custom"],
    responses={403: {"description": "Operation forbidden"}},
)
async def update_item(item_id: str):
    if item_id != "plumbus":
        raise HTTPException(
            status_code=403, detail="You can only update the item: plumbus"
        )
    return {"item_id": item_id, "name": "The great Plumbus"}

How relative imports workÂ¶

Tip

If you know perfectly how imports work, continue to the next section below.

A single dot ., like in:

from .dependencies import get_token_header

would mean:

    Starting in the same package that this module (the file app/routers/items.py) lives in (the directory app/routers/)...
    find the module dependencies (an imaginary file at app/routers/dependencies.py)...
    and from it, import the function get_token_header.

But that file doesn't exist, our dependencies are in a file at app/dependencies.py.

Remember how our app/file structure looks like:

The two dots .., like in:

from ..dependencies import get_token_header

mean:

    Starting in the same package that this module (the file app/routers/items.py) lives in (the directory app/routers/)...
    go to the parent package (the directory app/)...
    and in there, find the module dependencies (the file at app/dependencies.py)...
    and from it, import the function get_token_header.

That works correctly! ğŸ‰

The same way, if we had used three dots ..., like in:

from ...dependencies import get_token_header

that would mean:

    Starting in the same package that this module (the file app/routers/items.py) lives in (the directory app/routers/)...
    go to the parent package (the directory app/)...
    then go to the parent of that package (there's no parent package, app is the top level ğŸ˜±)...
    and in there, find the module dependencies (the file at app/dependencies.py)...
    and from it, import the function get_token_header.

That would refer to some package above app/, with its own file __init__.py, etc. But we don't have that. So, that would throw an error in our example. ğŸš¨

But now you know how it works, so you can use relative imports in your own apps no matter how complex they are. ğŸ¤“
Add some custom tags, responses, and dependenciesÂ¶

We are not adding the prefix /items nor the tags=["items"] to each path operation because we added them to the APIRouter.

But we can still add more tags that will be applied to a specific path operation, and also some extra responses specific to that path operation:
app/routers/items.py

from fastapi import APIRouter, Depends, HTTPException

from ..dependencies import get_token_header

router = APIRouter(
    prefix="/items",
    tags=["items"],
    dependencies=[Depends(get_token_header)],
    responses={404: {"description": "Not found"}},
)


fake_items_db = {"plumbus": {"name": "Plumbus"}, "gun": {"name": "Portal Gun"}}


@router.get("/")
async def read_items():
    return fake_items_db


@router.get("/{item_id}")
async def read_item(item_id: str):
    if item_id not in fake_items_db:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"name": fake_items_db[item_id]["name"], "item_id": item_id}


@router.put(
    "/{item_id}",
    tags=["custom"],
    responses={403: {"description": "Operation forbidden"}},
)
async def update_item(item_id: str):
    if item_id != "plumbus":
        raise HTTPException(
            status_code=403, detail="You can only update the item: plumbus"
        )
    return {"item_id": item_id, "name": "The great Plumbus"}

Tip

This last path operation will have the combination of tags: ["items", "custom"].

And it will also have both responses in the documentation, one for 404 and one for 403.
The main FastAPIÂ¶

Now, let's see the module at app/main.py.

Here's where you import and use the class FastAPI.

This will be the main file in your application that ties everything together.

And as most of your logic will now live in its own specific module, the main file will be quite simple.
Import FastAPIÂ¶

You import and create a FastAPI class as normally.

And we can even declare global dependencies that will be combined with the dependencies for each APIRouter:
app/main.py

from fastapi import Depends, FastAPI

from .dependencies import get_query_token, get_token_header
from .internal import admin
from .routers import items, users

app = FastAPI(dependencies=[Depends(get_query_token)])


app.include_router(users.router)
app.include_router(items.router)
app.include_router(
    admin.router,
    prefix="/admin",
    tags=["admin"],
    dependencies=[Depends(get_token_header)],
    responses={418: {"description": "I'm a teapot"}},
)


@app.get("/")
async def root():
    return {"message": "Hello Bigger Applications!"}

Import the APIRouterÂ¶

Now we import the other submodules that have APIRouters:
app/main.py

from fastapi import Depends, FastAPI

from .dependencies import get_query_token, get_token_header
from .internal import admin
from .routers import items, users

app = FastAPI(dependencies=[Depends(get_query_token)])


app.include_router(users.router)
app.include_router(items.router)
app.include_router(
    admin.router,
    prefix="/admin",
    tags=["admin"],
    dependencies=[Depends(get_token_header)],
    responses={418: {"description": "I'm a teapot"}},
)


@app.get("/")
async def root():
    return {"message": "Hello Bigger Applications!"}

As the files app/routers/users.py and app/routers/items.py are submodules that are part of the same Python package app, we can use a single dot . to import them using "relative imports".
How the importing worksÂ¶

The section:

from .routers import items, users

means:

    Starting in the same package that this module (the file app/main.py) lives in (the directory app/)...
    look for the subpackage routers (the directory at app/routers/)...
    and from it, import the submodule items (the file at app/routers/items.py) and users (the file at app/routers/users.py)...

The module items will have a variable router (items.router). This is the same one we created in the file app/routers/items.py, it's an APIRouter object.

And then we do the same for the module users.

We could also import them like:

from app.routers import items, users

Info

The first version is a "relative import":

from .routers import items, users

The second version is an "absolute import":

from app.routers import items, users

To learn more about Python Packages and Modules, read the official Python documentation about Modules.
Avoid name collisionsÂ¶

We are importing the submodule items directly, instead of importing just its variable router.

This is because we also have another variable named router in the submodule users.

If we had imported one after the other, like:

from .routers.items import router
from .routers.users import router

the router from users would overwrite the one from items and we wouldn't be able to use them at the same time.

So, to be able to use both of them in the same file, we import the submodules directly:
app/main.py

from fastapi import Depends, FastAPI

from .dependencies import get_query_token, get_token_header
from .internal import admin
from .routers import items, users

app = FastAPI(dependencies=[Depends(get_query_token)])


app.include_router(users.router)
app.include_router(items.router)
app.include_router(
    admin.router,
    prefix="/admin",
    tags=["admin"],
    dependencies=[Depends(get_token_header)],
    responses={418: {"description": "I'm a teapot"}},
)


@app.get("/")
async def root():
    return {"message": "Hello Bigger Applications!"}

Include the APIRouters for users and itemsÂ¶

Now, let's include the routers from the submodules users and items:
app/main.py

from fastapi import Depends, FastAPI

from .dependencies import get_query_token, get_token_header
from .internal import admin
from .routers import items, users

app = FastAPI(dependencies=[Depends(get_query_token)])


app.include_router(users.router)
app.include_router(items.router)
app.include_router(
    admin.router,
    prefix="/admin",
    tags=["admin"],
    dependencies=[Depends(get_token_header)],
    responses={418: {"description": "I'm a teapot"}},
)


@app.get("/")
async def root():
    return {"message": "Hello Bigger Applications!"}

Info

users.router contains the APIRouter inside of the file app/routers/users.py.

And items.router contains the APIRouter inside of the file app/routers/items.py.

With app.include_router() we can add each APIRouter to the main FastAPI application.

It will include all the routes from that router as part of it.

Technical Details

It will actually internally create a path operation for each path operation that was declared in the APIRouter.

So, behind the scenes, it will actually work as if everything was the same single app.

Check

You don't have to worry about performance when including routers.

This will take microseconds and will only happen at startup.

So it won't affect performance. âš¡
Include an APIRouter with a custom prefix, tags, responses, and dependenciesÂ¶

Now, let's imagine your organization gave you the app/internal/admin.py file.

It contains an APIRouter with some admin path operations that your organization shares between several projects.

For this example it will be super simple. But let's say that because it is shared with other projects in the organization, we cannot modify it and add a prefix, dependencies, tags, etc. directly to the APIRouter:
app/internal/admin.py

from fastapi import APIRouter

router = APIRouter()


@router.post("/")
async def update_admin():
    return {"message": "Admin getting schwifty"}

But we still want to set a custom prefix when including the APIRouter so that all its path operations start with /admin, we want to secure it with the dependencies we already have for this project, and we want to include tags and responses.

We can declare all that without having to modify the original APIRouter by passing those parameters to app.include_router():
app/main.py

from fastapi import Depends, FastAPI

from .dependencies import get_query_token, get_token_header
from .internal import admin
from .routers import items, users

app = FastAPI(dependencies=[Depends(get_query_token)])


app.include_router(users.router)
app.include_router(items.router)
app.include_router(
    admin.router,
    prefix="/admin",
    tags=["admin"],
    dependencies=[Depends(get_token_header)],
    responses={418: {"description": "I'm a teapot"}},
)


@app.get("/")
async def root():
    return {"message": "Hello Bigger Applications!"}

That way, the original APIRouter will stay unmodified, so we can still share that same app/internal/admin.py file with other projects in the organization.

The result is that in our app, each of the path operations from the admin module will have:

    The prefix /admin.
    The tag admin.
    The dependency get_token_header.
    The response 418. ğŸµ

But that will only affect that APIRouter in our app, not in any other code that uses it.

So, for example, other projects could use the same APIRouter with a different authentication method.
Include a path operationÂ¶

We can also add path operations directly to the FastAPI app.

Here we do it... just to show that we can ğŸ¤·:
app/main.py

from fastapi import Depends, FastAPI

from .dependencies import get_query_token, get_token_header
from .internal import admin
from .routers import items, users

app = FastAPI(dependencies=[Depends(get_query_token)])


app.include_router(users.router)
app.include_router(items.router)
app.include_router(
    admin.router,
    prefix="/admin",
    tags=["admin"],
    dependencies=[Depends(get_token_header)],
    responses={418: {"description": "I'm a teapot"}},
)


@app.get("/")
async def root():
    return {"message": "Hello Bigger Applications!"}

and it will work correctly, together with all the other path operations added with app.include_router().

Very Technical Details

Note: this is a very technical detail that you probably can just skip.

The APIRouters are not "mounted", they are not isolated from the rest of the application.

This is because we want to include their path operations in the OpenAPI schema and the user interfaces.

As we cannot just isolate them and "mount" them independently of the rest, the path operations are "cloned" (re-created), not included directly.
Check the automatic API docsÂ¶

Now, run your app:




And open the docs at http://127.0.0.1:8000/docs.

You will see the automatic API docs, including the paths from all the submodules, using the correct paths (and prefixes) and the correct tags:

Include the same router multiple times with different prefixÂ¶

You can also use .include_router() multiple times with the same router using different prefixes.

This could be useful, for example, to expose the same API under different prefixes, e.g. /api/v1 and /api/latest.

This is an advanced usage that you might not really need, but it's there in case you do.
Include an APIRouter in anotherÂ¶

The same way you can include an APIRouter in a FastAPI application, you can include an APIRouter in another APIRouter using:

router.include_router(other_router)

Make sure you do it before including router in the FastAPI app, so that the path operations from other_router are also included.
Previous
SQL (Relational) Databases
Next
Background Tasks
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Background Tasks

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
            Security
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Using BackgroundTasks
    Create a task function
    Add the background task
    Dependency Injection
    Technical Details
    Caveat
    Recap

    FastAPI
    Learn
    Tutorial - User Guide

Background TasksÂ¶

You can define background tasks to be run after returning a response.

This is useful for operations that need to happen after a request, but that the client doesn't really have to be waiting for the operation to complete before receiving the response.

This includes, for example:

    Email notifications sent after performing an action:
        As connecting to an email server and sending an email tends to be "slow" (several seconds), you can return the response right away and send the email notification in the background.
    Processing data:
        For example, let's say you receive a file that must go through a slow process, you can return a response of "Accepted" (HTTP 202) and process the file in the background.

Using BackgroundTasksÂ¶

First, import BackgroundTasks and define a parameter in your path operation function with a type declaration of BackgroundTasks:
Python 3.8+

from fastapi import BackgroundTasks, FastAPI

app = FastAPI()


def write_notification(email: str, message=""):
    with open("log.txt", mode="w") as email_file:
        content = f"notification for {email}: {message}"
        email_file.write(content)


@app.post("/send-notification/{email}")
async def send_notification(email: str, background_tasks: BackgroundTasks):
    background_tasks.add_task(write_notification, email, message="some notification")
    return {"message": "Notification sent in the background"}

FastAPI will create the object of type BackgroundTasks for you and pass it as that parameter.
Create a task functionÂ¶

Create a function to be run as the background task.

It is just a standard function that can receive parameters.

It can be an async def or normal def function, FastAPI will know how to handle it correctly.

In this case, the task function will write to a file (simulating sending an email).

And as the write operation doesn't use async and await, we define the function with normal def:
Python 3.8+

from fastapi import BackgroundTasks, FastAPI

app = FastAPI()


def write_notification(email: str, message=""):
    with open("log.txt", mode="w") as email_file:
        content = f"notification for {email}: {message}"
        email_file.write(content)


@app.post("/send-notification/{email}")
async def send_notification(email: str, background_tasks: BackgroundTasks):
    background_tasks.add_task(write_notification, email, message="some notification")
    return {"message": "Notification sent in the background"}

Add the background taskÂ¶

Inside of your path operation function, pass your task function to the background tasks object with the method .add_task():
Python 3.8+

from fastapi import BackgroundTasks, FastAPI

app = FastAPI()


def write_notification(email: str, message=""):
    with open("log.txt", mode="w") as email_file:
        content = f"notification for {email}: {message}"
        email_file.write(content)


@app.post("/send-notification/{email}")
async def send_notification(email: str, background_tasks: BackgroundTasks):
    background_tasks.add_task(write_notification, email, message="some notification")
    return {"message": "Notification sent in the background"}

.add_task() receives as arguments:

    A task function to be run in the background (write_notification).
    Any sequence of arguments that should be passed to the task function in order (email).
    Any keyword arguments that should be passed to the task function (message="some notification").

Dependency InjectionÂ¶

Using BackgroundTasks also works with the dependency injection system, you can declare a parameter of type BackgroundTasks at multiple levels: in a path operation function, in a dependency (dependable), in a sub-dependency, etc.

FastAPI knows what to do in each case and how to reuse the same object, so that all the background tasks are merged together and are run in the background afterwards:
Python 3.10+

from typing import Annotated

from fastapi import BackgroundTasks, Depends, FastAPI

app = FastAPI()


def write_log(message: str):
    with open("log.txt", mode="a") as log:
        log.write(message)


def get_query(background_tasks: BackgroundTasks, q: str | None = None):
    if q:
        message = f"found query: {q}\n"
        background_tasks.add_task(write_log, message)
    return q


@app.post("/send-notification/{email}")
async def send_notification(
    email: str, background_tasks: BackgroundTasks, q: Annotated[str, Depends(get_query)]
):
    message = f"message to {email}\n"
    background_tasks.add_task(write_log, message)
    return {"message": "Message sent"}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

In this example, the messages will be written to the log.txt file after the response is sent.

If there was a query in the request, it will be written to the log in a background task.

And then another background task generated at the path operation function will write a message using the email path parameter.
Technical DetailsÂ¶

The class BackgroundTasks comes directly from starlette.background.

It is imported/included directly into FastAPI so that you can import it from fastapi and avoid accidentally importing the alternative BackgroundTask (without the s at the end) from starlette.background.

By only using BackgroundTasks (and not BackgroundTask), it's then possible to use it as a path operation function parameter and have FastAPI handle the rest for you, just like when using the Request object directly.

It's still possible to use BackgroundTask alone in FastAPI, but you have to create the object in your code and return a Starlette Response including it.

You can see more details in Starlette's official docs for Background Tasks.
CaveatÂ¶

If you need to perform heavy background computation and you don't necessarily need it to be run by the same process (for example, you don't need to share memory, variables, etc), you might benefit from using other bigger tools like Celery.

They tend to require more complex configurations, a message/job queue manager, like RabbitMQ or Redis, but they allow you to run background tasks in multiple processes, and especially, in multiple servers.

But if you need to access variables and objects from the same FastAPI app, or you need to perform small background tasks (like sending an email notification), you can simply just use BackgroundTasks.
RecapÂ¶

Import and use BackgroundTasks with parameters in path operation functions and dependencies to add background tasks.
Previous
Bigger Applications - Multiple Files
Next
Metadata and Docs URLs
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
Metadata and Docs URLs

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
            Security
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Metadata for API
    License identifier
    Metadata for tags
        Create metadata for tags
        Use your tags
        Check the docs
        Order of tags
    OpenAPI URL
    Docs URLs

    FastAPI
    Learn
    Tutorial - User Guide

Metadata and Docs URLsÂ¶

You can customize several metadata configurations in your FastAPI application.
Metadata for APIÂ¶

You can set the following fields that are used in the OpenAPI specification and the automatic API docs UIs:
Parameter 	Type 	Description
title 	str 	The title of the API.
summary 	str 	A short summary of the API. Available since OpenAPI 3.1.0, FastAPI 0.99.0.
description 	str 	A short description of the API. It can use Markdown.
version 	string 	The version of the API. This is the version of your own application, not of OpenAPI. For example 2.5.0.
terms_of_service 	str 	A URL to the Terms of Service for the API. If provided, this has to be a URL.
contact 	dict 	The contact information for the exposed API. It can contain several fields.
contact fields
		
		
		
		
license_info 	dict 	The license information for the exposed API. It can contain several fields.
license_info fields
		
		
		
		

You can set them as follows:
Python 3.8+

from fastapi import FastAPI

description = """
ChimichangApp API helps you do awesome stuff. ğŸš€

## Items

You can **read items**.

## Users

You will be able to:

* **Create users** (_not implemented_).
* **Read users** (_not implemented_).
"""

app = FastAPI(
    title="ChimichangApp",
    description=description,
    summary="Deadpool's favorite app. Nuff said.",
    version="0.0.1",
    terms_of_service="http://example.com/terms/",
    contact={
        "name": "Deadpoolio the Amazing",
        "url": "http://x-force.example.com/contact/",
        "email": "dp@x-force.example.com",
    },
    license_info={
        "name": "Apache 2.0",
        "url": "https://www.apache.org/licenses/LICENSE-2.0.html",
    },
)


@app.get("/items/")
async def read_items():
    return [{"name": "Katana"}]

Tip

You can write Markdown in the description field and it will be rendered in the output.

With this configuration, the automatic API docs would look like:

License identifierÂ¶

Since OpenAPI 3.1.0 and FastAPI 0.99.0, you can also set the license_info with an identifier instead of a url.

For example:
Python 3.8+

from fastapi import FastAPI

description = """
ChimichangApp API helps you do awesome stuff. ğŸš€

## Items

You can **read items**.

## Users

You will be able to:

* **Create users** (_not implemented_).
* **Read users** (_not implemented_).
"""

app = FastAPI(
    title="ChimichangApp",
    description=description,
    summary="Deadpool's favorite app. Nuff said.",
    version="0.0.1",
    terms_of_service="http://example.com/terms/",
    contact={
        "name": "Deadpoolio the Amazing",
        "url": "http://x-force.example.com/contact/",
        "email": "dp@x-force.example.com",
    },
    license_info={
        "name": "Apache 2.0",
        "identifier": "MIT",
    },
)


@app.get("/items/")
async def read_items():
    return [{"name": "Katana"}]

Metadata for tagsÂ¶

You can also add additional metadata for the different tags used to group your path operations with the parameter openapi_tags.

It takes a list containing one dictionary for each tag.

Each dictionary can contain:

    name (required): a str with the same tag name you use in the tags parameter in your path operations and APIRouters.
    description: a str with a short description for the tag. It can have Markdown and will be shown in the docs UI.
    externalDocs: a dict describing external documentation with:
        description: a str with a short description for the external docs.
        url (required): a str with the URL for the external documentation.

Create metadata for tagsÂ¶

Let's try that in an example with tags for users and items.

Create metadata for your tags and pass it to the openapi_tags parameter:
Python 3.8+

from fastapi import FastAPI

tags_metadata = [
    {
        "name": "users",
        "description": "Operations with users. The **login** logic is also here.",
    },
    {
        "name": "items",
        "description": "Manage items. So _fancy_ they have their own docs.",
        "externalDocs": {
            "description": "Items external docs",
            "url": "https://fastapi.tiangolo.com/",
        },
    },
]

app = FastAPI(openapi_tags=tags_metadata)


@app.get("/users/", tags=["users"])
async def get_users():
    return [{"name": "Harry"}, {"name": "Ron"}]


@app.get("/items/", tags=["items"])
async def get_items():
    return [{"name": "wand"}, {"name": "flying broom"}]

Notice that you can use Markdown inside of the descriptions, for example "login" will be shown in bold (login) and "fancy" will be shown in italics (fancy).

Tip

You don't have to add metadata for all the tags that you use.
Use your tagsÂ¶

Use the tags parameter with your path operations (and APIRouters) to assign them to different tags:
Python 3.8+

from fastapi import FastAPI

tags_metadata = [
    {
        "name": "users",
        "description": "Operations with users. The **login** logic is also here.",
    },
    {
        "name": "items",
        "description": "Manage items. So _fancy_ they have their own docs.",
        "externalDocs": {
            "description": "Items external docs",
            "url": "https://fastapi.tiangolo.com/",
        },
    },
]

app = FastAPI(openapi_tags=tags_metadata)


@app.get("/users/", tags=["users"])
async def get_users():
    return [{"name": "Harry"}, {"name": "Ron"}]


@app.get("/items/", tags=["items"])
async def get_items():
    return [{"name": "wand"}, {"name": "flying broom"}]

Info

Read more about tags in Path Operation Configuration.
Check the docsÂ¶

Now, if you check the docs, they will show all the additional metadata:

Order of tagsÂ¶

The order of each tag metadata dictionary also defines the order shown in the docs UI.

For example, even though users would go after items in alphabetical order, it is shown before them, because we added their metadata as the first dictionary in the list.
OpenAPI URLÂ¶

By default, the OpenAPI schema is served at /openapi.json.

But you can configure it with the parameter openapi_url.

For example, to set it to be served at /api/v1/openapi.json:
Python 3.8+

from fastapi import FastAPI

app = FastAPI(openapi_url="/api/v1/openapi.json")


@app.get("/items/")
async def read_items():
    return [{"name": "Foo"}]

If you want to disable the OpenAPI schema completely you can set openapi_url=None, that will also disable the documentation user interfaces that use it.
Docs URLsÂ¶

You can configure the two documentation user interfaces included:

    Swagger UI: served at /docs.
        You can set its URL with the parameter docs_url.
        You can disable it by setting docs_url=None.
    ReDoc: served at /redoc.
        You can set its URL with the parameter redoc_url.
        You can disable it by setting redoc_url=None.

For example, to set Swagger UI to be served at /documentation and disable ReDoc:
Python 3.8+

from fastapi import FastAPI

app = FastAPI(docs_url="/documentation", redoc_url=None)


@app.get("/items/")
async def read_items():
    return [{"name": "Foo"}]

Previous
Background Tasks
Next
Static Files
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
Static Files

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
            Security
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Use StaticFiles
        What is "Mounting"
    Details
    More info

    FastAPI
    Learn
    Tutorial - User Guide

Static FilesÂ¶

You can serve static files automatically from a directory using StaticFiles.
Use StaticFilesÂ¶

    Import StaticFiles.
    "Mount" a StaticFiles() instance in a specific path.

Python 3.8+

from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles

app = FastAPI()

app.mount("/static", StaticFiles(directory="static"), name="static")

Technical Details

You could also use from starlette.staticfiles import StaticFiles.

FastAPI provides the same starlette.staticfiles as fastapi.staticfiles just as a convenience for you, the developer. But it actually comes directly from Starlette.
What is "Mounting"Â¶

"Mounting" means adding a complete "independent" application in a specific path, that then takes care of handling all the sub-paths.

This is different from using an APIRouter as a mounted application is completely independent. The OpenAPI and docs from your main application won't include anything from the mounted application, etc.

You can read more about this in the Advanced User Guide.
DetailsÂ¶

The first "/static" refers to the sub-path this "sub-application" will be "mounted" on. So, any path that starts with "/static" will be handled by it.

The directory="static" refers to the name of the directory that contains your static files.

The name="static" gives it a name that can be used internally by FastAPI.

All these parameters can be different than "static", adjust them with the needs and specific details of your own application.
More infoÂ¶

For more details and options check Starlette's docs about Static Files.
Previous
Metadata and Docs URLs
Next
Testing
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Testing

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
            Security
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Using TestClient
    Separating tests
        FastAPI app file
        Testing file
    Testing: extended example
        Extended FastAPI app file
        Extended testing file
    Run it

    FastAPI
    Learn
    Tutorial - User Guide

TestingÂ¶

Thanks to Starlette, testing FastAPI applications is easy and enjoyable.

It is based on HTTPX, which in turn is designed based on Requests, so it's very familiar and intuitive.

With it, you can use pytest directly with FastAPI.
Using TestClientÂ¶

Info

To use TestClient, first install httpx.

Make sure you create a virtual environment, activate it, and then install it, for example:

$ pip install httpx

Import TestClient.

Create a TestClient by passing your FastAPI application to it.

Create functions with a name that starts with test_ (this is standard pytest conventions).

Use the TestClient object the same way as you do with httpx.

Write simple assert statements with the standard Python expressions that you need to check (again, standard pytest).
Python 3.8+

from fastapi import FastAPI
from fastapi.testclient import TestClient

app = FastAPI()


@app.get("/")
async def read_main():
    return {"msg": "Hello World"}


client = TestClient(app)


def test_read_main():
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"msg": "Hello World"}

Tip

Notice that the testing functions are normal def, not async def.

And the calls to the client are also normal calls, not using await.

This allows you to use pytest directly without complications.

Technical Details

You could also use from starlette.testclient import TestClient.

FastAPI provides the same starlette.testclient as fastapi.testclient just as a convenience for you, the developer. But it comes directly from Starlette.

Tip

If you want to call async functions in your tests apart from sending requests to your FastAPI application (e.g. asynchronous database functions), have a look at the Async Tests in the advanced tutorial.
Separating testsÂ¶

In a real application, you probably would have your tests in a different file.

And your FastAPI application might also be composed of several files/modules, etc.
FastAPI app fileÂ¶

Let's say you have a file structure as described in Bigger Applications:

.
â”œâ”€â”€ app
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ main.py

In the file main.py you have your FastAPI app:
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/")
async def read_main():
    return {"msg": "Hello World"}

Testing fileÂ¶

Then you could have a file test_main.py with your tests. It could live on the same Python package (the same directory with a __init__.py file):

.
â”œâ”€â”€ app
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py
â”‚   â””â”€â”€ test_main.py

Because this file is in the same package, you can use relative imports to import the object app from the main module (main.py):
Python 3.8+

from fastapi.testclient import TestClient

from .main import app

client = TestClient(app)


def test_read_main():
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"msg": "Hello World"}

...and have the code for the tests just like before.
Testing: extended exampleÂ¶

Now let's extend this example and add more details to see how to test different parts.
Extended FastAPI app fileÂ¶

Let's continue with the same file structure as before:

.
â”œâ”€â”€ app
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py
â”‚   â””â”€â”€ test_main.py

Let's say that now the file main.py with your FastAPI app has some other path operations.

It has a GET operation that could return an error.

It has a POST operation that could return several errors.

Both path operations require an X-Token header.
Python 3.10+
Python 3.9+
Python 3.8+
Python 3.10+ non-Annotated
Python 3.8+ non-Annotated

from typing import Annotated

from fastapi import FastAPI, Header, HTTPException
from pydantic import BaseModel

fake_secret_token = "coneofsilence"

fake_db = {
    "foo": {"id": "foo", "title": "Foo", "description": "There goes my hero"},
    "bar": {"id": "bar", "title": "Bar", "description": "The bartenders"},
}

app = FastAPI()


class Item(BaseModel):
    id: str
    title: str
    description: str | None = None


@app.get("/items/{item_id}", response_model=Item)
async def read_main(item_id: str, x_token: Annotated[str, Header()]):
    if x_token != fake_secret_token:
        raise HTTPException(status_code=400, detail="Invalid X-Token header")
    if item_id not in fake_db:
        raise HTTPException(status_code=404, detail="Item not found")
    return fake_db[item_id]


@app.post("/items/", response_model=Item)
async def create_item(item: Item, x_token: Annotated[str, Header()]):
    if x_token != fake_secret_token:
        raise HTTPException(status_code=400, detail="Invalid X-Token header")
    if item.id in fake_db:
        raise HTTPException(status_code=409, detail="Item already exists")
    fake_db[item.id] = item
    return item

Extended testing fileÂ¶

You could then update test_main.py with the extended tests:
Python 3.8+

from fastapi.testclient import TestClient

from .main import app

client = TestClient(app)


def test_read_item():
    response = client.get("/items/foo", headers={"X-Token": "coneofsilence"})
    assert response.status_code == 200
    assert response.json() == {
        "id": "foo",
        "title": "Foo",
        "description": "There goes my hero",
    }


def test_read_item_bad_token():
    response = client.get("/items/foo", headers={"X-Token": "hailhydra"})
    assert response.status_code == 400
    assert response.json() == {"detail": "Invalid X-Token header"}


def test_read_nonexistent_item():
    response = client.get("/items/baz", headers={"X-Token": "coneofsilence"})
    assert response.status_code == 404
    assert response.json() == {"detail": "Item not found"}


def test_create_item():
    response = client.post(
        "/items/",
        headers={"X-Token": "coneofsilence"},
        json={"id": "foobar", "title": "Foo Bar", "description": "The Foo Barters"},
    )
    assert response.status_code == 200
    assert response.json() == {
        "id": "foobar",
        "title": "Foo Bar",
        "description": "The Foo Barters",
    }


def test_create_item_bad_token():
    response = client.post(
        "/items/",
        headers={"X-Token": "hailhydra"},
        json={"id": "bazz", "title": "Bazz", "description": "Drop the bazz"},
    )
    assert response.status_code == 400
    assert response.json() == {"detail": "Invalid X-Token header"}


def test_create_existing_item():
    response = client.post(
        "/items/",
        headers={"X-Token": "coneofsilence"},
        json={
            "id": "foo",
            "title": "The Foo ID Stealers",
            "description": "There goes my stealer",
        },
    )
    assert response.status_code == 409
    assert response.json() == {"detail": "Item already exists"}

Whenever you need the client to pass information in the request and you don't know how to, you can search (Google) how to do it in httpx, or even how to do it with requests, as HTTPX's design is based on Requests' design.

Then you just do the same in your tests.

E.g.:

    To pass a path or query parameter, add it to the URL itself.
    To pass a JSON body, pass a Python object (e.g. a dict) to the parameter json.
    If you need to send Form Data instead of JSON, use the data parameter instead.
    To pass headers, use a dict in the headers parameter.
    For cookies, a dict in the cookies parameter.

For more information about how to pass data to the backend (using httpx or the TestClient) check the HTTPX documentation.

Info

Note that the TestClient receives data that can be converted to JSON, not Pydantic models.

If you have a Pydantic model in your test and you want to send its data to the application during testing, you can use the jsonable_encoder described in JSON Compatible Encoder.
Run itÂ¶

After that, you just need to install pytest.

Make sure you create a virtual environment, activate it, and then install it, for example:



It will detect the files and tests automatically, execute them, and report the results back to you.

Run the tests with:













Previous
Static Files
Next
Debugging
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs




Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Debugging

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
            First Steps
            Path Parameters
            Query Parameters
            Request Body
            Query Parameters and String Validations
            Path Parameters and Numeric Validations
            Query Parameter Models
            Body - Multiple Parameters
            Body - Fields
            Body - Nested Models
            Declare Request Example Data
            Extra Data Types
            Cookie Parameters
            Header Parameters
            Cookie Parameter Models
            Header Parameter Models
            Response Model - Return Type
            Extra Models
            Response Status Code
            Form Data
            Form Models
            Request Files
            Request Forms and Files
            Handling Errors
            Path Operation Configuration
            JSON Compatible Encoder
            Body - Updates
            Dependencies
            Security
            Middleware
            CORS (Cross-Origin Resource Sharing)
            SQL (Relational) Databases
            Bigger Applications - Multiple Files
            Background Tasks
            Metadata and Docs URLs
            Static Files
            Testing
            Debugging
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Call uvicorn
        About __name__ == "__main__"
            More details
    Run your code with your debugger

    FastAPI
    Learn
    Tutorial - User Guide

DebuggingÂ¶

You can connect the debugger in your editor, for example with Visual Studio Code or PyCharm.
Call uvicornÂ¶

In your FastAPI application, import and run uvicorn directly:
Python 3.8+

import uvicorn
from fastapi import FastAPI

app = FastAPI()


@app.get("/")
def root():
    a = "a"
    b = "b" + a
    return {"hello world": b}


if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)

About __name__ == "__main__"Â¶

The main purpose of the __name__ == "__main__" is to have some code that is executed when your file is called with:


but is not called when another file imports it, like in:

from myapp import app

More detailsÂ¶

Let's say your file is named myapp.py.

If you run it with:


then the internal variable __name__ in your file, created automatically by Python, will have as value the string "__main__".

So, the section:

    uvicorn.run(app, host="0.0.0.0", port=8000)

will run.

This won't happen if you import that module (file).

So, if you have another file importer.py with:

from myapp import app

# Some more code

in that case, the automatically created variable __name__ inside of myapp.py will not have the value "__main__".

So, the line:

    uvicorn.run(app, host="0.0.0.0", port=8000)

will not be executed.

Info

For more information, check the official Python docs.
Run your code with your debuggerÂ¶

Because you are running the Uvicorn server directly from your code, you can call your Python program (your FastAPI application) directly from the debugger.

For example, in Visual Studio Code, you can:

    Go to the "Debug" panel.
    "Add configuration...".
    Select "Python"
    Run the debugger with the option "Python: Current File (Integrated Terminal)".

It will then start the server with your FastAPI code, stop at your breakpoints, etc.

Here's how it might look:

If you use Pycharm, you can:

    Open the "Run" menu.
    Select the option "Debug...".
    Then a context menu shows up.
    Select the file to debug (in this case, main.py).

It will then start the server with your FastAPI code, stop at your breakpoints, etc.

Here's how it might look:

Previous
Testing
Next
Advanced User Guide
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
Advanced User Guide

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Additional Features
    Read the Tutorial first

    FastAPI
    Learn
    Advanced User Guide

Advanced User GuideÂ¶
Additional FeaturesÂ¶

The main Tutorial - User Guide should be enough to give you a tour through all the main features of FastAPI.

In the next sections you will see other options, configurations, and additional features.

Tip

The next sections are not necessarily "advanced".

And it's possible that for your use case, the solution is in one of them.
Read the Tutorial firstÂ¶

You could still use most of the features in FastAPI with the knowledge from the main Tutorial - User Guide.

And the next sections assume you already read it, and assume that you know those main ideas.
Previous
Debugging
Next
Path Operation Advanced Configuration
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs




Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
Path Operation Advanced Configuration

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    OpenAPI operationId
        Using the path operation function name as the operationId
    Exclude from OpenAPI
    Advanced description from docstring
    Additional Responses
    OpenAPI Extra
        OpenAPI Extensions
        Custom OpenAPI path operation schema
        Custom OpenAPI content type

    FastAPI
    Learn
    Advanced User Guide

Path Operation Advanced ConfigurationÂ¶
OpenAPI operationIdÂ¶

Warning

If you are not an "expert" in OpenAPI, you probably don't need this.

You can set the OpenAPI operationId to be used in your path operation with the parameter operation_id.

You would have to make sure that it is unique for each operation.
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/items/", operation_id="some_specific_id_you_define")
async def read_items():
    return [{"item_id": "Foo"}]

Using the path operation function name as the operationIdÂ¶

If you want to use your APIs' function names as operationIds, you can iterate over all of them and override each path operation's operation_id using their APIRoute.name.

You should do it after adding all your path operations.
Python 3.8+

from fastapi import FastAPI
from fastapi.routing import APIRoute

app = FastAPI()


@app.get("/items/")
async def read_items():
    return [{"item_id": "Foo"}]


def use_route_names_as_operation_ids(app: FastAPI) -> None:
    """
    Simplify operation IDs so that generated API clients have simpler function
    names.

    Should be called only after all routes have been added.
    """
    for route in app.routes:
        if isinstance(route, APIRoute):
            route.operation_id = route.name  # in this case, 'read_items'


use_route_names_as_operation_ids(app)

Tip

If you manually call app.openapi(), you should update the operationIds before that.

Warning

If you do this, you have to make sure each one of your path operation functions has a unique name.

Even if they are in different modules (Python files).
Exclude from OpenAPIÂ¶

To exclude a path operation from the generated OpenAPI schema (and thus, from the automatic documentation systems), use the parameter include_in_schema and set it to False:
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/items/", include_in_schema=False)
async def read_items():
    return [{"item_id": "Foo"}]

Advanced description from docstringÂ¶

You can limit the lines used from the docstring of a path operation function for OpenAPI.

Adding an \f (an escaped "form feed" character) causes FastAPI to truncate the output used for OpenAPI at this point.

It won't show up in the documentation, but other tools (such as Sphinx) will be able to use the rest.
Python 3.8+

from typing import Set, Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None
    tags: Set[str] = set()


@app.post("/items/", response_model=Item, summary="Create an item")
async def create_item(item: Item):
    """
    Create an item with all the information:

    - **name**: each item must have a name
    - **description**: a long description
    - **price**: required
    - **tax**: if the item doesn't have tax, you can omit this
    - **tags**: a set of unique tag strings for this item
    \f
    :param item: User input.
    """
    return item

Additional ResponsesÂ¶

You probably have seen how to declare the response_model and status_code for a path operation.

That defines the metadata about the main response of a path operation.

You can also declare additional responses with their models, status codes, etc.

There's a whole chapter here in the documentation about it, you can read it at Additional Responses in OpenAPI.
OpenAPI ExtraÂ¶

When you declare a path operation in your application, FastAPI automatically generates the relevant metadata about that path operation to be included in the OpenAPI schema.

Technical details

In the OpenAPI specification it is called the Operation Object.

It has all the information about the path operation and is used to generate the automatic documentation.

It includes the tags, parameters, requestBody, responses, etc.

This path operation-specific OpenAPI schema is normally generated automatically by FastAPI, but you can also extend it.

Tip

This is a low level extension point.

If you only need to declare additional responses, a more convenient way to do it is with Additional Responses in OpenAPI.

You can extend the OpenAPI schema for a path operation using the parameter openapi_extra.
OpenAPI ExtensionsÂ¶

This openapi_extra can be helpful, for example, to declare OpenAPI Extensions:
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/items/", openapi_extra={"x-aperture-labs-portal": "blue"})
async def read_items():
    return [{"item_id": "portal-gun"}]

If you open the automatic API docs, your extension will show up at the bottom of the specific path operation.

And if you see the resulting OpenAPI (at /openapi.json in your API), you will see your extension as part of the specific path operation too:

{
    "openapi": "3.1.0",
    "info": {
        "title": "FastAPI",
        "version": "0.1.0"
    },
    "paths": {
        "/items/": {
            "get": {
                "summary": "Read Items",
                "operationId": "read_items_items__get",
                "responses": {
                    "200": {
                        "description": "Successful Response",
                        "content": {
                            "application/json": {
                                "schema": {}
                            }
                        }
                    }
                },
                "x-aperture-labs-portal": "blue"
            }
        }
    }
}

Custom OpenAPI path operation schemaÂ¶

The dictionary in openapi_extra will be deeply merged with the automatically generated OpenAPI schema for the path operation.

So, you could add additional data to the automatically generated schema.

For example, you could decide to read and validate the request with your own code, without using the automatic features of FastAPI with Pydantic, but you could still want to define the request in the OpenAPI schema.

You could do that with openapi_extra:
Python 3.8+

from fastapi import FastAPI, Request

app = FastAPI()


def magic_data_reader(raw_body: bytes):
    return {
        "size": len(raw_body),
        "content": {
            "name": "Maaaagic",
            "price": 42,
            "description": "Just kiddin', no magic here. âœ¨",
        },
    }


@app.post(
    "/items/",
    openapi_extra={
        "requestBody": {
            "content": {
                "application/json": {
                    "schema": {
                        "required": ["name", "price"],
                        "type": "object",
                        "properties": {
                            "name": {"type": "string"},
                            "price": {"type": "number"},
                            "description": {"type": "string"},
                        },
                    }
                }
            },
            "required": True,
        },
    },
)
async def create_item(request: Request):
    raw_body = await request.body()
    data = magic_data_reader(raw_body)
    return data

In this example, we didn't declare any Pydantic model. In fact, the request body is not even parsed as JSON, it is read directly as bytes, and the function magic_data_reader() would be in charge of parsing it in some way.

Nevertheless, we can declare the expected schema for the request body.
Custom OpenAPI content typeÂ¶

Using this same trick, you could use a Pydantic model to define the JSON Schema that is then included in the custom OpenAPI schema section for the path operation.

And you could do this even if the data type in the request is not JSON.

For example, in this application we don't use FastAPI's integrated functionality to extract the JSON Schema from Pydantic models nor the automatic validation for JSON. In fact, we are declaring the request content type as YAML, not JSON:
Pydantic v2
Pydantic v1
Python 3.8+

from typing import List

import yaml
from fastapi import FastAPI, HTTPException, Request
from pydantic import BaseModel, ValidationError

app = FastAPI()


class Item(BaseModel):
    name: str
    tags: List[str]


@app.post(
    "/items/",
    openapi_extra={
        "requestBody": {
            "content": {"application/x-yaml": {"schema": Item.model_json_schema()}},
            "required": True,
        },
    },
)
async def create_item(request: Request):
    raw_body = await request.body()
    try:
        data = yaml.safe_load(raw_body)
    except yaml.YAMLError:
        raise HTTPException(status_code=422, detail="Invalid YAML")
    try:
        item = Item.model_validate(data)
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=e.errors(include_url=False))
    return item

Info

In Pydantic version 1 the method to get the JSON Schema for a model was called Item.schema(), in Pydantic version 2, the method is called Item.model_json_schema().

Nevertheless, although we are not using the default integrated functionality, we are still using a Pydantic model to manually generate the JSON Schema for the data that we want to receive in YAML.

Then we use the request directly, and extract the body as bytes. This means that FastAPI won't even try to parse the request payload as JSON.

And then in our code, we parse that YAML content directly, and then we are again using the same Pydantic model to validate the YAML content:
Pydantic v2
Pydantic v1
Python 3.8+

from typing import List

import yaml
from fastapi import FastAPI, HTTPException, Request
from pydantic import BaseModel, ValidationError

app = FastAPI()


class Item(BaseModel):
    name: str
    tags: List[str]


@app.post(
    "/items/",
    openapi_extra={
        "requestBody": {
            "content": {"application/x-yaml": {"schema": Item.model_json_schema()}},
            "required": True,
        },
    },
)
async def create_item(request: Request):
    raw_body = await request.body()
    try:
        data = yaml.safe_load(raw_body)
    except yaml.YAMLError:
        raise HTTPException(status_code=422, detail="Invalid YAML")
    try:
        item = Item.model_validate(data)
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=e.errors(include_url=False))
    return item

Info

In Pydantic version 1 the method to parse and validate an object was Item.parse_obj(), in Pydantic version 2, the method is called Item.model_validate().

Tip

Here we reuse the same Pydantic model.

But the same way, we could have validated it in some other way.
Previous
Advanced User Guide
Next
Additional Status Codes
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
Additional Status Codes

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Additional status codes
    OpenAPI and API docs

    FastAPI
    Learn
    Advanced User Guide

Additional Status CodesÂ¶

By default, FastAPI will return the responses using a JSONResponse, putting the content you return from your path operation inside of that JSONResponse.

It will use the default status code or the one you set in your path operation.
Additional status codesÂ¶

If you want to return additional status codes apart from the main one, you can do that by returning a Response directly, like a JSONResponse, and set the additional status code directly.

For example, let's say that you want to have a path operation that allows to update items, and returns HTTP status codes of 200 "OK" when successful.

But you also want it to accept new items. And when the items didn't exist before, it creates them, and returns an HTTP status code of 201 "Created".

To achieve that, import JSONResponse, and return your content there directly, setting the status_code that you want:
Python 3.10+

from typing import Annotated

from fastapi import Body, FastAPI, status
from fastapi.responses import JSONResponse

app = FastAPI()

items = {"foo": {"name": "Fighters", "size": 6}, "bar": {"name": "Tenders", "size": 3}}


@app.put("/items/{item_id}")
async def upsert_item(
    item_id: str,
    name: Annotated[str | None, Body()] = None,
    size: Annotated[int | None, Body()] = None,
):
    if item_id in items:
        item = items[item_id]
        item["name"] = name
        item["size"] = size
        return item
    else:
        item = {"name": name, "size": size}
        items[item_id] = item
        return JSONResponse(status_code=status.HTTP_201_CREATED, content=item)

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Warning

When you return a Response directly, like in the example above, it will be returned directly.

It won't be serialized with a model, etc.

Make sure it has the data you want it to have, and that the values are valid JSON (if you are using JSONResponse).

Technical Details

You could also use from starlette.responses import JSONResponse.

FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with status.
OpenAPI and API docsÂ¶

If you return additional status codes and responses directly, they won't be included in the OpenAPI schema (the API docs), because FastAPI doesn't have a way to know beforehand what you are going to return.

But you can document that in your code, using: Additional Responses.
Previous
Path Operation Advanced Configuration
Next
Return a Response Directly
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Additional Status Codes

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Additional status codes
    OpenAPI and API docs

    FastAPI
    Learn
    Advanced User Guide

Additional Status CodesÂ¶

By default, FastAPI will return the responses using a JSONResponse, putting the content you return from your path operation inside of that JSONResponse.

It will use the default status code or the one you set in your path operation.
Additional status codesÂ¶

If you want to return additional status codes apart from the main one, you can do that by returning a Response directly, like a JSONResponse, and set the additional status code directly.

For example, let's say that you want to have a path operation that allows to update items, and returns HTTP status codes of 200 "OK" when successful.

But you also want it to accept new items. And when the items didn't exist before, it creates them, and returns an HTTP status code of 201 "Created".

To achieve that, import JSONResponse, and return your content there directly, setting the status_code that you want:
Python 3.10+

from typing import Annotated

from fastapi import Body, FastAPI, status
from fastapi.responses import JSONResponse

app = FastAPI()

items = {"foo": {"name": "Fighters", "size": 6}, "bar": {"name": "Tenders", "size": 3}}


@app.put("/items/{item_id}")
async def upsert_item(
    item_id: str,
    name: Annotated[str | None, Body()] = None,
    size: Annotated[int | None, Body()] = None,
):
    if item_id in items:
        item = items[item_id]
        item["name"] = name
        item["size"] = size
        return item
    else:
        item = {"name": name, "size": size}
        items[item_id] = item
        return JSONResponse(status_code=status.HTTP_201_CREATED, content=item)

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Warning

When you return a Response directly, like in the example above, it will be returned directly.

It won't be serialized with a model, etc.

Make sure it has the data you want it to have, and that the values are valid JSON (if you are using JSONResponse).

Technical Details

You could also use from starlette.responses import JSONResponse.

FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with status.
OpenAPI and API docsÂ¶

If you return additional status codes and responses directly, they won't be included in the OpenAPI schema (the API docs), because FastAPI doesn't have a way to know beforehand what you are going to return.

But you can document that in your code, using: Additional Responses.
Previous
Path Operation Advanced Configuration
Next
Return a Response Directly
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs




Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Return a Response Directly

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Return a Response
    Using the jsonable_encoder in a Response
    Returning a custom Response
    Notes

    FastAPI
    Learn
    Advanced User Guide

Return a Response DirectlyÂ¶

When you create a FastAPI path operation you can normally return any data from it: a dict, a list, a Pydantic model, a database model, etc.

By default, FastAPI would automatically convert that return value to JSON using the jsonable_encoder explained in JSON Compatible Encoder.

Then, behind the scenes, it would put that JSON-compatible data (e.g. a dict) inside of a JSONResponse that would be used to send the response to the client.

But you can return a JSONResponse directly from your path operations.

It might be useful, for example, to return custom headers or cookies.
Return a ResponseÂ¶

In fact, you can return any Response or any sub-class of it.

Tip

JSONResponse itself is a sub-class of Response.

And when you return a Response, FastAPI will pass it directly.

It won't do any data conversion with Pydantic models, it won't convert the contents to any type, etc.

This gives you a lot of flexibility. You can return any data type, override any data declaration or validation, etc.
Using the jsonable_encoder in a ResponseÂ¶

Because FastAPI doesn't make any changes to a Response you return, you have to make sure its contents are ready for it.

For example, you cannot put a Pydantic model in a JSONResponse without first converting it to a dict with all the data types (like datetime, UUID, etc) converted to JSON-compatible types.

For those cases, you can use the jsonable_encoder to convert your data before passing it to a response:
Python 3.8+

from datetime import datetime
from typing import Union

from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
from fastapi.responses import JSONResponse
from pydantic import BaseModel


class Item(BaseModel):
    title: str
    timestamp: datetime
    description: Union[str, None] = None


app = FastAPI()


@app.put("/items/{id}")
def update_item(id: str, item: Item):
    json_compatible_item_data = jsonable_encoder(item)
    return JSONResponse(content=json_compatible_item_data)

Technical Details

You could also use from starlette.responses import JSONResponse.

FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette.
Returning a custom ResponseÂ¶

The example above shows all the parts you need, but it's not very useful yet, as you could have just returned the item directly, and FastAPI would put it in a JSONResponse for you, converting it to a dict, etc. All that by default.

Now, let's see how you could use that to return a custom response.

Let's say that you want to return an XML response.

You could put your XML content in a string, put that in a Response, and return it:
Python 3.8+

from fastapi import FastAPI, Response

app = FastAPI()


@app.get("/legacy/")
def get_legacy_data():
    data = """<?xml version="1.0"?>
    <shampoo>
    <Header>
        Apply shampoo here.
    </Header>
    <Body>
        You'll have to use soap here.
    </Body>
    </shampoo>
    """
    return Response(content=data, media_type="application/xml")

NotesÂ¶

When you return a Response directly its data is not validated, converted (serialized), or documented automatically.

But you can still document it as described in Additional Responses in OpenAPI.

You can see in later sections how to use/declare these custom Responses while still having automatic data conversion, documentation, etc.
Previous
Additional Status Codes
Next
Custom Response - HTML, Stream, File, others
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Custom Response - HTML, Stream, File, others

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Use ORJSONResponse
    HTML Response
        Return a Response
        Document in OpenAPI and override Response
            Return an HTMLResponse directly
    Available responses
        Response
        HTMLResponse
        PlainTextResponse
        JSONResponse
        ORJSONResponse
        UJSONResponse
        RedirectResponse
        StreamingResponse
            Using StreamingResponse with file-like objects
        FileResponse
    Custom response class
    Default response class
    Additional documentation

    FastAPI
    Learn
    Advanced User Guide

Custom Response - HTML, Stream, File, othersÂ¶

By default, FastAPI will return the responses using JSONResponse.

You can override it by returning a Response directly as seen in Return a Response directly.

But if you return a Response directly (or any subclass, like JSONResponse), the data won't be automatically converted (even if you declare a response_model), and the documentation won't be automatically generated (for example, including the specific "media type", in the HTTP header Content-Type as part of the generated OpenAPI).

But you can also declare the Response that you want to be used (e.g. any Response subclass), in the path operation decorator using the response_class parameter.

The contents that you return from your path operation function will be put inside of that Response.

And if that Response has a JSON media type (application/json), like is the case with the JSONResponse and UJSONResponse, the data you return will be automatically converted (and filtered) with any Pydantic response_model that you declared in the path operation decorator.

Note

If you use a response class with no media type, FastAPI will expect your response to have no content, so it will not document the response format in its generated OpenAPI docs.
Use ORJSONResponseÂ¶

For example, if you are squeezing performance, you can install and use orjson and set the response to be ORJSONResponse.

Import the Response class (sub-class) you want to use and declare it in the path operation decorator.

For large responses, returning a Response directly is much faster than returning a dictionary.

This is because by default, FastAPI will inspect every item inside and make sure it is serializable as JSON, using the same JSON Compatible Encoder explained in the tutorial. This is what allows you to return arbitrary objects, for example database models.

But if you are certain that the content that you are returning is serializable with JSON, you can pass it directly to the response class and avoid the extra overhead that FastAPI would have by passing your return content through the jsonable_encoder before passing it to the response class.
Python 3.8+

from fastapi import FastAPI
from fastapi.responses import ORJSONResponse

app = FastAPI()


@app.get("/items/", response_class=ORJSONResponse)
async def read_items():
    return ORJSONResponse([{"item_id": "Foo"}])

Info

The parameter response_class will also be used to define the "media type" of the response.

In this case, the HTTP header Content-Type will be set to application/json.

And it will be documented as such in OpenAPI.

Tip

The ORJSONResponse is only available in FastAPI, not in Starlette.
HTML ResponseÂ¶

To return a response with HTML directly from FastAPI, use HTMLResponse.

    Import HTMLResponse.
    Pass HTMLResponse as the parameter response_class of your path operation decorator.

Python 3.8+

from fastapi import FastAPI
from fastapi.responses import HTMLResponse

app = FastAPI()


@app.get("/items/", response_class=HTMLResponse)
async def read_items():
    return """
    <html>
        <head>
            <title>Some HTML in here</title>
        </head>
        <body>
            <h1>Look ma! HTML!</h1>
        </body>
    </html>
    """

Info

The parameter response_class will also be used to define the "media type" of the response.

In this case, the HTTP header Content-Type will be set to text/html.

And it will be documented as such in OpenAPI.
Return a ResponseÂ¶

As seen in Return a Response directly, you can also override the response directly in your path operation, by returning it.

The same example from above, returning an HTMLResponse, could look like:
Python 3.8+

from fastapi import FastAPI
from fastapi.responses import HTMLResponse

app = FastAPI()


@app.get("/items/")
async def read_items():
    html_content = """
    <html>
        <head>
            <title>Some HTML in here</title>
        </head>
        <body>
            <h1>Look ma! HTML!</h1>
        </body>
    </html>
    """
    return HTMLResponse(content=html_content, status_code=200)

Warning

A Response returned directly by your path operation function won't be documented in OpenAPI (for example, the Content-Type won't be documented) and won't be visible in the automatic interactive docs.

Info

Of course, the actual Content-Type header, status code, etc, will come from the Response object you returned.
Document in OpenAPI and override ResponseÂ¶

If you want to override the response from inside of the function but at the same time document the "media type" in OpenAPI, you can use the response_class parameter AND return a Response object.

The response_class will then be used only to document the OpenAPI path operation, but your Response will be used as is.
Return an HTMLResponse directlyÂ¶

For example, it could be something like:
Python 3.8+

from fastapi import FastAPI
from fastapi.responses import HTMLResponse

app = FastAPI()


def generate_html_response():
    html_content = """
    <html>
        <head>
            <title>Some HTML in here</title>
        </head>
        <body>
            <h1>Look ma! HTML!</h1>
        </body>
    </html>
    """
    return HTMLResponse(content=html_content, status_code=200)


@app.get("/items/", response_class=HTMLResponse)
async def read_items():
    return generate_html_response()

In this example, the function generate_html_response() already generates and returns a Response instead of returning the HTML in a str.

By returning the result of calling generate_html_response(), you are already returning a Response that will override the default FastAPI behavior.

But as you passed the HTMLResponse in the response_class too, FastAPI will know how to document it in OpenAPI and the interactive docs as HTML with text/html:

Available responsesÂ¶

Here are some of the available responses.

Keep in mind that you can use Response to return anything else, or even create a custom sub-class.

Technical Details

You could also use from starlette.responses import HTMLResponse.

FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette.
ResponseÂ¶

The main Response class, all the other responses inherit from it.

You can return it directly.

It accepts the following parameters:

    content - A str or bytes.
    status_code - An int HTTP status code.
    headers - A dict of strings.
    media_type - A str giving the media type. E.g. "text/html".

FastAPI (actually Starlette) will automatically include a Content-Length header. It will also include a Content-Type header, based on the media_type and appending a charset for text types.
Python 3.8+

from fastapi import FastAPI, Response

app = FastAPI()


@app.get("/legacy/")
def get_legacy_data():
    data = """<?xml version="1.0"?>
    <shampoo>
    <Header>
        Apply shampoo here.
    </Header>
    <Body>
        You'll have to use soap here.
    </Body>
    </shampoo>
    """
    return Response(content=data, media_type="application/xml")

HTMLResponseÂ¶

Takes some text or bytes and returns an HTML response, as you read above.
PlainTextResponseÂ¶

Takes some text or bytes and returns a plain text response.
Python 3.8+

from fastapi import FastAPI
from fastapi.responses import PlainTextResponse

app = FastAPI()


@app.get("/", response_class=PlainTextResponse)
async def main():
    return "Hello World"

JSONResponseÂ¶

Takes some data and returns an application/json encoded response.

This is the default response used in FastAPI, as you read above.
ORJSONResponseÂ¶

A fast alternative JSON response using orjson, as you read above.

Info

This requires installing orjson for example with pip install orjson.
UJSONResponseÂ¶

An alternative JSON response using ujson.

Info

This requires installing ujson for example with pip install ujson.

Warning

ujson is less careful than Python's built-in implementation in how it handles some edge-cases.
Python 3.8+

from fastapi import FastAPI
from fastapi.responses import UJSONResponse

app = FastAPI()


@app.get("/items/", response_class=UJSONResponse)
async def read_items():
    return [{"item_id": "Foo"}]

Tip

It's possible that ORJSONResponse might be a faster alternative.
RedirectResponseÂ¶

Returns an HTTP redirect. Uses a 307 status code (Temporary Redirect) by default.

You can return a RedirectResponse directly:
Python 3.8+

from fastapi import FastAPI
from fastapi.responses import RedirectResponse

app = FastAPI()


@app.get("/typer")
async def redirect_typer():
    return RedirectResponse("https://typer.tiangolo.com")

Or you can use it in the response_class parameter:
Python 3.8+

from fastapi import FastAPI
from fastapi.responses import RedirectResponse

app = FastAPI()


@app.get("/fastapi", response_class=RedirectResponse)
async def redirect_fastapi():
    return "https://fastapi.tiangolo.com"

If you do that, then you can return the URL directly from your path operation function.

In this case, the status_code used will be the default one for the RedirectResponse, which is 307.

You can also use the status_code parameter combined with the response_class parameter:
Python 3.8+

from fastapi import FastAPI
from fastapi.responses import RedirectResponse

app = FastAPI()


@app.get("/pydantic", response_class=RedirectResponse, status_code=302)
async def redirect_pydantic():
    return "https://docs.pydantic.dev/"

StreamingResponseÂ¶

Takes an async generator or a normal generator/iterator and streams the response body.
Python 3.8+

from fastapi import FastAPI
from fastapi.responses import StreamingResponse

app = FastAPI()


async def fake_video_streamer():
    for i in range(10):
        yield b"some fake video bytes"


@app.get("/")
async def main():
    return StreamingResponse(fake_video_streamer())

Using StreamingResponse with file-like objectsÂ¶

If you have a file-like object (e.g. the object returned by open()), you can create a generator function to iterate over that file-like object.

That way, you don't have to read it all first in memory, and you can pass that generator function to the StreamingResponse, and return it.

This includes many libraries to interact with cloud storage, video processing, and others.
Python 3.8+

from fastapi import FastAPI
from fastapi.responses import StreamingResponse

some_file_path = "large-video-file.mp4"
app = FastAPI()


@app.get("/")
def main():
    def iterfile():  # (1)
        with open(some_file_path, mode="rb") as file_like:  # (2)
            yield from file_like  # (3)

    return StreamingResponse(iterfile(), media_type="video/mp4")

    This is the generator function. It's a "generator function" because it contains yield statements inside.
    By using a with block, we make sure that the file-like object is closed after the generator function is done. So, after it finishes sending the response.

    This yield from tells the function to iterate over that thing named file_like. And then, for each part iterated, yield that part as coming from this generator function (iterfile).

    So, it is a generator function that transfers the "generating" work to something else internally.

    By doing it this way, we can put it in a with block, and that way, ensure that the file-like object is closed after finishing.

Tip

Notice that here as we are using standard open() that doesn't support async and await, we declare the path operation with normal def.
FileResponseÂ¶

Asynchronously streams a file as the response.

Takes a different set of arguments to instantiate than the other response types:

    path - The file path to the file to stream.
    headers - Any custom headers to include, as a dictionary.
    media_type - A string giving the media type. If unset, the filename or path will be used to infer a media type.
    filename - If set, this will be included in the response Content-Disposition.

File responses will include appropriate Content-Length, Last-Modified and ETag headers.
Python 3.8+

from fastapi import FastAPI
from fastapi.responses import FileResponse

some_file_path = "large-video-file.mp4"
app = FastAPI()


@app.get("/")
async def main():
    return FileResponse(some_file_path)

You can also use the response_class parameter:
Python 3.8+

from fastapi import FastAPI
from fastapi.responses import FileResponse

some_file_path = "large-video-file.mp4"
app = FastAPI()


@app.get("/", response_class=FileResponse)
async def main():
    return some_file_path

In this case, you can return the file path directly from your path operation function.
Custom response classÂ¶

You can create your own custom response class, inheriting from Response and using it.

For example, let's say that you want to use orjson, but with some custom settings not used in the included ORJSONResponse class.

Let's say you want it to return indented and formatted JSON, so you want to use the orjson option orjson.OPT_INDENT_2.

You could create a CustomORJSONResponse. The main thing you have to do is create a Response.render(content) method that returns the content as bytes:
Python 3.8+

from typing import Any

import orjson
from fastapi import FastAPI, Response

app = FastAPI()


class CustomORJSONResponse(Response):
    media_type = "application/json"

    def render(self, content: Any) -> bytes:
        assert orjson is not None, "orjson must be installed"
        return orjson.dumps(content, option=orjson.OPT_INDENT_2)


@app.get("/", response_class=CustomORJSONResponse)
async def main():
    return {"message": "Hello World"}

Now instead of returning:

{"message": "Hello World"}

...this response will return:

{
  "message": "Hello World"
}

Of course, you will probably find much better ways to take advantage of this than formatting JSON. ğŸ˜‰
Default response classÂ¶

When creating a FastAPI class instance or an APIRouter you can specify which response class to use by default.

The parameter that defines this is default_response_class.

In the example below, FastAPI will use ORJSONResponse by default, in all path operations, instead of JSONResponse.
Python 3.8+

from fastapi import FastAPI
from fastapi.responses import ORJSONResponse

app = FastAPI(default_response_class=ORJSONResponse)


@app.get("/items/")
async def read_items():
    return [{"item_id": "Foo"}]

Tip

You can still override response_class in path operations as before.
Additional documentationÂ¶

You can also declare the media type and many other details in OpenAPI using responses: Additional Responses in OpenAPI.
Previous
Return a Response Directly
Next
Additional Responses in OpenAPI
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
Additional Responses in OpenAPI

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Additional Response with model
    Additional media types for the main response
    Combining information
    Combine predefined responses and custom ones
    More information about OpenAPI responses

    FastAPI
    Learn
    Advanced User Guide

Additional Responses in OpenAPIÂ¶

Warning

This is a rather advanced topic.

If you are starting with FastAPI, you might not need this.

You can declare additional responses, with additional status codes, media types, descriptions, etc.

Those additional responses will be included in the OpenAPI schema, so they will also appear in the API docs.

But for those additional responses you have to make sure you return a Response like JSONResponse directly, with your status code and content.
Additional Response with modelÂ¶

You can pass to your path operation decorators a parameter responses.

It receives a dict: the keys are status codes for each response (like 200), and the values are other dicts with the information for each of them.

Each of those response dicts can have a key model, containing a Pydantic model, just like response_model.

FastAPI will take that model, generate its JSON Schema and include it in the correct place in OpenAPI.

For example, to declare another response with a status code 404 and a Pydantic model Message, you can write:
Python 3.8+

from fastapi import FastAPI
from fastapi.responses import JSONResponse
from pydantic import BaseModel


class Item(BaseModel):
    id: str
    value: str


class Message(BaseModel):
    message: str


app = FastAPI()


@app.get("/items/{item_id}", response_model=Item, responses={404: {"model": Message}})
async def read_item(item_id: str):
    if item_id == "foo":
        return {"id": "foo", "value": "there goes my hero"}
    return JSONResponse(status_code=404, content={"message": "Item not found"})

Note

Keep in mind that you have to return the JSONResponse directly.

Info

The model key is not part of OpenAPI.

FastAPI will take the Pydantic model from there, generate the JSON Schema, and put it in the correct place.

The correct place is:

    In the key content, that has as value another JSON object (dict) that contains:
        A key with the media type, e.g. application/json, that contains as value another JSON object, that contains:
            A key schema, that has as the value the JSON Schema from the model, here's the correct place.
                FastAPI adds a reference here to the global JSON Schemas in another place in your OpenAPI instead of including it directly. This way, other applications and clients can use those JSON Schemas directly, provide better code generation tools, etc.

The generated responses in the OpenAPI for this path operation will be:

{
    "responses": {
        "404": {
            "description": "Additional Response",
            "content": {
                "application/json": {
                    "schema": {
                        "$ref": "#/components/schemas/Message"
                    }
                }
            }
        },
        "200": {
            "description": "Successful Response",
            "content": {
                "application/json": {
                    "schema": {
                        "$ref": "#/components/schemas/Item"
                    }
                }
            }
        },
        "422": {
            "description": "Validation Error",
            "content": {
                "application/json": {
                    "schema": {
                        "$ref": "#/components/schemas/HTTPValidationError"
                    }
                }
            }
        }
    }
}

The schemas are referenced to another place inside the OpenAPI schema:

{
    "components": {
        "schemas": {
            "Message": {
                "title": "Message",
                "required": [
                    "message"
                ],
                "type": "object",
                "properties": {
                    "message": {
                        "title": "Message",
                        "type": "string"
                    }
                }
            },
            "Item": {
                "title": "Item",
                "required": [
                    "id",
                    "value"
                ],
                "type": "object",
                "properties": {
                    "id": {
                        "title": "Id",
                        "type": "string"
                    },
                    "value": {
                        "title": "Value",
                        "type": "string"
                    }
                }
            },
            "ValidationError": {
                "title": "ValidationError",
                "required": [
                    "loc",
                    "msg",
                    "type"
                ],
                "type": "object",
                "properties": {
                    "loc": {
                        "title": "Location",
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "msg": {
                        "title": "Message",
                        "type": "string"
                    },
                    "type": {
                        "title": "Error Type",
                        "type": "string"
                    }
                }
            },
            "HTTPValidationError": {
                "title": "HTTPValidationError",
                "type": "object",
                "properties": {
                    "detail": {
                        "title": "Detail",
                        "type": "array",
                        "items": {
                            "$ref": "#/components/schemas/ValidationError"
                        }
                    }
                }
            }
        }
    }
}

Additional media types for the main responseÂ¶

You can use this same responses parameter to add different media types for the same main response.

For example, you can add an additional media type of image/png, declaring that your path operation can return a JSON object (with media type application/json) or a PNG image:
Python 3.8+

from typing import Union

from fastapi import FastAPI
from fastapi.responses import FileResponse
from pydantic import BaseModel


class Item(BaseModel):
    id: str
    value: str


app = FastAPI()


@app.get(
    "/items/{item_id}",
    response_model=Item,
    responses={
        200: {
            "content": {"image/png": {}},
            "description": "Return the JSON item or an image.",
        }
    },
)
async def read_item(item_id: str, img: Union[bool, None] = None):
    if img:
        return FileResponse("image.png", media_type="image/png")
    else:
        return {"id": "foo", "value": "there goes my hero"}

Note

Notice that you have to return the image using a FileResponse directly.

Info

Unless you specify a different media type explicitly in your responses parameter, FastAPI will assume the response has the same media type as the main response class (default application/json).

But if you have specified a custom response class with None as its media type, FastAPI will use application/json for any additional response that has an associated model.
Combining informationÂ¶

You can also combine response information from multiple places, including the response_model, status_code, and responses parameters.

You can declare a response_model, using the default status code 200 (or a custom one if you need), and then declare additional information for that same response in responses, directly in the OpenAPI schema.

FastAPI will keep the additional information from responses, and combine it with the JSON Schema from your model.

For example, you can declare a response with a status code 404 that uses a Pydantic model and has a custom description.

And a response with a status code 200 that uses your response_model, but includes a custom example:
Python 3.8+

from fastapi import FastAPI
from fastapi.responses import JSONResponse
from pydantic import BaseModel


class Item(BaseModel):
    id: str
    value: str


class Message(BaseModel):
    message: str


app = FastAPI()


@app.get(
    "/items/{item_id}",
    response_model=Item,
    responses={
        404: {"model": Message, "description": "The item was not found"},
        200: {
            "description": "Item requested by ID",
            "content": {
                "application/json": {
                    "example": {"id": "bar", "value": "The bar tenders"}
                }
            },
        },
    },
)
async def read_item(item_id: str):
    if item_id == "foo":
        return {"id": "foo", "value": "there goes my hero"}
    else:
        return JSONResponse(status_code=404, content={"message": "Item not found"})

It will all be combined and included in your OpenAPI, and shown in the API docs:

Combine predefined responses and custom onesÂ¶

You might want to have some predefined responses that apply to many path operations, but you want to combine them with custom responses needed by each path operation.

For those cases, you can use the Python technique of "unpacking" a dict with **dict_to_unpack:

old_dict = {
    "old key": "old value",
    "second old key": "second old value",
}
new_dict = {**old_dict, "new key": "new value"}

Here, new_dict will contain all the key-value pairs from old_dict plus the new key-value pair:

{
    "old key": "old value",
    "second old key": "second old value",
    "new key": "new value",
}

You can use that technique to reuse some predefined responses in your path operations and combine them with additional custom ones.

For example:
Python 3.8+

from typing import Union

from fastapi import FastAPI
from fastapi.responses import FileResponse
from pydantic import BaseModel


class Item(BaseModel):
    id: str
    value: str


responses = {
    404: {"description": "Item not found"},
    302: {"description": "The item was moved"},
    403: {"description": "Not enough privileges"},
}


app = FastAPI()


@app.get(
    "/items/{item_id}",
    response_model=Item,
    responses={**responses, 200: {"content": {"image/png": {}}}},
)
async def read_item(item_id: str, img: Union[bool, None] = None):
    if img:
        return FileResponse("image.png", media_type="image/png")
    else:
        return {"id": "foo", "value": "there goes my hero"}

More information about OpenAPI responsesÂ¶

To see what exactly you can include in the responses, you can check these sections in the OpenAPI specification:

    OpenAPI Responses Object, it includes the Response Object.
    OpenAPI Response Object, you can include anything from this directly in each response inside your responses parameter. Including description, headers, content (inside of this is that you declare different media types and JSON Schemas), and links.

Previous
Custom Response - HTML, Stream, File, others
Next
Response Cookies
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Response Cookies

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Use a Response parameter
    Return a Response directly
        More info

    FastAPI
    Learn
    Advanced User Guide

Response CookiesÂ¶
Use a Response parameterÂ¶

You can declare a parameter of type Response in your path operation function.

And then you can set cookies in that temporal response object.
Python 3.8+

from fastapi import FastAPI, Response

app = FastAPI()


@app.post("/cookie-and-object/")
def create_cookie(response: Response):
    response.set_cookie(key="fakesession", value="fake-cookie-session-value")
    return {"message": "Come to the dark side, we have cookies"}

And then you can return any object you need, as you normally would (a dict, a database model, etc).

And if you declared a response_model, it will still be used to filter and convert the object you returned.

FastAPI will use that temporal response to extract the cookies (also headers and status code), and will put them in the final response that contains the value you returned, filtered by any response_model.

You can also declare the Response parameter in dependencies, and set cookies (and headers) in them.
Return a Response directlyÂ¶

You can also create cookies when returning a Response directly in your code.

To do that, you can create a response as described in Return a Response Directly.

Then set Cookies in it, and then return it:
Python 3.8+

from fastapi import FastAPI
from fastapi.responses import JSONResponse

app = FastAPI()


@app.post("/cookie/")
def create_cookie():
    content = {"message": "Come to the dark side, we have cookies"}
    response = JSONResponse(content=content)
    response.set_cookie(key="fakesession", value="fake-cookie-session-value")
    return response

Tip

Keep in mind that if you return a response directly instead of using the Response parameter, FastAPI will return it directly.

So, you will have to make sure your data is of the correct type. E.g. it is compatible with JSON, if you are returning a JSONResponse.

And also that you are not sending any data that should have been filtered by a response_model.
More infoÂ¶

Technical Details

You could also use from starlette.responses import Response or from starlette.responses import JSONResponse.

FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette.

And as the Response can be used frequently to set headers and cookies, FastAPI also provides it at fastapi.Response.

To see all the available parameters and options, check the documentation in Starlette.
Previous
Additional Responses in OpenAPI
Next
Response Headers
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Response Headers

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Use a Response parameter
    Return a Response directly
    Custom Headers

    FastAPI
    Learn
    Advanced User Guide

Response HeadersÂ¶
Use a Response parameterÂ¶

You can declare a parameter of type Response in your path operation function (as you can do for cookies).

And then you can set headers in that temporal response object.
Python 3.8+

from fastapi import FastAPI, Response

app = FastAPI()


@app.get("/headers-and-object/")
def get_headers(response: Response):
    response.headers["X-Cat-Dog"] = "alone in the world"
    return {"message": "Hello World"}

And then you can return any object you need, as you normally would (a dict, a database model, etc).

And if you declared a response_model, it will still be used to filter and convert the object you returned.

FastAPI will use that temporal response to extract the headers (also cookies and status code), and will put them in the final response that contains the value you returned, filtered by any response_model.

You can also declare the Response parameter in dependencies, and set headers (and cookies) in them.
Return a Response directlyÂ¶

You can also add headers when you return a Response directly.

Create a response as described in Return a Response Directly and pass the headers as an additional parameter:
Python 3.8+

from fastapi import FastAPI
from fastapi.responses import JSONResponse

app = FastAPI()


@app.get("/headers/")
def get_headers():
    content = {"message": "Hello World"}
    headers = {"X-Cat-Dog": "alone in the world", "Content-Language": "en-US"}
    return JSONResponse(content=content, headers=headers)

Technical Details

You could also use from starlette.responses import Response or from starlette.responses import JSONResponse.

FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette.

And as the Response can be used frequently to set headers and cookies, FastAPI also provides it at fastapi.Response.
Custom HeadersÂ¶

Keep in mind that custom proprietary headers can be added using the X- prefix.

But if you have custom headers that you want a client in a browser to be able to see, you need to add them to your CORS configurations (read more in CORS (Cross-Origin Resource Sharing)), using the parameter expose_headers documented in Starlette's CORS docs.
Previous
Response Cookies
Next
Response - Change Status Code
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
Response - Change Status Code

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Use case
    Use a Response parameter

    FastAPI
    Learn
    Advanced User Guide

Response - Change Status CodeÂ¶

You probably read before that you can set a default Response Status Code.

But in some cases you need to return a different status code than the default.
Use caseÂ¶

For example, imagine that you want to return an HTTP status code of "OK" 200 by default.

But if the data didn't exist, you want to create it, and return an HTTP status code of "CREATED" 201.

But you still want to be able to filter and convert the data you return with a response_model.

For those cases, you can use a Response parameter.
Use a Response parameterÂ¶

You can declare a parameter of type Response in your path operation function (as you can do for cookies and headers).

And then you can set the status_code in that temporal response object.
Python 3.8+

from fastapi import FastAPI, Response, status

app = FastAPI()

tasks = {"foo": "Listen to the Bar Fighters"}


@app.put("/get-or-create-task/{task_id}", status_code=200)
def get_or_create_task(task_id: str, response: Response):
    if task_id not in tasks:
        tasks[task_id] = "This didn't exist before"
        response.status_code = status.HTTP_201_CREATED
    return tasks[task_id]

And then you can return any object you need, as you normally would (a dict, a database model, etc).

And if you declared a response_model, it will still be used to filter and convert the object you returned.

FastAPI will use that temporal response to extract the status code (also cookies and headers), and will put them in the final response that contains the value you returned, filtered by any response_model.

You can also declare the Response parameter in dependencies, and set the status code in them. But keep in mind that the last one to be set will win.
Previous
Response Headers
Next
Advanced Dependencies
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
Advanced Dependencies

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Parameterized dependencies
    A "callable" instance
    Parameterize the instance
    Create an instance
    Use the instance as a dependency
    Dependencies with yield, HTTPException, except and Background Tasks
        Dependencies with yield and scope
        Dependencies with yield and StreamingResponse, Technical Details
            Use Cases with Early Exit Code
        Dependencies with yield and except, Technical Details
        Background Tasks and Dependencies with yield, Technical Details

    FastAPI
    Learn
    Advanced User Guide

Advanced DependenciesÂ¶
Parameterized dependenciesÂ¶

All the dependencies we have seen are a fixed function or class.

But there could be cases where you want to be able to set parameters on the dependency, without having to declare many different functions or classes.

Let's imagine that we want to have a dependency that checks if the query parameter q contains some fixed content.

But we want to be able to parameterize that fixed content.
A "callable" instanceÂ¶

In Python there's a way to make an instance of a class a "callable".

Not the class itself (which is already a callable), but an instance of that class.

To do that, we declare a method __call__:
Python 3.9+

from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


class FixedContentQueryChecker:
    def __init__(self, fixed_content: str):
        self.fixed_content = fixed_content

    def __call__(self, q: str = ""):
        if q:
            return self.fixed_content in q
        return False


checker = FixedContentQueryChecker("bar")


@app.get("/query-checker/")
async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):
    return {"fixed_content_in_query": fixed_content_included}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

In this case, this __call__ is what FastAPI will use to check for additional parameters and sub-dependencies, and this is what will be called to pass a value to the parameter in your path operation function later.
Parameterize the instanceÂ¶

And now, we can use __init__ to declare the parameters of the instance that we can use to "parameterize" the dependency:
Python 3.9+

from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


class FixedContentQueryChecker:
    def __init__(self, fixed_content: str):
        self.fixed_content = fixed_content

    def __call__(self, q: str = ""):
        if q:
            return self.fixed_content in q
        return False


checker = FixedContentQueryChecker("bar")


@app.get("/query-checker/")
async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):
    return {"fixed_content_in_query": fixed_content_included}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

In this case, FastAPI won't ever touch or care about __init__, we will use it directly in our code.
Create an instanceÂ¶

We could create an instance of this class with:
Python 3.9+

from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


class FixedContentQueryChecker:
    def __init__(self, fixed_content: str):
        self.fixed_content = fixed_content

    def __call__(self, q: str = ""):
        if q:
            return self.fixed_content in q
        return False


checker = FixedContentQueryChecker("bar")


@app.get("/query-checker/")
async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):
    return {"fixed_content_in_query": fixed_content_included}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

And that way we are able to "parameterize" our dependency, that now has "bar" inside of it, as the attribute checker.fixed_content.
Use the instance as a dependencyÂ¶

Then, we could use this checker in a Depends(checker), instead of Depends(FixedContentQueryChecker), because the dependency is the instance, checker, not the class itself.

And when solving the dependency, FastAPI will call this checker like:

checker(q="somequery")

...and pass whatever that returns as the value of the dependency in our path operation function as the parameter fixed_content_included:
Python 3.9+

from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


class FixedContentQueryChecker:
    def __init__(self, fixed_content: str):
        self.fixed_content = fixed_content

    def __call__(self, q: str = ""):
        if q:
            return self.fixed_content in q
        return False


checker = FixedContentQueryChecker("bar")


@app.get("/query-checker/")
async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):
    return {"fixed_content_in_query": fixed_content_included}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Tip

All this might seem contrived. And it might not be very clear how is it useful yet.

These examples are intentionally simple, but show how it all works.

In the chapters about security, there are utility functions that are implemented in this same way.

If you understood all this, you already know how those utility tools for security work underneath.
Dependencies with yield, HTTPException, except and Background TasksÂ¶

Warning

You most probably don't need these technical details.

These details are useful mainly if you had a FastAPI application older than 0.121.0 and you are facing issues with dependencies with yield.

Dependencies with yield have evolved over time to account for the different use cases and to fix some issues, here's a summary of what has changed.
Dependencies with yield and scopeÂ¶

In version 0.121.0, FastAPI added support for Depends(scope="function") for dependencies with yield.

Using Depends(scope="function"), the exit code after yield is executed right after the path operation function is finished, before the response is sent back to the client.

And when using Depends(scope="request") (the default), the exit code after yield is executed after the response is sent.

You can read more about it in the docs for Dependencies with yield - Early exit and scope.
Dependencies with yield and StreamingResponse, Technical DetailsÂ¶

Before FastAPI 0.118.0, if you used a dependency with yield, it would run the exit code after the path operation function returned but right before sending the response.

The intention was to avoid holding resources for longer than necessary, waiting for the response to travel through the network.

This change also meant that if you returned a StreamingResponse, the exit code of the dependency with yield would have been already run.

For example, if you had a database session in a dependency with yield, the StreamingResponse would not be able to use that session while streaming data because the session would have already been closed in the exit code after yield.

This behavior was reverted in 0.118.0, to make the exit code after yield be executed after the response is sent.

Info

As you will see below, this is very similar to the behavior before version 0.106.0, but with several improvements and bug fixes for corner cases.
Use Cases with Early Exit CodeÂ¶

There are some use cases with specific conditions that could benefit from the old behavior of running the exit code of dependencies with yield before sending the response.

For example, imagine you have code that uses a database session in a dependency with yield only to verify a user, but the database session is never used again in the path operation function, only in the dependency, and the response takes a long time to be sent, like a StreamingResponse that sends data slowly, but for some reason doesn't use the database.

In this case, the database session would be held until the response is finished being sent, but if you don't use it, then it wouldn't be necessary to hold it.

Here's how it could look like:
Python 3.10+

import time
from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException
from fastapi.responses import StreamingResponse
from sqlmodel import Field, Session, SQLModel, create_engine

engine = create_engine("postgresql+psycopg://postgres:postgres@localhost/db")


class User(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str


app = FastAPI()


def get_session():
    with Session(engine) as session:
        yield session


def get_user(user_id: int, session: Annotated[Session, Depends(get_session)]):
    user = session.get(User, user_id)
    if not user:
        raise HTTPException(status_code=403, detail="Not authorized")


def generate_stream(query: str):
    for ch in query:
        yield ch
        time.sleep(0.1)


@app.get("/generate", dependencies=[Depends(get_user)])
def generate(query: str):
    return StreamingResponse(content=generate_stream(query))

The exit code, the automatic closing of the Session in:
Python 3.10+

# Code above omitted ğŸ‘†

def get_session():
    with Session(engine) as session:
        yield session

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

...would be run after the the response finishes sending the slow data:
Python 3.10+

# Code above omitted ğŸ‘†

def generate_stream(query: str):
    for ch in query:
        yield ch
        time.sleep(0.1)


@app.get("/generate", dependencies=[Depends(get_user)])
def generate(query: str):
    return StreamingResponse(content=generate_stream(query))

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

But as generate_stream() doesn't use the database session, it is not really necessary to keep the session open while sending the response.

If you have this specific use case using SQLModel (or SQLAlchemy), you could explicitly close the session after you don't need it anymore:
Python 3.10+

# Code above omitted ğŸ‘†

def get_user(user_id: int, session: Annotated[Session, Depends(get_session)]):
    user = session.get(User, user_id)
    if not user:
        raise HTTPException(status_code=403, detail="Not authorized")
    session.close()

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

That way the session would release the database connection, so other requests could use it.

If you have a different use case that needs to exit early from a dependency with yield, please create a GitHub Discussion Question with your specific use case and why you would benefit from having early closing for dependencies with yield.

If there are compelling use cases for early closing in dependencies with yield, I would consider adding a new way to opt in to early closing.
Dependencies with yield and except, Technical DetailsÂ¶

Before FastAPI 0.110.0, if you used a dependency with yield, and then you captured an exception with except in that dependency, and you didn't raise the exception again, the exception would be automatically raised/forwarded to any exception handlers or the internal server error handler.

This was changed in version 0.110.0 to fix unhandled memory consumption from forwarded exceptions without a handler (internal server errors), and to make it consistent with the behavior of regular Python code.
Background Tasks and Dependencies with yield, Technical DetailsÂ¶

Before FastAPI 0.106.0, raising exceptions after yield was not possible, the exit code in dependencies with yield was executed after the response was sent, so Exception Handlers would have already run.

This was designed this way mainly to allow using the same objects "yielded" by dependencies inside of background tasks, because the exit code would be executed after the background tasks were finished.

This was changed in FastAPI 0.106.0 with the intention to not hold resources while waiting for the response to travel through the network.

Tip

Additionally, a background task is normally an independent set of logic that should be handled separately, with its own resources (e.g. its own database connection).

So, this way you will probably have cleaner code.

If you used to rely on this behavior, now you should create the resources for background tasks inside the background task itself, and use internally only data that doesn't depend on the resources of dependencies with yield.

For example, instead of using the same database session, you would create a new database session inside of the background task, and you would obtain the objects from the database using this new session. And then instead of passing the object from the database as a parameter to the background task function, you would pass the ID of that object and then obtain the object again inside the background task function.
Previous
Response - Change Status Code
Next
Advanced Security
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs




    FastAPI
    Learn
    Advanced User Guide
    Advanced Security

Advanced SecurityÂ¶
Additional FeaturesÂ¶

There are some extra features to handle security apart from the ones covered in the Tutorial - User Guide: Security.

Tip

The next sections are not necessarily "advanced".

And it's possible that for your use case, the solution is in one of them.
Read the Tutorial firstÂ¶

The next sections assume you already read the main Tutorial - User Guide: Security.

They are all based on the same concepts, but allow some extra functionalities.



Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
OAuth2 scopes

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
                OAuth2 scopes
                HTTP Basic Auth
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    OAuth2 scopes and OpenAPI
    Global view
    OAuth2 Security scheme
    JWT token with scopes
    Declare scopes in path operations and dependencies
    Use SecurityScopes
    Use the scopes
    Verify the username and data shape
    Verify the scopes
    Dependency tree and scopes
    More details about SecurityScopes
    Check it
    About third party integrations
    Security in decorator dependencies

    FastAPI
    Learn
    Advanced User Guide
    Advanced Security

OAuth2 scopesÂ¶

You can use OAuth2 scopes directly with FastAPI, they are integrated to work seamlessly.

This would allow you to have a more fine-grained permission system, following the OAuth2 standard, integrated into your OpenAPI application (and the API docs).

OAuth2 with scopes is the mechanism used by many big authentication providers, like Facebook, Google, GitHub, Microsoft, X (Twitter), etc. They use it to provide specific permissions to users and applications.

Every time you "log in with" Facebook, Google, GitHub, Microsoft, X (Twitter), that application is using OAuth2 with scopes.

In this section you will see how to manage authentication and authorization with the same OAuth2 with scopes in your FastAPI application.

Warning

This is a more or less advanced section. If you are just starting, you can skip it.

You don't necessarily need OAuth2 scopes, and you can handle authentication and authorization however you want.

But OAuth2 with scopes can be nicely integrated into your API (with OpenAPI) and your API docs.

Nevertheless, you still enforce those scopes, or any other security/authorization requirement, however you need, in your code.

In many cases, OAuth2 with scopes can be an overkill.

But if you know you need it, or you are curious, keep reading.
OAuth2 scopes and OpenAPIÂ¶

The OAuth2 specification defines "scopes" as a list of strings separated by spaces.

The content of each of these strings can have any format, but should not contain spaces.

These scopes represent "permissions".

In OpenAPI (e.g. the API docs), you can define "security schemes".

When one of these security schemes uses OAuth2, you can also declare and use scopes.

Each "scope" is just a string (without spaces).

They are normally used to declare specific security permissions, for example:

    users:read or users:write are common examples.
    instagram_basic is used by Facebook / Instagram.
    https://www.googleapis.com/auth/drive is used by Google.

Info

In OAuth2 a "scope" is just a string that declares a specific permission required.

It doesn't matter if it has other characters like : or if it is a URL.

Those details are implementation specific.

For OAuth2 they are just strings.
Global viewÂ¶

First, let's quickly see the parts that change from the examples in the main Tutorial - User Guide for OAuth2 with Password (and hashing), Bearer with JWT tokens. Now using OAuth2 scopes:
Python 3.10+

from datetime import datetime, timedelta, timezone
from typing import Annotated

import jwt
from fastapi import Depends, FastAPI, HTTPException, Security, status
from fastapi.security import (
    OAuth2PasswordBearer,
    OAuth2PasswordRequestForm,
    SecurityScopes,
)
from jwt.exceptions import InvalidTokenError
from pwdlib import PasswordHash
from pydantic import BaseModel, ValidationError

# to get a string like this run:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30


fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
        "disabled": False,
    },
    "alice": {
        "username": "alice",
        "full_name": "Alice Chains",
        "email": "alicechains@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
        "disabled": True,
    },
}


class Token(BaseModel):
    access_token: str
    token_type: str


class TokenData(BaseModel):
    username: str | None = None
    scopes: list[str] = []


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    hashed_password: str


password_hash = PasswordHash.recommended()

oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl="token",
    scopes={"me": "Read information about the current user.", "items": "Read items."},
)

app = FastAPI()


def verify_password(plain_password, hashed_password):
    return password_hash.verify(plain_password, hashed_password)


def get_password_hash(password):
    return password_hash.hash(password)


def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)


def authenticate_user(fake_db, username: str, password: str):
    user = get_user(fake_db, username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user


def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


async def get_current_user(
    security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
):
    if security_scopes.scopes:
        authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
    else:
        authenticate_value = "Bearer"
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": authenticate_value},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise credentials_exception
        scope: str = payload.get("scope", "")
        token_scopes = scope.split(" ")
        token_data = TokenData(scopes=token_scopes, username=username)
    except (InvalidTokenError, ValidationError):
        raise credentials_exception
    user = get_user(fake_users_db, username=token_data.username)
    if user is None:
        raise credentials_exception
    for scope in security_scopes.scopes:
        if scope not in token_data.scopes:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not enough permissions",
                headers={"WWW-Authenticate": authenticate_value},
            )
    return user


async def get_current_active_user(
    current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


@app.post("/token")
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
) -> Token:
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username, "scope": " ".join(form_data.scopes)},
        expires_delta=access_token_expires,
    )
    return Token(access_token=access_token, token_type="bearer")


@app.get("/users/me/", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return current_user


@app.get("/users/me/items/")
async def read_own_items(
    current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
):
    return [{"item_id": "Foo", "owner": current_user.username}]


@app.get("/status/")
async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
    return {"status": "ok"}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Now let's review those changes step by step.
OAuth2 Security schemeÂ¶

The first change is that now we are declaring the OAuth2 security scheme with two available scopes, me and items.

The scopes parameter receives a dict with each scope as a key and the description as the value:
Python 3.10+

from datetime import datetime, timedelta, timezone
from typing import Annotated

import jwt
from fastapi import Depends, FastAPI, HTTPException, Security, status
from fastapi.security import (
    OAuth2PasswordBearer,
    OAuth2PasswordRequestForm,
    SecurityScopes,
)
from jwt.exceptions import InvalidTokenError
from pwdlib import PasswordHash
from pydantic import BaseModel, ValidationError

# to get a string like this run:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30


fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
        "disabled": False,
    },
    "alice": {
        "username": "alice",
        "full_name": "Alice Chains",
        "email": "alicechains@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
        "disabled": True,
    },
}


class Token(BaseModel):
    access_token: str
    token_type: str


class TokenData(BaseModel):
    username: str | None = None
    scopes: list[str] = []


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    hashed_password: str


password_hash = PasswordHash.recommended()

oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl="token",
    scopes={"me": "Read information about the current user.", "items": "Read items."},
)

app = FastAPI()


def verify_password(plain_password, hashed_password):
    return password_hash.verify(plain_password, hashed_password)


def get_password_hash(password):
    return password_hash.hash(password)


def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)


def authenticate_user(fake_db, username: str, password: str):
    user = get_user(fake_db, username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user


def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


async def get_current_user(
    security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
):
    if security_scopes.scopes:
        authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
    else:
        authenticate_value = "Bearer"
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": authenticate_value},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise credentials_exception
        scope: str = payload.get("scope", "")
        token_scopes = scope.split(" ")
        token_data = TokenData(scopes=token_scopes, username=username)
    except (InvalidTokenError, ValidationError):
        raise credentials_exception
    user = get_user(fake_users_db, username=token_data.username)
    if user is None:
        raise credentials_exception
    for scope in security_scopes.scopes:
        if scope not in token_data.scopes:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not enough permissions",
                headers={"WWW-Authenticate": authenticate_value},
            )
    return user


async def get_current_active_user(
    current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


@app.post("/token")
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
) -> Token:
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username, "scope": " ".join(form_data.scopes)},
        expires_delta=access_token_expires,
    )
    return Token(access_token=access_token, token_type="bearer")


@app.get("/users/me/", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return current_user


@app.get("/users/me/items/")
async def read_own_items(
    current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
):
    return [{"item_id": "Foo", "owner": current_user.username}]


@app.get("/status/")
async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
    return {"status": "ok"}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Because we are now declaring those scopes, they will show up in the API docs when you log-in/authorize.

And you will be able to select which scopes you want to give access to: me and items.

This is the same mechanism used when you give permissions while logging in with Facebook, Google, GitHub, etc:

JWT token with scopesÂ¶

Now, modify the token path operation to return the scopes requested.

We are still using the same OAuth2PasswordRequestForm. It includes a property scopes with a list of str, with each scope it received in the request.

And we return the scopes as part of the JWT token.

Danger

For simplicity, here we are just adding the scopes received directly to the token.

But in your application, for security, you should make sure you only add the scopes that the user is actually able to have, or the ones you have predefined.
Python 3.10+

from datetime import datetime, timedelta, timezone
from typing import Annotated

import jwt
from fastapi import Depends, FastAPI, HTTPException, Security, status
from fastapi.security import (
    OAuth2PasswordBearer,
    OAuth2PasswordRequestForm,
    SecurityScopes,
)
from jwt.exceptions import InvalidTokenError
from pwdlib import PasswordHash
from pydantic import BaseModel, ValidationError

# to get a string like this run:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30


fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
        "disabled": False,
    },
    "alice": {
        "username": "alice",
        "full_name": "Alice Chains",
        "email": "alicechains@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
        "disabled": True,
    },
}


class Token(BaseModel):
    access_token: str
    token_type: str


class TokenData(BaseModel):
    username: str | None = None
    scopes: list[str] = []


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    hashed_password: str


password_hash = PasswordHash.recommended()

oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl="token",
    scopes={"me": "Read information about the current user.", "items": "Read items."},
)

app = FastAPI()


def verify_password(plain_password, hashed_password):
    return password_hash.verify(plain_password, hashed_password)


def get_password_hash(password):
    return password_hash.hash(password)


def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)


def authenticate_user(fake_db, username: str, password: str):
    user = get_user(fake_db, username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user


def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


async def get_current_user(
    security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
):
    if security_scopes.scopes:
        authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
    else:
        authenticate_value = "Bearer"
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": authenticate_value},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise credentials_exception
        scope: str = payload.get("scope", "")
        token_scopes = scope.split(" ")
        token_data = TokenData(scopes=token_scopes, username=username)
    except (InvalidTokenError, ValidationError):
        raise credentials_exception
    user = get_user(fake_users_db, username=token_data.username)
    if user is None:
        raise credentials_exception
    for scope in security_scopes.scopes:
        if scope not in token_data.scopes:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not enough permissions",
                headers={"WWW-Authenticate": authenticate_value},
            )
    return user


async def get_current_active_user(
    current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


@app.post("/token")
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
) -> Token:
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username, "scope": " ".join(form_data.scopes)},
        expires_delta=access_token_expires,
    )
    return Token(access_token=access_token, token_type="bearer")


@app.get("/users/me/", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return current_user


@app.get("/users/me/items/")
async def read_own_items(
    current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
):
    return [{"item_id": "Foo", "owner": current_user.username}]


@app.get("/status/")
async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
    return {"status": "ok"}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Declare scopes in path operations and dependenciesÂ¶

Now we declare that the path operation for /users/me/items/ requires the scope items.

For this, we import and use Security from fastapi.

You can use Security to declare dependencies (just like Depends), but Security also receives a parameter scopes with a list of scopes (strings).

In this case, we pass a dependency function get_current_active_user to Security (the same way we would do with Depends).

But we also pass a list of scopes, in this case with just one scope: items (it could have more).

And the dependency function get_current_active_user can also declare sub-dependencies, not only with Depends but also with Security. Declaring its own sub-dependency function (get_current_user), and more scope requirements.

In this case, it requires the scope me (it could require more than one scope).

Note

You don't necessarily need to add different scopes in different places.

We are doing it here to demonstrate how FastAPI handles scopes declared at different levels.
Python 3.10+

from datetime import datetime, timedelta, timezone
from typing import Annotated

import jwt
from fastapi import Depends, FastAPI, HTTPException, Security, status
from fastapi.security import (
    OAuth2PasswordBearer,
    OAuth2PasswordRequestForm,
    SecurityScopes,
)
from jwt.exceptions import InvalidTokenError
from pwdlib import PasswordHash
from pydantic import BaseModel, ValidationError

# to get a string like this run:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30


fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
        "disabled": False,
    },
    "alice": {
        "username": "alice",
        "full_name": "Alice Chains",
        "email": "alicechains@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
        "disabled": True,
    },
}


class Token(BaseModel):
    access_token: str
    token_type: str


class TokenData(BaseModel):
    username: str | None = None
    scopes: list[str] = []


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    hashed_password: str


password_hash = PasswordHash.recommended()

oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl="token",
    scopes={"me": "Read information about the current user.", "items": "Read items."},
)

app = FastAPI()


def verify_password(plain_password, hashed_password):
    return password_hash.verify(plain_password, hashed_password)


def get_password_hash(password):
    return password_hash.hash(password)


def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)


def authenticate_user(fake_db, username: str, password: str):
    user = get_user(fake_db, username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user


def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


async def get_current_user(
    security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
):
    if security_scopes.scopes:
        authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
    else:
        authenticate_value = "Bearer"
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": authenticate_value},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise credentials_exception
        scope: str = payload.get("scope", "")
        token_scopes = scope.split(" ")
        token_data = TokenData(scopes=token_scopes, username=username)
    except (InvalidTokenError, ValidationError):
        raise credentials_exception
    user = get_user(fake_users_db, username=token_data.username)
    if user is None:
        raise credentials_exception
    for scope in security_scopes.scopes:
        if scope not in token_data.scopes:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not enough permissions",
                headers={"WWW-Authenticate": authenticate_value},
            )
    return user


async def get_current_active_user(
    current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


@app.post("/token")
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
) -> Token:
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username, "scope": " ".join(form_data.scopes)},
        expires_delta=access_token_expires,
    )
    return Token(access_token=access_token, token_type="bearer")


@app.get("/users/me/", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return current_user


@app.get("/users/me/items/")
async def read_own_items(
    current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
):
    return [{"item_id": "Foo", "owner": current_user.username}]


@app.get("/status/")
async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
    return {"status": "ok"}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Technical Details

Security is actually a subclass of Depends, and it has just one extra parameter that we'll see later.

But by using Security instead of Depends, FastAPI will know that it can declare security scopes, use them internally, and document the API with OpenAPI.

But when you import Query, Path, Depends, Security and others from fastapi, those are actually functions that return special classes.
Use SecurityScopesÂ¶

Now update the dependency get_current_user.

This is the one used by the dependencies above.

Here's where we are using the same OAuth2 scheme we created before, declaring it as a dependency: oauth2_scheme.

Because this dependency function doesn't have any scope requirements itself, we can use Depends with oauth2_scheme, we don't have to use Security when we don't need to specify security scopes.

We also declare a special parameter of type SecurityScopes, imported from fastapi.security.

This SecurityScopes class is similar to Request (Request was used to get the request object directly).
Python 3.10+

from datetime import datetime, timedelta, timezone
from typing import Annotated

import jwt
from fastapi import Depends, FastAPI, HTTPException, Security, status
from fastapi.security import (
    OAuth2PasswordBearer,
    OAuth2PasswordRequestForm,
    SecurityScopes,
)
from jwt.exceptions import InvalidTokenError
from pwdlib import PasswordHash
from pydantic import BaseModel, ValidationError

# to get a string like this run:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30


fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
        "disabled": False,
    },
    "alice": {
        "username": "alice",
        "full_name": "Alice Chains",
        "email": "alicechains@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
        "disabled": True,
    },
}


class Token(BaseModel):
    access_token: str
    token_type: str


class TokenData(BaseModel):
    username: str | None = None
    scopes: list[str] = []


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    hashed_password: str


password_hash = PasswordHash.recommended()

oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl="token",
    scopes={"me": "Read information about the current user.", "items": "Read items."},
)

app = FastAPI()


def verify_password(plain_password, hashed_password):
    return password_hash.verify(plain_password, hashed_password)


def get_password_hash(password):
    return password_hash.hash(password)


def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)


def authenticate_user(fake_db, username: str, password: str):
    user = get_user(fake_db, username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user


def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


async def get_current_user(
    security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
):
    if security_scopes.scopes:
        authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
    else:
        authenticate_value = "Bearer"
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": authenticate_value},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise credentials_exception
        scope: str = payload.get("scope", "")
        token_scopes = scope.split(" ")
        token_data = TokenData(scopes=token_scopes, username=username)
    except (InvalidTokenError, ValidationError):
        raise credentials_exception
    user = get_user(fake_users_db, username=token_data.username)
    if user is None:
        raise credentials_exception
    for scope in security_scopes.scopes:
        if scope not in token_data.scopes:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not enough permissions",
                headers={"WWW-Authenticate": authenticate_value},
            )
    return user


async def get_current_active_user(
    current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


@app.post("/token")
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
) -> Token:
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username, "scope": " ".join(form_data.scopes)},
        expires_delta=access_token_expires,
    )
    return Token(access_token=access_token, token_type="bearer")


@app.get("/users/me/", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return current_user


@app.get("/users/me/items/")
async def read_own_items(
    current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
):
    return [{"item_id": "Foo", "owner": current_user.username}]


@app.get("/status/")
async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
    return {"status": "ok"}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Use the scopesÂ¶

The parameter security_scopes will be of type SecurityScopes.

It will have a property scopes with a list containing all the scopes required by itself and all the dependencies that use this as a sub-dependency. That means, all the "dependants"... this might sound confusing, it is explained again later below.

The security_scopes object (of class SecurityScopes) also provides a scope_str attribute with a single string, containing those scopes separated by spaces (we are going to use it).

We create an HTTPException that we can reuse (raise) later at several points.

In this exception, we include the scopes required (if any) as a string separated by spaces (using scope_str). We put that string containing the scopes in the WWW-Authenticate header (this is part of the spec).
Python 3.10+

from datetime import datetime, timedelta, timezone
from typing import Annotated

import jwt
from fastapi import Depends, FastAPI, HTTPException, Security, status
from fastapi.security import (
    OAuth2PasswordBearer,
    OAuth2PasswordRequestForm,
    SecurityScopes,
)
from jwt.exceptions import InvalidTokenError
from pwdlib import PasswordHash
from pydantic import BaseModel, ValidationError

# to get a string like this run:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30


fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
        "disabled": False,
    },
    "alice": {
        "username": "alice",
        "full_name": "Alice Chains",
        "email": "alicechains@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
        "disabled": True,
    },
}


class Token(BaseModel):
    access_token: str
    token_type: str


class TokenData(BaseModel):
    username: str | None = None
    scopes: list[str] = []


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    hashed_password: str


password_hash = PasswordHash.recommended()

oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl="token",
    scopes={"me": "Read information about the current user.", "items": "Read items."},
)

app = FastAPI()


def verify_password(plain_password, hashed_password):
    return password_hash.verify(plain_password, hashed_password)


def get_password_hash(password):
    return password_hash.hash(password)


def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)


def authenticate_user(fake_db, username: str, password: str):
    user = get_user(fake_db, username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user


def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


async def get_current_user(
    security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
):
    if security_scopes.scopes:
        authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
    else:
        authenticate_value = "Bearer"
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": authenticate_value},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise credentials_exception
        scope: str = payload.get("scope", "")
        token_scopes = scope.split(" ")
        token_data = TokenData(scopes=token_scopes, username=username)
    except (InvalidTokenError, ValidationError):
        raise credentials_exception
    user = get_user(fake_users_db, username=token_data.username)
    if user is None:
        raise credentials_exception
    for scope in security_scopes.scopes:
        if scope not in token_data.scopes:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not enough permissions",
                headers={"WWW-Authenticate": authenticate_value},
            )
    return user


async def get_current_active_user(
    current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


@app.post("/token")
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
) -> Token:
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username, "scope": " ".join(form_data.scopes)},
        expires_delta=access_token_expires,
    )
    return Token(access_token=access_token, token_type="bearer")


@app.get("/users/me/", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return current_user


@app.get("/users/me/items/")
async def read_own_items(
    current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
):
    return [{"item_id": "Foo", "owner": current_user.username}]


@app.get("/status/")
async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
    return {"status": "ok"}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Verify the username and data shapeÂ¶

We verify that we get a username, and extract the scopes.

And then we validate that data with the Pydantic model (catching the ValidationError exception), and if we get an error reading the JWT token or validating the data with Pydantic, we raise the HTTPException we created before.

For that, we update the Pydantic model TokenData with a new property scopes.

By validating the data with Pydantic we can make sure that we have, for example, exactly a list of str with the scopes and a str with the username.

Instead of, for example, a dict, or something else, as it could break the application at some point later, making it a security risk.

We also verify that we have a user with that username, and if not, we raise that same exception we created before.
Python 3.10+

from datetime import datetime, timedelta, timezone
from typing import Annotated

import jwt
from fastapi import Depends, FastAPI, HTTPException, Security, status
from fastapi.security import (
    OAuth2PasswordBearer,
    OAuth2PasswordRequestForm,
    SecurityScopes,
)
from jwt.exceptions import InvalidTokenError
from pwdlib import PasswordHash
from pydantic import BaseModel, ValidationError

# to get a string like this run:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30


fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
        "disabled": False,
    },
    "alice": {
        "username": "alice",
        "full_name": "Alice Chains",
        "email": "alicechains@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
        "disabled": True,
    },
}


class Token(BaseModel):
    access_token: str
    token_type: str


class TokenData(BaseModel):
    username: str | None = None
    scopes: list[str] = []


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    hashed_password: str


password_hash = PasswordHash.recommended()

oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl="token",
    scopes={"me": "Read information about the current user.", "items": "Read items."},
)

app = FastAPI()


def verify_password(plain_password, hashed_password):
    return password_hash.verify(plain_password, hashed_password)


def get_password_hash(password):
    return password_hash.hash(password)


def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)


def authenticate_user(fake_db, username: str, password: str):
    user = get_user(fake_db, username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user


def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


async def get_current_user(
    security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
):
    if security_scopes.scopes:
        authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
    else:
        authenticate_value = "Bearer"
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": authenticate_value},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise credentials_exception
        scope: str = payload.get("scope", "")
        token_scopes = scope.split(" ")
        token_data = TokenData(scopes=token_scopes, username=username)
    except (InvalidTokenError, ValidationError):
        raise credentials_exception
    user = get_user(fake_users_db, username=token_data.username)
    if user is None:
        raise credentials_exception
    for scope in security_scopes.scopes:
        if scope not in token_data.scopes:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not enough permissions",
                headers={"WWW-Authenticate": authenticate_value},
            )
    return user


async def get_current_active_user(
    current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


@app.post("/token")
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
) -> Token:
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username, "scope": " ".join(form_data.scopes)},
        expires_delta=access_token_expires,
    )
    return Token(access_token=access_token, token_type="bearer")


@app.get("/users/me/", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return current_user


@app.get("/users/me/items/")
async def read_own_items(
    current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
):
    return [{"item_id": "Foo", "owner": current_user.username}]


@app.get("/status/")
async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
    return {"status": "ok"}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Verify the scopesÂ¶

We now verify that all the scopes required, by this dependency and all the dependants (including path operations), are included in the scopes provided in the token received, otherwise raise an HTTPException.

For this, we use security_scopes.scopes, that contains a list with all these scopes as str.
Python 3.10+

from datetime import datetime, timedelta, timezone
from typing import Annotated

import jwt
from fastapi import Depends, FastAPI, HTTPException, Security, status
from fastapi.security import (
    OAuth2PasswordBearer,
    OAuth2PasswordRequestForm,
    SecurityScopes,
)
from jwt.exceptions import InvalidTokenError
from pwdlib import PasswordHash
from pydantic import BaseModel, ValidationError

# to get a string like this run:
# openssl rand -hex 32
SECRET_KEY = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30


fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$wagCPXjifgvUFBzq4hqe3w$CYaIb8sB+wtD+Vu/P4uod1+Qof8h+1g7bbDlBID48Rc",
        "disabled": False,
    },
    "alice": {
        "username": "alice",
        "full_name": "Alice Chains",
        "email": "alicechains@example.com",
        "hashed_password": "$argon2id$v=19$m=65536,t=3,p=4$g2/AV1zwopqUntPKJavBFw$BwpRGDCyUHLvHICnwijyX8ROGoiUPwNKZ7915MeYfCE",
        "disabled": True,
    },
}


class Token(BaseModel):
    access_token: str
    token_type: str


class TokenData(BaseModel):
    username: str | None = None
    scopes: list[str] = []


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    hashed_password: str


password_hash = PasswordHash.recommended()

oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl="token",
    scopes={"me": "Read information about the current user.", "items": "Read items."},
)

app = FastAPI()


def verify_password(plain_password, hashed_password):
    return password_hash.verify(plain_password, hashed_password)


def get_password_hash(password):
    return password_hash.hash(password)


def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)


def authenticate_user(fake_db, username: str, password: str):
    user = get_user(fake_db, username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user


def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


async def get_current_user(
    security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
):
    if security_scopes.scopes:
        authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
    else:
        authenticate_value = "Bearer"
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": authenticate_value},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise credentials_exception
        scope: str = payload.get("scope", "")
        token_scopes = scope.split(" ")
        token_data = TokenData(scopes=token_scopes, username=username)
    except (InvalidTokenError, ValidationError):
        raise credentials_exception
    user = get_user(fake_users_db, username=token_data.username)
    if user is None:
        raise credentials_exception
    for scope in security_scopes.scopes:
        if scope not in token_data.scopes:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Not enough permissions",
                headers={"WWW-Authenticate": authenticate_value},
            )
    return user


async def get_current_active_user(
    current_user: Annotated[User, Security(get_current_user, scopes=["me"])],
):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


@app.post("/token")
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
) -> Token:
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username, "scope": " ".join(form_data.scopes)},
        expires_delta=access_token_expires,
    )
    return Token(access_token=access_token, token_type="bearer")


@app.get("/users/me/", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_active_user)],
):
    return current_user


@app.get("/users/me/items/")
async def read_own_items(
    current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])],
):
    return [{"item_id": "Foo", "owner": current_user.username}]


@app.get("/status/")
async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]):
    return {"status": "ok"}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Dependency tree and scopesÂ¶

Let's review again this dependency tree and the scopes.

As the get_current_active_user dependency has as a sub-dependency on get_current_user, the scope "me" declared at get_current_active_user will be included in the list of required scopes in the security_scopes.scopes passed to get_current_user.

The path operation itself also declares a scope, "items", so this will also be in the list of security_scopes.scopes passed to get_current_user.

Here's how the hierarchy of dependencies and scopes looks like:

    The path operation read_own_items has:
        Required scopes ["items"] with the dependency:
        get_current_active_user:
            The dependency function get_current_active_user has:
                Required scopes ["me"] with the dependency:
                get_current_user:
                    The dependency function get_current_user has:
                        No scopes required by itself.
                        A dependency using oauth2_scheme.
                        A security_scopes parameter of type SecurityScopes:
                            This security_scopes parameter has a property scopes with a list containing all these scopes declared above, so:
                                security_scopes.scopes will contain ["me", "items"] for the path operation read_own_items.
                                security_scopes.scopes will contain ["me"] for the path operation read_users_me, because it is declared in the dependency get_current_active_user.
                                security_scopes.scopes will contain [] (nothing) for the path operation read_system_status, because it didn't declare any Security with scopes, and its dependency, get_current_user, doesn't declare any scopes either.

Tip

The important and "magic" thing here is that get_current_user will have a different list of scopes to check for each path operation.

All depending on the scopes declared in each path operation and each dependency in the dependency tree for that specific path operation.
More details about SecurityScopesÂ¶

You can use SecurityScopes at any point, and in multiple places, it doesn't have to be at the "root" dependency.

It will always have the security scopes declared in the current Security dependencies and all the dependants for that specific path operation and that specific dependency tree.

Because the SecurityScopes will have all the scopes declared by dependants, you can use it to verify that a token has the required scopes in a central dependency function, and then declare different scope requirements in different path operations.

They will be checked independently for each path operation.
Check itÂ¶

If you open the API docs, you can authenticate and specify which scopes you want to authorize.

If you don't select any scope, you will be "authenticated", but when you try to access /users/me/ or /users/me/items/ you will get an error saying that you don't have enough permissions. You will still be able to access /status/.

And if you select the scope me but not the scope items, you will be able to access /users/me/ but not /users/me/items/.

That's what would happen to a third party application that tried to access one of these path operations with a token provided by a user, depending on how many permissions the user gave the application.
About third party integrationsÂ¶

In this example we are using the OAuth2 "password" flow.

This is appropriate when we are logging in to our own application, probably with our own frontend.

Because we can trust it to receive the username and password, as we control it.

But if you are building an OAuth2 application that others would connect to (i.e., if you are building an authentication provider equivalent to Facebook, Google, GitHub, etc.) you should use one of the other flows.

The most common is the implicit flow.

The most secure is the code flow, but it's more complex to implement as it requires more steps. As it is more complex, many providers end up suggesting the implicit flow.

Note

It's common that each authentication provider names their flows in a different way, to make it part of their brand.

But in the end, they are implementing the same OAuth2 standard.

FastAPI includes utilities for all these OAuth2 authentication flows in fastapi.security.oauth2.
Security in decorator dependenciesÂ¶

The same way you can define a list of Depends in the decorator's dependencies parameter (as explained in Dependencies in path operation decorators), you could also use Security with scopes there.
Previous
Advanced Security
Next
HTTP Basic Auth
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
HTTP Basic Auth

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
                OAuth2 scopes
                HTTP Basic Auth
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Simple HTTP Basic Auth
    Check the username
        Timing Attacks
            The time to answer helps the attackers
            A "professional" attack
            Fix it with secrets.compare_digest()
        Return the error

    FastAPI
    Learn
    Advanced User Guide
    Advanced Security

HTTP Basic AuthÂ¶

For the simplest cases, you can use HTTP Basic Auth.

In HTTP Basic Auth, the application expects a header that contains a username and a password.

If it doesn't receive it, it returns an HTTP 401 "Unauthorized" error.

And returns a header WWW-Authenticate with a value of Basic, and an optional realm parameter.

That tells the browser to show the integrated prompt for a username and password.

Then, when you type that username and password, the browser sends them in the header automatically.
Simple HTTP Basic AuthÂ¶

    Import HTTPBasic and HTTPBasicCredentials.
    Create a "security scheme" using HTTPBasic.
    Use that security with a dependency in your path operation.
    It returns an object of type HTTPBasicCredentials:
        It contains the username and password sent.

Python 3.9+

from typing import Annotated

from fastapi import Depends, FastAPI
from fastapi.security import HTTPBasic, HTTPBasicCredentials

app = FastAPI()

security = HTTPBasic()


@app.get("/users/me")
def read_current_user(credentials: Annotated[HTTPBasicCredentials, Depends(security)]):
    return {"username": credentials.username, "password": credentials.password}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

When you try to open the URL for the first time (or click the "Execute" button in the docs) the browser will ask you for your username and password:

Check the usernameÂ¶

Here's a more complete example.

Use a dependency to check if the username and password are correct.

For this, use the Python standard module secrets to check the username and password.

secrets.compare_digest() needs to take bytes or a str that only contains ASCII characters (the ones in English), this means it wouldn't work with characters like Ã¡, as in SebastiÃ¡n.

To handle that, we first convert the username and password to bytes encoding them with UTF-8.

Then we can use secrets.compare_digest() to ensure that credentials.username is "stanleyjobson", and that credentials.password is "swordfish".
Python 3.9+

import secrets
from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import HTTPBasic, HTTPBasicCredentials

app = FastAPI()

security = HTTPBasic()


def get_current_username(
    credentials: Annotated[HTTPBasicCredentials, Depends(security)],
):
    current_username_bytes = credentials.username.encode("utf8")
    correct_username_bytes = b"stanleyjobson"
    is_correct_username = secrets.compare_digest(
        current_username_bytes, correct_username_bytes
    )
    current_password_bytes = credentials.password.encode("utf8")
    correct_password_bytes = b"swordfish"
    is_correct_password = secrets.compare_digest(
        current_password_bytes, correct_password_bytes
    )
    if not (is_correct_username and is_correct_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Basic"},
        )
    return credentials.username


@app.get("/users/me")
def read_current_user(username: Annotated[str, Depends(get_current_username)]):
    return {"username": username}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

This would be similar to:

if not (credentials.username == "stanleyjobson") or not (credentials.password == "swordfish"):
    # Return some error
    ...

But by using the secrets.compare_digest() it will be secure against a type of attacks called "timing attacks".
Timing AttacksÂ¶

But what's a "timing attack"?

Let's imagine some attackers are trying to guess the username and password.

And they send a request with a username johndoe and a password love123.

Then the Python code in your application would be equivalent to something like:

if "johndoe" == "stanleyjobson" and "love123" == "swordfish":
    ...

But right at the moment Python compares the first j in johndoe to the first s in stanleyjobson, it will return False, because it already knows that those two strings are not the same, thinking that "there's no need to waste more computation comparing the rest of the letters". And your application will say "Incorrect username or password".

But then the attackers try with username stanleyjobsox and password love123.

And your application code does something like:

if "stanleyjobsox" == "stanleyjobson" and "love123" == "swordfish":
    ...

Python will have to compare the whole stanleyjobso in both stanleyjobsox and stanleyjobson before realizing that both strings are not the same. So it will take some extra microseconds to reply back "Incorrect username or password".
The time to answer helps the attackersÂ¶

At that point, by noticing that the server took some microseconds longer to send the "Incorrect username or password" response, the attackers will know that they got something right, some of the initial letters were right.

And then they can try again knowing that it's probably something more similar to stanleyjobsox than to johndoe.
A "professional" attackÂ¶

Of course, the attackers would not try all this by hand, they would write a program to do it, possibly with thousands or millions of tests per second. And they would get just one extra correct letter at a time.

But doing that, in some minutes or hours the attackers would have guessed the correct username and password, with the "help" of our application, just using the time taken to answer.
Fix it with secrets.compare_digest()Â¶

But in our code we are actually using secrets.compare_digest().

In short, it will take the same time to compare stanleyjobsox to stanleyjobson than it takes to compare johndoe to stanleyjobson. And the same for the password.

That way, using secrets.compare_digest() in your application code, it will be safe against this whole range of security attacks.
Return the errorÂ¶

After detecting that the credentials are incorrect, return an HTTPException with a status code 401 (the same returned when no credentials are provided) and add the header WWW-Authenticate to make the browser show the login prompt again:
Python 3.9+

import secrets
from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import HTTPBasic, HTTPBasicCredentials

app = FastAPI()

security = HTTPBasic()


def get_current_username(
    credentials: Annotated[HTTPBasicCredentials, Depends(security)],
):
    current_username_bytes = credentials.username.encode("utf8")
    correct_username_bytes = b"stanleyjobson"
    is_correct_username = secrets.compare_digest(
        current_username_bytes, correct_username_bytes
    )
    current_password_bytes = credentials.password.encode("utf8")
    correct_password_bytes = b"swordfish"
    is_correct_password = secrets.compare_digest(
        current_password_bytes, correct_password_bytes
    )
    if not (is_correct_username and is_correct_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Basic"},
        )
    return credentials.username


@app.get("/users/me")
def read_current_user(username: Annotated[str, Depends(get_current_username)]):
    return {"username": username}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Previous
OAuth2 scopes
Next
Using the Request Directly
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Using the Request Directly

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Details about the Request object
    Use the Request object directly
    Request documentation

    FastAPI
    Learn
    Advanced User Guide

Using the Request DirectlyÂ¶

Up to now, you have been declaring the parts of the request that you need with their types.

Taking data from:

    The path as parameters.
    Headers.
    Cookies.
    etc.

And by doing so, FastAPI is validating that data, converting it and generating documentation for your API automatically.

But there are situations where you might need to access the Request object directly.
Details about the Request objectÂ¶

As FastAPI is actually Starlette underneath, with a layer of several tools on top, you can use Starlette's Request object directly when you need to.

It would also mean that if you get data from the Request object directly (for example, read the body) it won't be validated, converted or documented (with OpenAPI, for the automatic API user interface) by FastAPI.

Although any other parameter declared normally (for example, the body with a Pydantic model) would still be validated, converted, annotated, etc.

But there are specific cases where it's useful to get the Request object.
Use the Request object directlyÂ¶

Let's imagine you want to get the client's IP address/host inside of your path operation function.

For that you need to access the request directly.
Python 3.8+

from fastapi import FastAPI, Request

app = FastAPI()


@app.get("/items/{item_id}")
def read_root(item_id: str, request: Request):
    client_host = request.client.host
    return {"client_host": client_host, "item_id": item_id}

By declaring a path operation function parameter with the type being the Request FastAPI will know to pass the Request in that parameter.

Tip

Note that in this case, we are declaring a path parameter beside the request parameter.

So, the path parameter will be extracted, validated, converted to the specified type and annotated with OpenAPI.

The same way, you can declare any other parameter as normally, and additionally, get the Request too.
Request documentationÂ¶

You can read more details about the Request object in the official Starlette documentation site.

Technical Details

You could also use from starlette.requests import Request.

FastAPI provides it directly just as a convenience for you, the developer. But it comes directly from Starlette.
Previous
HTTP Basic Auth
Next
Using Dataclasses
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs




Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
Using Dataclasses

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Dataclasses in response_model
    Dataclasses in Nested Data Structures
    Learn More
    Version

    FastAPI
    Learn
    Advanced User Guide

Using DataclassesÂ¶

FastAPI is built on top of Pydantic, and I have been showing you how to use Pydantic models to declare requests and responses.

But FastAPI also supports using dataclasses the same way:
Python 3.8+

from dataclasses import dataclass
from typing import Union

from fastapi import FastAPI


@dataclass
class Item:
    name: str
    price: float
    description: Union[str, None] = None
    tax: Union[float, None] = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    return item

This is still supported thanks to Pydantic, as it has internal support for dataclasses.

So, even with the code above that doesn't use Pydantic explicitly, FastAPI is using Pydantic to convert those standard dataclasses to Pydantic's own flavor of dataclasses.

And of course, it supports the same:

    data validation
    data serialization
    data documentation, etc.

This works the same way as with Pydantic models. And it is actually achieved in the same way underneath, using Pydantic.

Info

Keep in mind that dataclasses can't do everything Pydantic models can do.

So, you might still need to use Pydantic models.

But if you have a bunch of dataclasses laying around, this is a nice trick to use them to power a web API using FastAPI. ğŸ¤“
Dataclasses in response_modelÂ¶

You can also use dataclasses in the response_model parameter:
Python 3.8+

from dataclasses import dataclass, field
from typing import List, Union

from fastapi import FastAPI


@dataclass
class Item:
    name: str
    price: float
    tags: List[str] = field(default_factory=list)
    description: Union[str, None] = None
    tax: Union[float, None] = None


app = FastAPI()


@app.get("/items/next", response_model=Item)
async def read_next_item():
    return {
        "name": "Island In The Moon",
        "price": 12.99,
        "description": "A place to be playin' and havin' fun",
        "tags": ["breater"],
    }

The dataclass will be automatically converted to a Pydantic dataclass.

This way, its schema will show up in the API docs user interface:

Dataclasses in Nested Data StructuresÂ¶

You can also combine dataclasses with other type annotations to make nested data structures.

In some cases, you might still have to use Pydantic's version of dataclasses. For example, if you have errors with the automatically generated API documentation.

In that case, you can simply swap the standard dataclasses with pydantic.dataclasses, which is a drop-in replacement:
Python 3.8+

from dataclasses import field  # (1)
from typing import List, Union

from fastapi import FastAPI
from pydantic.dataclasses import dataclass  # (2)


@dataclass
class Item:
    name: str
    description: Union[str, None] = None


@dataclass
class Author:
    name: str
    items: List[Item] = field(default_factory=list)  # (3)


app = FastAPI()


@app.post("/authors/{author_id}/items/", response_model=Author)  # (4)
async def create_author_items(author_id: str, items: List[Item]):  # (5)
    return {"name": author_id, "items": items}  # (6)


@app.get("/authors/", response_model=List[Author])  # (7)
def get_authors():  # (8)
    return [  # (9)
        {
            "name": "Breaters",
            "items": [
                {
                    "name": "Island In The Moon",
                    "description": "A place to be playin' and havin' fun",
                },
                {"name": "Holy Buddies"},
            ],
        },
        {
            "name": "System of an Up",
            "items": [
                {
                    "name": "Salt",
                    "description": "The kombucha mushroom people's favorite",
                },
                {"name": "Pad Thai"},
                {
                    "name": "Lonely Night",
                    "description": "The mostests lonliest nightiest of allest",
                },
            ],
        },
    ]

    We still import field from standard dataclasses.

    pydantic.dataclasses is a drop-in replacement for dataclasses.

    The Author dataclass includes a list of Item dataclasses.

    The Author dataclass is used as the response_model parameter.

    You can use other standard type annotations with dataclasses as the request body.

    In this case, it's a list of Item dataclasses.

    Here we are returning a dictionary that contains items which is a list of dataclasses.

    FastAPI is still capable of serializing the data to JSON.

    Here the response_model is using a type annotation of a list of Author dataclasses.

    Again, you can combine dataclasses with standard type annotations.

    Notice that this path operation function uses regular def instead of async def.

    As always, in FastAPI you can combine def and async def as needed.

    If you need a refresher about when to use which, check out the section "In a hurry?" in the docs about async and await.

    This path operation function is not returning dataclasses (although it could), but a list of dictionaries with internal data.

    FastAPI will use the response_model parameter (that includes dataclasses) to convert the response.

You can combine dataclasses with other type annotations in many different combinations to form complex data structures.

Check the in-code annotation tips above to see more specific details.
Learn MoreÂ¶

You can also combine dataclasses with other Pydantic models, inherit from them, include them in your own models, etc.

To learn more, check the Pydantic docs about dataclasses.
VersionÂ¶

This is available since FastAPI version 0.67.0. ğŸ”–
Previous
Using the Request Directly
Next
Advanced Middleware
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
Advanced Middleware

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Adding ASGI middlewares
    Integrated middlewares
    HTTPSRedirectMiddleware
    TrustedHostMiddleware
    GZipMiddleware
    Other middlewares

    FastAPI
    Learn
    Advanced User Guide

Advanced MiddlewareÂ¶

In the main tutorial you read how to add Custom Middleware to your application.

And then you also read how to handle CORS with the CORSMiddleware.

In this section we'll see how to use other middlewares.
Adding ASGI middlewaresÂ¶

As FastAPI is based on Starlette and implements the ASGI specification, you can use any ASGI middleware.

A middleware doesn't have to be made for FastAPI or Starlette to work, as long as it follows the ASGI spec.

In general, ASGI middlewares are classes that expect to receive an ASGI app as the first argument.

So, in the documentation for third-party ASGI middlewares they will probably tell you to do something like:

from unicorn import UnicornMiddleware

app = SomeASGIApp()

new_app = UnicornMiddleware(app, some_config="rainbow")

But FastAPI (actually Starlette) provides a simpler way to do it that makes sure that the internal middlewares handle server errors and custom exception handlers work properly.

For that, you use app.add_middleware() (as in the example for CORS).

from fastapi import FastAPI
from unicorn import UnicornMiddleware

app = FastAPI()

app.add_middleware(UnicornMiddleware, some_config="rainbow")

app.add_middleware() receives a middleware class as the first argument and any additional arguments to be passed to the middleware.
Integrated middlewaresÂ¶

FastAPI includes several middlewares for common use cases, we'll see next how to use them.

Technical Details

For the next examples, you could also use from starlette.middleware.something import SomethingMiddleware.

FastAPI provides several middlewares in fastapi.middleware just as a convenience for you, the developer. But most of the available middlewares come directly from Starlette.
HTTPSRedirectMiddlewareÂ¶

Enforces that all incoming requests must either be https or wss.

Any incoming request to http or ws will be redirected to the secure scheme instead.
Python 3.8+

from fastapi import FastAPI
from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware

app = FastAPI()

app.add_middleware(HTTPSRedirectMiddleware)


@app.get("/")
async def main():
    return {"message": "Hello World"}

TrustedHostMiddlewareÂ¶

Enforces that all incoming requests have a correctly set Host header, in order to guard against HTTP Host Header attacks.
Python 3.8+

from fastapi import FastAPI
from fastapi.middleware.trustedhost import TrustedHostMiddleware

app = FastAPI()

app.add_middleware(
    TrustedHostMiddleware, allowed_hosts=["example.com", "*.example.com"]
)


@app.get("/")
async def main():
    return {"message": "Hello World"}

The following arguments are supported:

    allowed_hosts - A list of domain names that should be allowed as hostnames. Wildcard domains such as *.example.com are supported for matching subdomains. To allow any hostname either use allowed_hosts=["*"] or omit the middleware.
    www_redirect - If set to True, requests to non-www versions of the allowed hosts will be redirected to their www counterparts. Defaults to True.

If an incoming request does not validate correctly then a 400 response will be sent.
GZipMiddlewareÂ¶

Handles GZip responses for any request that includes "gzip" in the Accept-Encoding header.

The middleware will handle both standard and streaming responses.
Python 3.8+

from fastapi import FastAPI
from fastapi.middleware.gzip import GZipMiddleware

app = FastAPI()

app.add_middleware(GZipMiddleware, minimum_size=1000, compresslevel=5)


@app.get("/")
async def main():
    return "somebigcontent"

The following arguments are supported:

    minimum_size - Do not GZip responses that are smaller than this minimum size in bytes. Defaults to 500.
    compresslevel - Used during GZip compression. It is an integer ranging from 1 to 9. Defaults to 9. Lower value results in faster compression but larger file sizes, while higher value results in slower compression but smaller file sizes.

Other middlewaresÂ¶

There are many other ASGI middlewares.

For example:

    Uvicorn's ProxyHeadersMiddleware
    MessagePack

To see other available middlewares check Starlette's Middleware docs and the ASGI Awesome List.
Previous
Using Dataclasses
Next
Sub Applications - Mounts
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
Sub Applications - Mounts

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Mounting a FastAPI application
        Top-level application
        Sub-application
        Mount the sub-application
        Check the automatic API docs
        Technical Details: root_path

    FastAPI
    Learn
    Advanced User Guide

Sub Applications - MountsÂ¶

If you need to have two independent FastAPI applications, with their own independent OpenAPI and their own docs UIs, you can have a main app and "mount" one (or more) sub-application(s).
Mounting a FastAPI applicationÂ¶

"Mounting" means adding a completely "independent" application in a specific path, that then takes care of handling everything under that path, with the path operations declared in that sub-application.
Top-level applicationÂ¶

First, create the main, top-level, FastAPI application, and its path operations:
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/app")
def read_main():
    return {"message": "Hello World from main app"}


subapi = FastAPI()


@subapi.get("/sub")
def read_sub():
    return {"message": "Hello World from sub API"}


app.mount("/subapi", subapi)

Sub-applicationÂ¶

Then, create your sub-application, and its path operations.

This sub-application is just another standard FastAPI application, but this is the one that will be "mounted":
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/app")
def read_main():
    return {"message": "Hello World from main app"}


subapi = FastAPI()


@subapi.get("/sub")
def read_sub():
    return {"message": "Hello World from sub API"}


app.mount("/subapi", subapi)

Mount the sub-applicationÂ¶

In your top-level application, app, mount the sub-application, subapi.

In this case, it will be mounted at the path /subapi:
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/app")
def read_main():
    return {"message": "Hello World from main app"}


subapi = FastAPI()


@subapi.get("/sub")
def read_sub():
    return {"message": "Hello World from sub API"}


app.mount("/subapi", subapi)

Check the automatic API docsÂ¶

Now, run the fastapi command with your file:




And open the docs at http://127.0.0.1:8000/docs.

You will see the automatic API docs for the main app, including only its own path operations:

And then, open the docs for the sub-application, at http://127.0.0.1:8000/subapi/docs.

You will see the automatic API docs for the sub-application, including only its own path operations, all under the correct sub-path prefix /subapi:

If you try interacting with any of the two user interfaces, they will work correctly, because the browser will be able to talk to each specific app or sub-app.
Technical Details: root_pathÂ¶

When you mount a sub-application as described above, FastAPI will take care of communicating the mount path for the sub-application using a mechanism from the ASGI specification called a root_path.

That way, the sub-application will know to use that path prefix for the docs UI.

And the sub-application could also have its own mounted sub-applications and everything would work correctly, because FastAPI handles all these root_paths automatically.

You will learn more about the root_path and how to use it explicitly in the section about Behind a Proxy.
Previous
Advanced Middleware
Next
Behind a Proxy
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Behind a Proxy

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Proxy Forwarded Headers
        Enable Proxy Forwarded Headers
        Redirects with HTTPS
        How Proxy Forwarded Headers Work
    Proxy with a stripped path prefix
        Providing the root_path
        Checking the current root_path
        Setting the root_path in the FastAPI app
        About root_path
    About proxies with a stripped path prefix
    Testing locally with Traefik
        Check the responses
        Check the docs UI
    Additional servers
        Disable automatic server from root_path
    Mounting a sub-application

    FastAPI
    Learn
    Advanced User Guide

Behind a ProxyÂ¶

In many situations, you would use a proxy like Traefik or Nginx in front of your FastAPI app.

These proxies could handle HTTPS certificates and other things.
Proxy Forwarded HeadersÂ¶

A proxy in front of your application would normally set some headers on the fly before sending the requests to your server to let the server know that the request was forwarded by the proxy, letting it know the original (public) URL, including the domain, that it is using HTTPS, etc.

The server program (for example Uvicorn via FastAPI CLI) is capable of interpreting these headers, and then passing that information to your application.

But for security, as the server doesn't know it is behind a trusted proxy, it won't interpret those headers.

Technical Details

The proxy headers are:

    X-Forwarded-For
    X-Forwarded-Proto
    X-Forwarded-Host

Enable Proxy Forwarded HeadersÂ¶

You can start FastAPI CLI with the CLI Option --forwarded-allow-ips and pass the IP addresses that should be trusted to read those forwarded headers.

If you set it to --forwarded-allow-ips="*" it would trust all the incoming IPs.

If your server is behind a trusted proxy and only the proxy talks to it, this would make it accept whatever is the IP of that proxy.




Redirects with HTTPSÂ¶

For example, let's say you define a path operation /items/:
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/items/")
def read_items():
    return ["plumbus", "portal gun"]

If the client tries to go to /items, by default, it would be redirected to /items/.

But before setting the CLI Option --forwarded-allow-ips it could redirect to http://localhost:8000/items/.

But maybe your application is hosted at https://mysuperapp.com, and the redirection should be to https://mysuperapp.com/items/.

By setting --proxy-headers now FastAPI would be able to redirect to the right location. ğŸ˜

https://mysuperapp.com/items/

Tip

If you want to learn more about HTTPS, check the guide About HTTPS.
How Proxy Forwarded Headers WorkÂ¶

Here's a visual representation of how the proxy adds forwarded headers between the client and the application server:
FastAPI ServerProxy/Load BalancerClientFastAPI ServerProxy/Load BalancerClientProxy adds forwarded headersServer interprets headers(if --forwarded-allow-ips is set)HTTPS RequestHost: mysuperapp.comPath: /itemsHTTP RequestX-Forwarded-For: [client IP]X-Forwarded-Proto: httpsX-Forwarded-Host: mysuperapp.comPath: /itemsHTTP Responsewith correct HTTPS URLsHTTPS Response

The proxy intercepts the original client request and adds the special forwarded headers (X-Forwarded-*) before passing the request to the application server.

These headers preserve information about the original request that would otherwise be lost:

    X-Forwarded-For: The original client's IP address
    X-Forwarded-Proto: The original protocol (https)
    X-Forwarded-Host: The original host (mysuperapp.com)

When FastAPI CLI is configured with --forwarded-allow-ips, it trusts these headers and uses them, for example to generate the correct URLs in redirects.
Proxy with a stripped path prefixÂ¶

You could have a proxy that adds a path prefix to your application.

In these cases you can use root_path to configure your application.

The root_path is a mechanism provided by the ASGI specification (that FastAPI is built on, through Starlette).

The root_path is used to handle these specific cases.

And it's also used internally when mounting sub-applications.

Having a proxy with a stripped path prefix, in this case, means that you could declare a path at /app in your code, but then, you add a layer on top (the proxy) that would put your FastAPI application under a path like /api/v1.

In this case, the original path /app would actually be served at /api/v1/app.

Even though all your code is written assuming there's just /app.
Python 3.8+

from fastapi import FastAPI, Request

app = FastAPI()


@app.get("/app")
def read_main(request: Request):
    return {"message": "Hello World", "root_path": request.scope.get("root_path")}

And the proxy would be "stripping" the path prefix on the fly before transmitting the request to the app server (probably Uvicorn via FastAPI CLI), keeping your application convinced that it is being served at /app, so that you don't have to update all your code to include the prefix /api/v1.

Up to here, everything would work as normally.

But then, when you open the integrated docs UI (the frontend), it would expect to get the OpenAPI schema at /openapi.json, instead of /api/v1/openapi.json.

So, the frontend (that runs in the browser) would try to reach /openapi.json and wouldn't be able to get the OpenAPI schema.

Because we have a proxy with a path prefix of /api/v1 for our app, the frontend needs to fetch the OpenAPI schema at /api/v1/openapi.json.
Browser
Proxy on http://0.0.0.0:9999/api/v1/app
Server on http://127.0.0.1:8000/app

Tip

The IP 0.0.0.0 is commonly used to mean that the program listens on all the IPs available in that machine/server.

The docs UI would also need the OpenAPI schema to declare that this API server is located at /api/v1 (behind the proxy). For example:

{
    "openapi": "3.1.0",
    // More stuff here
    "servers": [
        {
            "url": "/api/v1"
        }
    ],
    "paths": {
            // More stuff here
    }
}

In this example, the "Proxy" could be something like Traefik. And the server would be something like FastAPI CLI with Uvicorn, running your FastAPI application.
Providing the root_pathÂ¶

To achieve this, you can use the command line option --root-path like:




If you use Hypercorn, it also has the option --root-path.

Technical Details

The ASGI specification defines a root_path for this use case.

And the --root-path command line option provides that root_path.
Checking the current root_pathÂ¶

You can get the current root_path used by your application for each request, it is part of the scope dictionary (that's part of the ASGI spec).

Here we are including it in the message just for demonstration purposes.
Python 3.8+

from fastapi import FastAPI, Request

app = FastAPI()


@app.get("/app")
def read_main(request: Request):
    return {"message": "Hello World", "root_path": request.scope.get("root_path")}

Then, if you start Uvicorn with:




The response would be something like:

{
    "message": "Hello World",
    "root_path": "/api/v1"
}

Setting the root_path in the FastAPI appÂ¶

Alternatively, if you don't have a way to provide a command line option like --root-path or equivalent, you can set the root_path parameter when creating your FastAPI app:
Python 3.8+

from fastapi import FastAPI, Request

app = FastAPI(root_path="/api/v1")


@app.get("/app")
def read_main(request: Request):
    return {"message": "Hello World", "root_path": request.scope.get("root_path")}

Passing the root_path to FastAPI would be the equivalent of passing the --root-path command line option to Uvicorn or Hypercorn.
About root_pathÂ¶

Keep in mind that the server (Uvicorn) won't use that root_path for anything else than passing it to the app.

But if you go with your browser to http://127.0.0.1:8000/app you will see the normal response:

{
    "message": "Hello World",
    "root_path": "/api/v1"
}

So, it won't expect to be accessed at http://127.0.0.1:8000/api/v1/app.

Uvicorn will expect the proxy to access Uvicorn at http://127.0.0.1:8000/app, and then it would be the proxy's responsibility to add the extra /api/v1 prefix on top.
About proxies with a stripped path prefixÂ¶

Keep in mind that a proxy with stripped path prefix is only one of the ways to configure it.

Probably in many cases the default will be that the proxy doesn't have a stripped path prefix.

In a case like that (without a stripped path prefix), the proxy would listen on something like https://myawesomeapp.com, and then if the browser goes to https://myawesomeapp.com/api/v1/app and your server (e.g. Uvicorn) listens on http://127.0.0.1:8000 the proxy (without a stripped path prefix) would access Uvicorn at the same path: http://127.0.0.1:8000/api/v1/app.
Testing locally with TraefikÂ¶

You can easily run the experiment locally with a stripped path prefix using Traefik.

Download Traefik, it's a single binary, you can extract the compressed file and run it directly from the terminal.

Then create a file traefik.toml with:

[entryPoints]
  [entryPoints.http]
    address = ":9999"

[providers]
  [providers.file]
    filename = "routes.toml"

This tells Traefik to listen on port 9999 and to use another file routes.toml.

Tip

We are using port 9999 instead of the standard HTTP port 80 so that you don't have to run it with admin (sudo) privileges.

Now create that other file routes.toml:

[http]
  [http.middlewares]

    [http.middlewares.api-stripprefix.stripPrefix]
      prefixes = ["/api/v1"]

  [http.routers]

    [http.routers.app-http]
      entryPoints = ["http"]
      service = "app"
      rule = "PathPrefix(`/api/v1`)"
      middlewares = ["api-stripprefix"]

  [http.services]

    [http.services.app]
      [http.services.app.loadBalancer]
        [[http.services.app.loadBalancer.servers]]
          url = "http://127.0.0.1:8000"

This file configures Traefik to use the path prefix /api/v1.

And then Traefik will redirect its requests to your Uvicorn running on http://127.0.0.1:8000.

Now start Traefik:




And now start your app, using the --root-path option:




Check the responsesÂ¶

Now, if you go to the URL with the port for Uvicorn: http://127.0.0.1:8000/app, you will see the normal response:

{
    "message": "Hello World",
    "root_path": "/api/v1"
}

Tip

Notice that even though you are accessing it at http://127.0.0.1:8000/app it shows the root_path of /api/v1, taken from the option --root-path.

And now open the URL with the port for Traefik, including the path prefix: http://127.0.0.1:9999/api/v1/app.

We get the same response:

{
    "message": "Hello World",
    "root_path": "/api/v1"
}

but this time at the URL with the prefix path provided by the proxy: /api/v1.

Of course, the idea here is that everyone would access the app through the proxy, so the version with the path prefix /api/v1 is the "correct" one.

And the version without the path prefix (http://127.0.0.1:8000/app), provided by Uvicorn directly, would be exclusively for the proxy (Traefik) to access it.

That demonstrates how the Proxy (Traefik) uses the path prefix and how the server (Uvicorn) uses the root_path from the option --root-path.
Check the docs UIÂ¶

But here's the fun part. âœ¨

The "official" way to access the app would be through the proxy with the path prefix that we defined. So, as we would expect, if you try the docs UI served by Uvicorn directly, without the path prefix in the URL, it won't work, because it expects to be accessed through the proxy.

You can check it at http://127.0.0.1:8000/docs:

But if we access the docs UI at the "official" URL using the proxy with port 9999, at /api/v1/docs, it works correctly! ğŸ‰

You can check it at http://127.0.0.1:9999/api/v1/docs:

Right as we wanted it. âœ”ï¸

This is because FastAPI uses this root_path to create the default server in OpenAPI with the URL provided by root_path.
Additional serversÂ¶

Warning

This is a more advanced use case. Feel free to skip it.

By default, FastAPI will create a server in the OpenAPI schema with the URL for the root_path.

But you can also provide other alternative servers, for example if you want the same docs UI to interact with both a staging and a production environment.

If you pass a custom list of servers and there's a root_path (because your API lives behind a proxy), FastAPI will insert a "server" with this root_path at the beginning of the list.

For example:
Python 3.8+

from fastapi import FastAPI, Request

app = FastAPI(
    servers=[
        {"url": "https://stag.example.com", "description": "Staging environment"},
        {"url": "https://prod.example.com", "description": "Production environment"},
    ],
    root_path="/api/v1",
)


@app.get("/app")
def read_main(request: Request):
    return {"message": "Hello World", "root_path": request.scope.get("root_path")}

Will generate an OpenAPI schema like:

{
    "openapi": "3.1.0",
    // More stuff here
    "servers": [
        {
            "url": "/api/v1"
        },
        {
            "url": "https://stag.example.com",
            "description": "Staging environment"
        },
        {
            "url": "https://prod.example.com",
            "description": "Production environment"
        }
    ],
    "paths": {
            // More stuff here
    }
}

Tip

Notice the auto-generated server with a url value of /api/v1, taken from the root_path.

In the docs UI at http://127.0.0.1:9999/api/v1/docs it would look like:

Tip

The docs UI will interact with the server that you select.
Disable automatic server from root_pathÂ¶

If you don't want FastAPI to include an automatic server using the root_path, you can use the parameter root_path_in_servers=False:
Python 3.8+

from fastapi import FastAPI, Request

app = FastAPI(
    servers=[
        {"url": "https://stag.example.com", "description": "Staging environment"},
        {"url": "https://prod.example.com", "description": "Production environment"},
    ],
    root_path="/api/v1",
    root_path_in_servers=False,
)


@app.get("/app")
def read_main(request: Request):
    return {"message": "Hello World", "root_path": request.scope.get("root_path")}

and then it won't include it in the OpenAPI schema.
Mounting a sub-applicationÂ¶

If you need to mount a sub-application (as described in Sub Applications - Mounts) while also using a proxy with root_path, you can do it normally, as you would expect.

FastAPI will internally use the root_path smartly, so it will just work. âœ¨
Previous
Sub Applications - Mounts
Next
Templates
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs




Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
Templates

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Install dependencies
    Using Jinja2Templates
    Writing templates
        Template Context Values
        Template url_for Arguments
    Templates and static files
    More details

    FastAPI
    Learn
    Advanced User Guide

TemplatesÂ¶

You can use any template engine you want with FastAPI.

A common choice is Jinja2, the same one used by Flask and other tools.

There are utilities to configure it easily that you can use directly in your FastAPI application (provided by Starlette).
Install dependenciesÂ¶

Make sure you create a virtual environment, activate it, and install jinja2:

pip install jinja2
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100%
restart â†»

Using Jinja2TemplatesÂ¶

    Import Jinja2Templates.
    Create a templates object that you can reuse later.
    Declare a Request parameter in the path operation that will return a template.
    Use the templates you created to render and return a TemplateResponse, pass the name of the template, the request object, and a "context" dictionary with key-value pairs to be used inside of the Jinja2 template.

Python 3.8+

from fastapi import FastAPI, Request
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates

app = FastAPI()

app.mount("/static", StaticFiles(directory="static"), name="static")


templates = Jinja2Templates(directory="templates")


@app.get("/items/{id}", response_class=HTMLResponse)
async def read_item(request: Request, id: str):
    return templates.TemplateResponse(
        request=request, name="item.html", context={"id": id}
    )

Note

Before FastAPI 0.108.0, Starlette 0.29.0, the name was the first parameter.

Also, before that, in previous versions, the request object was passed as part of the key-value pairs in the context for Jinja2.

Tip

By declaring response_class=HTMLResponse the docs UI will be able to know that the response will be HTML.

Technical Details

You could also use from starlette.templating import Jinja2Templates.

FastAPI provides the same starlette.templating as fastapi.templating just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with Request and StaticFiles.
Writing templatesÂ¶

Then you can write a template at templates/item.html with, for example:

<html>
<head>
    <title>Item Details</title>
    <link href="{{ url_for('static', path='/styles.css') }}" rel="stylesheet">
</head>
<body>
    <h1><a href="{{ url_for('read_item', id=id) }}">Item ID: {{ id }}</a></h1>
</body>
</html>

Template Context ValuesÂ¶

In the HTML that contains:

Item ID: {{ id }}

...it will show the id taken from the "context" dict you passed:

{"id": id}

For example, with an ID of 42, this would render:

Item ID: 42

Template url_for ArgumentsÂ¶

You can also use url_for() inside of the template, it takes as arguments the same arguments that would be used by your path operation function.

So, the section with:

<a href="{{ url_for('read_item', id=id) }}">

...will generate a link to the same URL that would be handled by the path operation function read_item(id=id).

For example, with an ID of 42, this would render:

<a href="/items/42">

Templates and static filesÂ¶

You can also use url_for() inside of the template, and use it, for example, with the StaticFiles you mounted with the name="static".

<html>
<head>
    <title>Item Details</title>
    <link href="{{ url_for('static', path='/styles.css') }}" rel="stylesheet">
</head>
<body>
    <h1><a href="{{ url_for('read_item', id=id) }}">Item ID: {{ id }}</a></h1>
</body>
</html>

In this example, it would link to a CSS file at static/styles.css with:

h1 {
    color: green;
}

And because you are using StaticFiles, that CSS file would be served automatically by your FastAPI application at the URL /static/styles.css.
More detailsÂ¶

For more details, including how to test templates, check Starlette's docs on templates.
Previous
Behind a Proxy
Next
WebSockets
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
WebSockets

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Install websockets
    WebSockets client
        In production
    Create a websocket
    Await for messages and send messages
    Try it
    Using Depends and others
        Try the WebSockets with dependencies
    Handling disconnections and multiple clients
    More info

    FastAPI
    Learn
    Advanced User Guide

WebSocketsÂ¶

You can use WebSockets with FastAPI.
Install websocketsÂ¶

Make sure you create a virtual environment, activate it, and install websockets (a Python library that makes it easy to use the "WebSocket" protocol):

pip install websockets
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100%
restart â†»

WebSockets clientÂ¶
In productionÂ¶

In your production system, you probably have a frontend created with a modern framework like React, Vue.js or Angular.

And to communicate using WebSockets with your backend you would probably use your frontend's utilities.

Or you might have a native mobile application that communicates with your WebSocket backend directly, in native code.

Or you might have any other way to communicate with the WebSocket endpoint.

But for this example, we'll use a very simple HTML document with some JavaScript, all inside a long string.

This, of course, is not optimal and you wouldn't use it for production.

In production you would have one of the options above.

But it's the simplest way to focus on the server-side of WebSockets and have a working example:
Python 3.8+

from fastapi import FastAPI, WebSocket
from fastapi.responses import HTMLResponse

app = FastAPI()

html = """
<!DOCTYPE html>
<html>
    <head>
        <title>Chat</title>
    </head>
    <body>
        <h1>WebSocket Chat</h1>
        <form action="" onsubmit="sendMessage(event)">
            <input type="text" id="messageText" autocomplete="off"/>
            <button>Send</button>
        </form>
        <ul id='messages'>
        </ul>
        <script>
            var ws = new WebSocket("ws://localhost:8000/ws");
            ws.onmessage = function(event) {
                var messages = document.getElementById('messages')
                var message = document.createElement('li')
                var content = document.createTextNode(event.data)
                message.appendChild(content)
                messages.appendChild(message)
            };
            function sendMessage(event) {
                var input = document.getElementById("messageText")
                ws.send(input.value)
                input.value = ''
                event.preventDefault()
            }
        </script>
    </body>
</html>
"""


@app.get("/")
async def get():
    return HTMLResponse(html)


@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        await websocket.send_text(f"Message text was: {data}")

Create a websocketÂ¶

In your FastAPI application, create a websocket:
Python 3.8+

from fastapi import FastAPI, WebSocket
from fastapi.responses import HTMLResponse

app = FastAPI()

html = """
<!DOCTYPE html>
<html>
    <head>
        <title>Chat</title>
    </head>
    <body>
        <h1>WebSocket Chat</h1>
        <form action="" onsubmit="sendMessage(event)">
            <input type="text" id="messageText" autocomplete="off"/>
            <button>Send</button>
        </form>
        <ul id='messages'>
        </ul>
        <script>
            var ws = new WebSocket("ws://localhost:8000/ws");
            ws.onmessage = function(event) {
                var messages = document.getElementById('messages')
                var message = document.createElement('li')
                var content = document.createTextNode(event.data)
                message.appendChild(content)
                messages.appendChild(message)
            };
            function sendMessage(event) {
                var input = document.getElementById("messageText")
                ws.send(input.value)
                input.value = ''
                event.preventDefault()
            }
        </script>
    </body>
</html>
"""


@app.get("/")
async def get():
    return HTMLResponse(html)


@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        await websocket.send_text(f"Message text was: {data}")

Technical Details

You could also use from starlette.websockets import WebSocket.

FastAPI provides the same WebSocket directly just as a convenience for you, the developer. But it comes directly from Starlette.
Await for messages and send messagesÂ¶

In your WebSocket route you can await for messages and send messages.
Python 3.8+

from fastapi import FastAPI, WebSocket
from fastapi.responses import HTMLResponse

app = FastAPI()

html = """
<!DOCTYPE html>
<html>
    <head>
        <title>Chat</title>
    </head>
    <body>
        <h1>WebSocket Chat</h1>
        <form action="" onsubmit="sendMessage(event)">
            <input type="text" id="messageText" autocomplete="off"/>
            <button>Send</button>
        </form>
        <ul id='messages'>
        </ul>
        <script>
            var ws = new WebSocket("ws://localhost:8000/ws");
            ws.onmessage = function(event) {
                var messages = document.getElementById('messages')
                var message = document.createElement('li')
                var content = document.createTextNode(event.data)
                message.appendChild(content)
                messages.appendChild(message)
            };
            function sendMessage(event) {
                var input = document.getElementById("messageText")
                ws.send(input.value)
                input.value = ''
                event.preventDefault()
            }
        </script>
    </body>
</html>
"""


@app.get("/")
async def get():
    return HTMLResponse(html)


@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        await websocket.send_text(f"Message text was: {data}")

You can receive and send binary, text, and JSON data.
Try itÂ¶

If your file is named main.py, run your application with:




Open your browser at http://127.0.0.1:8000.

You will see a simple page like:

You can type messages in the input box, and send them:

And your FastAPI application with WebSockets will respond back:

You can send (and receive) many messages:

And all of them will use the same WebSocket connection.
Using Depends and othersÂ¶

In WebSocket endpoints you can import from fastapi and use:

    Depends
    Security
    Cookie
    Header
    Path
    Query

They work the same way as for other FastAPI endpoints/path operations:
Python 3.10+

from typing import Annotated

from fastapi import (
    Cookie,
    Depends,
    FastAPI,
    Query,
    WebSocket,
    WebSocketException,
    status,
)
from fastapi.responses import HTMLResponse

app = FastAPI()

html = """
<!DOCTYPE html>
<html>
    <head>
        <title>Chat</title>
    </head>
    <body>
        <h1>WebSocket Chat</h1>
        <form action="" onsubmit="sendMessage(event)">
            <label>Item ID: <input type="text" id="itemId" autocomplete="off" value="foo"/></label>
            <label>Token: <input type="text" id="token" autocomplete="off" value="some-key-token"/></label>
            <button onclick="connect(event)">Connect</button>
            <hr>
            <label>Message: <input type="text" id="messageText" autocomplete="off"/></label>
            <button>Send</button>
        </form>
        <ul id='messages'>
        </ul>
        <script>
        var ws = null;
            function connect(event) {
                var itemId = document.getElementById("itemId")
                var token = document.getElementById("token")
                ws = new WebSocket("ws://localhost:8000/items/" + itemId.value + "/ws?token=" + token.value);
                ws.onmessage = function(event) {
                    var messages = document.getElementById('messages')
                    var message = document.createElement('li')
                    var content = document.createTextNode(event.data)
                    message.appendChild(content)
                    messages.appendChild(message)
                };
                event.preventDefault()
            }
            function sendMessage(event) {
                var input = document.getElementById("messageText")
                ws.send(input.value)
                input.value = ''
                event.preventDefault()
            }
        </script>
    </body>
</html>
"""


@app.get("/")
async def get():
    return HTMLResponse(html)


async def get_cookie_or_token(
    websocket: WebSocket,
    session: Annotated[str | None, Cookie()] = None,
    token: Annotated[str | None, Query()] = None,
):
    if session is None and token is None:
        raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
    return session or token


@app.websocket("/items/{item_id}/ws")
async def websocket_endpoint(
    *,
    websocket: WebSocket,
    item_id: str,
    q: int | None = None,
    cookie_or_token: Annotated[str, Depends(get_cookie_or_token)],
):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        await websocket.send_text(
            f"Session cookie or query token value is: {cookie_or_token}"
        )
        if q is not None:
            await websocket.send_text(f"Query parameter q is: {q}")
        await websocket.send_text(f"Message text was: {data}, for item ID: {item_id}")

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Info

As this is a WebSocket it doesn't really make sense to raise an HTTPException, instead we raise a WebSocketException.

You can use a closing code from the valid codes defined in the specification.
Try the WebSockets with dependenciesÂ¶

If your file is named main.py, run your application with:




Open your browser at http://127.0.0.1:8000.

There you can set:

    The "Item ID", used in the path.
    The "Token" used as a query parameter.

Tip

Notice that the query token will be handled by a dependency.

With that you can connect the WebSocket and then send and receive messages:

Handling disconnections and multiple clientsÂ¶

When a WebSocket connection is closed, the await websocket.receive_text() will raise a WebSocketDisconnect exception, which you can then catch and handle like in this example.
Python 3.9+

from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.responses import HTMLResponse

app = FastAPI()

html = """
<!DOCTYPE html>
<html>
    <head>
        <title>Chat</title>
    </head>
    <body>
        <h1>WebSocket Chat</h1>
        <h2>Your ID: <span id="ws-id"></span></h2>
        <form action="" onsubmit="sendMessage(event)">
            <input type="text" id="messageText" autocomplete="off"/>
            <button>Send</button>
        </form>
        <ul id='messages'>
        </ul>
        <script>
            var client_id = Date.now()
            document.querySelector("#ws-id").textContent = client_id;
            var ws = new WebSocket(`ws://localhost:8000/ws/${client_id}`);
            ws.onmessage = function(event) {
                var messages = document.getElementById('messages')
                var message = document.createElement('li')
                var content = document.createTextNode(event.data)
                message.appendChild(content)
                messages.appendChild(message)
            };
            function sendMessage(event) {
                var input = document.getElementById("messageText")
                ws.send(input.value)
                input.value = ''
                event.preventDefault()
            }
        </script>
    </body>
</html>
"""


class ConnectionManager:
    def __init__(self):
        self.active_connections: list[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def send_personal_message(self, message: str, websocket: WebSocket):
        await websocket.send_text(message)

    async def broadcast(self, message: str):
        for connection in self.active_connections:
            await connection.send_text(message)


manager = ConnectionManager()


@app.get("/")
async def get():
    return HTMLResponse(html)


@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: int):
    await manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            await manager.send_personal_message(f"You wrote: {data}", websocket)
            await manager.broadcast(f"Client #{client_id} says: {data}")
    except WebSocketDisconnect:
        manager.disconnect(websocket)
        await manager.broadcast(f"Client #{client_id} left the chat")

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

To try it out:

    Open the app with several browser tabs.
    Write messages from them.
    Then close one of the tabs.

That will raise the WebSocketDisconnect exception, and all the other clients will receive a message like:

Client #1596980209979 left the chat

Tip

The app above is a minimal and simple example to demonstrate how to handle and broadcast messages to several WebSocket connections.

But keep in mind that, as everything is handled in memory, in a single list, it will only work while the process is running, and will only work with a single process.

If you need something easy to integrate with FastAPI but that is more robust, supported by Redis, PostgreSQL or others, check encode/broadcaster.
More infoÂ¶

To learn more about the options, check Starlette's documentation for:

    The WebSocket class.
    Class-based WebSocket handling.

Previous
Templates
Next
Lifespan Events
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
Lifespan Events

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Use Case
    Lifespan
        Lifespan function
        Async Context Manager
    Alternative Events (deprecated)
        startup event
        shutdown event
        startup and shutdown together
    Technical Details
    Sub Applications

    FastAPI
    Learn
    Advanced User Guide

Lifespan EventsÂ¶

You can define logic (code) that should be executed before the application starts up. This means that this code will be executed once, before the application starts receiving requests.

The same way, you can define logic (code) that should be executed when the application is shutting down. In this case, this code will be executed once, after having handled possibly many requests.

Because this code is executed before the application starts taking requests, and right after it finishes handling requests, it covers the whole application lifespan (the word "lifespan" will be important in a second ğŸ˜‰).

This can be very useful for setting up resources that you need to use for the whole app, and that are shared among requests, and/or that you need to clean up afterwards. For example, a database connection pool, or loading a shared machine learning model.
Use CaseÂ¶

Let's start with an example use case and then see how to solve it with this.

Let's imagine that you have some machine learning models that you want to use to handle requests. ğŸ¤–

The same models are shared among requests, so, it's not one model per request, or one per user or something similar.

Let's imagine that loading the model can take quite some time, because it has to read a lot of data from disk. So you don't want to do it for every request.

You could load it at the top level of the module/file, but that would also mean that it would load the model even if you are just running a simple automated test, then that test would be slow because it would have to wait for the model to load before being able to run an independent part of the code.

That's what we'll solve, let's load the model before the requests are handled, but only right before the application starts receiving requests, not while the code is being loaded.
LifespanÂ¶

You can define this startup and shutdown logic using the lifespan parameter of the FastAPI app, and a "context manager" (I'll show you what that is in a second).

Let's start with an example and then see it in detail.

We create an async function lifespan() with yield like this:
Python 3.8+

from contextlib import asynccontextmanager

from fastapi import FastAPI


def fake_answer_to_everything_ml_model(x: float):
    return x * 42


ml_models = {}


@asynccontextmanager
async def lifespan(app: FastAPI):
    # Load the ML model
    ml_models["answer_to_everything"] = fake_answer_to_everything_ml_model
    yield
    # Clean up the ML models and release the resources
    ml_models.clear()


app = FastAPI(lifespan=lifespan)


@app.get("/predict")
async def predict(x: float):
    result = ml_models["answer_to_everything"](x)
    return {"result": result}

Here we are simulating the expensive startup operation of loading the model by putting the (fake) model function in the dictionary with machine learning models before the yield. This code will be executed before the application starts taking requests, during the startup.

And then, right after the yield, we unload the model. This code will be executed after the application finishes handling requests, right before the shutdown. This could, for example, release resources like memory or a GPU.

Tip

The shutdown would happen when you are stopping the application.

Maybe you need to start a new version, or you just got tired of running it. ğŸ¤·
Lifespan functionÂ¶

The first thing to notice, is that we are defining an async function with yield. This is very similar to Dependencies with yield.
Python 3.8+

from contextlib import asynccontextmanager

from fastapi import FastAPI


def fake_answer_to_everything_ml_model(x: float):
    return x * 42


ml_models = {}


@asynccontextmanager
async def lifespan(app: FastAPI):
    # Load the ML model
    ml_models["answer_to_everything"] = fake_answer_to_everything_ml_model
    yield
    # Clean up the ML models and release the resources
    ml_models.clear()


app = FastAPI(lifespan=lifespan)


@app.get("/predict")
async def predict(x: float):
    result = ml_models["answer_to_everything"](x)
    return {"result": result}

The first part of the function, before the yield, will be executed before the application starts.

And the part after the yield will be executed after the application has finished.
Async Context ManagerÂ¶

If you check, the function is decorated with an @asynccontextmanager.

That converts the function into something called an "async context manager".
Python 3.8+

from contextlib import asynccontextmanager

from fastapi import FastAPI


def fake_answer_to_everything_ml_model(x: float):
    return x * 42


ml_models = {}


@asynccontextmanager
async def lifespan(app: FastAPI):
    # Load the ML model
    ml_models["answer_to_everything"] = fake_answer_to_everything_ml_model
    yield
    # Clean up the ML models and release the resources
    ml_models.clear()


app = FastAPI(lifespan=lifespan)


@app.get("/predict")
async def predict(x: float):
    result = ml_models["answer_to_everything"](x)
    return {"result": result}

A context manager in Python is something that you can use in a with statement, for example, open() can be used as a context manager:

with open("file.txt") as file:
    file.read()

In recent versions of Python, there's also an async context manager. You would use it with async with:

async with lifespan(app):
    await do_stuff()

When you create a context manager or an async context manager like above, what it does is that, before entering the with block, it will execute the code before the yield, and after exiting the with block, it will execute the code after the yield.

In our code example above, we don't use it directly, but we pass it to FastAPI for it to use it.

The lifespan parameter of the FastAPI app takes an async context manager, so we can pass our new lifespan async context manager to it.
Python 3.8+

from contextlib import asynccontextmanager

from fastapi import FastAPI


def fake_answer_to_everything_ml_model(x: float):
    return x * 42


ml_models = {}


@asynccontextmanager
async def lifespan(app: FastAPI):
    # Load the ML model
    ml_models["answer_to_everything"] = fake_answer_to_everything_ml_model
    yield
    # Clean up the ML models and release the resources
    ml_models.clear()


app = FastAPI(lifespan=lifespan)


@app.get("/predict")
async def predict(x: float):
    result = ml_models["answer_to_everything"](x)
    return {"result": result}

Alternative Events (deprecated)Â¶

Warning

The recommended way to handle the startup and shutdown is using the lifespan parameter of the FastAPI app as described above. If you provide a lifespan parameter, startup and shutdown event handlers will no longer be called. It's all lifespan or all events, not both.

You can probably skip this part.

There's an alternative way to define this logic to be executed during startup and during shutdown.

You can define event handlers (functions) that need to be executed before the application starts up, or when the application is shutting down.

These functions can be declared with async def or normal def.
startup eventÂ¶

To add a function that should be run before the application starts, declare it with the event "startup":
Python 3.8+

from fastapi import FastAPI

app = FastAPI()

items = {}


@app.on_event("startup")
async def startup_event():
    items["foo"] = {"name": "Fighters"}
    items["bar"] = {"name": "Tenders"}


@app.get("/items/{item_id}")
async def read_items(item_id: str):
    return items[item_id]

In this case, the startup event handler function will initialize the items "database" (just a dict) with some values.

You can add more than one event handler function.

And your application won't start receiving requests until all the startup event handlers have completed.
shutdown eventÂ¶

To add a function that should be run when the application is shutting down, declare it with the event "shutdown":
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.on_event("shutdown")
def shutdown_event():
    with open("log.txt", mode="a") as log:
        log.write("Application shutdown")


@app.get("/items/")
async def read_items():
    return [{"name": "Foo"}]

Here, the shutdown event handler function will write a text line "Application shutdown" to a file log.txt.

Info

In the open() function, the mode="a" means "append", so, the line will be added after whatever is on that file, without overwriting the previous contents.

Tip

Notice that in this case we are using a standard Python open() function that interacts with a file.

So, it involves I/O (input/output), that requires "waiting" for things to be written to disk.

But open() doesn't use async and await.

So, we declare the event handler function with standard def instead of async def.
startup and shutdown togetherÂ¶

There's a high chance that the logic for your startup and shutdown is connected, you might want to start something and then finish it, acquire a resource and then release it, etc.

Doing that in separated functions that don't share logic or variables together is more difficult as you would need to store values in global variables or similar tricks.

Because of that, it's now recommended to instead use the lifespan as explained above.
Technical DetailsÂ¶

Just a technical detail for the curious nerds. ğŸ¤“

Underneath, in the ASGI technical specification, this is part of the Lifespan Protocol, and it defines events called startup and shutdown.

Info

You can read more about the Starlette lifespan handlers in Starlette's Lifespan' docs.

Including how to handle lifespan state that can be used in other areas of your code.
Sub ApplicationsÂ¶

ğŸš¨ Keep in mind that these lifespan events (startup and shutdown) will only be executed for the main application, not for Sub Applications - Mounts.
Previous
WebSockets
Next
Testing WebSockets
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
Testing WebSockets

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

    FastAPI
    Learn
    Advanced User Guide

Testing WebSocketsÂ¶

You can use the same TestClient to test WebSockets.

For this, you use the TestClient in a with statement, connecting to the WebSocket:
Python 3.8+

from fastapi import FastAPI
from fastapi.testclient import TestClient
from fastapi.websockets import WebSocket

app = FastAPI()


@app.get("/")
async def read_main():
    return {"msg": "Hello World"}


@app.websocket("/ws")
async def websocket(websocket: WebSocket):
    await websocket.accept()
    await websocket.send_json({"msg": "Hello WebSocket"})
    await websocket.close()


def test_read_main():
    client = TestClient(app)
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"msg": "Hello World"}


def test_websocket():
    client = TestClient(app)
    with client.websocket_connect("/ws") as websocket:
        data = websocket.receive_json()
        assert data == {"msg": "Hello WebSocket"}

Note

For more details, check Starlette's documentation for testing WebSockets.
Previous
Lifespan Events
Next
Testing Events: lifespan and startup - shutdown
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
Testing Events: lifespan and startup - shutdown

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

    FastAPI
    Learn
    Advanced User Guide

Testing Events: lifespan and startup - shutdownÂ¶

When you need lifespan to run in your tests, you can use the TestClient with a with statement:
Python 3.8+

from contextlib import asynccontextmanager

from fastapi import FastAPI
from fastapi.testclient import TestClient

items = {}


@asynccontextmanager
async def lifespan(app: FastAPI):
    items["foo"] = {"name": "Fighters"}
    items["bar"] = {"name": "Tenders"}
    yield
    # clean up items
    items.clear()


app = FastAPI(lifespan=lifespan)


@app.get("/items/{item_id}")
async def read_items(item_id: str):
    return items[item_id]


def test_read_items():
    # Before the lifespan starts, "items" is still empty
    assert items == {}

    with TestClient(app) as client:
        # Inside the "with TestClient" block, the lifespan starts and items added
        assert items == {"foo": {"name": "Fighters"}, "bar": {"name": "Tenders"}}

        response = client.get("/items/foo")
        assert response.status_code == 200
        assert response.json() == {"name": "Fighters"}

        # After the requests is done, the items are still there
        assert items == {"foo": {"name": "Fighters"}, "bar": {"name": "Tenders"}}

    # The end of the "with TestClient" block simulates terminating the app, so
    # the lifespan ends and items are cleaned up
    assert items == {}

You can read more details about the "Running lifespan in tests in the official Starlette documentation site."

For the deprecated startup and shutdown events, you can use the TestClient as follows:
Python 3.8+

from fastapi import FastAPI
from fastapi.testclient import TestClient

app = FastAPI()

items = {}


@app.on_event("startup")
async def startup_event():
    items["foo"] = {"name": "Fighters"}
    items["bar"] = {"name": "Tenders"}


@app.get("/items/{item_id}")
async def read_items(item_id: str):
    return items[item_id]


def test_read_items():
    with TestClient(app) as client:
        response = client.get("/items/foo")
        assert response.status_code == 200
        assert response.json() == {"name": "Fighters"}

Previous
Testing WebSockets
Next
Testing Dependencies with Overrides
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
Testing Dependencies with Overrides

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Overriding dependencies during testing
        Use cases: external service
        Use the app.dependency_overrides attribute

    FastAPI
    Learn
    Advanced User Guide

Testing Dependencies with OverridesÂ¶
Overriding dependencies during testingÂ¶

There are some scenarios where you might want to override a dependency during testing.

You don't want the original dependency to run (nor any of the sub-dependencies it might have).

Instead, you want to provide a different dependency that will be used only during tests (possibly only some specific tests), and will provide a value that can be used where the value of the original dependency was used.
Use cases: external serviceÂ¶

An example could be that you have an external authentication provider that you need to call.

You send it a token and it returns an authenticated user.

This provider might be charging you per request, and calling it might take some extra time than if you had a fixed mock user for tests.

You probably want to test the external provider once, but not necessarily call it for every test that runs.

In this case, you can override the dependency that calls that provider, and use a custom dependency that returns a mock user, only for your tests.
Use the app.dependency_overrides attributeÂ¶

For these cases, your FastAPI application has an attribute app.dependency_overrides, it is a simple dict.

To override a dependency for testing, you put as a key the original dependency (a function), and as the value, your dependency override (another function).

And then FastAPI will call that override instead of the original dependency.
Python 3.10+

from typing import Annotated

from fastapi import Depends, FastAPI
from fastapi.testclient import TestClient

app = FastAPI()


async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}


@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    return {"message": "Hello Items!", "params": commons}


@app.get("/users/")
async def read_users(commons: Annotated[dict, Depends(common_parameters)]):
    return {"message": "Hello Users!", "params": commons}


client = TestClient(app)


async def override_dependency(q: str | None = None):
    return {"q": q, "skip": 5, "limit": 10}


app.dependency_overrides[common_parameters] = override_dependency


def test_override_in_items():
    response = client.get("/items/")
    assert response.status_code == 200
    assert response.json() == {
        "message": "Hello Items!",
        "params": {"q": None, "skip": 5, "limit": 10},
    }


def test_override_in_items_with_q():
    response = client.get("/items/?q=foo")
    assert response.status_code == 200
    assert response.json() == {
        "message": "Hello Items!",
        "params": {"q": "foo", "skip": 5, "limit": 10},
    }


def test_override_in_items_with_params():
    response = client.get("/items/?q=foo&skip=100&limit=200")
    assert response.status_code == 200
    assert response.json() == {
        "message": "Hello Items!",
        "params": {"q": "foo", "skip": 5, "limit": 10},
    }

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Tip

You can set a dependency override for a dependency used anywhere in your FastAPI application.

The original dependency could be used in a path operation function, a path operation decorator (when you don't use the return value), a .include_router() call, etc.

FastAPI will still be able to override it.

Then you can reset your overrides (remove them) by setting app.dependency_overrides to be an empty dict:

app.dependency_overrides = {}

Tip

If you want to override a dependency only during some tests, you can set the override at the beginning of the test (inside the test function) and reset it at the end (at the end of the test function).
Previous
Testing Events: lifespan and startup - shutdown
Next
Async Tests
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Async Tests

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    pytest.mark.anyio
    HTTPX
    Example
    Run it
    In Detail
    Other Asynchronous Function Calls

    FastAPI
    Learn
    Advanced User Guide

Async TestsÂ¶

You have already seen how to test your FastAPI applications using the provided TestClient. Up to now, you have only seen how to write synchronous tests, without using async functions.

Being able to use asynchronous functions in your tests could be useful, for example, when you're querying your database asynchronously. Imagine you want to test sending requests to your FastAPI application and then verify that your backend successfully wrote the correct data in the database, while using an async database library.

Let's look at how we can make that work.
pytest.mark.anyioÂ¶

If we want to call asynchronous functions in our tests, our test functions have to be asynchronous. AnyIO provides a neat plugin for this, that allows us to specify that some test functions are to be called asynchronously.
HTTPXÂ¶

Even if your FastAPI application uses normal def functions instead of async def, it is still an async application underneath.

The TestClient does some magic inside to call the asynchronous FastAPI application in your normal def test functions, using standard pytest. But that magic doesn't work anymore when we're using it inside asynchronous functions. By running our tests asynchronously, we can no longer use the TestClient inside our test functions.

The TestClient is based on HTTPX, and luckily, we can use it directly to test the API.
ExampleÂ¶

For a simple example, let's consider a file structure similar to the one described in Bigger Applications and Testing:

.
â”œâ”€â”€ app
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py
â”‚   â””â”€â”€ test_main.py

The file main.py would have:
Python 3.8+

from fastapi import FastAPI

app = FastAPI()


@app.get("/")
async def root():
    return {"message": "Tomato"}

The file test_main.py would have the tests for main.py, it could look like this now:
Python 3.8+

import pytest
from httpx import ASGITransport, AsyncClient

from .main import app


@pytest.mark.anyio
async def test_root():
    async with AsyncClient(
        transport=ASGITransport(app=app), base_url="http://test"
    ) as ac:
        response = await ac.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "Tomato"}

Run itÂ¶

You can run your tests as usual via:



In DetailÂ¶

The marker @pytest.mark.anyio tells pytest that this test function should be called asynchronously:
Python 3.8+

import pytest
from httpx import ASGITransport, AsyncClient

from .main import app


@pytest.mark.anyio
async def test_root():
    async with AsyncClient(
        transport=ASGITransport(app=app), base_url="http://test"
    ) as ac:
        response = await ac.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "Tomato"}

Tip

Note that the test function is now async def instead of just def as before when using the TestClient.

Then we can create an AsyncClient with the app, and send async requests to it, using await.
Python 3.8+

import pytest
from httpx import ASGITransport, AsyncClient

from .main import app


@pytest.mark.anyio
async def test_root():
    async with AsyncClient(
        transport=ASGITransport(app=app), base_url="http://test"
    ) as ac:
        response = await ac.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "Tomato"}

This is the equivalent to:

response = client.get('/')

...that we used to make our requests with the TestClient.

Tip

Note that we're using async/await with the new AsyncClient - the request is asynchronous.

Warning

If your application relies on lifespan events, the AsyncClient won't trigger these events. To ensure they are triggered, use LifespanManager from florimondmanca/asgi-lifespan.
Other Asynchronous Function CallsÂ¶

As the testing function is now asynchronous, you can now also call (and await) other async functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code.

Tip

If you encounter a RuntimeError: Task attached to a different loop when integrating asynchronous function calls in your tests (e.g. when using MongoDB's MotorClient), remember to instantiate objects that need an event loop only within async functions, e.g. an @app.on_event("startup") callback.
Previous
Testing Dependencies with Overrides
Next
Settings and Environment Variables
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
Settings and Environment Variables

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Types and validation
    Pydantic Settings
        Install pydantic-settings
        Create the Settings object
        Use the settings
        Run the server
    Settings in another module
    Settings in a dependency
        The config file
        The main app file
        Settings and testing
    Reading a .env file
        The .env file
        Read settings from .env
        Creating the Settings only once with lru_cache
            lru_cache Technical Details
    Recap

    FastAPI
    Learn
    Advanced User Guide

Settings and Environment VariablesÂ¶

In many cases your application could need some external settings or configurations, for example secret keys, database credentials, credentials for email services, etc.

Most of these settings are variable (can change), like database URLs. And many could be sensitive, like secrets.

For this reason it's common to provide them in environment variables that are read by the application.

Tip

To understand environment variables you can read Environment Variables.
Types and validationÂ¶

These environment variables can only handle text strings, as they are external to Python and have to be compatible with other programs and the rest of the system (and even with different operating systems, as Linux, Windows, macOS).

That means that any value read in Python from an environment variable will be a str, and any conversion to a different type or any validation has to be done in code.
Pydantic SettingsÂ¶

Fortunately, Pydantic provides a great utility to handle these settings coming from environment variables with Pydantic: Settings management.
Install pydantic-settingsÂ¶

First, make sure you create your virtual environment, activate it, and then install the pydantic-settings package:


It also comes included when you install the all extras with:


Info

In Pydantic v1 it came included with the main package. Now it is distributed as this independent package so that you can choose to install it or not if you don't need that functionality.
Create the Settings objectÂ¶

Import BaseSettings from Pydantic and create a sub-class, very much like with a Pydantic model.

The same way as with Pydantic models, you declare class attributes with type annotations, and possibly default values.

You can use all the same validation features and tools you use for Pydantic models, like different data types and additional validations with Field().
Pydantic v2
Pydantic v1
Python 3.8+

from fastapi import FastAPI
from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    app_name: str = "Awesome API"
    admin_email: str
    items_per_user: int = 50


settings = Settings()
app = FastAPI()


@app.get("/info")
async def info():
    return {
        "app_name": settings.app_name,
        "admin_email": settings.admin_email,
        "items_per_user": settings.items_per_user,
    }

Tip

If you want something quick to copy and paste, don't use this example, use the last one below.

Then, when you create an instance of that Settings class (in this case, in the settings object), Pydantic will read the environment variables in a case-insensitive way, so, an upper-case variable APP_NAME will still be read for the attribute app_name.

Next it will convert and validate the data. So, when you use that settings object, you will have data of the types you declared (e.g. items_per_user will be an int).
Use the settingsÂ¶

Then you can use the new settings object in your application:
Python 3.8+

from fastapi import FastAPI
from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    app_name: str = "Awesome API"
    admin_email: str
    items_per_user: int = 50


settings = Settings()
app = FastAPI()


@app.get("/info")
async def info():
    return {
        "app_name": settings.app_name,
        "admin_email": settings.admin_email,
        "items_per_user": settings.items_per_user,
    }

Run the serverÂ¶

Next, you would run the server passing the configurations as environment variables, for example you could set an ADMIN_EMAIL and APP_NAME with:




Tip

To set multiple env vars for a single command just separate them with a space, and put them all before the command.

And then the admin_email setting would be set to "deadpool@example.com".

The app_name would be "ChimichangApp".

And the items_per_user would keep its default value of 50.
Settings in another moduleÂ¶

You could put those settings in another module file as you saw in Bigger Applications - Multiple Files.

For example, you could have a file config.py with:
Python 3.8+

from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    app_name: str = "Awesome API"
    admin_email: str
    items_per_user: int = 50


settings = Settings()

And then use it in a file main.py:
Python 3.8+

from fastapi import FastAPI

from .config import settings

app = FastAPI()


@app.get("/info")
async def info():
    return {
        "app_name": settings.app_name,
        "admin_email": settings.admin_email,
        "items_per_user": settings.items_per_user,
    }

Tip

You would also need a file __init__.py as you saw in Bigger Applications - Multiple Files.
Settings in a dependencyÂ¶

In some occasions it might be useful to provide the settings from a dependency, instead of having a global object with settings that is used everywhere.

This could be especially useful during testing, as it's very easy to override a dependency with your own custom settings.
The config fileÂ¶

Coming from the previous example, your config.py file could look like:
Python 3.8+

from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    app_name: str = "Awesome API"
    admin_email: str
    items_per_user: int = 50

Notice that now we don't create a default instance settings = Settings().
The main app fileÂ¶

Now we create a dependency that returns a new config.Settings().
Python 3.8+

from functools import lru_cache
from typing import Annotated

from fastapi import Depends, FastAPI

from .config import Settings

app = FastAPI()


@lru_cache
def get_settings():
    return Settings()


@app.get("/info")
async def info(settings: Annotated[Settings, Depends(get_settings)]):
    return {
        "app_name": settings.app_name,
        "admin_email": settings.admin_email,
        "items_per_user": settings.items_per_user,
    }

Tip

We'll discuss the @lru_cache in a bit.

For now you can assume get_settings() is a normal function.

And then we can require it from the path operation function as a dependency and use it anywhere we need it.
Python 3.8+

from functools import lru_cache
from typing import Annotated

from fastapi import Depends, FastAPI

from .config import Settings

app = FastAPI()


@lru_cache
def get_settings():
    return Settings()


@app.get("/info")
async def info(settings: Annotated[Settings, Depends(get_settings)]):
    return {
        "app_name": settings.app_name,
        "admin_email": settings.admin_email,
        "items_per_user": settings.items_per_user,
    }

Settings and testingÂ¶

Then it would be very easy to provide a different settings object during testing by creating a dependency override for get_settings:
Python 3.8+

from fastapi.testclient import TestClient

from .config import Settings
from .main import app, get_settings

client = TestClient(app)


def get_settings_override():
    return Settings(admin_email="testing_admin@example.com")


app.dependency_overrides[get_settings] = get_settings_override


def test_app():
    response = client.get("/info")
    data = response.json()
    assert data == {
        "app_name": "Awesome API",
        "admin_email": "testing_admin@example.com",
        "items_per_user": 50,
    }

In the dependency override we set a new value for the admin_email when creating the new Settings object, and then we return that new object.

Then we can test that it is used.
Reading a .env fileÂ¶

If you have many settings that possibly change a lot, maybe in different environments, it might be useful to put them on a file and then read them from it as if they were environment variables.

This practice is common enough that it has a name, these environment variables are commonly placed in a file .env, and the file is called a "dotenv".

Tip

A file starting with a dot (.) is a hidden file in Unix-like systems, like Linux and macOS.

But a dotenv file doesn't really have to have that exact filename.

Pydantic has support for reading from these types of files using an external library. You can read more at Pydantic Settings: Dotenv (.env) support.

Tip

For this to work, you need to pip install python-dotenv.
The .env fileÂ¶

You could have a .env file with:

ADMIN_EMAIL="deadpool@example.com"
APP_NAME="ChimichangApp"

Read settings from .envÂ¶

And then update your config.py with:
Pydantic v2
Pydantic v1
Python 3.8+

from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    app_name: str = "Awesome API"
    admin_email: str
    items_per_user: int = 50

    model_config = SettingsConfigDict(env_file=".env")

Tip

The model_config attribute is used just for Pydantic configuration. You can read more at Pydantic: Concepts: Configuration.

Info

In Pydantic version 1 the configuration was done in an internal class Config, in Pydantic version 2 it's done in an attribute model_config. This attribute takes a dict, and to get autocompletion and inline errors you can import and use SettingsConfigDict to define that dict.

Here we define the config env_file inside of your Pydantic Settings class, and set the value to the filename with the dotenv file we want to use.
Creating the Settings only once with lru_cacheÂ¶

Reading a file from disk is normally a costly (slow) operation, so you probably want to do it only once and then reuse the same settings object, instead of reading it for each request.

But every time we do:

Settings()

a new Settings object would be created, and at creation it would read the .env file again.

If the dependency function was just like:

def get_settings():
    return Settings()

we would create that object for each request, and we would be reading the .env file for each request. âš ï¸

But as we are using the @lru_cache decorator on top, the Settings object will be created only once, the first time it's called. âœ”ï¸
Python 3.8+

from functools import lru_cache

from fastapi import Depends, FastAPI
from typing_extensions import Annotated

from . import config

app = FastAPI()


@lru_cache
def get_settings():
    return config.Settings()


@app.get("/info")
async def info(settings: Annotated[config.Settings, Depends(get_settings)]):
    return {
        "app_name": settings.app_name,
        "admin_email": settings.admin_email,
        "items_per_user": settings.items_per_user,
    }

Then for any subsequent call of get_settings() in the dependencies for the next requests, instead of executing the internal code of get_settings() and creating a new Settings object, it will return the same object that was returned on the first call, again and again.
lru_cache Technical DetailsÂ¶

@lru_cache modifies the function it decorates to return the same value that was returned the first time, instead of computing it again, executing the code of the function every time.

So, the function below it will be executed once for each combination of arguments. And then the values returned by each of those combinations of arguments will be used again and again whenever the function is called with exactly the same combination of arguments.

For example, if you have a function:

@lru_cache
def say_hi(name: str, salutation: str = "Ms."):
    return f"Hello {salutation} {name}"

your program could execute like this:
Execute functionsay_hi()CodeExecute functionsay_hi()Codesay_hi(name="Camila")execute function codereturn the resultsay_hi(name="Camila")return stored resultsay_hi(name="Rick")execute function codereturn the resultsay_hi(name="Rick", salutation="Mr.")execute function codereturn the resultsay_hi(name="Rick")return stored resultsay_hi(name="Camila")return stored result

In the case of our dependency get_settings(), the function doesn't even take any arguments, so it always returns the same value.

That way, it behaves almost as if it was just a global variable. But as it uses a dependency function, then we can override it easily for testing.

@lru_cache is part of functools which is part of Python's standard library, you can read more about it in the Python docs for @lru_cache.
RecapÂ¶

You can use Pydantic Settings to handle the settings or configurations for your application, with all the power of Pydantic models.

    By using a dependency you can simplify testing.
    You can use .env files with it.
    Using @lru_cache lets you avoid reading the dotenv file again and again for each request, while allowing you to override it during testing.

Previous
Async Tests
Next
OpenAPI Callbacks
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
OpenAPI Callbacks

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    An app with callbacks
    The normal FastAPI app
    Documenting the callback
    Write the callback documentation code
        Create a callback APIRouter
        Create the callback path operation
        The callback path expression
        Add the callback router
        Check the docs

    FastAPI
    Learn
    Advanced User Guide

OpenAPI CallbacksÂ¶

You could create an API with a path operation that could trigger a request to an external API created by someone else (probably the same developer that would be using your API).

The process that happens when your API app calls the external API is named a "callback". Because the software that the external developer wrote sends a request to your API and then your API calls back, sending a request to an external API (that was probably created by the same developer).

In this case, you could want to document how that external API should look like. What path operation it should have, what body it should expect, what response it should return, etc.
An app with callbacksÂ¶

Let's see all this with an example.

Imagine you develop an app that allows creating invoices.

These invoices will have an id, title (optional), customer, and total.

The user of your API (an external developer) will create an invoice in your API with a POST request.

Then your API will (let's imagine):

    Send the invoice to some customer of the external developer.
    Collect the money.
    Send a notification back to the API user (the external developer).
        This will be done by sending a POST request (from your API) to some external API provided by that external developer (this is the "callback").

The normal FastAPI appÂ¶

Let's first see how the normal API app would look like before adding the callback.

It will have a path operation that will receive an Invoice body, and a query parameter callback_url that will contain the URL for the callback.

This part is pretty normal, most of the code is probably already familiar to you:
Python 3.8+

from typing import Union

from fastapi import APIRouter, FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Invoice(BaseModel):
    id: str
    title: Union[str, None] = None
    customer: str
    total: float


class InvoiceEvent(BaseModel):
    description: str
    paid: bool


class InvoiceEventReceived(BaseModel):
    ok: bool


invoices_callback_router = APIRouter()


@invoices_callback_router.post(
    "{$callback_url}/invoices/{$request.body.id}", response_model=InvoiceEventReceived
)
def invoice_notification(body: InvoiceEvent):
    pass


@app.post("/invoices/", callbacks=invoices_callback_router.routes)
def create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None):
    """
    Create an invoice.

    This will (let's imagine) let the API user (some external developer) create an
    invoice.

    And this path operation will:

    * Send the invoice to the client.
    * Collect the money from the client.
    * Send a notification back to the API user (the external developer), as a callback.
        * At this point is that the API will somehow send a POST request to the
            external API with the notification of the invoice event
            (e.g. "payment successful").
    """
    # Send the invoice, collect the money, send the notification (the callback)
    return {"msg": "Invoice received"}

Tip

The callback_url query parameter uses a Pydantic Url type.

The only new thing is the callbacks=invoices_callback_router.routes as an argument to the path operation decorator. We'll see what that is next.
Documenting the callbackÂ¶

The actual callback code will depend heavily on your own API app.

And it will probably vary a lot from one app to the next.

It could be just one or two lines of code, like:

callback_url = "https://example.com/api/v1/invoices/events/"
httpx.post(callback_url, json={"description": "Invoice paid", "paid": True})

But possibly the most important part of the callback is making sure that your API user (the external developer) implements the external API correctly, according to the data that your API is going to send in the request body of the callback, etc.

So, what we will do next is add the code to document how that external API should look like to receive the callback from your API.

That documentation will show up in the Swagger UI at /docs in your API, and it will let external developers know how to build the external API.

This example doesn't implement the callback itself (that could be just a line of code), only the documentation part.

Tip

The actual callback is just an HTTP request.

When implementing the callback yourself, you could use something like HTTPX or Requests.
Write the callback documentation codeÂ¶

This code won't be executed in your app, we only need it to document how that external API should look like.

But, you already know how to easily create automatic documentation for an API with FastAPI.

So we are going to use that same knowledge to document how the external API should look like... by creating the path operation(s) that the external API should implement (the ones your API will call).

Tip

When writing the code to document a callback, it might be useful to imagine that you are that external developer. And that you are currently implementing the external API, not your API.

Temporarily adopting this point of view (of the external developer) can help you feel like it's more obvious where to put the parameters, the Pydantic model for the body, for the response, etc. for that external API.
Create a callback APIRouterÂ¶

First create a new APIRouter that will contain one or more callbacks.
Python 3.8+

from typing import Union

from fastapi import APIRouter, FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Invoice(BaseModel):
    id: str
    title: Union[str, None] = None
    customer: str
    total: float


class InvoiceEvent(BaseModel):
    description: str
    paid: bool


class InvoiceEventReceived(BaseModel):
    ok: bool


invoices_callback_router = APIRouter()


@invoices_callback_router.post(
    "{$callback_url}/invoices/{$request.body.id}", response_model=InvoiceEventReceived
)
def invoice_notification(body: InvoiceEvent):
    pass


@app.post("/invoices/", callbacks=invoices_callback_router.routes)
def create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None):
    """
    Create an invoice.

    This will (let's imagine) let the API user (some external developer) create an
    invoice.

    And this path operation will:

    * Send the invoice to the client.
    * Collect the money from the client.
    * Send a notification back to the API user (the external developer), as a callback.
        * At this point is that the API will somehow send a POST request to the
            external API with the notification of the invoice event
            (e.g. "payment successful").
    """
    # Send the invoice, collect the money, send the notification (the callback)
    return {"msg": "Invoice received"}

Create the callback path operationÂ¶

To create the callback path operation use the same APIRouter you created above.

It should look just like a normal FastAPI path operation:

    It should probably have a declaration of the body it should receive, e.g. body: InvoiceEvent.
    And it could also have a declaration of the response it should return, e.g. response_model=InvoiceEventReceived.

Python 3.8+

from typing import Union

from fastapi import APIRouter, FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Invoice(BaseModel):
    id: str
    title: Union[str, None] = None
    customer: str
    total: float


class InvoiceEvent(BaseModel):
    description: str
    paid: bool


class InvoiceEventReceived(BaseModel):
    ok: bool


invoices_callback_router = APIRouter()


@invoices_callback_router.post(
    "{$callback_url}/invoices/{$request.body.id}", response_model=InvoiceEventReceived
)
def invoice_notification(body: InvoiceEvent):
    pass


@app.post("/invoices/", callbacks=invoices_callback_router.routes)
def create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None):
    """
    Create an invoice.

    This will (let's imagine) let the API user (some external developer) create an
    invoice.

    And this path operation will:

    * Send the invoice to the client.
    * Collect the money from the client.
    * Send a notification back to the API user (the external developer), as a callback.
        * At this point is that the API will somehow send a POST request to the
            external API with the notification of the invoice event
            (e.g. "payment successful").
    """
    # Send the invoice, collect the money, send the notification (the callback)
    return {"msg": "Invoice received"}

There are 2 main differences from a normal path operation:

    It doesn't need to have any actual code, because your app will never call this code. It's only used to document the external API. So, the function could just have pass.
    The path can contain an OpenAPI 3 expression (see more below) where it can use variables with parameters and parts of the original request sent to your API.

The callback path expressionÂ¶

The callback path can have an OpenAPI 3 expression that can contain parts of the original request sent to your API.

In this case, it's the str:

"{$callback_url}/invoices/{$request.body.id}"

So, if your API user (the external developer) sends a request to your API to:

https://yourapi.com/invoices/?callback_url=https://www.external.org/events

with a JSON body of:

{
    "id": "2expen51ve",
    "customer": "Mr. Richie Rich",
    "total": "9999"
}

then your API will process the invoice, and at some point later, send a callback request to the callback_url (the external API):

https://www.external.org/events/invoices/2expen51ve

with a JSON body containing something like:

{
    "description": "Payment celebration",
    "paid": true
}

and it would expect a response from that external API with a JSON body like:

{
    "ok": true
}

Tip

Notice how the callback URL used contains the URL received as a query parameter in callback_url (https://www.external.org/events) and also the invoice id from inside of the JSON body (2expen51ve).
Add the callback routerÂ¶

At this point you have the callback path operation(s) needed (the one(s) that the external developer should implement in the external API) in the callback router you created above.

Now use the parameter callbacks in your API's path operation decorator to pass the attribute .routes (that's actually just a list of routes/path operations) from that callback router:
Python 3.8+

from typing import Union

from fastapi import APIRouter, FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()


class Invoice(BaseModel):
    id: str
    title: Union[str, None] = None
    customer: str
    total: float


class InvoiceEvent(BaseModel):
    description: str
    paid: bool


class InvoiceEventReceived(BaseModel):
    ok: bool


invoices_callback_router = APIRouter()


@invoices_callback_router.post(
    "{$callback_url}/invoices/{$request.body.id}", response_model=InvoiceEventReceived
)
def invoice_notification(body: InvoiceEvent):
    pass


@app.post("/invoices/", callbacks=invoices_callback_router.routes)
def create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None):
    """
    Create an invoice.

    This will (let's imagine) let the API user (some external developer) create an
    invoice.

    And this path operation will:

    * Send the invoice to the client.
    * Collect the money from the client.
    * Send a notification back to the API user (the external developer), as a callback.
        * At this point is that the API will somehow send a POST request to the
            external API with the notification of the invoice event
            (e.g. "payment successful").
    """
    # Send the invoice, collect the money, send the notification (the callback)
    return {"msg": "Invoice received"}

Tip

Notice that you are not passing the router itself (invoices_callback_router) to callback=, but the attribute .routes, as in invoices_callback_router.routes.
Check the docsÂ¶

Now you can start your app and go to http://127.0.0.1:8000/docs.

You will see your docs including a "Callbacks" section for your path operation that shows how the external API should look like:

Previous
Settings and Environment Variables
Next
OpenAPI Webhooks
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
OpenAPI Webhooks

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Webhooks steps
    Documenting webhooks with FastAPI and OpenAPI
    An app with webhooks
        Check the docs

    FastAPI
    Learn
    Advanced User Guide

OpenAPI WebhooksÂ¶

There are cases where you want to tell your API users that your app could call their app (sending a request) with some data, normally to notify of some type of event.

This means that instead of the normal process of your users sending requests to your API, it's your API (or your app) that could send requests to their system (to their API, their app).

This is normally called a webhook.
Webhooks stepsÂ¶

The process normally is that you define in your code what is the message that you will send, the body of the request.

You also define in some way at which moments your app will send those requests or events.

And your users define in some way (for example in a web dashboard somewhere) the URL where your app should send those requests.

All the logic about how to register the URLs for webhooks and the code to actually send those requests is up to you. You write it however you want to in your own code.
Documenting webhooks with FastAPI and OpenAPIÂ¶

With FastAPI, using OpenAPI, you can define the names of these webhooks, the types of HTTP operations that your app can send (e.g. POST, PUT, etc.) and the request bodies that your app would send.

This can make it a lot easier for your users to implement their APIs to receive your webhook requests, they might even be able to autogenerate some of their own API code.

Info

Webhooks are available in OpenAPI 3.1.0 and above, supported by FastAPI 0.99.0 and above.
An app with webhooksÂ¶

When you create a FastAPI application, there is a webhooks attribute that you can use to define webhooks, the same way you would define path operations, for example with @app.webhooks.post().
Python 3.8+

from datetime import datetime

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Subscription(BaseModel):
    username: str
    monthly_fee: float
    start_date: datetime


@app.webhooks.post("new-subscription")
def new_subscription(body: Subscription):
    """
    When a new user subscribes to your service we'll send you a POST request with this
    data to the URL that you register for the event `new-subscription` in the dashboard.
    """


@app.get("/users/")
def read_users():
    return ["Rick", "Morty"]

The webhooks that you define will end up in the OpenAPI schema and the automatic docs UI.

Info

The app.webhooks object is actually just an APIRouter, the same type you would use when structuring your app with multiple files.

Notice that with webhooks you are actually not declaring a path (like /items/), the text you pass there is just an identifier of the webhook (the name of the event), for example in @app.webhooks.post("new-subscription"), the webhook name is new-subscription.

This is because it is expected that your users would define the actual URL path where they want to receive the webhook request in some other way (e.g. a web dashboard).
Check the docsÂ¶

Now you can start your app and go to http://127.0.0.1:8000/docs.

You will see your docs have the normal path operations and now also some webhooks:

Previous
OpenAPI Callbacks
Next
Including WSGI - Flask, Django, others
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
Including WSGI - Flask, Django, others

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Using WSGIMiddleware
    Check it

    FastAPI
    Learn
    Advanced User Guide

Including WSGI - Flask, Django, othersÂ¶

You can mount WSGI applications as you saw with Sub Applications - Mounts, Behind a Proxy.

For that, you can use the WSGIMiddleware and use it to wrap your WSGI application, for example, Flask, Django, etc.
Using WSGIMiddlewareÂ¶

You need to import WSGIMiddleware.

Then wrap the WSGI (e.g. Flask) app with the middleware.

And then mount that under a path.
Python 3.8+

from fastapi import FastAPI
from fastapi.middleware.wsgi import WSGIMiddleware
from flask import Flask, request
from markupsafe import escape

flask_app = Flask(__name__)


@flask_app.route("/")
def flask_main():
    name = request.args.get("name", "World")
    return f"Hello, {escape(name)} from Flask!"


app = FastAPI()


@app.get("/v2")
def read_main():
    return {"message": "Hello World"}


app.mount("/v1", WSGIMiddleware(flask_app))

Check itÂ¶

Now, every request under the path /v1/ will be handled by the Flask application.

And the rest will be handled by FastAPI.

If you run it and go to http://localhost:8000/v1/ you will see the response from Flask:

Hello, World from Flask!

And if you go to http://localhost:8000/v2 you will see the response from FastAPI:

{
    "message": "Hello World"
}

Previous
OpenAPI Webhooks
Next
Generating SDKs
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Generating SDKs

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
            Path Operation Advanced Configuration
            Additional Status Codes
            Return a Response Directly
            Custom Response - HTML, Stream, File, others
            Additional Responses in OpenAPI
            Response Cookies
            Response Headers
            Response - Change Status Code
            Advanced Dependencies
            Advanced Security
            Using the Request Directly
            Using Dataclasses
            Advanced Middleware
            Sub Applications - Mounts
            Behind a Proxy
            Templates
            WebSockets
            Lifespan Events
            Testing WebSockets
            Testing Events: lifespan and startup - shutdown
            Testing Dependencies with Overrides
            Async Tests
            Settings and Environment Variables
            OpenAPI Callbacks
            OpenAPI Webhooks
            Including WSGI - Flask, Django, others
            Generating SDKs
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    Open Source SDK Generators
    SDK Generators from FastAPI Sponsors
    Create a TypeScript SDK
        API Docs
        Hey API
        Using the SDK
    FastAPI App with Tags
        Generate a TypeScript Client with Tags
        Client Method Names
    Custom Operation IDs and Better Method Names
        Custom Generate Unique ID Function
        Generate a TypeScript Client with Custom Operation IDs
        Preprocess the OpenAPI Specification for the Client Generator
        Generate a TypeScript Client with the Preprocessed OpenAPI
    Benefits

    FastAPI
    Learn
    Advanced User Guide

Generating SDKsÂ¶

Because FastAPI is based on the OpenAPI specification, its APIs can be described in a standard format that many tools understand.

This makes it easy to generate up-to-date documentation, client libraries (SDKs) in multiple languages, and testing or automation workflows that stay in sync with your code.

In this guide, you'll learn how to generate a TypeScript SDK for your FastAPI backend.
Open Source SDK GeneratorsÂ¶

A versatile option is the OpenAPI Generator, which supports many programming languages and can generate SDKs from your OpenAPI specification.

For TypeScript clients, Hey API is a purpose-built solution, providing an optimized experience for the TypeScript ecosystem.

You can discover more SDK generators on OpenAPI.Tools.

Tip

FastAPI automatically generates OpenAPI 3.1 specifications, so any tool you use must support this version.
SDK Generators from FastAPI SponsorsÂ¶

This section highlights venture-backed and company-supported solutions from companies that sponsor FastAPI. These products provide additional features and integrations on top of high-quality generated SDKs.

By âœ¨ sponsoring FastAPI âœ¨, these companies help ensure the framework and its ecosystem remain healthy and sustainable.

Their sponsorship also demonstrates a strong commitment to the FastAPI community (you), showing that they care not only about offering a great service but also about supporting a robust and thriving framework, FastAPI. ğŸ™‡

For example, you might want to try:

    Speakeasy
    Stainless
    liblab

Some of these solutions may also be open source or offer free tiers, so you can try them without a financial commitment. Other commercial SDK generators are available and can be found online. ğŸ¤“
Create a TypeScript SDKÂ¶

Let's start with a simple FastAPI application:
Python 3.9+

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    price: float


class ResponseMessage(BaseModel):
    message: str


@app.post("/items/", response_model=ResponseMessage)
async def create_item(item: Item):
    return {"message": "item received"}


@app.get("/items/", response_model=list[Item])
async def get_items():
    return [
        {"name": "Plumbus", "price": 3},
        {"name": "Portal Gun", "price": 9001},
    ]

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Notice that the path operations define the models they use for request payload and response payload, using the models Item and ResponseMessage.
API DocsÂ¶

If you go to /docs, you will see that it has the schemas for the data to be sent in requests and received in responses:

You can see those schemas because they were declared with the models in the app.

That information is available in the app's OpenAPI schema, and then shown in the API docs.

That same information from the models that is included in OpenAPI is what can be used to generate the client code.
Hey APIÂ¶

Once we have a FastAPI app with the models, we can use Hey API to generate a TypeScript client. The fastest way to do that is via npx.

npx @hey-api/openapi-ts -i http://localhost:8000/openapi.json -o src/client

This will generate a TypeScript SDK in ./src/client.

You can learn how to install @hey-api/openapi-ts and read about the generated output on their website.
Using the SDKÂ¶

Now you can import and use the client code. It could look like this, notice that you get autocompletion for the methods:

You will also get autocompletion for the payload to send:

Tip

Notice the autocompletion for name and price, that was defined in the FastAPI application, in the Item model.

You will have inline errors for the data that you send:

The response object will also have autocompletion:

FastAPI App with TagsÂ¶

In many cases, your FastAPI app will be bigger, and you will probably use tags to separate different groups of path operations.

For example, you could have a section for items and another section for users, and they could be separated by tags:
Python 3.9+

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    price: float


class ResponseMessage(BaseModel):
    message: str


class User(BaseModel):
    username: str
    email: str


@app.post("/items/", response_model=ResponseMessage, tags=["items"])
async def create_item(item: Item):
    return {"message": "Item received"}


@app.get("/items/", response_model=list[Item], tags=["items"])
async def get_items():
    return [
        {"name": "Plumbus", "price": 3},
        {"name": "Portal Gun", "price": 9001},
    ]


@app.post("/users/", response_model=ResponseMessage, tags=["users"])
async def create_user(user: User):
    return {"message": "User received"}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Generate a TypeScript Client with TagsÂ¶

If you generate a client for a FastAPI app using tags, it will normally also separate the client code based on the tags.

This way, you will be able to have things ordered and grouped correctly for the client code:

In this case, you have:

    ItemsService
    UsersService

Client Method NamesÂ¶

Right now, the generated method names like createItemItemsPost don't look very clean:

ItemsService.createItemItemsPost({name: "Plumbus", price: 5})

...that's because the client generator uses the OpenAPI internal operation ID for each path operation.

OpenAPI requires that each operation ID is unique across all the path operations, so FastAPI uses the function name, the path, and the HTTP method/operation to generate that operation ID, because that way it can make sure that the operation IDs are unique.

But I'll show you how to improve that next. ğŸ¤“
Custom Operation IDs and Better Method NamesÂ¶

You can modify the way these operation IDs are generated to make them simpler and have simpler method names in the clients.

In this case, you will have to ensure that each operation ID is unique in some other way.

For example, you could make sure that each path operation has a tag, and then generate the operation ID based on the tag and the path operation name (the function name).
Custom Generate Unique ID FunctionÂ¶

FastAPI uses a unique ID for each path operation, which is used for the operation ID and also for the names of any needed custom models, for requests or responses.

You can customize that function. It takes an APIRoute and outputs a string.

For example, here it is using the first tag (you will probably have only one tag) and the path operation name (the function name).

You can then pass that custom function to FastAPI as the generate_unique_id_function parameter:
Python 3.9+

from fastapi import FastAPI
from fastapi.routing import APIRoute
from pydantic import BaseModel


def custom_generate_unique_id(route: APIRoute):
    return f"{route.tags[0]}-{route.name}"


app = FastAPI(generate_unique_id_function=custom_generate_unique_id)


class Item(BaseModel):
    name: str
    price: float


class ResponseMessage(BaseModel):
    message: str


class User(BaseModel):
    username: str
    email: str


@app.post("/items/", response_model=ResponseMessage, tags=["items"])
async def create_item(item: Item):
    return {"message": "Item received"}


@app.get("/items/", response_model=list[Item], tags=["items"])
async def get_items():
    return [
        {"name": "Plumbus", "price": 3},
        {"name": "Portal Gun", "price": 9001},
    ]


@app.post("/users/", response_model=ResponseMessage, tags=["users"])
async def create_user(user: User):
    return {"message": "User received"}

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Generate a TypeScript Client with Custom Operation IDsÂ¶

Now, if you generate the client again, you will see that it has the improved method names:

As you see, the method names now have the tag and then the function name, now they don't include information from the URL path and the HTTP operation.
Preprocess the OpenAPI Specification for the Client GeneratorÂ¶

The generated code still has some duplicated information.

We already know that this method is related to the items because that word is in the ItemsService (taken from the tag), but we still have the tag name prefixed in the method name too. ğŸ˜•

We will probably still want to keep it for OpenAPI in general, as that will ensure that the operation IDs are unique.

But for the generated client, we could modify the OpenAPI operation IDs right before generating the clients, just to make those method names nicer and cleaner.

We could download the OpenAPI JSON to a file openapi.json and then we could remove that prefixed tag with a script like this:
Python 3.8+
Node.js

import json
from pathlib import Path

file_path = Path("./openapi.json")
openapi_content = json.loads(file_path.read_text())

for path_data in openapi_content["paths"].values():
    for operation in path_data.values():
        tag = operation["tags"][0]
        operation_id = operation["operationId"]
        to_remove = f"{tag}-"
        new_operation_id = operation_id[len(to_remove) :]
        operation["operationId"] = new_operation_id

file_path.write_text(json.dumps(openapi_content))

With that, the operation IDs would be renamed from things like items-get_items to just get_items, that way the client generator can generate simpler method names.
Generate a TypeScript Client with the Preprocessed OpenAPIÂ¶

Since the end result is now in an openapi.json file, you need to update your input location:

npx @hey-api/openapi-ts -i ./openapi.json -o src/client

After generating the new client, you would now have clean method names, with all the autocompletion, inline errors, etc:

BenefitsÂ¶

When using the automatically generated clients, you would get autocompletion for:

    Methods.
    Request payloads in the body, query parameters, etc.
    Response payloads.

You would also have inline errors for everything.

And whenever you update the backend code, and regenerate the frontend, it would have any new path operations available as methods, the old ones removed, and any other change would be reflected on the generated code. ğŸ¤“

This also means that if something changed, it will be reflected on the client code automatically. And if you build the client, it will error out if you have any mismatch in the data used.

So, you would detect many errors very early in the development cycle instead of having to wait for the errors to show up to your final users in production and then trying to debug where the problem is. âœ¨
Previous
Including WSGI - Flask, Django, others
Next
FastAPI CLI
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
FastAPI CLI

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes

Table of contents

    fastapi dev
    fastapi run

    FastAPI
    Learn

FastAPI CLIÂ¶

FastAPI CLI is a command line program that you can use to serve your FastAPI app, manage your FastAPI project, and more.

When you install FastAPI (e.g. with pip install "fastapi[standard]"), it includes a package called fastapi-cli, this package provides the fastapi command in the terminal.

To run your FastAPI app for development, you can use the fastapi dev command:

fastapi dev main.py
   FastAPI   Starting development server ğŸš€

             Searching for package file structure from directories with
             __init__.py files
             Importing from /home/user/code/awesomeapp

    module   ğŸ main.py

      code   Importing the FastAPI app object from the module with the
             following code:

             from main import app

       app   Using import string: main:app

    server   Server started at http://127.0.0.1:8000
    server   Documentation at http://127.0.0.1:8000/docs

       tip   Running in development mode, for production use:
             fastapi run

             Logs:

      INFO   Will watch for changes in these directories:
             ['/home/user/code/awesomeapp']
      INFO   Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to
             quit)
      INFO   Started reloader process [383138] using WatchFiles
      INFO   Started server process [383153]
      INFO   Waiting for application startup.
      INFO   Application startup complete.

restart â†»

The command line program called fastapi is FastAPI CLI.

FastAPI CLI takes the path to your Python program (e.g. main.py) and automatically detects the FastAPI instance (commonly named app), determines the correct import process, and then serves it.

For production you would use fastapi run instead. ğŸš€

Internally, FastAPI CLI uses Uvicorn, a high-performance, production-ready, ASGI server. ğŸ˜
fastapi devÂ¶

Running fastapi dev initiates development mode.

By default, auto-reload is enabled, automatically reloading the server when you make changes to your code. This is resource-intensive and could be less stable than when it's disabled. You should only use it for development. It also listens on the IP address 127.0.0.1, which is the IP for your machine to communicate with itself alone (localhost).
fastapi runÂ¶

Executing fastapi run starts FastAPI in production mode by default.

By default, auto-reload is disabled. It also listens on the IP address 0.0.0.0, which means all the available IP addresses, this way it will be publicly accessible to anyone that can communicate with the machine. This is how you would normally run it in production, for example, in a container.

In most cases you would (and should) have a "termination proxy" handling HTTPS for you on top, this will depend on how you deploy your application, your provider might do this for you, or you might need to set it up yourself.

Tip

You can learn more about it in the deployment documentation.
Previous
Generating SDKs
Next
Deployment
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Deployment

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
            About FastAPI versions
            FastAPI Cloud
            About HTTPS
            Run a Server Manually
            Deployments Concepts
            Deploy FastAPI on Cloud Providers
            Server Workers - Uvicorn with Workers
            FastAPI in Containers - Docker
        How To - Recipes

Table of contents

    What Does Deployment Mean
    Deployment Strategies

    FastAPI
    Learn
    Deployment

DeploymentÂ¶

Deploying a FastAPI application is relatively easy.
What Does Deployment MeanÂ¶

To deploy an application means to perform the necessary steps to make it available to the users.

For a web API, it normally involves putting it in a remote machine, with a server program that provides good performance, stability, etc, so that your users can access the application efficiently and without interruptions or problems.

This is in contrast to the development stages, where you are constantly changing the code, breaking it and fixing it, stopping and restarting the development server, etc.
Deployment StrategiesÂ¶

There are several ways to do it depending on your specific use case and the tools that you use.

You could deploy a server yourself using a combination of tools, you could use a cloud service that does part of the work for you, or other possible options.

For example, we, the team behind FastAPI, built FastAPI Cloud, to make deploying FastAPI apps to the cloud as streamlined as possible, with the same developer experience of working with FastAPI.

I will show you some of the main concepts you should probably keep in mind when deploying a FastAPI application (although most of it applies to any other type of web application).

You will see more details to keep in mind and some of the techniques to do it in the next sections. âœ¨
Previous
FastAPI CLI
Next
About FastAPI versions
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
About FastAPI versions

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
            About FastAPI versions
            FastAPI Cloud
            About HTTPS
            Run a Server Manually
            Deployments Concepts
            Deploy FastAPI on Cloud Providers
            Server Workers - Uvicorn with Workers
            FastAPI in Containers - Docker
        How To - Recipes

Table of contents

    Pin your fastapi version
    Available versions
    About versions
    Upgrading the FastAPI versions
    About Starlette
    About Pydantic

    FastAPI
    Learn
    Deployment

About FastAPI versionsÂ¶

FastAPI is already being used in production in many applications and systems. And the test coverage is kept at 100%. But its development is still moving quickly.

New features are added frequently, bugs are fixed regularly, and the code is still continuously improving.

That's why the current versions are still 0.x.x, this reflects that each version could potentially have breaking changes. This follows the Semantic Versioning conventions.

You can create production applications with FastAPI right now (and you have probably been doing it for some time), you just have to make sure that you use a version that works correctly with the rest of your code.
Pin your fastapi versionÂ¶

The first thing you should do is to "pin" the version of FastAPI you are using to the specific latest version that you know works correctly for your application.

For example, let's say you are using version 0.112.0 in your app.

If you use a requirements.txt file you could specify the version with:

fastapi[standard]==0.112.0

that would mean that you would use exactly the version 0.112.0.

Or you could also pin it with:

fastapi[standard]>=0.112.0,<0.113.0

that would mean that you would use the versions 0.112.0 or above, but less than 0.113.0, for example, a version 0.112.2 would still be accepted.

If you use any other tool to manage your installations, like uv, Poetry, Pipenv, or others, they all have a way that you can use to define specific versions for your packages.
Available versionsÂ¶

You can see the available versions (e.g. to check what is the current latest) in the Release Notes.
About versionsÂ¶

Following the Semantic Versioning conventions, any version below 1.0.0 could potentially add breaking changes.

FastAPI also follows the convention that any "PATCH" version change is for bug fixes and non-breaking changes.

Tip

The "PATCH" is the last number, for example, in 0.2.3, the PATCH version is 3.

So, you should be able to pin to a version like:

fastapi>=0.45.0,<0.46.0

Breaking changes and new features are added in "MINOR" versions.

Tip

The "MINOR" is the number in the middle, for example, in 0.2.3, the MINOR version is 2.
Upgrading the FastAPI versionsÂ¶

You should add tests for your app.

With FastAPI it's very easy (thanks to Starlette), check the docs: Testing

After you have tests, then you can upgrade the FastAPI version to a more recent one, and make sure that all your code is working correctly by running your tests.

If everything is working, or after you make the necessary changes, and all your tests are passing, then you can pin your fastapi to that new recent version.
About StarletteÂ¶

You shouldn't pin the version of starlette.

Different versions of FastAPI will use a specific newer version of Starlette.

So, you can just let FastAPI use the correct Starlette version.
About PydanticÂ¶

Pydantic includes the tests for FastAPI with its own tests, so new versions of Pydantic (above 1.0.0) are always compatible with FastAPI.

You can pin Pydantic to any version above 1.0.0 that works for you.

For example:

pydantic>=2.7.0,<3.0.0

Previous
Deployment
Next
FastAPI Cloud
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
FastAPI Cloud

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
            About FastAPI versions
            FastAPI Cloud
            About HTTPS
            Run a Server Manually
            Deployments Concepts
            Deploy FastAPI on Cloud Providers
            Server Workers - Uvicorn with Workers
            FastAPI in Containers - Docker
        How To - Recipes

Table of contents

    Login
    Deploy
    About FastAPI Cloud
    Deploy to other cloud providers
    Deploy your own server

    FastAPI
    Learn
    Deployment

FastAPI CloudÂ¶

You can deploy your FastAPI app to FastAPI Cloud with one command, go and join the waiting list if you haven't. ğŸš€
LoginÂ¶

Make sure you already have a FastAPI Cloud account (we invited you from the waiting list ğŸ˜‰).

Then log in:

fastapi login
You are logged in to FastAPI Cloud ğŸš€

restart â†»

DeployÂ¶

Now deploy your app, with one command:

fastapi deploy
Deploying to FastAPI Cloud...

âœ… Deployment successful!

ğŸ” Ready the chicken! Your app is ready at https://myapp.fastapicloud.dev

restart â†»

That's it! Now you can access your app at that URL. âœ¨
About FastAPI CloudÂ¶

FastAPI Cloud is built by the same author and team behind FastAPI.

It streamlines the process of building, deploying, and accessing an API with minimal effort.

It brings the same developer experience of building apps with FastAPI to deploying them to the cloud. ğŸ‰

It will also take care of most of the things you would need when deploying an app, like:

    HTTPS
    Replication, with autoscaling based on requests
    etc.

FastAPI Cloud is the primary sponsor and funding provider for the FastAPI and friends open source projects. âœ¨
Deploy to other cloud providersÂ¶

FastAPI is open source and based on standards. You can deploy FastAPI apps to any cloud provider you choose.

Follow your cloud provider's guides to deploy FastAPI apps with them. ğŸ¤“
Deploy your own serverÂ¶

I will also teach you later in this Deployment guide all the details, so you can understand what is going on, what needs to happen, or how to deploy FastAPI apps on your own, also with your own servers. ğŸ¤“
Previous
About FastAPI versions
Next
About HTTPS
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
About HTTPS

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
            About FastAPI versions
            FastAPI Cloud
            About HTTPS
            Run a Server Manually
            Deployments Concepts
            Deploy FastAPI on Cloud Providers
            Server Workers - Uvicorn with Workers
            FastAPI in Containers - Docker
        How To - Recipes

Table of contents

    Let's Encrypt
    HTTPS for Developers
        Domain Name
        DNS
        TLS Handshake Start
        TLS with SNI Extension
        HTTPS Request
        Decrypt the Request
        HTTP Response
        HTTPS Response
        Multiple Applications
        Certificate Renewal
    Proxy Forwarded Headers
    Recap

    FastAPI
    Learn
    Deployment

About HTTPSÂ¶

It is easy to assume that HTTPS is something that is just "enabled" or not.

But it is way more complex than that.

Tip

If you are in a hurry or don't care, continue with the next sections for step by step instructions to set everything up with different techniques.

To learn the basics of HTTPS, from a consumer perspective, check https://howhttps.works/.

Now, from a developer's perspective, here are several things to keep in mind while thinking about HTTPS:

    For HTTPS, the server needs to have "certificates" generated by a third party.
        Those certificates are actually acquired from the third party, not "generated".
    Certificates have a lifetime.
        They expire.
        And then they need to be renewed, acquired again from the third party.
    The encryption of the connection happens at the TCP level.
        That's one layer below HTTP.
        So, the certificate and encryption handling is done before HTTP.
    TCP doesn't know about "domains". Only about IP addresses.
        The information about the specific domain requested goes in the HTTP data.
    The HTTPS certificates "certify" a certain domain, but the protocol and encryption happen at the TCP level, before knowing which domain is being dealt with.
    By default, that would mean that you can only have one HTTPS certificate per IP address.
        No matter how big your server is or how small each application you have on it might be.
        There is a solution to this, however.
    There's an extension to the TLS protocol (the one handling the encryption at the TCP level, before HTTP) called SNI.
        This SNI extension allows one single server (with a single IP address) to have several HTTPS certificates and serve multiple HTTPS domains/applications.
        For this to work, a single component (program) running on the server, listening on the public IP address, must have all the HTTPS certificates in the server.
    After obtaining a secure connection, the communication protocol is still HTTP.
        The contents are encrypted, even though they are being sent with the HTTP protocol.

It is a common practice to have one program/HTTP server running on the server (the machine, host, etc.) and managing all the HTTPS parts: receiving the encrypted HTTPS requests, sending the decrypted HTTP requests to the actual HTTP application running in the same server (the FastAPI application, in this case), take the HTTP response from the application, encrypt it using the appropriate HTTPS certificate and sending it back to the client using HTTPS. This server is often called a TLS Termination Proxy.

Some of the options you could use as a TLS Termination Proxy are:

    Traefik (that can also handle certificate renewals)
    Caddy (that can also handle certificate renewals)
    Nginx
    HAProxy

Let's EncryptÂ¶

Before Let's Encrypt, these HTTPS certificates were sold by trusted third parties.

The process to acquire one of these certificates used to be cumbersome, require quite some paperwork and the certificates were quite expensive.

But then Let's Encrypt was created.

It is a project from the Linux Foundation. It provides HTTPS certificates for free, in an automated way. These certificates use all the standard cryptographic security, and are short-lived (about 3 months), so the security is actually better because of their reduced lifespan.

The domains are securely verified and the certificates are generated automatically. This also allows automating the renewal of these certificates.

The idea is to automate the acquisition and renewal of these certificates so that you can have secure HTTPS, for free, forever.
HTTPS for DevelopersÂ¶

Here's an example of how an HTTPS API could look like, step by step, paying attention mainly to the ideas important for developers.
Domain NameÂ¶

It would probably all start by you acquiring some domain name. Then, you would configure it in a DNS server (possibly your same cloud provider).

You would probably get a cloud server (a virtual machine) or something similar, and it would have a fixed public IP address.

In the DNS server(s) you would configure a record (an "A record") to point your domain to the public IP address of your server.

You would probably do this just once, the first time, when setting everything up.

Tip

This Domain Name part is way before HTTPS, but as everything depends on the domain and the IP address, it's worth mentioning it here.
DNSÂ¶

Now let's focus on all the actual HTTPS parts.

First, the browser would check with the DNS servers what is the IP for the domain, in this case, someapp.example.com.

The DNS servers would tell the browser to use some specific IP address. That would be the public IP address used by your server, that you configured in the DNS servers.

TLS Handshake StartÂ¶

The browser would then communicate with that IP address on port 443 (the HTTPS port).

The first part of the communication is just to establish the connection between the client and the server and to decide the cryptographic keys they will use, etc.

This interaction between the client and the server to establish the TLS connection is called the TLS handshake.
TLS with SNI ExtensionÂ¶

Only one process in the server can be listening on a specific port in a specific IP address. There could be other processes listening on other ports in the same IP address, but only one for each combination of IP address and port.

TLS (HTTPS) uses the specific port 443 by default. So that's the port we would need.

As only one process can be listening on this port, the process that would do it would be the TLS Termination Proxy.

The TLS Termination Proxy would have access to one or more TLS certificates (HTTPS certificates).

Using the SNI extension discussed above, the TLS Termination Proxy would check which of the TLS (HTTPS) certificates available it should use for this connection, using the one that matches the domain expected by the client.

In this case, it would use the certificate for someapp.example.com.

The client already trusts the entity that generated that TLS certificate (in this case Let's Encrypt, but we'll see about that later), so it can verify that the certificate is valid.

Then, using the certificate, the client and the TLS Termination Proxy decide how to encrypt the rest of the TCP communication. This completes the TLS Handshake part.

After this, the client and the server have an encrypted TCP connection, this is what TLS provides. And then they can use that connection to start the actual HTTP communication.

And that's what HTTPS is, it's just plain HTTP inside a secure TLS connection instead of a pure (unencrypted) TCP connection.

Tip

Notice that the encryption of the communication happens at the TCP level, not at the HTTP level.
HTTPS RequestÂ¶

Now that the client and server (specifically the browser and the TLS Termination Proxy) have an encrypted TCP connection, they can start the HTTP communication.

So, the client sends an HTTPS request. This is just an HTTP request through an encrypted TLS connection.

Decrypt the RequestÂ¶

The TLS Termination Proxy would use the encryption agreed to decrypt the request, and would transmit the plain (decrypted) HTTP request to the process running the application (for example a process with Uvicorn running the FastAPI application).

HTTP ResponseÂ¶

The application would process the request and send a plain (unencrypted) HTTP response to the TLS Termination Proxy.

HTTPS ResponseÂ¶

The TLS Termination Proxy would then encrypt the response using the cryptography agreed before (that started with the certificate for someapp.example.com), and send it back to the browser.

Next, the browser would verify that the response is valid and encrypted with the right cryptographic key, etc. It would then decrypt the response and process it.

The client (browser) will know that the response comes from the correct server because it is using the cryptography they agreed using the HTTPS certificate before.
Multiple ApplicationsÂ¶

In the same server (or servers), there could be multiple applications, for example, other API programs or a database.

Only one process can be handling the specific IP and port (the TLS Termination Proxy in our example) but the other applications/processes can be running on the server(s) too, as long as they don't try to use the same combination of public IP and port.

That way, the TLS Termination Proxy could handle HTTPS and certificates for multiple domains, for multiple applications, and then transmit the requests to the right application in each case.
Certificate RenewalÂ¶

At some point in the future, each certificate would expire (about 3 months after acquiring it).

And then, there would be another program (in some cases it's another program, in some cases it could be the same TLS Termination Proxy) that would talk to Let's Encrypt, and renew the certificate(s).

The TLS certificates are associated with a domain name, not with an IP address.

So, to renew the certificates, the renewal program needs to prove to the authority (Let's Encrypt) that it indeed "owns" and controls that domain.

To do that, and to accommodate different application needs, there are several ways it can do it. Some popular ways are:

    Modify some DNS records.
        For this, the renewal program needs to support the APIs of the DNS provider, so, depending on the DNS provider you are using, this might or might not be an option.
    Run as a server (at least during the certificate acquisition process) on the public IP address associated with the domain.
        As we said above, only one process can be listening on a specific IP and port.
        This is one of the reasons why it's very useful when the same TLS Termination Proxy also takes care of the certificate renewal process.
        Otherwise, you might have to stop the TLS Termination Proxy momentarily, start the renewal program to acquire the certificates, then configure them with the TLS Termination Proxy, and then restart the TLS Termination Proxy. This is not ideal, as your app(s) will not be available during the time that the TLS Termination Proxy is off.

All this renewal process, while still serving the app, is one of the main reasons why you would want to have a separate system to handle HTTPS with a TLS Termination Proxy instead of just using the TLS certificates with the application server directly (e.g. Uvicorn).
Proxy Forwarded HeadersÂ¶

When using a proxy to handle HTTPS, your application server (for example Uvicorn via FastAPI CLI) doesn't known anything about the HTTPS process, it communicates with plain HTTP with the TLS Termination Proxy.

This proxy would normally set some HTTP headers on the fly before transmitting the request to the application server, to let the application server know that the request is being forwarded by the proxy.

Technical Details

The proxy headers are:

    X-Forwarded-For
    X-Forwarded-Proto
    X-Forwarded-Host

Nevertheless, as the application server doesn't know it is behind a trusted proxy, by default, it wouldn't trust those headers.

But you can configure the application server to trust the forwarded headers sent by the proxy. If you are using FastAPI CLI, you can use the CLI Option --forwarded-allow-ips to tell it from which IPs it should trust those forwarded headers.

For example, if the application server is only receiving communication from the trusted proxy, you can set it to --forwarded-allow-ips="*" to make it trust all incoming IPs, as it will only receive requests from whatever is the IP used by the proxy.

This way the application would be able to know what is its own public URL, if it is using HTTPS, the domain, etc.

This would be useful for example to properly handle redirects.

Tip

You can learn more about this in the documentation for Behind a Proxy - Enable Proxy Forwarded Headers
RecapÂ¶

Having HTTPS is very important, and quite critical in most cases. Most of the effort you as a developer have to put around HTTPS is just about understanding these concepts and how they work.

But once you know the basic information of HTTPS for developers you can easily combine and configure different tools to help you manage everything in a simple way.

In some of the next chapters, I'll show you several concrete examples of how to set up HTTPS for FastAPI applications. ğŸ”’
Previous
FastAPI Cloud
Next
Run a Server Manually
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Run a Server Manually

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
            About FastAPI versions
            FastAPI Cloud
            About HTTPS
            Run a Server Manually
            Deployments Concepts
            Deploy FastAPI on Cloud Providers
            Server Workers - Uvicorn with Workers
            FastAPI in Containers - Docker
        How To - Recipes

Table of contents

    Use the fastapi run Command
    ASGI Servers
    Server Machine and Server Program
    Install the Server Program
    Run the Server Program
    Deployment Concepts

    FastAPI
    Learn
    Deployment

Run a Server ManuallyÂ¶
Use the fastapi run CommandÂ¶

In short, use fastapi run to serve your FastAPI application:

fastapi run main.py
   FastAPI   Starting production server ğŸš€

             Searching for package file structure from directories
             with __init__.py files
             Importing from /home/user/code/awesomeapp

    module   ğŸ main.py

      code   Importing the FastAPI app object from the module with
             the following code:

             from main import app

       app   Using import string: main:app

    server   Server started at http://0.0.0.0:8000
    server   Documentation at http://0.0.0.0:8000/docs

             Logs:

      INFO   Started server process [2306215]
      INFO   Waiting for application startup.
      INFO   Application startup complete.
      INFO   Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C
             to quit)

restart â†»

That would work for most of the cases. ğŸ˜

You could use that command for example to start your FastAPI app in a container, in a server, etc.
ASGI ServersÂ¶

Let's go a little deeper into the details.

FastAPI uses a standard for building Python web frameworks and servers called ASGI. FastAPI is an ASGI web framework.

The main thing you need to run a FastAPI application (or any other ASGI application) in a remote server machine is an ASGI server program like Uvicorn, this is the one that comes by default in the fastapi command.

There are several alternatives, including:

    Uvicorn: a high performance ASGI server.
    Hypercorn: an ASGI server compatible with HTTP/2 and Trio among other features.
    Daphne: the ASGI server built for Django Channels.
    Granian: A Rust HTTP server for Python applications.
    NGINX Unit: NGINX Unit is a lightweight and versatile web application runtime.

Server Machine and Server ProgramÂ¶

There's a small detail about names to keep in mind. ğŸ’¡

The word "server" is commonly used to refer to both the remote/cloud computer (the physical or virtual machine) and also the program that is running on that machine (e.g. Uvicorn).

Just keep in mind that when you read "server" in general, it could refer to one of those two things.

When referring to the remote machine, it's common to call it server, but also machine, VM (virtual machine), node. Those all refer to some type of remote machine, normally running Linux, where you run programs.
Install the Server ProgramÂ¶

When you install FastAPI, it comes with a production server, Uvicorn, and you can start it with the fastapi run command.

But you can also install an ASGI server manually.

Make sure you create a virtual environment, activate it, and then you can install the server application.

For example, to install Uvicorn:



A similar process would apply to any other ASGI server program.

Tip

By adding the standard, Uvicorn will install and use some recommended extra dependencies.

That including uvloop, the high-performance drop-in replacement for asyncio, that provides the big concurrency performance boost.

When you install FastAPI with something like pip install "fastapi[standard]" you already get uvicorn[standard] as well.
Run the Server ProgramÂ¶

If you installed an ASGI server manually, you would normally need to pass an import string in a special format for it to import your FastAPI application:




Note

The command uvicorn main:app refers to:

    main: the file main.py (the Python "module").
    app: the object created inside of main.py with the line app = FastAPI().

It is equivalent to:

from main import app

Each alternative ASGI server program would have a similar command, you can read more in their respective documentation.

Warning

Uvicorn and other servers support a --reload option that is useful during development.

The --reload option consumes much more resources, is more unstable, etc.

It helps a lot during development, but you shouldn't use it in production.
Deployment ConceptsÂ¶

These examples run the server program (e.g Uvicorn), starting a single process, listening on all the IPs (0.0.0.0) on a predefined port (e.g. 80).

This is the basic idea. But you will probably want to take care of some additional things, like:

    Security - HTTPS
    Running on startup
    Restarts
    Replication (the number of processes running)
    Memory
    Previous steps before starting

I'll tell you more about each of these concepts, how to think about them, and some concrete examples with strategies to handle them in the next chapters. ğŸš€
Previous
About HTTPS
Next
Deployments Concepts
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Deployments Concepts

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
            About FastAPI versions
            FastAPI Cloud
            About HTTPS
            Run a Server Manually
            Deployments Concepts
            Deploy FastAPI on Cloud Providers
            Server Workers - Uvicorn with Workers
            FastAPI in Containers - Docker
        How To - Recipes

Table of contents

    Security - HTTPS
        Example Tools for HTTPS
    Program and Process
        What is a Program
        What is a Process
    Running on Startup
        In a Remote Server
        Run Automatically on Startup
        Separate Program
        Example Tools to Run at Startup
    Restarts
        We Make Mistakes
        Small Errors Automatically Handled
        Bigger Errors - Crashes
        Restart After Crash
        Example Tools to Restart Automatically
    Replication - Processes and Memory
        Multiple Processes - Workers
        Worker Processes and Ports
        Memory per Process
        Server Memory
        Multiple Processes - An Example
        Examples of Replication Tools and Strategies
    Previous Steps Before Starting
        Examples of Previous Steps Strategies
    Resource Utilization
    Recap

    FastAPI
    Learn
    Deployment

Deployments ConceptsÂ¶

When deploying a FastAPI application, or actually, any type of web API, there are several concepts that you probably care about, and using them you can find the most appropriate way to deploy your application.

Some of the important concepts are:

    Security - HTTPS
    Running on startup
    Restarts
    Replication (the number of processes running)
    Memory
    Previous steps before starting

We'll see how they would affect deployments.

In the end, the ultimate objective is to be able to serve your API clients in a way that is secure, to avoid disruptions, and to use the compute resources (for example remote servers/virtual machines) as efficiently as possible. ğŸš€

I'll tell you a bit more about these concepts here, and that would hopefully give you the intuition you would need to decide how to deploy your API in very different environments, possibly even in future ones that don't exist yet.

By considering these concepts, you will be able to evaluate and design the best way to deploy your own APIs.

In the next chapters, I'll give you more concrete recipes to deploy FastAPI applications.

But for now, let's check these important conceptual ideas. These concepts also apply to any other type of web API. ğŸ’¡
Security - HTTPSÂ¶

In the previous chapter about HTTPS we learned about how HTTPS provides encryption for your API.

We also saw that HTTPS is normally provided by a component external to your application server, a TLS Termination Proxy.

And there has to be something in charge of renewing the HTTPS certificates, it could be the same component or it could be something different.
Example Tools for HTTPSÂ¶

Some of the tools you could use as a TLS Termination Proxy are:

    Traefik
        Automatically handles certificates renewals âœ¨
    Caddy
        Automatically handles certificates renewals âœ¨
    Nginx
        With an external component like Certbot for certificate renewals
    HAProxy
        With an external component like Certbot for certificate renewals
    Kubernetes with an Ingress Controller like Nginx
        With an external component like cert-manager for certificate renewals
    Handled internally by a cloud provider as part of their services (read below ğŸ‘‡)

Another option is that you could use a cloud service that does more of the work including setting up HTTPS. It could have some restrictions or charge you more, etc. But in that case, you wouldn't have to set up a TLS Termination Proxy yourself.

I'll show you some concrete examples in the next chapters.

Then the next concepts to consider are all about the program running your actual API (e.g. Uvicorn).
Program and ProcessÂ¶

We will talk a lot about the running "process", so it's useful to have clarity about what it means, and what's the difference with the word "program".
What is a ProgramÂ¶

The word program is commonly used to describe many things:

    The code that you write, the Python files.
    The file that can be executed by the operating system, for example: python, python.exe or uvicorn.
    A particular program while it is running on the operating system, using the CPU, and storing things in memory. This is also called a process.

What is a ProcessÂ¶

The word process is normally used in a more specific way, only referring to the thing that is running in the operating system (like in the last point above):

    A particular program while it is running on the operating system.
        This doesn't refer to the file, nor to the code, it refers specifically to the thing that is being executed and managed by the operating system.
    Any program, any code, can only do things when it is being executed. So, when there's a process running.
    The process can be terminated (or "killed") by you, or by the operating system. At that point, it stops running/being executed, and it can no longer do things.
    Each application that you have running on your computer has some process behind it, each running program, each window, etc. And there are normally many processes running at the same time while a computer is on.
    There can be multiple processes of the same program running at the same time.

If you check out the "task manager" or "system monitor" (or similar tools) in your operating system, you will be able to see many of those processes running.

And, for example, you will probably see that there are multiple processes running the same browser program (Firefox, Chrome, Edge, etc). They normally run one process per tab, plus some other extra processes.

Now that we know the difference between the terms process and program, let's continue talking about deployments.
Running on StartupÂ¶

In most cases, when you create a web API, you want it to be always running, uninterrupted, so that your clients can always access it. This is of course, unless you have a specific reason why you want it to run only in certain situations, but most of the time you want it constantly running and available.
In a Remote ServerÂ¶

When you set up a remote server (a cloud server, a virtual machine, etc.) the simplest thing you can do is use fastapi run (which uses Uvicorn) or something similar, manually, the same way you do when developing locally.

And it will work and will be useful during development.

But if your connection to the server is lost, the running process will probably die.

And if the server is restarted (for example after updates, or migrations from the cloud provider) you probably won't notice it. And because of that, you won't even know that you have to restart the process manually. So, your API will just stay dead. ğŸ˜±
Run Automatically on StartupÂ¶

In general, you will probably want the server program (e.g. Uvicorn) to be started automatically on server startup, and without needing any human intervention, to have a process always running with your API (e.g. Uvicorn running your FastAPI app).
Separate ProgramÂ¶

To achieve this, you will normally have a separate program that would make sure your application is run on startup. And in many cases, it would also make sure other components or applications are also run, for example, a database.
Example Tools to Run at StartupÂ¶

Some examples of the tools that can do this job are:

    Docker
    Kubernetes
    Docker Compose
    Docker in Swarm Mode
    Systemd
    Supervisor
    Handled internally by a cloud provider as part of their services
    Others...

I'll give you more concrete examples in the next chapters.
RestartsÂ¶

Similar to making sure your application is run on startup, you probably also want to make sure it is restarted after failures.
We Make MistakesÂ¶

We, as humans, make mistakes, all the time. Software almost always has bugs hidden in different places. ğŸ›

And we as developers keep improving the code as we find those bugs and as we implement new features (possibly adding new bugs too ğŸ˜…).
Small Errors Automatically HandledÂ¶

When building web APIs with FastAPI, if there's an error in our code, FastAPI will normally contain it to the single request that triggered the error. ğŸ›¡

The client will get a 500 Internal Server Error for that request, but the application will continue working for the next requests instead of just crashing completely.
Bigger Errors - CrashesÂ¶

Nevertheless, there might be cases where we write some code that crashes the entire application making Uvicorn and Python crash. ğŸ’¥

And still, you would probably not want the application to stay dead because there was an error in one place, you probably want it to continue running at least for the path operations that are not broken.
Restart After CrashÂ¶

But in those cases with really bad errors that crash the running process, you would want an external component that is in charge of restarting the process, at least a couple of times...

Tip

...Although if the whole application is just crashing immediately it probably doesn't make sense to keep restarting it forever. But in those cases, you will probably notice it during development, or at least right after deployment.

So let's focus on the main cases, where it could crash entirely in some particular cases in the future, and it still makes sense to restart it.

You would probably want to have the thing in charge of restarting your application as an external component, because by that point, the same application with Uvicorn and Python already crashed, so there's nothing in the same code of the same app that could do anything about it.
Example Tools to Restart AutomaticallyÂ¶

In most cases, the same tool that is used to run the program on startup is also used to handle automatic restarts.

For example, this could be handled by:

    Docker
    Kubernetes
    Docker Compose
    Docker in Swarm Mode
    Systemd
    Supervisor
    Handled internally by a cloud provider as part of their services
    Others...

Replication - Processes and MemoryÂ¶

With a FastAPI application, using a server program like the fastapi command that runs Uvicorn, running it once in one process can serve multiple clients concurrently.

But in many cases, you will want to run several worker processes at the same time.
Multiple Processes - WorkersÂ¶

If you have more clients than what a single process can handle (for example if the virtual machine is not too big) and you have multiple cores in the server's CPU, then you could have multiple processes running with the same application at the same time, and distribute all the requests among them.

When you run multiple processes of the same API program, they are commonly called workers.
Worker Processes and PortsÂ¶

Remember from the docs About HTTPS that only one process can be listening on one combination of port and IP address in a server?

This is still true.

So, to be able to have multiple processes at the same time, there has to be a single process listening on a port that then transmits the communication to each worker process in some way.
Memory per ProcessÂ¶

Now, when the program loads things in memory, for example, a machine learning model in a variable, or the contents of a large file in a variable, all that consumes a bit of the memory (RAM) of the server.

And multiple processes normally don't share any memory. This means that each running process has its own things, variables, and memory. And if you are consuming a large amount of memory in your code, each process will consume an equivalent amount of memory.
Server MemoryÂ¶

For example, if your code loads a Machine Learning model with 1 GB in size, when you run one process with your API, it will consume at least 1 GB of RAM. And if you start 4 processes (4 workers), each will consume 1 GB of RAM. So in total, your API will consume 4 GB of RAM.

And if your remote server or virtual machine only has 3 GB of RAM, trying to load more than 4 GB of RAM will cause problems. ğŸš¨
Multiple Processes - An ExampleÂ¶

In this example, there's a Manager Process that starts and controls two Worker Processes.

This Manager Process would probably be the one listening on the port in the IP. And it would transmit all the communication to the worker processes.

Those worker processes would be the ones running your application, they would perform the main computations to receive a request and return a response, and they would load anything you put in variables in RAM.

And of course, the same machine would probably have other processes running as well, apart from your application.

An interesting detail is that the percentage of the CPU used by each process can vary a lot over time, but the memory (RAM) normally stays more or less stable.

If you have an API that does a comparable amount of computations every time and you have a lot of clients, then the CPU utilization will probably also be stable (instead of constantly going up and down quickly).
Examples of Replication Tools and StrategiesÂ¶

There can be several approaches to achieve this, and I'll tell you more about specific strategies in the next chapters, for example when talking about Docker and containers.

The main constraint to consider is that there has to be a single component handling the port in the public IP. And then it has to have a way to transmit the communication to the replicated processes/workers.

Here are some possible combinations and strategies:

    Uvicorn with --workers
        One Uvicorn process manager would listen on the IP and port, and it would start multiple Uvicorn worker processes.
    Kubernetes and other distributed container systems
        Something in the Kubernetes layer would listen on the IP and port. The replication would be by having multiple containers, each with one Uvicorn process running.
    Cloud services that handle this for you
        The cloud service will probably handle replication for you. It would possibly let you define a process to run, or a container image to use, in any case, it would most probably be a single Uvicorn process, and the cloud service would be in charge of replicating it.

Tip

Don't worry if some of these items about containers, Docker, or Kubernetes don't make a lot of sense yet.

I'll tell you more about container images, Docker, Kubernetes, etc. in a future chapter: FastAPI in Containers - Docker.
Previous Steps Before StartingÂ¶

There are many cases where you want to perform some steps before starting your application.

For example, you might want to run database migrations.

But in most cases, you will want to perform these steps only once.

So, you will want to have a single process to perform those previous steps, before starting the application.

And you will have to make sure that it's a single process running those previous steps even if afterwards, you start multiple processes (multiple workers) for the application itself. If those steps were run by multiple processes, they would duplicate the work by running it in parallel, and if the steps were something delicate like a database migration, they could cause conflicts with each other.

Of course, there are some cases where there's no problem in running the previous steps multiple times, in that case, it's a lot easier to handle.

Tip

Also, keep in mind that depending on your setup, in some cases you might not even need any previous steps before starting your application.

In that case, you wouldn't have to worry about any of this. ğŸ¤·
Examples of Previous Steps StrategiesÂ¶

This will depend heavily on the way you deploy your system, and it would probably be connected to the way you start programs, handling restarts, etc.

Here are some possible ideas:

    An "Init Container" in Kubernetes that runs before your app container
    A bash script that runs the previous steps and then starts your application
        You would still need a way to start/restart that bash script, detect errors, etc.

Tip

I'll give you more concrete examples for doing this with containers in a future chapter: FastAPI in Containers - Docker.
Resource UtilizationÂ¶

Your server(s) is (are) a resource, you can consume or utilize, with your programs, the computation time on the CPUs, and the RAM memory available.

How much of the system resources do you want to be consuming/utilizing? It might be easy to think "not much", but in reality, you will probably want to consume as much as possible without crashing.

If you are paying for 3 servers but you are using only a little bit of their RAM and CPU, you are probably wasting money ğŸ’¸, and probably wasting server electric power ğŸŒ, etc.

In that case, it could be better to have only 2 servers and use a higher percentage of their resources (CPU, memory, disk, network bandwidth, etc).

On the other hand, if you have 2 servers and you are using 100% of their CPU and RAM, at some point one process will ask for more memory, and the server will have to use the disk as "memory" (which can be thousands of times slower), or even crash. Or one process might need to do some computation and would have to wait until the CPU is free again.

In this case, it would be better to get one extra server and run some processes on it so that they all have enough RAM and CPU time.

There's also the chance that for some reason you have a spike of usage of your API. Maybe it went viral, or maybe some other services or bots start using it. And you might want to have extra resources to be safe in those cases.

You could put an arbitrary number to target, for example, something between 50% to 90% of resource utilization. The point is that those are probably the main things you will want to measure and use to tweak your deployments.

You can use simple tools like htop to see the CPU and RAM used in your server or the amount used by each process. Or you can use more complex monitoring tools, which may be distributed across servers, etc.
RecapÂ¶

You have been reading here some of the main concepts that you would probably need to keep in mind when deciding how to deploy your application:

    Security - HTTPS
    Running on startup
    Restarts
    Replication (the number of processes running)
    Memory
    Previous steps before starting

Understanding these ideas and how to apply them should give you the intuition necessary to take any decisions when configuring and tweaking your deployments. ğŸ¤“

In the next sections, I'll give you more concrete examples of possible strategies you can follow. ğŸš€
Previous
Run a Server Manually
Next
Deploy FastAPI on Cloud Providers
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
Deploy FastAPI on Cloud Providers

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
            About FastAPI versions
            FastAPI Cloud
            About HTTPS
            Run a Server Manually
            Deployments Concepts
            Deploy FastAPI on Cloud Providers
            Server Workers - Uvicorn with Workers
            FastAPI in Containers - Docker
        How To - Recipes

Table of contents

    FastAPI Cloud
    Cloud Providers - Sponsors

    FastAPI
    Learn
    Deployment

Deploy FastAPI on Cloud ProvidersÂ¶

You can use virtually any cloud provider to deploy your FastAPI application.

In most of the cases, the main cloud providers have guides to deploy FastAPI with them.
FastAPI CloudÂ¶

FastAPI Cloud is built by the same author and team behind FastAPI.

It streamlines the process of building, deploying, and accessing an API with minimal effort.

It brings the same developer experience of building apps with FastAPI to deploying them to the cloud. ğŸ‰

FastAPI Cloud is the primary sponsor and funding provider for the FastAPI and friends open source projects. âœ¨
Cloud Providers - SponsorsÂ¶

Some other cloud providers âœ¨ sponsor FastAPI âœ¨ too. ğŸ™‡

You might also want to consider them to follow their guides and try their services:

    Render
    Railway

Previous
Deployments Concepts
Next
Server Workers - Uvicorn with Workers
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Server Workers - Uvicorn with Workers

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
            About FastAPI versions
            FastAPI Cloud
            About HTTPS
            Run a Server Manually
            Deployments Concepts
            Deploy FastAPI on Cloud Providers
            Server Workers - Uvicorn with Workers
            FastAPI in Containers - Docker
        How To - Recipes

Table of contents

    Multiple Workers
    Deployment Concepts
    Containers and Docker
    Recap

    FastAPI
    Learn
    Deployment

Server Workers - Uvicorn with WorkersÂ¶

Let's check back those deployment concepts from before:

    Security - HTTPS
    Running on startup
    Restarts
    Replication (the number of processes running)
    Memory
    Previous steps before starting

Up to this point, with all the tutorials in the docs, you have probably been running a server program, for example, using the fastapi command, that runs Uvicorn, running a single process.

When deploying applications you will probably want to have some replication of processes to take advantage of multiple cores and to be able to handle more requests.

As you saw in the previous chapter about Deployment Concepts, there are multiple strategies you can use.

Here I'll show you how to use Uvicorn with worker processes using the fastapi command or the uvicorn command directly.

Info

If you are using containers, for example with Docker or Kubernetes, I'll tell you more about that in the next chapter: FastAPI in Containers - Docker.

In particular, when running on Kubernetes you will probably not want to use workers and instead run a single Uvicorn process per container, but I'll tell you about it later in that chapter.
Multiple WorkersÂ¶

You can start multiple workers with the --workers command line option:
fastapi
uvicorn

If you use the fastapi command:






































The only new option here is --workers telling Uvicorn to start 4 worker processes.

You can also see that it shows the PID of each process, 27365 for the parent process (this is the process manager) and one for each worker process: 27368, 27369, 27370, and 27367.
Deployment ConceptsÂ¶

Here you saw how to use multiple workers to parallelize the execution of the application, take advantage of multiple cores in the CPU, and be able to serve more requests.

From the list of deployment concepts from above, using workers would mainly help with the replication part, and a little bit with the restarts, but you still need to take care of the others:

    Security - HTTPS
    Running on startup
    Restarts
    Replication (the number of processes running)
    Memory
    Previous steps before starting

Containers and DockerÂ¶

In the next chapter about FastAPI in Containers - Docker I'll explain some strategies you could use to handle the other deployment concepts.

I'll show you how to build your own image from scratch to run a single Uvicorn process. It is a simple process and is probably what you would want to do when using a distributed container management system like Kubernetes.
RecapÂ¶

You can use multiple worker processes with the --workers CLI option with the fastapi or uvicorn commands to take advantage of multi-core CPUs, to run multiple processes in parallel.

You could use these tools and ideas if you are setting up your own deployment system while taking care of the other deployment concepts yourself.

Check out the next chapter to learn about FastAPI with containers (e.g. Docker and Kubernetes). You will see that those tools have simple ways to solve the other deployment concepts as well. âœ¨
Previous
Deploy FastAPI on Cloud Providers
Next
FastAPI in Containers - Docker
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
FastAPI in Containers - Docker

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
            About FastAPI versions
            FastAPI Cloud
            About HTTPS
            Run a Server Manually
            Deployments Concepts
            Deploy FastAPI on Cloud Providers
            Server Workers - Uvicorn with Workers
            FastAPI in Containers - Docker
        How To - Recipes

Table of contents

    What is a Container
    What is a Container Image
    Container Images
    Containers and Processes
    Build a Docker Image for FastAPI
        Package Requirements
        Create the FastAPI Code
        Dockerfile
            Use CMD - Exec Form
            Directory Structure
            Behind a TLS Termination Proxy
            Docker Cache
        Build the Docker Image
        Start the Docker Container
    Check it
    Interactive API docs
    Alternative API docs
    Build a Docker Image with a Single-File FastAPI
    Deployment Concepts
    HTTPS
    Running on Startup and Restarts
    Replication - Number of Processes
        Load Balancer
        One Load Balancer - Multiple Worker Containers
        One Process per Container
        Containers with Multiple Processes and Special Cases
            A Simple App
            Docker Compose
    Memory
    Previous Steps Before Starting and Containers
        Multiple Containers
        Single Container
        Base Docker Image
    Deploy the Container Image
    Docker Image with uv
    Recap

    FastAPI
    Learn
    Deployment

FastAPI in Containers - DockerÂ¶

When deploying FastAPI applications a common approach is to build a Linux container image. It's normally done using Docker. You can then deploy that container image in one of a few possible ways.

Using Linux containers has several advantages including security, replicability, simplicity, and others.

Tip

In a hurry and already know this stuff? Jump to the Dockerfile below ğŸ‘‡.
Dockerfile Preview ğŸ‘€

FROM python:3.9

WORKDIR /code

COPY ./requirements.txt /code/requirements.txt

RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt

COPY ./app /code/app

CMD ["fastapi", "run", "app/main.py", "--port", "80"]

# If running behind a proxy like Nginx or Traefik add --proxy-headers
# CMD ["fastapi", "run", "app/main.py", "--port", "80", "--proxy-headers"]

Dockerfile Preview ğŸ‘€

FROM python:3.9

WORKDIR /code

COPY ./requirements.txt /code/requirements.txt

RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt

COPY ./app /code/app

CMD ["fastapi", "run", "app/main.py", "--port", "80"]

# If running behind a proxy like Nginx or Traefik add --proxy-headers
# CMD ["fastapi", "run", "app/main.py", "--port", "80", "--proxy-headers"]

What is a ContainerÂ¶

Containers (mainly Linux containers) are a very lightweight way to package applications including all their dependencies and necessary files while keeping them isolated from other containers (other applications or components) in the same system.

Linux containers run using the same Linux kernel of the host (machine, virtual machine, cloud server, etc). This just means that they are very lightweight (compared to full virtual machines emulating an entire operating system).

This way, containers consume little resources, an amount comparable to running the processes directly (a virtual machine would consume much more).

Containers also have their own isolated running processes (commonly just one process), file system, and network, simplifying deployment, security, development, etc.
What is a Container ImageÂ¶

A container is run from a container image.

A container image is a static version of all the files, environment variables, and the default command/program that should be present in a container. Static here means that the container image is not running, it's not being executed, it's only the packaged files and metadata.

In contrast to a "container image" that is the stored static contents, a "container" normally refers to the running instance, the thing that is being executed.

When the container is started and running (started from a container image) it could create or change files, environment variables, etc. Those changes will exist only in that container, but would not persist in the underlying container image (would not be saved to disk).

A container image is comparable to the program file and contents, e.g. python and some file main.py.

And the container itself (in contrast to the container image) is the actual running instance of the image, comparable to a process. In fact, a container is running only when it has a process running (and normally it's only a single process). The container stops when there's no process running in it.
Container ImagesÂ¶

Docker has been one of the main tools to create and manage container images and containers.

And there's a public Docker Hub with pre-made official container images for many tools, environments, databases, and applications.

For example, there's an official Python Image.

And there are many other images for different things like databases, for example for:

    PostgreSQL
    MySQL
    MongoDB
    Redis, etc.

By using a pre-made container image it's very easy to combine and use different tools. For example, to try out a new database. In most cases, you can use the official images, and just configure them with environment variables.

That way, in many cases you can learn about containers and Docker and reuse that knowledge with many different tools and components.

So, you would run multiple containers with different things, like a database, a Python application, a web server with a React frontend application, and connect them together via their internal network.

All the container management systems (like Docker or Kubernetes) have these networking features integrated into them.
Containers and ProcessesÂ¶

A container image normally includes in its metadata the default program or command that should be run when the container is started and the parameters to be passed to that program. Very similar to what would be if it was in the command line.

When a container is started, it will run that command/program (although you can override it and make it run a different command/program).

A container is running as long as the main process (command or program) is running.

A container normally has a single process, but it's also possible to start subprocesses from the main process, and that way you will have multiple processes in the same container.

But it's not possible to have a running container without at least one running process. If the main process stops, the container stops.
Build a Docker Image for FastAPIÂ¶

Okay, let's build something now! ğŸš€

I'll show you how to build a Docker image for FastAPI from scratch, based on the official Python image.

This is what you would want to do in most cases, for example:

    Using Kubernetes or similar tools
    When running on a Raspberry Pi
    Using a cloud service that would run a container image for you, etc.

Package RequirementsÂ¶

You would normally have the package requirements for your application in some file.

It would depend mainly on the tool you use to install those requirements.

The most common way to do it is to have a file requirements.txt with the package names and their versions, one per line.

You would of course use the same ideas you read in About FastAPI versions to set the ranges of versions.

For example, your requirements.txt could look like:

fastapi[standard]>=0.113.0,<0.114.0
pydantic>=2.7.0,<3.0.0

And you would normally install those package dependencies with pip, for example:



Info

There are other formats and tools to define and install package dependencies.
Create the FastAPI CodeÂ¶

    Create an app directory and enter it.
    Create an empty file __init__.py.
    Create a main.py file with:

from typing import Union

from fastapi import FastAPI

app = FastAPI()


@app.get("/")
def read_root():
    return {"Hello": "World"}


@app.get("/items/{item_id}")
def read_item(item_id: int, q: Union[str, None] = None):
    return {"item_id": item_id, "q": q}

DockerfileÂ¶

Now in the same project directory create a file Dockerfile with:


FROM python:3.9


WORKDIR /code


COPY ./requirements.txt /code/requirements.txt


RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt


COPY ./app /code/app


CMD ["fastapi", "run", "app/main.py", "--port", "80"]

Tip

Review what each line does by clicking each number bubble in the code. ğŸ‘†

Warning

Make sure to always use the exec form of the CMD instruction, as explained below.
Use CMD - Exec FormÂ¶

The CMD Docker instruction can be written using two forms:

âœ… Exec form:

# âœ… Do this
CMD ["fastapi", "run", "app/main.py", "--port", "80"]

â›”ï¸ Shell form:

# â›”ï¸ Don't do this
CMD fastapi run app/main.py --port 80

Make sure to always use the exec form to ensure that FastAPI can shutdown gracefully and lifespan events are triggered.

You can read more about it in the Docker docs for shell and exec form.

This can be quite noticeable when using docker compose. See this Docker Compose FAQ section for more technical details: Why do my services take 10 seconds to recreate or stop?.
Directory StructureÂ¶

You should now have a directory structure like:

.
â”œâ”€â”€ app
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ main.py
â”œâ”€â”€ Dockerfile
â””â”€â”€ requirements.txt

Behind a TLS Termination ProxyÂ¶

If you are running your container behind a TLS Termination Proxy (load balancer) like Nginx or Traefik, add the option --proxy-headers, this will tell Uvicorn (through the FastAPI CLI) to trust the headers sent by that proxy telling it that the application is running behind HTTPS, etc.

CMD ["fastapi", "run", "app/main.py", "--proxy-headers", "--port", "80"]

Docker CacheÂ¶

There's an important trick in this Dockerfile, we first copy the file with the dependencies alone, not the rest of the code. Let me tell you why is that.

COPY ./requirements.txt /code/requirements.txt

Docker and other tools build these container images incrementally, adding one layer on top of the other, starting from the top of the Dockerfile and adding any files created by each of the instructions of the Dockerfile.

Docker and similar tools also use an internal cache when building the image, if a file hasn't changed since the last time building the container image, then it will reuse the same layer created the last time, instead of copying the file again and creating a new layer from scratch.

Just avoiding the copy of files doesn't necessarily improve things too much, but because it used the cache for that step, it can use the cache for the next step. For example, it could use the cache for the instruction that installs dependencies with:

RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt

The file with the package requirements won't change frequently. So, by copying only that file, Docker will be able to use the cache for that step.

And then, Docker will be able to use the cache for the next step that downloads and install those dependencies. And here's where we save a lot of time. âœ¨ ...and avoid boredom waiting. ğŸ˜ªğŸ˜†

Downloading and installing the package dependencies could take minutes, but using the cache would take seconds at most.

And as you would be building the container image again and again during development to check that your code changes are working, there's a lot of accumulated time this would save.

Then, near the end of the Dockerfile, we copy all the code. As this is what changes most frequently, we put it near the end, because almost always, anything after this step will not be able to use the cache.

COPY ./app /code/app

Build the Docker ImageÂ¶

Now that all the files are in place, let's build the container image.

    Go to the project directory (in where your Dockerfile is, containing your app directory).
    Build your FastAPI image:



Tip

Notice the . at the end, it's equivalent to ./, it tells Docker the directory to use to build the container image.

In this case, it's the same current directory (.).
Start the Docker ContainerÂ¶

    Run a container based on your image:


Check itÂ¶

You should be able to check it in your Docker container's URL, for example: http://192.168.99.100/items/5?q=somequery or http://127.0.0.1/items/5?q=somequery (or equivalent, using your Docker host).

You will see something like:

{"item_id": 5, "q": "somequery"}

Interactive API docsÂ¶

Now you can go to http://192.168.99.100/docs or http://127.0.0.1/docs (or equivalent, using your Docker host).

You will see the automatic interactive API documentation (provided by Swagger UI):

Swagger UI
Alternative API docsÂ¶

And you can also go to http://192.168.99.100/redoc or http://127.0.0.1/redoc (or equivalent, using your Docker host).

You will see the alternative automatic documentation (provided by ReDoc):

ReDoc
Build a Docker Image with a Single-File FastAPIÂ¶

If your FastAPI is a single file, for example, main.py without an ./app directory, your file structure could look like this:

.
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ main.py
â””â”€â”€ requirements.txt

Then you would just have to change the corresponding paths to copy the file inside the Dockerfile:

FROM python:3.9

WORKDIR /code

COPY ./requirements.txt /code/requirements.txt

RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt


COPY ./main.py /code/


CMD ["fastapi", "run", "main.py", "--port", "80"]

When you pass the file to fastapi run it will detect automatically that it is a single file and not part of a package and will know how to import it and serve your FastAPI app. ğŸ˜
Deployment ConceptsÂ¶

Let's talk again about some of the same Deployment Concepts in terms of containers.

Containers are mainly a tool to simplify the process of building and deploying an application, but they don't enforce a particular approach to handle these deployment concepts, and there are several possible strategies.

The good news is that with each different strategy there's a way to cover all of the deployment concepts. ğŸ‰

Let's review these deployment concepts in terms of containers:

    HTTPS
    Running on startup
    Restarts
    Replication (the number of processes running)
    Memory
    Previous steps before starting

HTTPSÂ¶

If we focus just on the container image for a FastAPI application (and later the running container), HTTPS normally would be handled externally by another tool.

It could be another container, for example with Traefik, handling HTTPS and automatic acquisition of certificates.

Tip

Traefik has integrations with Docker, Kubernetes, and others, so it's very easy to set up and configure HTTPS for your containers with it.

Alternatively, HTTPS could be handled by a cloud provider as one of their services (while still running the application in a container).
Running on Startup and RestartsÂ¶

There is normally another tool in charge of starting and running your container.

It could be Docker directly, Docker Compose, Kubernetes, a cloud service, etc.

In most (or all) cases, there's a simple option to enable running the container on startup and enabling restarts on failures. For example, in Docker, it's the command line option --restart.

Without using containers, making applications run on startup and with restarts can be cumbersome and difficult. But when working with containers in most cases that functionality is included by default. âœ¨
Replication - Number of ProcessesÂ¶

If you have a cluster of machines with Kubernetes, Docker Swarm Mode, Nomad, or another similar complex system to manage distributed containers on multiple machines, then you will probably want to handle replication at the cluster level instead of using a process manager (like Uvicorn with workers) in each container.

One of those distributed container management systems like Kubernetes normally has some integrated way of handling replication of containers while still supporting load balancing for the incoming requests. All at the cluster level.

In those cases, you would probably want to build a Docker image from scratch as explained above, installing your dependencies, and running a single Uvicorn process instead of using multiple Uvicorn workers.
Load BalancerÂ¶

When using containers, you would normally have some component listening on the main port. It could possibly be another container that is also a TLS Termination Proxy to handle HTTPS or some similar tool.

As this component would take the load of requests and distribute that among the workers in a (hopefully) balanced way, it is also commonly called a Load Balancer.

Tip

The same TLS Termination Proxy component used for HTTPS would probably also be a Load Balancer.

And when working with containers, the same system you use to start and manage them would already have internal tools to transmit the network communication (e.g. HTTP requests) from that load balancer (that could also be a TLS Termination Proxy) to the container(s) with your app.
One Load Balancer - Multiple Worker ContainersÂ¶

When working with Kubernetes or similar distributed container management systems, using their internal networking mechanisms would allow the single load balancer that is listening on the main port to transmit communication (requests) to possibly multiple containers running your app.

Each of these containers running your app would normally have just one process (e.g. a Uvicorn process running your FastAPI application). They would all be identical containers, running the same thing, but each with its own process, memory, etc. That way you would take advantage of parallelization in different cores of the CPU, or even in different machines.

And the distributed container system with the load balancer would distribute the requests to each one of the containers with your app in turns. So, each request could be handled by one of the multiple replicated containers running your app.

And normally this load balancer would be able to handle requests that go to other apps in your cluster (e.g. to a different domain, or under a different URL path prefix), and would transmit that communication to the right containers for that other application running in your cluster.
One Process per ContainerÂ¶

In this type of scenario, you probably would want to have a single (Uvicorn) process per container, as you would already be handling replication at the cluster level.

So, in this case, you would not want to have a multiple workers in the container, for example with the --workers command line option. You would want to have just a single Uvicorn process per container (but probably multiple containers).

Having another process manager inside the container (as would be with multiple workers) would only add unnecessary complexity that you are most probably already taking care of with your cluster system.
Containers with Multiple Processes and Special CasesÂ¶

Of course, there are special cases where you could want to have a container with several Uvicorn worker processes inside.

In those cases, you can use the --workers command line option to set the number of workers that you want to run:

FROM python:3.9

WORKDIR /code

COPY ./requirements.txt /code/requirements.txt

RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt

COPY ./app /code/app


CMD ["fastapi", "run", "app/main.py", "--port", "80", "--workers", "4"]

Here are some examples of when that could make sense:
A Simple AppÂ¶

You could want a process manager in the container if your application is simple enough that can run it on a single server, not a cluster.
Docker ComposeÂ¶

You could be deploying to a single server (not a cluster) with Docker Compose, so you wouldn't have an easy way to manage replication of containers (with Docker Compose) while preserving the shared network and load balancing.

Then you could want to have a single container with a process manager starting several worker processes inside.

The main point is, none of these are rules written in stone that you have to blindly follow. You can use these ideas to evaluate your own use case and decide what is the best approach for your system, checking out how to manage the concepts of:

    Security - HTTPS
    Running on startup
    Restarts
    Replication (the number of processes running)
    Memory
    Previous steps before starting

MemoryÂ¶

If you run a single process per container you will have a more or less well-defined, stable, and limited amount of memory consumed by each of those containers (more than one if they are replicated).

And then you can set those same memory limits and requirements in your configurations for your container management system (for example in Kubernetes). That way it will be able to replicate the containers in the available machines taking into account the amount of memory needed by them, and the amount available in the machines in the cluster.

If your application is simple, this will probably not be a problem, and you might not need to specify hard memory limits. But if you are using a lot of memory (for example with machine learning models), you should check how much memory you are consuming and adjust the number of containers that runs in each machine (and maybe add more machines to your cluster).

If you run multiple processes per container you will have to make sure that the number of processes started doesn't consume more memory than what is available.
Previous Steps Before Starting and ContainersÂ¶

If you are using containers (e.g. Docker, Kubernetes), then there are two main approaches you can use.
Multiple ContainersÂ¶

If you have multiple containers, probably each one running a single process (for example, in a Kubernetes cluster), then you would probably want to have a separate container doing the work of the previous steps in a single container, running a single process, before running the replicated worker containers.

Info

If you are using Kubernetes, this would probably be an Init Container.

If in your use case there's no problem in running those previous steps multiple times in parallel (for example if you are not running database migrations, but just checking if the database is ready yet), then you could also just put them in each container right before starting the main process.
Single ContainerÂ¶

If you have a simple setup, with a single container that then starts multiple worker processes (or also just one process), then you could run those previous steps in the same container, right before starting the process with the app.
Base Docker ImageÂ¶

There used to be an official FastAPI Docker image: tiangolo/uvicorn-gunicorn-fastapi. But it is now deprecated. â›”ï¸

You should probably not use this base Docker image (or any other similar one).

If you are using Kubernetes (or others) and you are already setting replication at the cluster level, with multiple containers. In those cases, you are better off building an image from scratch as described above: Build a Docker Image for FastAPI.

And if you need to have multiple workers, you can simply use the --workers command line option.

Technical Details

The Docker image was created when Uvicorn didn't support managing and restarting dead workers, so it was needed to use Gunicorn with Uvicorn, which added quite some complexity, just to have Gunicorn manage and restart the Uvicorn worker processes.

But now that Uvicorn (and the fastapi command) support using --workers, there's no reason to use a base Docker image instead of building your own (it's pretty much the same amount of code ğŸ˜…).
Deploy the Container ImageÂ¶

After having a Container (Docker) Image there are several ways to deploy it.

For example:

    With Docker Compose in a single server
    With a Kubernetes cluster
    With a Docker Swarm Mode cluster
    With another tool like Nomad
    With a cloud service that takes your container image and deploys it

Docker Image with uvÂ¶

If you are using uv to install and manage your project, you can follow their uv Docker guide.
RecapÂ¶

Using container systems (e.g. with Docker and Kubernetes) it becomes fairly straightforward to handle all the deployment concepts:

    HTTPS
    Running on startup
    Restarts
    Replication (the number of processes running)
    Memory
    Previous steps before starting

In most cases, you probably won't want to use any base image, and instead build a container image from scratch based on the official Python Docker image.

Taking care of the order of instructions in the Dockerfile and the Docker cache you can minimize build times, to maximize your productivity (and avoid boredom). ğŸ˜
Previous
Server Workers - Uvicorn with Workers
Next
How To - Recipes
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
How To - Recipes

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes
            General - How To - Recipes
            Migrate from Pydantic v1 to Pydantic v2
            GraphQL
            Custom Request and APIRoute class
            Conditional OpenAPI
            Extending OpenAPI
            Separate OpenAPI Schemas for Input and Output or Not
            Custom Docs UI Static Assets (Self-Hosting)
            Configure Swagger UI
            Testing a Database

    FastAPI
    Learn
    How To - Recipes

How To - RecipesÂ¶

Here you will see different recipes or "how to" guides for several topics.

Most of these ideas would be more or less independent, and in most cases you should only need to study them if they apply directly to your project.

If something seems interesting and useful to your project, go ahead and check it, but otherwise, you might probably just skip them.

Tip

If you want to learn FastAPI in a structured way (recommended), go and read the Tutorial - User Guide chapter by chapter instead.
Previous
FastAPI in Containers - Docker
Next
General - How To - Recipes
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
General - How To - Recipes

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes
            General - How To - Recipes
            Migrate from Pydantic v1 to Pydantic v2
            GraphQL
            Custom Request and APIRoute class
            Conditional OpenAPI
            Extending OpenAPI
            Separate OpenAPI Schemas for Input and Output or Not
            Custom Docs UI Static Assets (Self-Hosting)
            Configure Swagger UI
            Testing a Database

Table of contents

    Filter Data - Security
    Documentation Tags - OpenAPI
    Documentation Summary and Description - OpenAPI
    Documentation Response description - OpenAPI
    Documentation Deprecate a Path Operation - OpenAPI
    Convert any Data to JSON-compatible
    OpenAPI Metadata - Docs
    OpenAPI Custom URL
    OpenAPI Docs URLs

    FastAPI
    Learn
    How To - Recipes

General - How To - RecipesÂ¶

Here are several pointers to other places in the docs, for general or frequent questions.
Filter Data - SecurityÂ¶

To ensure that you don't return more data than you should, read the docs for Tutorial - Response Model - Return Type.
Documentation Tags - OpenAPIÂ¶

To add tags to your path operations, and group them in the docs UI, read the docs for Tutorial - Path Operation Configurations - Tags.
Documentation Summary and Description - OpenAPIÂ¶

To add a summary and description to your path operations, and show them in the docs UI, read the docs for Tutorial - Path Operation Configurations - Summary and Description.
Documentation Response description - OpenAPIÂ¶

To define the description of the response, shown in the docs UI, read the docs for Tutorial - Path Operation Configurations - Response description.
Documentation Deprecate a Path Operation - OpenAPIÂ¶

To deprecate a path operation, and show it in the docs UI, read the docs for Tutorial - Path Operation Configurations - Deprecation.
Convert any Data to JSON-compatibleÂ¶

To convert any data to JSON-compatible, read the docs for Tutorial - JSON Compatible Encoder.
OpenAPI Metadata - DocsÂ¶

To add metadata to your OpenAPI schema, including a license, version, contact, etc, read the docs for Tutorial - Metadata and Docs URLs.
OpenAPI Custom URLÂ¶

To customize the OpenAPI URL (or remove it), read the docs for Tutorial - Metadata and Docs URLs.
OpenAPI Docs URLsÂ¶

To update the URLs used for the automatically generated docs user interfaces, read the docs for Tutorial - Metadata and Docs URLs.
Previous
How To - Recipes
Next
Migrate from Pydantic v1 to Pydantic v2
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Migrate from Pydantic v1 to Pydantic v2

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes
            General - How To - Recipes
            Migrate from Pydantic v1 to Pydantic v2
            GraphQL
            Custom Request and APIRoute class
            Conditional OpenAPI
            Extending OpenAPI
            Separate OpenAPI Schemas for Input and Output or Not
            Custom Docs UI Static Assets (Self-Hosting)
            Configure Swagger UI
            Testing a Database

Table of contents

    Official Guide
    Tests
    bump-pydantic
    Pydantic v1 in v2
        FastAPI support for Pydantic v1 in v2
        Pydantic v1 and v2 on the same app
        Pydantic v1 parameters
        Migrate in steps

    FastAPI
    Learn
    How To - Recipes

Migrate from Pydantic v1 to Pydantic v2Â¶

If you have an old FastAPI app, you might be using Pydantic version 1.

FastAPI has had support for either Pydantic v1 or v2 since version 0.100.0.

If you had installed Pydantic v2, it would use it. If instead you had Pydantic v1, it would use that.

Pydantic v1 is now deprecated and support for it will be removed in the next versions of FastAPI, you should migrate to Pydantic v2. This way you will get the latest features, improvements, and fixes.

Warning

Also, the Pydantic team stopped support for Pydantic v1 for the latest versions of Python, starting with Python 3.14.

If you want to use the latest features of Python, you will need to make sure you use Pydantic v2.

If you have an old FastAPI app with Pydantic v1, here I'll show you how to migrate it to Pydantic v2, and the new features in FastAPI 0.119.0 to help you with a gradual migration.
Official GuideÂ¶

Pydantic has an official Migration Guide from v1 to v2.

It also includes what has changed, how validations are now more correct and strict, possible caveats, etc.

You can read it to understand better what has changed.
TestsÂ¶

Make sure you have tests for your app and you run them on continuous integration (CI).

This way, you can do the upgrade and make sure everything is still working as expected.
bump-pydanticÂ¶

In many cases, when you use regular Pydantic models without customizations, you will be able to automate most of the process of migrating from Pydantic v1 to Pydantic v2.

You can use bump-pydantic from the same Pydantic team.

This tool will help you to automatically change most of the code that needs to be changed.

After this, you can run the tests and check if everything works. If it does, you are done. ğŸ˜
Pydantic v1 in v2Â¶

Pydantic v2 includes everything from Pydantic v1 as a submodule pydantic.v1.

This means that you can install the latest version of Pydantic v2 and import and use the old Pydantic v1 components from this submodule, as if you had the old Pydantic v1 installed.
Python 3.10+

from pydantic.v1 import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None
    size: float

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

FastAPI support for Pydantic v1 in v2Â¶

Since FastAPI 0.119.0, there's also partial support for Pydantic v1 from inside of Pydantic v2, to facilitate the migration to v2.

So, you could upgrade Pydantic to the latest version 2, and change the imports to use the pydantic.v1 submodule, and in many cases it would just work.
Python 3.10+

from fastapi import FastAPI
from pydantic.v1 import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None
    size: float


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item) -> Item:
    return item

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Warning

Have in mind that as the Pydantic team no longer supports Pydantic v1 in recent versions of Python, starting from Python 3.14, using pydantic.v1 is also not supported in Python 3.14 and above.
Pydantic v1 and v2 on the same appÂ¶

It's not supported by Pydantic to have a model of Pydantic v2 with its own fields defined as Pydantic v1 models or vice versa.
âŒ Not Supported
Pydantic v2 Model
Pydantic v1 Model
Pydantic v1 Model
Pydantic v2 Model

...but, you can have separated models using Pydantic v1 and v2 in the same app.
âœ… Supported
Pydantic v2 Model
Pydantic v2 Model
Pydantic v1 Model
Pydantic v1 Model

In some cases, it's even possible to have both Pydantic v1 and v2 models in the same path operation in your FastAPI app:
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel as BaseModelV2
from pydantic.v1 import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None
    size: float


class ItemV2(BaseModelV2):
    name: str
    description: str | None = None
    size: float


app = FastAPI()


@app.post("/items/", response_model=ItemV2)
async def create_item(item: Item):
    return item

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

In this example above, the input model is a Pydantic v1 model, and the output model (defined in response_model=ItemV2) is a Pydantic v2 model.
Pydantic v1 parametersÂ¶

If you need to use some of the FastAPI-specific tools for parameters like Body, Query, Form, etc. with Pydantic v1 models, you can import them from fastapi.temp_pydantic_v1_params while you finish the migration to Pydantic v2:
Python 3.10+

from typing import Annotated

from fastapi import FastAPI
from fastapi.temp_pydantic_v1_params import Body
from pydantic.v1 import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None
    size: float


app = FastAPI()


@app.post("/items/")
async def create_item(item: Annotated[Item, Body(embed=True)]) -> Item:
    return item

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Migrate in stepsÂ¶

Tip

First try with bump-pydantic, if your tests pass and that works, then you're done in one command. âœ¨

If bump-pydantic doesn't work for your use case, you can use the support for both Pydantic v1 and v2 models in the same app to do the migration to Pydantic v2 gradually.

You could fist upgrade Pydantic to use the latest version 2, and change the imports to use pydantic.v1 for all your models.

Then, you can start migrating your models from Pydantic v1 to v2 in groups, in gradual steps. ğŸš¶
Previous
General - How To - Recipes
Next
GraphQL
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
GraphQL

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes
            General - How To - Recipes
            Migrate from Pydantic v1 to Pydantic v2
            GraphQL
            Custom Request and APIRoute class
            Conditional OpenAPI
            Extending OpenAPI
            Separate OpenAPI Schemas for Input and Output or Not
            Custom Docs UI Static Assets (Self-Hosting)
            Configure Swagger UI
            Testing a Database

Table of contents

    GraphQL Libraries
    GraphQL with Strawberry
    Older GraphQLApp from Starlette
    Learn More

    FastAPI
    Learn
    How To - Recipes

GraphQLÂ¶

As FastAPI is based on the ASGI standard, it's very easy to integrate any GraphQL library also compatible with ASGI.

You can combine normal FastAPI path operations with GraphQL on the same application.

Tip

GraphQL solves some very specific use cases.

It has advantages and disadvantages when compared to common web APIs.

Make sure you evaluate if the benefits for your use case compensate the drawbacks. ğŸ¤“
GraphQL LibrariesÂ¶

Here are some of the GraphQL libraries that have ASGI support. You could use them with FastAPI:

    Strawberry ğŸ“
        With docs for FastAPI
    Ariadne
        With docs for FastAPI
    Tartiflette
        With Tartiflette ASGI to provide ASGI integration
    Graphene
        With starlette-graphene3

GraphQL with StrawberryÂ¶

If you need or want to work with GraphQL, Strawberry is the recommended library as it has the design closest to FastAPI's design, it's all based on type annotations.

Depending on your use case, you might prefer to use a different library, but if you asked me, I would probably suggest you try Strawberry.

Here's a small preview of how you could integrate Strawberry with FastAPI:
Python 3.8+

import strawberry
from fastapi import FastAPI
from strawberry.fastapi import GraphQLRouter


@strawberry.type
class User:
    name: str
    age: int


@strawberry.type
class Query:
    @strawberry.field
    def user(self) -> User:
        return User(name="Patrick", age=100)


schema = strawberry.Schema(query=Query)


graphql_app = GraphQLRouter(schema)

app = FastAPI()
app.include_router(graphql_app, prefix="/graphql")

You can learn more about Strawberry in the Strawberry documentation.

And also the docs about Strawberry with FastAPI.
Older GraphQLApp from StarletteÂ¶

Previous versions of Starlette included a GraphQLApp class to integrate with Graphene.

It was deprecated from Starlette, but if you have code that used it, you can easily migrate to starlette-graphene3, that covers the same use case and has an almost identical interface.

Tip

If you need GraphQL, I still would recommend you check out Strawberry, as it's based on type annotations instead of custom classes and types.
Learn MoreÂ¶

You can learn more about GraphQL in the official GraphQL documentation.

You can also read more about each those libraries described above in their links.
Previous
Migrate from Pydantic v1 to Pydantic v2
Next
Custom Request and APIRoute class
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
Custom Request and APIRoute class

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes
            General - How To - Recipes
            Migrate from Pydantic v1 to Pydantic v2
            GraphQL
            Custom Request and APIRoute class
            Conditional OpenAPI
            Extending OpenAPI
            Separate OpenAPI Schemas for Input and Output or Not
            Custom Docs UI Static Assets (Self-Hosting)
            Configure Swagger UI
            Testing a Database

Table of contents

    Use cases
    Handling custom request body encodings
        Create a custom GzipRequest class
        Create a custom GzipRoute class
    Accessing the request body in an exception handler
    Custom APIRoute class in a router

    FastAPI
    Learn
    How To - Recipes

Custom Request and APIRoute classÂ¶

In some cases, you may want to override the logic used by the Request and APIRoute classes.

In particular, this may be a good alternative to logic in a middleware.

For example, if you want to read or manipulate the request body before it is processed by your application.

Danger

This is an "advanced" feature.

If you are just starting with FastAPI you might want to skip this section.
Use casesÂ¶

Some use cases include:

    Converting non-JSON request bodies to JSON (e.g. msgpack).
    Decompressing gzip-compressed request bodies.
    Automatically logging all request bodies.

Handling custom request body encodingsÂ¶

Let's see how to make use of a custom Request subclass to decompress gzip requests.

And an APIRoute subclass to use that custom request class.
Create a custom GzipRequest classÂ¶

Tip

This is a toy example to demonstrate how it works, if you need Gzip support, you can use the provided GzipMiddleware.

First, we create a GzipRequest class, which will overwrite the Request.body() method to decompress the body in the presence of an appropriate header.

If there's no gzip in the header, it will not try to decompress the body.

That way, the same route class can handle gzip compressed or uncompressed requests.
Python 3.8+

import gzip
from typing import Callable, List

from fastapi import Body, FastAPI, Request, Response
from fastapi.routing import APIRoute


class GzipRequest(Request):
    async def body(self) -> bytes:
        if not hasattr(self, "_body"):
            body = await super().body()
            if "gzip" in self.headers.getlist("Content-Encoding"):
                body = gzip.decompress(body)
            self._body = body
        return self._body


class GzipRoute(APIRoute):
    def get_route_handler(self) -> Callable:
        original_route_handler = super().get_route_handler()

        async def custom_route_handler(request: Request) -> Response:
            request = GzipRequest(request.scope, request.receive)
            return await original_route_handler(request)

        return custom_route_handler


app = FastAPI()
app.router.route_class = GzipRoute


@app.post("/sum")
async def sum_numbers(numbers: List[int] = Body()):
    return {"sum": sum(numbers)}

Create a custom GzipRoute classÂ¶

Next, we create a custom subclass of fastapi.routing.APIRoute that will make use of the GzipRequest.

This time, it will overwrite the method APIRoute.get_route_handler().

This method returns a function. And that function is what will receive a request and return a response.

Here we use it to create a GzipRequest from the original request.
Python 3.8+

import gzip
from typing import Callable, List

from fastapi import Body, FastAPI, Request, Response
from fastapi.routing import APIRoute


class GzipRequest(Request):
    async def body(self) -> bytes:
        if not hasattr(self, "_body"):
            body = await super().body()
            if "gzip" in self.headers.getlist("Content-Encoding"):
                body = gzip.decompress(body)
            self._body = body
        return self._body


class GzipRoute(APIRoute):
    def get_route_handler(self) -> Callable:
        original_route_handler = super().get_route_handler()

        async def custom_route_handler(request: Request) -> Response:
            request = GzipRequest(request.scope, request.receive)
            return await original_route_handler(request)

        return custom_route_handler


app = FastAPI()
app.router.route_class = GzipRoute


@app.post("/sum")
async def sum_numbers(numbers: List[int] = Body()):
    return {"sum": sum(numbers)}

Technical Details

A Request has a request.scope attribute, that's just a Python dict containing the metadata related to the request.

A Request also has a request.receive, that's a function to "receive" the body of the request.

The scope dict and receive function are both part of the ASGI specification.

And those two things, scope and receive, are what is needed to create a new Request instance.

To learn more about the Request check Starlette's docs about Requests.

The only thing the function returned by GzipRequest.get_route_handler does differently is convert the Request to a GzipRequest.

Doing this, our GzipRequest will take care of decompressing the data (if necessary) before passing it to our path operations.

After that, all of the processing logic is the same.

But because of our changes in GzipRequest.body, the request body will be automatically decompressed when it is loaded by FastAPI when needed.
Accessing the request body in an exception handlerÂ¶

Tip

To solve this same problem, it's probably a lot easier to use the body in a custom handler for RequestValidationError (Handling Errors).

But this example is still valid and it shows how to interact with the internal components.

We can also use this same approach to access the request body in an exception handler.

All we need to do is handle the request inside a try/except block:
Python 3.8+

from typing import Callable, List

from fastapi import Body, FastAPI, HTTPException, Request, Response
from fastapi.exceptions import RequestValidationError
from fastapi.routing import APIRoute


class ValidationErrorLoggingRoute(APIRoute):
    def get_route_handler(self) -> Callable:
        original_route_handler = super().get_route_handler()

        async def custom_route_handler(request: Request) -> Response:
            try:
                return await original_route_handler(request)
            except RequestValidationError as exc:
                body = await request.body()
                detail = {"errors": exc.errors(), "body": body.decode()}
                raise HTTPException(status_code=422, detail=detail)

        return custom_route_handler


app = FastAPI()
app.router.route_class = ValidationErrorLoggingRoute


@app.post("/")
async def sum_numbers(numbers: List[int] = Body()):
    return sum(numbers)

If an exception occurs, theRequest instance will still be in scope, so we can read and make use of the request body when handling the error:
Python 3.8+

from typing import Callable, List

from fastapi import Body, FastAPI, HTTPException, Request, Response
from fastapi.exceptions import RequestValidationError
from fastapi.routing import APIRoute


class ValidationErrorLoggingRoute(APIRoute):
    def get_route_handler(self) -> Callable:
        original_route_handler = super().get_route_handler()

        async def custom_route_handler(request: Request) -> Response:
            try:
                return await original_route_handler(request)
            except RequestValidationError as exc:
                body = await request.body()
                detail = {"errors": exc.errors(), "body": body.decode()}
                raise HTTPException(status_code=422, detail=detail)

        return custom_route_handler


app = FastAPI()
app.router.route_class = ValidationErrorLoggingRoute


@app.post("/")
async def sum_numbers(numbers: List[int] = Body()):
    return sum(numbers)

Custom APIRoute class in a routerÂ¶

You can also set the route_class parameter of an APIRouter:
Python 3.8+

import time
from typing import Callable

from fastapi import APIRouter, FastAPI, Request, Response
from fastapi.routing import APIRoute


class TimedRoute(APIRoute):
    def get_route_handler(self) -> Callable:
        original_route_handler = super().get_route_handler()

        async def custom_route_handler(request: Request) -> Response:
            before = time.time()
            response: Response = await original_route_handler(request)
            duration = time.time() - before
            response.headers["X-Response-Time"] = str(duration)
            print(f"route duration: {duration}")
            print(f"route response: {response}")
            print(f"route response headers: {response.headers}")
            return response

        return custom_route_handler


app = FastAPI()
router = APIRouter(route_class=TimedRoute)


@app.get("/")
async def not_timed():
    return {"message": "Not timed"}


@router.get("/timed")
async def timed():
    return {"message": "It's the time of my life"}


app.include_router(router)

In this example, the path operations under the router will use the custom TimedRoute class, and will have an extra X-Response-Time header in the response with the time it took to generate the response:
Python 3.8+

import time
from typing import Callable

from fastapi import APIRouter, FastAPI, Request, Response
from fastapi.routing import APIRoute


class TimedRoute(APIRoute):
    def get_route_handler(self) -> Callable:
        original_route_handler = super().get_route_handler()

        async def custom_route_handler(request: Request) -> Response:
            before = time.time()
            response: Response = await original_route_handler(request)
            duration = time.time() - before
            response.headers["X-Response-Time"] = str(duration)
            print(f"route duration: {duration}")
            print(f"route response: {response}")
            print(f"route response headers: {response.headers}")
            return response

        return custom_route_handler


app = FastAPI()
router = APIRouter(route_class=TimedRoute)


@app.get("/")
async def not_timed():
    return {"message": "Not timed"}


@router.get("/timed")
async def timed():
    return {"message": "It's the time of my life"}


app.include_router(router)

Previous
GraphQL
Next
Conditional OpenAPI
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Conditional OpenAPI

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes
            General - How To - Recipes
            Migrate from Pydantic v1 to Pydantic v2
            GraphQL
            Custom Request and APIRoute class
            Conditional OpenAPI
            Extending OpenAPI
            Separate OpenAPI Schemas for Input and Output or Not
            Custom Docs UI Static Assets (Self-Hosting)
            Configure Swagger UI
            Testing a Database

Table of contents

    About security, APIs, and docs
    Conditional OpenAPI from settings and env vars

    FastAPI
    Learn
    How To - Recipes

Conditional OpenAPIÂ¶

If you needed to, you could use settings and environment variables to configure OpenAPI conditionally depending on the environment, and even disable it entirely.
About security, APIs, and docsÂ¶

Hiding your documentation user interfaces in production shouldn't be the way to protect your API.

That doesn't add any extra security to your API, the path operations will still be available where they are.

If there's a security flaw in your code, it will still exist.

Hiding the documentation just makes it more difficult to understand how to interact with your API, and could make it more difficult for you to debug it in production. It could be considered simply a form of Security through obscurity.

If you want to secure your API, there are several better things you can do, for example:

    Make sure you have well defined Pydantic models for your request bodies and responses.
    Configure any required permissions and roles using dependencies.
    Never store plaintext passwords, only password hashes.
    Implement and use well-known cryptographic tools, like pwdlib and JWT tokens, etc.
    Add more granular permission controls with OAuth2 scopes where needed.
    ...etc.

Nevertheless, you might have a very specific use case where you really need to disable the API docs for some environment (e.g. for production) or depending on configurations from environment variables.
Conditional OpenAPI from settings and env varsÂ¶

You can easily use the same Pydantic settings to configure your generated OpenAPI and the docs UIs.

For example:
Python 3.8+

from fastapi import FastAPI
from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    openapi_url: str = "/openapi.json"


settings = Settings()

app = FastAPI(openapi_url=settings.openapi_url)


@app.get("/")
def root():
    return {"message": "Hello World"}

Here we declare the setting openapi_url with the same default of "/openapi.json".

And then we use it when creating the FastAPI app.

Then you could disable OpenAPI (including the UI docs) by setting the environment variable OPENAPI_URL to the empty string, like:




Then if you go to the URLs at /openapi.json, /docs, or /redoc you will just get a 404 Not Found error like:

{
    "detail": "Not Found"
}

Previous
Custom Request and APIRoute class
Next
Extending OpenAPI
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Extending OpenAPI

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes
            General - How To - Recipes
            Migrate from Pydantic v1 to Pydantic v2
            GraphQL
            Custom Request and APIRoute class
            Conditional OpenAPI
            Extending OpenAPI
            Separate OpenAPI Schemas for Input and Output or Not
            Custom Docs UI Static Assets (Self-Hosting)
            Configure Swagger UI
            Testing a Database

Table of contents

    The normal process
    Overriding the defaults
        Normal FastAPI
        Generate the OpenAPI schema
        Modify the OpenAPI schema
        Cache the OpenAPI schema
        Override the method
        Check it

    FastAPI
    Learn
    How To - Recipes

Extending OpenAPIÂ¶

There are some cases where you might need to modify the generated OpenAPI schema.

In this section you will see how.
The normal processÂ¶

The normal (default) process, is as follows.

A FastAPI application (instance) has an .openapi() method that is expected to return the OpenAPI schema.

As part of the application object creation, a path operation for /openapi.json (or for whatever you set your openapi_url) is registered.

It just returns a JSON response with the result of the application's .openapi() method.

By default, what the method .openapi() does is check the property .openapi_schema to see if it has contents and return them.

If it doesn't, it generates them using the utility function at fastapi.openapi.utils.get_openapi.

And that function get_openapi() receives as parameters:

    title: The OpenAPI title, shown in the docs.
    version: The version of your API, e.g. 2.5.0.
    openapi_version: The version of the OpenAPI specification used. By default, the latest: 3.1.0.
    summary: A short summary of the API.
    description: The description of your API, this can include markdown and will be shown in the docs.
    routes: A list of routes, these are each of the registered path operations. They are taken from app.routes.

Info

The parameter summary is available in OpenAPI 3.1.0 and above, supported by FastAPI 0.99.0 and above.
Overriding the defaultsÂ¶

Using the information above, you can use the same utility function to generate the OpenAPI schema and override each part that you need.

For example, let's add ReDoc's OpenAPI extension to include a custom logo.
Normal FastAPIÂ¶

First, write all your FastAPI application as normally:
Python 3.8+

from fastapi import FastAPI
from fastapi.openapi.utils import get_openapi

app = FastAPI()


@app.get("/items/")
async def read_items():
    return [{"name": "Foo"}]


def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema
    openapi_schema = get_openapi(
        title="Custom title",
        version="2.5.0",
        summary="This is a very custom OpenAPI schema",
        description="Here's a longer description of the custom **OpenAPI** schema",
        routes=app.routes,
    )
    openapi_schema["info"]["x-logo"] = {
        "url": "https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
    }
    app.openapi_schema = openapi_schema
    return app.openapi_schema


app.openapi = custom_openapi

Generate the OpenAPI schemaÂ¶

Then, use the same utility function to generate the OpenAPI schema, inside a custom_openapi() function:
Python 3.8+

from fastapi import FastAPI
from fastapi.openapi.utils import get_openapi

app = FastAPI()


@app.get("/items/")
async def read_items():
    return [{"name": "Foo"}]


def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema
    openapi_schema = get_openapi(
        title="Custom title",
        version="2.5.0",
        summary="This is a very custom OpenAPI schema",
        description="Here's a longer description of the custom **OpenAPI** schema",
        routes=app.routes,
    )
    openapi_schema["info"]["x-logo"] = {
        "url": "https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
    }
    app.openapi_schema = openapi_schema
    return app.openapi_schema


app.openapi = custom_openapi

Modify the OpenAPI schemaÂ¶

Now you can add the ReDoc extension, adding a custom x-logo to the info "object" in the OpenAPI schema:
Python 3.8+

from fastapi import FastAPI
from fastapi.openapi.utils import get_openapi

app = FastAPI()


@app.get("/items/")
async def read_items():
    return [{"name": "Foo"}]


def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema
    openapi_schema = get_openapi(
        title="Custom title",
        version="2.5.0",
        summary="This is a very custom OpenAPI schema",
        description="Here's a longer description of the custom **OpenAPI** schema",
        routes=app.routes,
    )
    openapi_schema["info"]["x-logo"] = {
        "url": "https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
    }
    app.openapi_schema = openapi_schema
    return app.openapi_schema


app.openapi = custom_openapi

Cache the OpenAPI schemaÂ¶

You can use the property .openapi_schema as a "cache", to store your generated schema.

That way, your application won't have to generate the schema every time a user opens your API docs.

It will be generated only once, and then the same cached schema will be used for the next requests.
Python 3.8+

from fastapi import FastAPI
from fastapi.openapi.utils import get_openapi

app = FastAPI()


@app.get("/items/")
async def read_items():
    return [{"name": "Foo"}]


def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema
    openapi_schema = get_openapi(
        title="Custom title",
        version="2.5.0",
        summary="This is a very custom OpenAPI schema",
        description="Here's a longer description of the custom **OpenAPI** schema",
        routes=app.routes,
    )
    openapi_schema["info"]["x-logo"] = {
        "url": "https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
    }
    app.openapi_schema = openapi_schema
    return app.openapi_schema


app.openapi = custom_openapi

Override the methodÂ¶

Now you can replace the .openapi() method with your new function.
Python 3.8+

from fastapi import FastAPI
from fastapi.openapi.utils import get_openapi

app = FastAPI()


@app.get("/items/")
async def read_items():
    return [{"name": "Foo"}]


def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema
    openapi_schema = get_openapi(
        title="Custom title",
        version="2.5.0",
        summary="This is a very custom OpenAPI schema",
        description="Here's a longer description of the custom **OpenAPI** schema",
        routes=app.routes,
    )
    openapi_schema["info"]["x-logo"] = {
        "url": "https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
    }
    app.openapi_schema = openapi_schema
    return app.openapi_schema


app.openapi = custom_openapi

Check itÂ¶

Once you go to http://127.0.0.1:8000/redoc you will see that you are using your custom logo (in this example, FastAPI's logo):

Previous
Conditional OpenAPI
Next
Separate OpenAPI Schemas for Input and Output or Not
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
Separate OpenAPI Schemas for Input and Output or Not

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes
            General - How To - Recipes
            Migrate from Pydantic v1 to Pydantic v2
            GraphQL
            Custom Request and APIRoute class
            Conditional OpenAPI
            Extending OpenAPI
            Separate OpenAPI Schemas for Input and Output or Not
            Custom Docs UI Static Assets (Self-Hosting)
            Configure Swagger UI
            Testing a Database

Table of contents

    Pydantic Models for Input and Output
        Model for Input
        Input Model in Docs
        Model for Output
        Model for Output Response Data
        Model for Output in Docs
        Model for Input and Output in Docs
    Do not Separate Schemas
        Same Schema for Input and Output Models in Docs

    FastAPI
    Learn
    How To - Recipes

Separate OpenAPI Schemas for Input and Output or NotÂ¶

When using Pydantic v2, the generated OpenAPI is a bit more exact and correct than before. ğŸ˜

In fact, in some cases, it will even have two JSON Schemas in OpenAPI for the same Pydantic model, for input and output, depending on if they have default values.

Let's see how that works and how to change it if you need to do that.
Pydantic Models for Input and OutputÂ¶

Let's say you have a Pydantic model with default values, like this one:
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Model for InputÂ¶

If you use this model as an input like here:
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None


app = FastAPI()


@app.post("/items/")
def create_item(item: Item):
    return item

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

...then the description field will not be required. Because it has a default value of None.
Input Model in DocsÂ¶

You can confirm that in the docs, the description field doesn't have a red asterisk, it's not marked as required:
Model for OutputÂ¶

But if you use the same model as an output, like here:
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None


app = FastAPI()


@app.post("/items/")
def create_item(item: Item):
    return item


@app.get("/items/")
def read_items() -> list[Item]:
    return [
        Item(
            name="Portal Gun",
            description="Device to travel through the multi-rick-verse",
        ),
        Item(name="Plumbus"),
    ]

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

...then because description has a default value, if you don't return anything for that field, it will still have that default value.
Model for Output Response DataÂ¶

If you interact with the docs and check the response, even though the code didn't add anything in one of the description fields, the JSON response contains the default value (null):

This means that it will always have a value, it's just that sometimes the value could be None (or null in JSON).

That means that, clients using your API don't have to check if the value exists or not, they can assume the field will always be there, but just that in some cases it will have the default value of None.

The way to describe this in OpenAPI, is to mark that field as required, because it will always be there.

Because of that, the JSON Schema for a model can be different depending on if it's used for input or output:

    for input the description will not be required
    for output it will be required (and possibly None, or in JSON terms, null)

Model for Output in DocsÂ¶

You can check the output model in the docs too, both name and description are marked as required with a red asterisk:
Model for Input and Output in DocsÂ¶

And if you check all the available Schemas (JSON Schemas) in OpenAPI, you will see that there are two, one Item-Input and one Item-Output.

For Item-Input, description is not required, it doesn't have a red asterisk.

But for Item-Output, description is required, it has a red asterisk.

With this feature from Pydantic v2, your API documentation is more precise, and if you have autogenerated clients and SDKs, they will be more precise too, with a better developer experience and consistency. ğŸ‰
Do not Separate SchemasÂ¶

Now, there are some cases where you might want to have the same schema for input and output.

Probably the main use case for this is if you already have some autogenerated client code/SDKs and you don't want to update all the autogenerated client code/SDKs yet, you probably will want to do it at some point, but maybe not right now.

In that case, you can disable this feature in FastAPI, with the parameter separate_input_output_schemas=False.

Info

Support for separate_input_output_schemas was added in FastAPI 0.102.0. ğŸ¤“
Python 3.10+

from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None


app = FastAPI(separate_input_output_schemas=False)


@app.post("/items/")
def create_item(item: Item):
    return item


@app.get("/items/")
def read_items() -> list[Item]:
    return [
        Item(
            name="Portal Gun",
            description="Device to travel through the multi-rick-verse",
        ),
        Item(name="Plumbus"),
    ]

ğŸ¤“ Other versions and variants

ğŸ¤“ Other versions and variants

Same Schema for Input and Output Models in DocsÂ¶

And now there will be one single schema for input and output for the model, only Item, and it will have description as not required:

This is the same behavior as in Pydantic v1. ğŸ¤“
Previous
Extending OpenAPI
Next
Custom Docs UI Static Assets (Self-Hosting)
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
Custom Docs UI Static Assets (Self-Hosting)

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes
            General - How To - Recipes
            Migrate from Pydantic v1 to Pydantic v2
            GraphQL
            Custom Request and APIRoute class
            Conditional OpenAPI
            Extending OpenAPI
            Separate OpenAPI Schemas for Input and Output or Not
            Custom Docs UI Static Assets (Self-Hosting)
            Configure Swagger UI
            Testing a Database

Table of contents

    Custom CDN for JavaScript and CSS
        Disable the automatic docs
        Include the custom docs
        Create a path operation to test it
        Test it
    Self-hosting JavaScript and CSS for docs
        Project file structure
        Download the files
        Serve the static files
        Test the static files
        Disable the automatic docs for static files
        Include the custom docs for static files
        Create a path operation to test static files
        Test Static Files UI

    FastAPI
    Learn
    How To - Recipes

Custom Docs UI Static Assets (Self-Hosting)Â¶

The API docs use Swagger UI and ReDoc, and each of those need some JavaScript and CSS files.

By default, those files are served from a CDN.

But it's possible to customize it, you can set a specific CDN, or serve the files yourself.
Custom CDN for JavaScript and CSSÂ¶

Let's say that you want to use a different CDN, for example you want to use https://unpkg.com/.

This could be useful if for example you live in a country that restricts some URLs.
Disable the automatic docsÂ¶

The first step is to disable the automatic docs, as by default, those use the default CDN.

To disable them, set their URLs to None when creating your FastAPI app:
Python 3.8+

from fastapi import FastAPI
from fastapi.openapi.docs import (
    get_redoc_html,
    get_swagger_ui_html,
    get_swagger_ui_oauth2_redirect_html,
)

app = FastAPI(docs_url=None, redoc_url=None)


@app.get("/docs", include_in_schema=False)
async def custom_swagger_ui_html():
    return get_swagger_ui_html(
        openapi_url=app.openapi_url,
        title=app.title + " - Swagger UI",
        oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,
        swagger_js_url="https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js",
        swagger_css_url="https://unpkg.com/swagger-ui-dist@5/swagger-ui.css",
    )


@app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False)
async def swagger_ui_redirect():
    return get_swagger_ui_oauth2_redirect_html()


@app.get("/redoc", include_in_schema=False)
async def redoc_html():
    return get_redoc_html(
        openapi_url=app.openapi_url,
        title=app.title + " - ReDoc",
        redoc_js_url="https://unpkg.com/redoc@2/bundles/redoc.standalone.js",
    )


@app.get("/users/{username}")
async def read_user(username: str):
    return {"message": f"Hello {username}"}

Include the custom docsÂ¶

Now you can create the path operations for the custom docs.

You can reuse FastAPI's internal functions to create the HTML pages for the docs, and pass them the needed arguments:

    openapi_url: the URL where the HTML page for the docs can get the OpenAPI schema for your API. You can use here the attribute app.openapi_url.
    title: the title of your API.
    oauth2_redirect_url: you can use app.swagger_ui_oauth2_redirect_url here to use the default.
    swagger_js_url: the URL where the HTML for your Swagger UI docs can get the JavaScript file. This is the custom CDN URL.
    swagger_css_url: the URL where the HTML for your Swagger UI docs can get the CSS file. This is the custom CDN URL.

And similarly for ReDoc...
Python 3.8+

from fastapi import FastAPI
from fastapi.openapi.docs import (
    get_redoc_html,
    get_swagger_ui_html,
    get_swagger_ui_oauth2_redirect_html,
)

app = FastAPI(docs_url=None, redoc_url=None)


@app.get("/docs", include_in_schema=False)
async def custom_swagger_ui_html():
    return get_swagger_ui_html(
        openapi_url=app.openapi_url,
        title=app.title + " - Swagger UI",
        oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,
        swagger_js_url="https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js",
        swagger_css_url="https://unpkg.com/swagger-ui-dist@5/swagger-ui.css",
    )


@app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False)
async def swagger_ui_redirect():
    return get_swagger_ui_oauth2_redirect_html()


@app.get("/redoc", include_in_schema=False)
async def redoc_html():
    return get_redoc_html(
        openapi_url=app.openapi_url,
        title=app.title + " - ReDoc",
        redoc_js_url="https://unpkg.com/redoc@2/bundles/redoc.standalone.js",
    )


@app.get("/users/{username}")
async def read_user(username: str):
    return {"message": f"Hello {username}"}

Tip

The path operation for swagger_ui_redirect is a helper for when you use OAuth2.

If you integrate your API with an OAuth2 provider, you will be able to authenticate and come back to the API docs with the acquired credentials. And interact with it using the real OAuth2 authentication.

Swagger UI will handle it behind the scenes for you, but it needs this "redirect" helper.
Create a path operation to test itÂ¶

Now, to be able to test that everything works, create a path operation:
Python 3.8+

from fastapi import FastAPI
from fastapi.openapi.docs import (
    get_redoc_html,
    get_swagger_ui_html,
    get_swagger_ui_oauth2_redirect_html,
)

app = FastAPI(docs_url=None, redoc_url=None)


@app.get("/docs", include_in_schema=False)
async def custom_swagger_ui_html():
    return get_swagger_ui_html(
        openapi_url=app.openapi_url,
        title=app.title + " - Swagger UI",
        oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,
        swagger_js_url="https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js",
        swagger_css_url="https://unpkg.com/swagger-ui-dist@5/swagger-ui.css",
    )


@app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False)
async def swagger_ui_redirect():
    return get_swagger_ui_oauth2_redirect_html()


@app.get("/redoc", include_in_schema=False)
async def redoc_html():
    return get_redoc_html(
        openapi_url=app.openapi_url,
        title=app.title + " - ReDoc",
        redoc_js_url="https://unpkg.com/redoc@2/bundles/redoc.standalone.js",
    )


@app.get("/users/{username}")
async def read_user(username: str):
    return {"message": f"Hello {username}"}

Test itÂ¶

Now, you should be able to go to your docs at http://127.0.0.1:8000/docs, and reload the page, it will load those assets from the new CDN.
Self-hosting JavaScript and CSS for docsÂ¶

Self-hosting the JavaScript and CSS could be useful if, for example, you need your app to keep working even while offline, without open Internet access, or in a local network.

Here you'll see how to serve those files yourself, in the same FastAPI app, and configure the docs to use them.
Project file structureÂ¶

Let's say your project file structure looks like this:

.
â”œâ”€â”€ app
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py

Now create a directory to store those static files.

Your new file structure could look like this:

.
â”œâ”€â”€ app
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py
â””â”€â”€ static/

Download the filesÂ¶

Download the static files needed for the docs and put them on that static/ directory.

You can probably right-click each link and select an option similar to "Save link as...".

Swagger UI uses the files:

    swagger-ui-bundle.js
    swagger-ui.css

And ReDoc uses the file:

    redoc.standalone.js

After that, your file structure could look like:

.
â”œâ”€â”€ app
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py
â””â”€â”€ static
    â”œâ”€â”€ redoc.standalone.js
    â”œâ”€â”€ swagger-ui-bundle.js
    â””â”€â”€ swagger-ui.css

Serve the static filesÂ¶

    Import StaticFiles.
    "Mount" a StaticFiles() instance in a specific path.

Python 3.8+

from fastapi import FastAPI
from fastapi.openapi.docs import (
    get_redoc_html,
    get_swagger_ui_html,
    get_swagger_ui_oauth2_redirect_html,
)
from fastapi.staticfiles import StaticFiles

app = FastAPI(docs_url=None, redoc_url=None)

app.mount("/static", StaticFiles(directory="static"), name="static")


@app.get("/docs", include_in_schema=False)
async def custom_swagger_ui_html():
    return get_swagger_ui_html(
        openapi_url=app.openapi_url,
        title=app.title + " - Swagger UI",
        oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,
        swagger_js_url="/static/swagger-ui-bundle.js",
        swagger_css_url="/static/swagger-ui.css",
    )


@app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False)
async def swagger_ui_redirect():
    return get_swagger_ui_oauth2_redirect_html()


@app.get("/redoc", include_in_schema=False)
async def redoc_html():
    return get_redoc_html(
        openapi_url=app.openapi_url,
        title=app.title + " - ReDoc",
        redoc_js_url="/static/redoc.standalone.js",
    )


@app.get("/users/{username}")
async def read_user(username: str):
    return {"message": f"Hello {username}"}

Test the static filesÂ¶

Start your application and go to http://127.0.0.1:8000/static/redoc.standalone.js.

You should see a very long JavaScript file for ReDoc.

It could start with something like:

/*! For license information please see redoc.standalone.js.LICENSE.txt */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("null")):
...

That confirms that you are being able to serve static files from your app, and that you placed the static files for the docs in the correct place.

Now we can configure the app to use those static files for the docs.
Disable the automatic docs for static filesÂ¶

The same as when using a custom CDN, the first step is to disable the automatic docs, as those use the CDN by default.

To disable them, set their URLs to None when creating your FastAPI app:
Python 3.8+

from fastapi import FastAPI
from fastapi.openapi.docs import (
    get_redoc_html,
    get_swagger_ui_html,
    get_swagger_ui_oauth2_redirect_html,
)
from fastapi.staticfiles import StaticFiles

app = FastAPI(docs_url=None, redoc_url=None)

app.mount("/static", StaticFiles(directory="static"), name="static")


@app.get("/docs", include_in_schema=False)
async def custom_swagger_ui_html():
    return get_swagger_ui_html(
        openapi_url=app.openapi_url,
        title=app.title + " - Swagger UI",
        oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,
        swagger_js_url="/static/swagger-ui-bundle.js",
        swagger_css_url="/static/swagger-ui.css",
    )


@app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False)
async def swagger_ui_redirect():
    return get_swagger_ui_oauth2_redirect_html()


@app.get("/redoc", include_in_schema=False)
async def redoc_html():
    return get_redoc_html(
        openapi_url=app.openapi_url,
        title=app.title + " - ReDoc",
        redoc_js_url="/static/redoc.standalone.js",
    )


@app.get("/users/{username}")
async def read_user(username: str):
    return {"message": f"Hello {username}"}

Include the custom docs for static filesÂ¶

And the same way as with a custom CDN, now you can create the path operations for the custom docs.

Again, you can reuse FastAPI's internal functions to create the HTML pages for the docs, and pass them the needed arguments:

    openapi_url: the URL where the HTML page for the docs can get the OpenAPI schema for your API. You can use here the attribute app.openapi_url.
    title: the title of your API.
    oauth2_redirect_url: you can use app.swagger_ui_oauth2_redirect_url here to use the default.
    swagger_js_url: the URL where the HTML for your Swagger UI docs can get the JavaScript file. This is the one that your own app is now serving.
    swagger_css_url: the URL where the HTML for your Swagger UI docs can get the CSS file. This is the one that your own app is now serving.

And similarly for ReDoc...
Python 3.8+

from fastapi import FastAPI
from fastapi.openapi.docs import (
    get_redoc_html,
    get_swagger_ui_html,
    get_swagger_ui_oauth2_redirect_html,
)
from fastapi.staticfiles import StaticFiles

app = FastAPI(docs_url=None, redoc_url=None)

app.mount("/static", StaticFiles(directory="static"), name="static")


@app.get("/docs", include_in_schema=False)
async def custom_swagger_ui_html():
    return get_swagger_ui_html(
        openapi_url=app.openapi_url,
        title=app.title + " - Swagger UI",
        oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,
        swagger_js_url="/static/swagger-ui-bundle.js",
        swagger_css_url="/static/swagger-ui.css",
    )


@app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False)
async def swagger_ui_redirect():
    return get_swagger_ui_oauth2_redirect_html()


@app.get("/redoc", include_in_schema=False)
async def redoc_html():
    return get_redoc_html(
        openapi_url=app.openapi_url,
        title=app.title + " - ReDoc",
        redoc_js_url="/static/redoc.standalone.js",
    )


@app.get("/users/{username}")
async def read_user(username: str):
    return {"message": f"Hello {username}"}

Tip

The path operation for swagger_ui_redirect is a helper for when you use OAuth2.

If you integrate your API with an OAuth2 provider, you will be able to authenticate and come back to the API docs with the acquired credentials. And interact with it using the real OAuth2 authentication.

Swagger UI will handle it behind the scenes for you, but it needs this "redirect" helper.
Create a path operation to test static filesÂ¶

Now, to be able to test that everything works, create a path operation:
Python 3.8+

from fastapi import FastAPI
from fastapi.openapi.docs import (
    get_redoc_html,
    get_swagger_ui_html,
    get_swagger_ui_oauth2_redirect_html,
)
from fastapi.staticfiles import StaticFiles

app = FastAPI(docs_url=None, redoc_url=None)

app.mount("/static", StaticFiles(directory="static"), name="static")


@app.get("/docs", include_in_schema=False)
async def custom_swagger_ui_html():
    return get_swagger_ui_html(
        openapi_url=app.openapi_url,
        title=app.title + " - Swagger UI",
        oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,
        swagger_js_url="/static/swagger-ui-bundle.js",
        swagger_css_url="/static/swagger-ui.css",
    )


@app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False)
async def swagger_ui_redirect():
    return get_swagger_ui_oauth2_redirect_html()


@app.get("/redoc", include_in_schema=False)
async def redoc_html():
    return get_redoc_html(
        openapi_url=app.openapi_url,
        title=app.title + " - ReDoc",
        redoc_js_url="/static/redoc.standalone.js",
    )


@app.get("/users/{username}")
async def read_user(username: str):
    return {"message": f"Hello {username}"}

Test Static Files UIÂ¶

Now, you should be able to disconnect your WiFi, go to your docs at http://127.0.0.1:8000/docs, and reload the page.

And even without Internet, you would be able to see the docs for your API and interact with it.
Previous
Separate OpenAPI Schemas for Input and Output or Not
Next
Configure Swagger UI
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Configure Swagger UI

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes
            General - How To - Recipes
            Migrate from Pydantic v1 to Pydantic v2
            GraphQL
            Custom Request and APIRoute class
            Conditional OpenAPI
            Extending OpenAPI
            Separate OpenAPI Schemas for Input and Output or Not
            Custom Docs UI Static Assets (Self-Hosting)
            Configure Swagger UI
            Testing a Database

Table of contents

    Disable Syntax Highlighting
    Change the Theme
    Change Default Swagger UI Parameters
    Other Swagger UI Parameters
    JavaScript-only settings

    FastAPI
    Learn
    How To - Recipes

Configure Swagger UIÂ¶

You can configure some extra Swagger UI parameters.

To configure them, pass the swagger_ui_parameters argument when creating the FastAPI() app object or to the get_swagger_ui_html() function.

swagger_ui_parameters receives a dictionary with the configurations passed to Swagger UI directly.

FastAPI converts the configurations to JSON to make them compatible with JavaScript, as that's what Swagger UI needs.
Disable Syntax HighlightingÂ¶

For example, you could disable syntax highlighting in Swagger UI.

Without changing the settings, syntax highlighting is enabled by default:

But you can disable it by setting syntaxHighlight to False:
Python 3.8+

from fastapi import FastAPI

app = FastAPI(swagger_ui_parameters={"syntaxHighlight": False})


@app.get("/users/{username}")
async def read_user(username: str):
    return {"message": f"Hello {username}"}

...and then Swagger UI won't show the syntax highlighting anymore:

Change the ThemeÂ¶

The same way you could set the syntax highlighting theme with the key "syntaxHighlight.theme" (notice that it has a dot in the middle):
Python 3.8+

from fastapi import FastAPI

app = FastAPI(swagger_ui_parameters={"syntaxHighlight": {"theme": "obsidian"}})


@app.get("/users/{username}")
async def read_user(username: str):
    return {"message": f"Hello {username}"}

That configuration would change the syntax highlighting color theme:

Change Default Swagger UI ParametersÂ¶

FastAPI includes some default configuration parameters appropriate for most of the use cases.

It includes these default configurations:
Python 3.8+

# Code above omitted ğŸ‘†


swagger_ui_default_parameters: Annotated[
    Dict[str, Any],
    Doc(
        """
        Default configurations for Swagger UI.

        You can use it as a template to add any other configurations needed.
        """
    ),
] = {
    "dom_id": "#swagger-ui",
    "layout": "BaseLayout",
    "deepLinking": True,
    "showExtensions": True,
    "showCommonExtensions": True,

# Code below omitted ğŸ‘‡

ğŸ‘€ Full file preview

ğŸ‘€ Full file preview

You can override any of them by setting a different value in the argument swagger_ui_parameters.

For example, to disable deepLinking you could pass these settings to swagger_ui_parameters:
Python 3.8+

from fastapi import FastAPI

app = FastAPI(swagger_ui_parameters={"deepLinking": False})


@app.get("/users/{username}")
async def read_user(username: str):
    return {"message": f"Hello {username}"}

Other Swagger UI ParametersÂ¶

To see all the other possible configurations you can use, read the official docs for Swagger UI parameters.
JavaScript-only settingsÂ¶

Swagger UI also allows other configurations to be JavaScript-only objects (for example, JavaScript functions).

FastAPI also includes these JavaScript-only presets settings:

presets: [
    SwaggerUIBundle.presets.apis,
    SwaggerUIBundle.SwaggerUIStandalonePreset
]

These are JavaScript objects, not strings, so you can't pass them from Python code directly.

If you need to use JavaScript-only configurations like those, you can use one of the methods above. Override all the Swagger UI path operation and manually write any JavaScript you need.
Previous
Custom Docs UI Static Assets (Self-Hosting)
Next
Testing a Database
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Testing a Database

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Learn
        Python Types Intro
        Concurrency and async / await
        Environment Variables
        Virtual Environments
        Tutorial - User Guide
        Advanced User Guide
        FastAPI CLI
        Deployment
        How To - Recipes
            General - How To - Recipes
            Migrate from Pydantic v1 to Pydantic v2
            GraphQL
            Custom Request and APIRoute class
            Conditional OpenAPI
            Extending OpenAPI
            Separate OpenAPI Schemas for Input and Output or Not
            Custom Docs UI Static Assets (Self-Hosting)
            Configure Swagger UI
            Testing a Database

    FastAPI
    Learn
    How To - Recipes

Testing a DatabaseÂ¶

You can study about databases, SQL, and SQLModel in the SQLModel docs. ğŸ¤“

There's a mini tutorial on using SQLModel with FastAPI. âœ¨

That tutorial includes a section about testing SQL databases. ğŸ˜
Previous
Configure Swagger UI
Next
Reference
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
Reference

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

    FastAPI
    Reference

ReferenceÂ¶

Here's the reference or code API, the classes, functions, parameters, attributes, and all the FastAPI parts you can use in your applications.

If you want to learn FastAPI you are much better off reading the FastAPI Tutorial.
Previous
Testing a Database
Next
FastAPI class
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
FastAPI class

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

     FastAPI
        Example
         openapi_version
         webhooks
         state
         dependency_overrides
         openapi
         websocket
         include_router
            Example
         get
            Example
         put
            Example
         post
            Example
         delete
            Example
         options
            Example
         head
            Example
         patch
            Example
         trace
            Example
         on_event
         middleware
            Example
         exception_handler
            Example

    FastAPI
    Reference

FastAPI classÂ¶

Here's the reference information for the FastAPI class, with all its parameters, attributes and methods.

You can import the FastAPI class directly from fastapi:

from fastapi import FastAPI

fastapi.FastAPI Â¶

FastAPI(
    *,
    debug=False,
    routes=None,
    title="FastAPI",
    summary=None,
    description="",
    version="0.1.0",
    openapi_url="/openapi.json",
    openapi_tags=None,
    servers=None,
    dependencies=None,
    default_response_class=Default(JSONResponse),
    redirect_slashes=True,
    docs_url="/docs",
    redoc_url="/redoc",
    swagger_ui_oauth2_redirect_url="/docs/oauth2-redirect",
    swagger_ui_init_oauth=None,
    middleware=None,
    exception_handlers=None,
    on_startup=None,
    on_shutdown=None,
    lifespan=None,
    terms_of_service=None,
    contact=None,
    license_info=None,
    openapi_prefix="",
    root_path="",
    root_path_in_servers=True,
    responses=None,
    callbacks=None,
    webhooks=None,
    deprecated=None,
    include_in_schema=True,
    swagger_ui_parameters=None,
    generate_unique_id_function=Default(generate_unique_id),
    separate_input_output_schemas=True,
    openapi_external_docs=None,
    **extra
)

Bases: Starlette

FastAPI app class, the main entrypoint to use FastAPI.

Read more in the FastAPI docs for First Steps.
ExampleÂ¶

from fastapi import FastAPI

app = FastAPI()

PARAMETER 	DESCRIPTION
debug 	

Boolean indicating if debug tracebacks should be returned on server errors.

Read more in the Starlette docs for Applications.

TYPE: bool DEFAULT: False
routes 	

Note: you probably shouldn't use this parameter, it is inherited from Starlette and supported for compatibility.

A list of routes to serve incoming HTTP and WebSocket requests.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
title 	

The title of the API.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more in the FastAPI docs for Metadata and Docs URLs.

Example

from fastapi import FastAPI

app = FastAPI(title="ChimichangApp")

TYPE: str DEFAULT: 'FastAPI'
summary 	

A short summary of the API.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more in the FastAPI docs for Metadata and Docs URLs.

Example

from fastapi import FastAPI

app = FastAPI(summary="Deadpond's favorite app. Nuff said.")

TYPE: Optional[str] DEFAULT: None
description 	

A description of the API. Supports Markdown (using CommonMark syntax).

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more in the FastAPI docs for Metadata and Docs URLs.

Example

from fastapi import FastAPI

app = FastAPI(
    description="""
                ChimichangApp API helps you do awesome stuff. ğŸš€

                ## Items

                You can **read items**.

                ## Users

                You will be able to:

                * **Create users** (_not implemented_).
                * **Read users** (_not implemented_).

                """
)

TYPE: str DEFAULT: ''
version 	

The version of the API.

Note This is the version of your application, not the version of the OpenAPI specification nor the version of FastAPI being used.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more in the FastAPI docs for Metadata and Docs URLs.

Example

from fastapi import FastAPI

app = FastAPI(version="0.0.1")

TYPE: str DEFAULT: '0.1.0'
openapi_url 	

The URL where the OpenAPI schema will be served from.

If you set it to None, no OpenAPI schema will be served publicly, and the default automatic endpoints /docs and /redoc will also be disabled.

Read more in the FastAPI docs for Metadata and Docs URLs.

Example

from fastapi import FastAPI

app = FastAPI(openapi_url="/api/v1/openapi.json")

TYPE: Optional[str] DEFAULT: '/openapi.json'
openapi_tags 	

A list of tags used by OpenAPI, these are the same tags you can set in the path operations, like:

    @app.get("/users/", tags=["users"])
    @app.get("/items/", tags=["items"])

The order of the tags can be used to specify the order shown in tools like Swagger UI, used in the automatic path /docs.

It's not required to specify all the tags used.

The tags that are not declared MAY be organized randomly or based on the tools' logic. Each tag name in the list MUST be unique.

The value of each item is a dict containing:

    name: The name of the tag.
    description: A short description of the tag. CommonMark syntax MAY be used for rich text representation.
    externalDocs: Additional external documentation for this tag. If provided, it would contain a dict with:
        description: A short description of the target documentation. CommonMark syntax MAY be used for rich text representation.
        url: The URL for the target documentation. Value MUST be in the form of a URL.

Read more in the FastAPI docs for Metadata and Docs URLs.

Example

from fastapi import FastAPI

tags_metadata = [
    {
        "name": "users",
        "description": "Operations with users. The **login** logic is also here.",
    },
    {
        "name": "items",
        "description": "Manage items. So _fancy_ they have their own docs.",
        "externalDocs": {
            "description": "Items external docs",
            "url": "https://fastapi.tiangolo.com/",
        },
    },
]

app = FastAPI(openapi_tags=tags_metadata)

TYPE: Optional[List[Dict[str, Any]]] DEFAULT: None
servers 	

A list of dicts with connectivity information to a target server.

You would use it, for example, if your application is served from different domains and you want to use the same Swagger UI in the browser to interact with each of them (instead of having multiple browser tabs open). Or if you want to leave fixed the possible URLs.

If the servers list is not provided, or is an empty list, the default value would be a dict with a url value of /.

Each item in the list is a dict containing:

    url: A URL to the target host. This URL supports Server Variables and MAY be relative, to indicate that the host location is relative to the location where the OpenAPI document is being served. Variable substitutions will be made when a variable is named in {brackets}.
    description: An optional string describing the host designated by the URL. CommonMark syntax MAY be used for rich text representation.
    variables: A dict between a variable name and its value. The value is used for substitution in the server's URL template.

Read more in the FastAPI docs for Behind a Proxy.

Example

from fastapi import FastAPI

app = FastAPI(
    servers=[
        {"url": "https://stag.example.com", "description": "Staging environment"},
        {"url": "https://prod.example.com", "description": "Production environment"},
    ]
)

TYPE: Optional[List[Dict[str, Union[str, Any]]]] DEFAULT: None
dependencies 	

A list of global dependencies, they will be applied to each path operation, including in sub-routers.

Read more about it in the FastAPI docs for Global Dependencies.

Example

from fastapi import Depends, FastAPI

from .dependencies import func_dep_1, func_dep_2

app = FastAPI(dependencies=[Depends(func_dep_1), Depends(func_dep_2)])

TYPE: Optional[Sequence[Depends]] DEFAULT: None
default_response_class 	

The default response class to be used.

Read more in the FastAPI docs for Custom Response - HTML, Stream, File, others.

Example

from fastapi import FastAPI
from fastapi.responses import ORJSONResponse

app = FastAPI(default_response_class=ORJSONResponse)

TYPE: Type[Response] DEFAULT: Default(JSONResponse)
redirect_slashes 	

Whether to detect and redirect slashes in URLs when the client doesn't use the same format.

Example

from fastapi import FastAPI

app = FastAPI(redirect_slashes=True)  # the default

@app.get("/items/")
async def read_items():
    return [{"item_id": "Foo"}]

With this app, if a client goes to /items (without a trailing slash), they will be automatically redirected with an HTTP status code of 307 to /items/.

TYPE: bool DEFAULT: True
docs_url 	

The path to the automatic interactive API documentation. It is handled in the browser by Swagger UI.

The default URL is /docs. You can disable it by setting it to None.

If openapi_url is set to None, this will be automatically disabled.

Read more in the FastAPI docs for Metadata and Docs URLs.

Example

from fastapi import FastAPI

app = FastAPI(docs_url="/documentation", redoc_url=None)

TYPE: Optional[str] DEFAULT: '/docs'
redoc_url 	

The path to the alternative automatic interactive API documentation provided by ReDoc.

The default URL is /redoc. You can disable it by setting it to None.

If openapi_url is set to None, this will be automatically disabled.

Read more in the FastAPI docs for Metadata and Docs URLs.

Example

from fastapi import FastAPI

app = FastAPI(docs_url="/documentation", redoc_url="redocumentation")

TYPE: Optional[str] DEFAULT: '/redoc'
swagger_ui_oauth2_redirect_url 	

The OAuth2 redirect endpoint for the Swagger UI.

By default it is /docs/oauth2-redirect.

This is only used if you use OAuth2 (with the "Authorize" button) with Swagger UI.

TYPE: Optional[str] DEFAULT: '/docs/oauth2-redirect'
swagger_ui_init_oauth 	

OAuth2 configuration for the Swagger UI, by default shown at /docs.

Read more about the available configuration options in the Swagger UI docs.

TYPE: Optional[Dict[str, Any]] DEFAULT: None
middleware 	

List of middleware to be added when creating the application.

In FastAPI you would normally do this with app.add_middleware() instead.

Read more in the FastAPI docs for Middleware.

TYPE: Optional[Sequence[Middleware]] DEFAULT: None
exception_handlers 	

A dictionary with handlers for exceptions.

In FastAPI, you would normally use the decorator @app.exception_handler().

Read more in the FastAPI docs for Handling Errors.

TYPE: Optional[Dict[Union[int, Type[Exception]], Callable[[Request, Any], Coroutine[Any, Any, Response]]]] DEFAULT: None
on_startup 	

A list of startup event handler functions.

You should instead use the lifespan handlers.

Read more in the FastAPI docs for lifespan.

TYPE: Optional[Sequence[Callable[[], Any]]] DEFAULT: None
on_shutdown 	

A list of shutdown event handler functions.

You should instead use the lifespan handlers.

Read more in the FastAPI docs for lifespan.

TYPE: Optional[Sequence[Callable[[], Any]]] DEFAULT: None
lifespan 	

A Lifespan context manager handler. This replaces startup and shutdown functions with a single context manager.

Read more in the FastAPI docs for lifespan.

TYPE: Optional[Lifespan[AppType]] DEFAULT: None
terms_of_service 	

A URL to the Terms of Service for your API.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more at the FastAPI docs for Metadata and Docs URLs.

Example

app = FastAPI(terms_of_service="http://example.com/terms/")

TYPE: Optional[str] DEFAULT: None
contact 	

A dictionary with the contact information for the exposed API.

It can contain several fields.

    name: (str) The name of the contact person/organization.
    url: (str) A URL pointing to the contact information. MUST be in the format of a URL.
    email: (str) The email address of the contact person/organization. MUST be in the format of an email address.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more at the FastAPI docs for Metadata and Docs URLs.

Example

app = FastAPI(
    contact={
        "name": "Deadpoolio the Amazing",
        "url": "http://x-force.example.com/contact/",
        "email": "dp@x-force.example.com",
    }
)

TYPE: Optional[Dict[str, Union[str, Any]]] DEFAULT: None
license_info 	

A dictionary with the license information for the exposed API.

It can contain several fields.

    name: (str) REQUIRED (if a license_info is set). The license name used for the API.
    identifier: (str) An SPDX license expression for the API. The identifier field is mutually exclusive of the url field. Available since OpenAPI 3.1.0, FastAPI 0.99.0.
    url: (str) A URL to the license used for the API. This MUST be the format of a URL.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more at the FastAPI docs for Metadata and Docs URLs.

Example

app = FastAPI(
    license_info={
        "name": "Apache 2.0",
        "url": "https://www.apache.org/licenses/LICENSE-2.0.html",
    }
)

TYPE: Optional[Dict[str, Union[str, Any]]] DEFAULT: None
openapi_prefix 	

A URL prefix for the OpenAPI URL.

TYPE: str DEFAULT: ''
root_path 	

A path prefix handled by a proxy that is not seen by the application but is seen by external clients, which affects things like Swagger UI.

Read more about it at the FastAPI docs for Behind a Proxy.

Example

from fastapi import FastAPI

app = FastAPI(root_path="/api/v1")

TYPE: str DEFAULT: ''
root_path_in_servers 	

To disable automatically generating the URLs in the servers field in the autogenerated OpenAPI using the root_path.

Read more about it in the FastAPI docs for Behind a Proxy.

Example

from fastapi import FastAPI

app = FastAPI(root_path_in_servers=False)

TYPE: bool DEFAULT: True
responses 	

Additional responses to be shown in OpenAPI.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Additional Responses in OpenAPI.

And in the FastAPI docs for Bigger Applications.

TYPE: Optional[Dict[Union[int, str], Dict[str, Any]]] DEFAULT: None
callbacks 	

OpenAPI callbacks that should apply to all path operations.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for OpenAPI Callbacks.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
webhooks 	

Add OpenAPI webhooks. This is similar to callbacks but it doesn't depend on specific path operations.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Note: This is available since OpenAPI 3.1.0, FastAPI 0.99.0.

Read more about it in the FastAPI docs for OpenAPI Webhooks.

TYPE: Optional[APIRouter] DEFAULT: None
deprecated 	

Mark all path operations as deprecated. You probably don't need it, but it's available.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[bool] DEFAULT: None
include_in_schema 	

To include (or not) all the path operations in the generated OpenAPI. You probably don't need it, but it's available.

This affects the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Query Parameters and String Validations.

TYPE: bool DEFAULT: True
swagger_ui_parameters 	

Parameters to configure Swagger UI, the autogenerated interactive API documentation (by default at /docs).

Read more about it in the FastAPI docs about how to Configure Swagger UI.

TYPE: Optional[Dict[str, Any]] DEFAULT: None
generate_unique_id_function 	

Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI.

This is particularly useful when automatically generating clients or SDKs for your API.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Callable[[APIRoute], str] DEFAULT: Default(generate_unique_id)
separate_input_output_schemas 	

Whether to generate separate OpenAPI schemas for request body and response body when the results would be more precise.

This is particularly useful when automatically generating clients.

For example, if you have a model like:

from pydantic import BaseModel

class Item(BaseModel):
    name: str
    tags: list[str] = []

When Item is used for input, a request body, tags is not required, the client doesn't have to provide it.

But when using Item for output, for a response body, tags is always available because it has a default value, even if it's just an empty list. So, the client should be able to always expect it.

In this case, there would be two different schemas, one for input and another one for output.

TYPE: bool DEFAULT: True
openapi_external_docs 	

This field allows you to provide additional external documentation links. If provided, it must be a dictionary containing:

    description: A brief description of the external documentation.
    url: The URL pointing to the external documentation. The value MUST be a valid URL format.

Example:

from fastapi import FastAPI

external_docs = {
    "description": "Detailed API Reference",
    "url": "https://example.com/api-docs",
}

app = FastAPI(openapi_external_docs=external_docs)

TYPE: Optional[Dict[str, Any]] DEFAULT: None
**extra 	

Extra keyword arguments to be stored in the app, not used by FastAPI anywhere.

TYPE: Any DEFAULT: {}
Source code in fastapi/applications.py

Source code in fastapi/applications.py

openapi_version instance-attribute Â¶

openapi_version = '3.1.0'

The version string of OpenAPI.

FastAPI will generate OpenAPI version 3.1.0, and will output that as the OpenAPI version. But some tools, even though they might be compatible with OpenAPI 3.1.0, might not recognize it as a valid.

So you could override this value to trick those tools into using the generated OpenAPI. Have in mind that this is a hack. But if you avoid using features added in OpenAPI 3.1.0, it might work for your use case.

This is not passed as a parameter to the FastAPI class to avoid giving the false idea that FastAPI would generate a different OpenAPI schema. It is only available as an attribute.

Example

from fastapi import FastAPI

app = FastAPI()

app.openapi_version = "3.0.2"

webhooks instance-attribute Â¶

webhooks = webhooks or APIRouter()

The app.webhooks attribute is an APIRouter with the path operations that will be used just for documentation of webhooks.

Read more about it in the FastAPI docs for OpenAPI Webhooks.
state instance-attribute Â¶

state = State()

A state object for the application. This is the same object for the entire application, it doesn't change from request to request.

You normally wouldn't use this in FastAPI, for most of the cases you would instead use FastAPI dependencies.

This is simply inherited from Starlette.

Read more about it in the Starlette docs for Applications.
dependency_overrides instance-attribute Â¶

dependency_overrides = {}

A dictionary with overrides for the dependencies.

Each key is the original dependency callable, and the value is the actual dependency that should be called.

This is for testing, to replace expensive dependencies with testing versions.

Read more about it in the FastAPI docs for Testing Dependencies with Overrides.
openapi Â¶

openapi()

Generate the OpenAPI schema of the application. This is called by FastAPI internally.

The first time it is called it stores the result in the attribute app.openapi_schema, and next times it is called, it just returns that same result. To avoid the cost of generating the schema every time.

If you need to modify the generated OpenAPI schema, you could modify it.

Read more in the FastAPI docs for OpenAPI.
Source code in fastapi/applications.py

Source code in fastapi/applications.py

websocket Â¶

websocket(path, name=None, *, dependencies=None)

Decorate a WebSocket function.

Read more about it in the FastAPI docs for WebSockets.

Example

from fastapi import FastAPI, WebSocket

app = FastAPI()

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        await websocket.send_text(f"Message text was: {data}")

PARAMETER 	DESCRIPTION
path 	

WebSocket path.

TYPE: str
name 	

A name for the WebSocket. Only used internally.

TYPE: Optional[str] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be used for this WebSocket.

Read more about it in the FastAPI docs for WebSockets.

TYPE: Optional[Sequence[Depends]] DEFAULT: None
Source code in fastapi/applications.py

Source code in fastapi/applications.py

include_router Â¶

include_router(
    router,
    *,
    prefix="",
    tags=None,
    dependencies=None,
    responses=None,
    deprecated=None,
    include_in_schema=True,
    default_response_class=Default(JSONResponse),
    callbacks=None,
    generate_unique_id_function=Default(generate_unique_id)
)

Include an APIRouter in the same app.

Read more about it in the FastAPI docs for Bigger Applications.
ExampleÂ¶

from fastapi import FastAPI

from .users import users_router

app = FastAPI()

app.include_router(users_router)

PARAMETER 	DESCRIPTION
router 	

The APIRouter to include.

TYPE: APIRouter
prefix 	

An optional path prefix for the router.

TYPE: str DEFAULT: ''
tags 	

A list of tags to be applied to all the path operations in this router.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[List[Union[str, Enum]]] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be applied to all the path operations in this router.

Read more about it in the FastAPI docs for Bigger Applications - Multiple Files.

Example

from fastapi import Depends, FastAPI

from .dependencies import get_token_header
from .internal import admin

app = FastAPI()

app.include_router(
    admin.router,
    dependencies=[Depends(get_token_header)],
)

TYPE: Optional[Sequence[Depends]] DEFAULT: None
responses 	

Additional responses to be shown in OpenAPI.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Additional Responses in OpenAPI.

And in the FastAPI docs for Bigger Applications.

TYPE: Optional[Dict[Union[int, str], Dict[str, Any]]] DEFAULT: None
deprecated 	

Mark all the path operations in this router as deprecated.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Example

from fastapi import FastAPI

from .internal import old_api

app = FastAPI()

app.include_router(
    old_api.router,
    deprecated=True,
)

TYPE: Optional[bool] DEFAULT: None
include_in_schema 	

Include (or not) all the path operations in this router in the generated OpenAPI schema.

This affects the generated OpenAPI (e.g. visible at /docs).

Example

from fastapi import FastAPI

from .internal import old_api

app = FastAPI()

app.include_router(
    old_api.router,
    include_in_schema=False,
)

TYPE: bool DEFAULT: True
default_response_class 	

Default response class to be used for the path operations in this router.

Read more in the FastAPI docs for Custom Response - HTML, Stream, File, others.

Example

from fastapi import FastAPI
from fastapi.responses import ORJSONResponse

from .internal import old_api

app = FastAPI()

app.include_router(
    old_api.router,
    default_response_class=ORJSONResponse,
)

TYPE: Type[Response] DEFAULT: Default(JSONResponse)
callbacks 	

List of path operations that will be used as OpenAPI callbacks.

This is only for OpenAPI documentation, the callbacks won't be used directly.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for OpenAPI Callbacks.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
generate_unique_id_function 	

Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI.

This is particularly useful when automatically generating clients or SDKs for your API.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Callable[[APIRoute], str] DEFAULT: Default(generate_unique_id)
Source code in fastapi/applications.py

Source code in fastapi/applications.py

get Â¶

get(
    path,
    *,
    response_model=Default(None),
    status_code=None,
    tags=None,
    dependencies=None,
    summary=None,
    description=None,
    response_description="Successful Response",
    responses=None,
    deprecated=None,
    operation_id=None,
    response_model_include=None,
    response_model_exclude=None,
    response_model_by_alias=True,
    response_model_exclude_unset=False,
    response_model_exclude_defaults=False,
    response_model_exclude_none=False,
    include_in_schema=True,
    response_class=Default(JSONResponse),
    name=None,
    callbacks=None,
    openapi_extra=None,
    generate_unique_id_function=Default(generate_unique_id)
)

Add a path operation using an HTTP GET operation.
ExampleÂ¶

from fastapi import FastAPI

app = FastAPI()

@app.get("/items/")
def read_items():
    return [{"name": "Empanada"}, {"name": "Arepa"}]

PARAMETER 	DESCRIPTION
path 	

The URL path to be used for this path operation.

For example, in http://example.com/items, the path is /items.

TYPE: str
response_model 	

The type to use for the response.

It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc.

It will be used for:

    Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema).
    Serialization: you could return an arbitrary object and the response_model would be used to serialize that object into the corresponding JSON.
    Filtering: the JSON sent to the client will only contain the data (fields) defined in the response_model. If you returned an object that contains an attribute password but the response_model does not include that field, the JSON sent to the client would not have that password.
    Validation: whatever you return will be serialized with the response_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the FastAPI docs for Response Model.

TYPE: Any DEFAULT: Default(None)
status_code 	

The default status code to be used for the response.

You could override the status code by returning a response directly.

Read more about it in the FastAPI docs for Response Status Code.

TYPE: Optional[int] DEFAULT: None
tags 	

A list of tags to be applied to the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[List[Union[str, Enum]]] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be applied to the path operation.

Read more about it in the FastAPI docs for Dependencies in path operation decorators.

TYPE: Optional[Sequence[Depends]] DEFAULT: None
summary 	

A summary for the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
description 	

A description for the path operation.

If not provided, it will be extracted automatically from the docstring of the path operation function.

It can contain Markdown.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
response_description 	

The description for the default response.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: str DEFAULT: 'Successful Response'
responses 	

Additional responses that could be returned by this path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[Dict[Union[int, str], Dict[str, Any]]] DEFAULT: None
deprecated 	

Mark this path operation as deprecated.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[bool] DEFAULT: None
operation_id 	

Custom operation ID to be used by this path operation.

By default, it is generated automatically.

If you provide a custom operation ID, you need to make sure it is unique for the whole API.

You can customize the operation ID generation with the parameter generate_unique_id_function in the FastAPI class.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Optional[str] DEFAULT: None
response_model_include 	

Configuration passed to Pydantic to include only certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_exclude 	

Configuration passed to Pydantic to exclude certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_by_alias 	

Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: True
response_model_exclude_unset 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response_model_exclude_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_defaults 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response_model_exclude_unset in that if the fields are set but contain the same default values, they will be excluded from the response.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_none 	

Configuration passed to Pydantic to define if the response data should exclude fields set to None.

This is much simpler (less smart) than response_model_exclude_unset and response_model_exclude_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
include_in_schema 	

Include this path operation in the generated OpenAPI schema.

This affects the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Query Parameters and String Validations.

TYPE: bool DEFAULT: True
response_class 	

Response class to be used for this path operation.

This will not be used if you return a response directly.

Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others.

TYPE: Type[Response] DEFAULT: Default(JSONResponse)
name 	

Name for this path operation. Only used internally.

TYPE: Optional[str] DEFAULT: None
callbacks 	

List of path operations that will be used as OpenAPI callbacks.

This is only for OpenAPI documentation, the callbacks won't be used directly.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for OpenAPI Callbacks.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
openapi_extra 	

Extra metadata to be included in the OpenAPI schema for this path operation.

Read more about it in the FastAPI docs for Path Operation Advanced Configuration.

TYPE: Optional[Dict[str, Any]] DEFAULT: None
generate_unique_id_function 	

Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI.

This is particularly useful when automatically generating clients or SDKs for your API.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Callable[[APIRoute], str] DEFAULT: Default(generate_unique_id)
Source code in fastapi/applications.py

Source code in fastapi/applications.py

put Â¶

put(
    path,
    *,
    response_model=Default(None),
    status_code=None,
    tags=None,
    dependencies=None,
    summary=None,
    description=None,
    response_description="Successful Response",
    responses=None,
    deprecated=None,
    operation_id=None,
    response_model_include=None,
    response_model_exclude=None,
    response_model_by_alias=True,
    response_model_exclude_unset=False,
    response_model_exclude_defaults=False,
    response_model_exclude_none=False,
    include_in_schema=True,
    response_class=Default(JSONResponse),
    name=None,
    callbacks=None,
    openapi_extra=None,
    generate_unique_id_function=Default(generate_unique_id)
)

Add a path operation using an HTTP PUT operation.
ExampleÂ¶

from fastapi import FastAPI
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    description: str | None = None

app = FastAPI()

@app.put("/items/{item_id}")
def replace_item(item_id: str, item: Item):
    return {"message": "Item replaced", "id": item_id}

PARAMETER 	DESCRIPTION
path 	

The URL path to be used for this path operation.

For example, in http://example.com/items, the path is /items.

TYPE: str
response_model 	

The type to use for the response.

It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc.

It will be used for:

    Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema).
    Serialization: you could return an arbitrary object and the response_model would be used to serialize that object into the corresponding JSON.
    Filtering: the JSON sent to the client will only contain the data (fields) defined in the response_model. If you returned an object that contains an attribute password but the response_model does not include that field, the JSON sent to the client would not have that password.
    Validation: whatever you return will be serialized with the response_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the FastAPI docs for Response Model.

TYPE: Any DEFAULT: Default(None)
status_code 	

The default status code to be used for the response.

You could override the status code by returning a response directly.

Read more about it in the FastAPI docs for Response Status Code.

TYPE: Optional[int] DEFAULT: None
tags 	

A list of tags to be applied to the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[List[Union[str, Enum]]] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be applied to the path operation.

Read more about it in the FastAPI docs for Dependencies in path operation decorators.

TYPE: Optional[Sequence[Depends]] DEFAULT: None
summary 	

A summary for the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
description 	

A description for the path operation.

If not provided, it will be extracted automatically from the docstring of the path operation function.

It can contain Markdown.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
response_description 	

The description for the default response.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: str DEFAULT: 'Successful Response'
responses 	

Additional responses that could be returned by this path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[Dict[Union[int, str], Dict[str, Any]]] DEFAULT: None
deprecated 	

Mark this path operation as deprecated.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[bool] DEFAULT: None
operation_id 	

Custom operation ID to be used by this path operation.

By default, it is generated automatically.

If you provide a custom operation ID, you need to make sure it is unique for the whole API.

You can customize the operation ID generation with the parameter generate_unique_id_function in the FastAPI class.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Optional[str] DEFAULT: None
response_model_include 	

Configuration passed to Pydantic to include only certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_exclude 	

Configuration passed to Pydantic to exclude certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_by_alias 	

Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: True
response_model_exclude_unset 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response_model_exclude_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_defaults 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response_model_exclude_unset in that if the fields are set but contain the same default values, they will be excluded from the response.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_none 	

Configuration passed to Pydantic to define if the response data should exclude fields set to None.

This is much simpler (less smart) than response_model_exclude_unset and response_model_exclude_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
include_in_schema 	

Include this path operation in the generated OpenAPI schema.

This affects the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Query Parameters and String Validations.

TYPE: bool DEFAULT: True
response_class 	

Response class to be used for this path operation.

This will not be used if you return a response directly.

Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others.

TYPE: Type[Response] DEFAULT: Default(JSONResponse)
name 	

Name for this path operation. Only used internally.

TYPE: Optional[str] DEFAULT: None
callbacks 	

List of path operations that will be used as OpenAPI callbacks.

This is only for OpenAPI documentation, the callbacks won't be used directly.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for OpenAPI Callbacks.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
openapi_extra 	

Extra metadata to be included in the OpenAPI schema for this path operation.

Read more about it in the FastAPI docs for Path Operation Advanced Configuration.

TYPE: Optional[Dict[str, Any]] DEFAULT: None
generate_unique_id_function 	

Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI.

This is particularly useful when automatically generating clients or SDKs for your API.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Callable[[APIRoute], str] DEFAULT: Default(generate_unique_id)
Source code in fastapi/applications.py

Source code in fastapi/applications.py

post Â¶

post(
    path,
    *,
    response_model=Default(None),
    status_code=None,
    tags=None,
    dependencies=None,
    summary=None,
    description=None,
    response_description="Successful Response",
    responses=None,
    deprecated=None,
    operation_id=None,
    response_model_include=None,
    response_model_exclude=None,
    response_model_by_alias=True,
    response_model_exclude_unset=False,
    response_model_exclude_defaults=False,
    response_model_exclude_none=False,
    include_in_schema=True,
    response_class=Default(JSONResponse),
    name=None,
    callbacks=None,
    openapi_extra=None,
    generate_unique_id_function=Default(generate_unique_id)
)

Add a path operation using an HTTP POST operation.
ExampleÂ¶

from fastapi import FastAPI
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    description: str | None = None

app = FastAPI()

@app.post("/items/")
def create_item(item: Item):
    return {"message": "Item created"}

PARAMETER 	DESCRIPTION
path 	

The URL path to be used for this path operation.

For example, in http://example.com/items, the path is /items.

TYPE: str
response_model 	

The type to use for the response.

It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc.

It will be used for:

    Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema).
    Serialization: you could return an arbitrary object and the response_model would be used to serialize that object into the corresponding JSON.
    Filtering: the JSON sent to the client will only contain the data (fields) defined in the response_model. If you returned an object that contains an attribute password but the response_model does not include that field, the JSON sent to the client would not have that password.
    Validation: whatever you return will be serialized with the response_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the FastAPI docs for Response Model.

TYPE: Any DEFAULT: Default(None)
status_code 	

The default status code to be used for the response.

You could override the status code by returning a response directly.

Read more about it in the FastAPI docs for Response Status Code.

TYPE: Optional[int] DEFAULT: None
tags 	

A list of tags to be applied to the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[List[Union[str, Enum]]] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be applied to the path operation.

Read more about it in the FastAPI docs for Dependencies in path operation decorators.

TYPE: Optional[Sequence[Depends]] DEFAULT: None
summary 	

A summary for the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
description 	

A description for the path operation.

If not provided, it will be extracted automatically from the docstring of the path operation function.

It can contain Markdown.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
response_description 	

The description for the default response.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: str DEFAULT: 'Successful Response'
responses 	

Additional responses that could be returned by this path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[Dict[Union[int, str], Dict[str, Any]]] DEFAULT: None
deprecated 	

Mark this path operation as deprecated.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[bool] DEFAULT: None
operation_id 	

Custom operation ID to be used by this path operation.

By default, it is generated automatically.

If you provide a custom operation ID, you need to make sure it is unique for the whole API.

You can customize the operation ID generation with the parameter generate_unique_id_function in the FastAPI class.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Optional[str] DEFAULT: None
response_model_include 	

Configuration passed to Pydantic to include only certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_exclude 	

Configuration passed to Pydantic to exclude certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_by_alias 	

Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: True
response_model_exclude_unset 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response_model_exclude_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_defaults 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response_model_exclude_unset in that if the fields are set but contain the same default values, they will be excluded from the response.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_none 	

Configuration passed to Pydantic to define if the response data should exclude fields set to None.

This is much simpler (less smart) than response_model_exclude_unset and response_model_exclude_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
include_in_schema 	

Include this path operation in the generated OpenAPI schema.

This affects the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Query Parameters and String Validations.

TYPE: bool DEFAULT: True
response_class 	

Response class to be used for this path operation.

This will not be used if you return a response directly.

Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others.

TYPE: Type[Response] DEFAULT: Default(JSONResponse)
name 	

Name for this path operation. Only used internally.

TYPE: Optional[str] DEFAULT: None
callbacks 	

List of path operations that will be used as OpenAPI callbacks.

This is only for OpenAPI documentation, the callbacks won't be used directly.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for OpenAPI Callbacks.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
openapi_extra 	

Extra metadata to be included in the OpenAPI schema for this path operation.

Read more about it in the FastAPI docs for Path Operation Advanced Configuration.

TYPE: Optional[Dict[str, Any]] DEFAULT: None
generate_unique_id_function 	

Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI.

This is particularly useful when automatically generating clients or SDKs for your API.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Callable[[APIRoute], str] DEFAULT: Default(generate_unique_id)
Source code in fastapi/applications.py

Source code in fastapi/applications.py

delete Â¶

delete(
    path,
    *,
    response_model=Default(None),
    status_code=None,
    tags=None,
    dependencies=None,
    summary=None,
    description=None,
    response_description="Successful Response",
    responses=None,
    deprecated=None,
    operation_id=None,
    response_model_include=None,
    response_model_exclude=None,
    response_model_by_alias=True,
    response_model_exclude_unset=False,
    response_model_exclude_defaults=False,
    response_model_exclude_none=False,
    include_in_schema=True,
    response_class=Default(JSONResponse),
    name=None,
    callbacks=None,
    openapi_extra=None,
    generate_unique_id_function=Default(generate_unique_id)
)

Add a path operation using an HTTP DELETE operation.
ExampleÂ¶

from fastapi import FastAPI

app = FastAPI()

@app.delete("/items/{item_id}")
def delete_item(item_id: str):
    return {"message": "Item deleted"}

PARAMETER 	DESCRIPTION
path 	

The URL path to be used for this path operation.

For example, in http://example.com/items, the path is /items.

TYPE: str
response_model 	

The type to use for the response.

It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc.

It will be used for:

    Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema).
    Serialization: you could return an arbitrary object and the response_model would be used to serialize that object into the corresponding JSON.
    Filtering: the JSON sent to the client will only contain the data (fields) defined in the response_model. If you returned an object that contains an attribute password but the response_model does not include that field, the JSON sent to the client would not have that password.
    Validation: whatever you return will be serialized with the response_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the FastAPI docs for Response Model.

TYPE: Any DEFAULT: Default(None)
status_code 	

The default status code to be used for the response.

You could override the status code by returning a response directly.

Read more about it in the FastAPI docs for Response Status Code.

TYPE: Optional[int] DEFAULT: None
tags 	

A list of tags to be applied to the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[List[Union[str, Enum]]] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be applied to the path operation.

Read more about it in the FastAPI docs for Dependencies in path operation decorators.

TYPE: Optional[Sequence[Depends]] DEFAULT: None
summary 	

A summary for the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
description 	

A description for the path operation.

If not provided, it will be extracted automatically from the docstring of the path operation function.

It can contain Markdown.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
response_description 	

The description for the default response.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: str DEFAULT: 'Successful Response'
responses 	

Additional responses that could be returned by this path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[Dict[Union[int, str], Dict[str, Any]]] DEFAULT: None
deprecated 	

Mark this path operation as deprecated.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[bool] DEFAULT: None
operation_id 	

Custom operation ID to be used by this path operation.

By default, it is generated automatically.

If you provide a custom operation ID, you need to make sure it is unique for the whole API.

You can customize the operation ID generation with the parameter generate_unique_id_function in the FastAPI class.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Optional[str] DEFAULT: None
response_model_include 	

Configuration passed to Pydantic to include only certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_exclude 	

Configuration passed to Pydantic to exclude certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_by_alias 	

Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: True
response_model_exclude_unset 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response_model_exclude_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_defaults 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response_model_exclude_unset in that if the fields are set but contain the same default values, they will be excluded from the response.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_none 	

Configuration passed to Pydantic to define if the response data should exclude fields set to None.

This is much simpler (less smart) than response_model_exclude_unset and response_model_exclude_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
include_in_schema 	

Include this path operation in the generated OpenAPI schema.

This affects the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Query Parameters and String Validations.

TYPE: bool DEFAULT: True
response_class 	

Response class to be used for this path operation.

This will not be used if you return a response directly.

Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others.

TYPE: Type[Response] DEFAULT: Default(JSONResponse)
name 	

Name for this path operation. Only used internally.

TYPE: Optional[str] DEFAULT: None
callbacks 	

List of path operations that will be used as OpenAPI callbacks.

This is only for OpenAPI documentation, the callbacks won't be used directly.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for OpenAPI Callbacks.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
openapi_extra 	

Extra metadata to be included in the OpenAPI schema for this path operation.

Read more about it in the FastAPI docs for Path Operation Advanced Configuration.

TYPE: Optional[Dict[str, Any]] DEFAULT: None
generate_unique_id_function 	

Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI.

This is particularly useful when automatically generating clients or SDKs for your API.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Callable[[APIRoute], str] DEFAULT: Default(generate_unique_id)
Source code in fastapi/applications.py

Source code in fastapi/applications.py

options Â¶

options(
    path,
    *,
    response_model=Default(None),
    status_code=None,
    tags=None,
    dependencies=None,
    summary=None,
    description=None,
    response_description="Successful Response",
    responses=None,
    deprecated=None,
    operation_id=None,
    response_model_include=None,
    response_model_exclude=None,
    response_model_by_alias=True,
    response_model_exclude_unset=False,
    response_model_exclude_defaults=False,
    response_model_exclude_none=False,
    include_in_schema=True,
    response_class=Default(JSONResponse),
    name=None,
    callbacks=None,
    openapi_extra=None,
    generate_unique_id_function=Default(generate_unique_id)
)

Add a path operation using an HTTP OPTIONS operation.
ExampleÂ¶

from fastapi import FastAPI

app = FastAPI()

@app.options("/items/")
def get_item_options():
    return {"additions": ["Aji", "Guacamole"]}

PARAMETER 	DESCRIPTION
path 	

The URL path to be used for this path operation.

For example, in http://example.com/items, the path is /items.

TYPE: str
response_model 	

The type to use for the response.

It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc.

It will be used for:

    Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema).
    Serialization: you could return an arbitrary object and the response_model would be used to serialize that object into the corresponding JSON.
    Filtering: the JSON sent to the client will only contain the data (fields) defined in the response_model. If you returned an object that contains an attribute password but the response_model does not include that field, the JSON sent to the client would not have that password.
    Validation: whatever you return will be serialized with the response_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the FastAPI docs for Response Model.

TYPE: Any DEFAULT: Default(None)
status_code 	

The default status code to be used for the response.

You could override the status code by returning a response directly.

Read more about it in the FastAPI docs for Response Status Code.

TYPE: Optional[int] DEFAULT: None
tags 	

A list of tags to be applied to the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[List[Union[str, Enum]]] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be applied to the path operation.

Read more about it in the FastAPI docs for Dependencies in path operation decorators.

TYPE: Optional[Sequence[Depends]] DEFAULT: None
summary 	

A summary for the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
description 	

A description for the path operation.

If not provided, it will be extracted automatically from the docstring of the path operation function.

It can contain Markdown.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
response_description 	

The description for the default response.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: str DEFAULT: 'Successful Response'
responses 	

Additional responses that could be returned by this path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[Dict[Union[int, str], Dict[str, Any]]] DEFAULT: None
deprecated 	

Mark this path operation as deprecated.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[bool] DEFAULT: None
operation_id 	

Custom operation ID to be used by this path operation.

By default, it is generated automatically.

If you provide a custom operation ID, you need to make sure it is unique for the whole API.

You can customize the operation ID generation with the parameter generate_unique_id_function in the FastAPI class.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Optional[str] DEFAULT: None
response_model_include 	

Configuration passed to Pydantic to include only certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_exclude 	

Configuration passed to Pydantic to exclude certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_by_alias 	

Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: True
response_model_exclude_unset 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response_model_exclude_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_defaults 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response_model_exclude_unset in that if the fields are set but contain the same default values, they will be excluded from the response.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_none 	

Configuration passed to Pydantic to define if the response data should exclude fields set to None.

This is much simpler (less smart) than response_model_exclude_unset and response_model_exclude_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
include_in_schema 	

Include this path operation in the generated OpenAPI schema.

This affects the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Query Parameters and String Validations.

TYPE: bool DEFAULT: True
response_class 	

Response class to be used for this path operation.

This will not be used if you return a response directly.

Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others.

TYPE: Type[Response] DEFAULT: Default(JSONResponse)
name 	

Name for this path operation. Only used internally.

TYPE: Optional[str] DEFAULT: None
callbacks 	

List of path operations that will be used as OpenAPI callbacks.

This is only for OpenAPI documentation, the callbacks won't be used directly.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for OpenAPI Callbacks.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
openapi_extra 	

Extra metadata to be included in the OpenAPI schema for this path operation.

Read more about it in the FastAPI docs for Path Operation Advanced Configuration.

TYPE: Optional[Dict[str, Any]] DEFAULT: None
generate_unique_id_function 	

Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI.

This is particularly useful when automatically generating clients or SDKs for your API.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Callable[[APIRoute], str] DEFAULT: Default(generate_unique_id)
Source code in fastapi/applications.py

Source code in fastapi/applications.py

head Â¶

head(
    path,
    *,
    response_model=Default(None),
    status_code=None,
    tags=None,
    dependencies=None,
    summary=None,
    description=None,
    response_description="Successful Response",
    responses=None,
    deprecated=None,
    operation_id=None,
    response_model_include=None,
    response_model_exclude=None,
    response_model_by_alias=True,
    response_model_exclude_unset=False,
    response_model_exclude_defaults=False,
    response_model_exclude_none=False,
    include_in_schema=True,
    response_class=Default(JSONResponse),
    name=None,
    callbacks=None,
    openapi_extra=None,
    generate_unique_id_function=Default(generate_unique_id)
)

Add a path operation using an HTTP HEAD operation.
ExampleÂ¶

from fastapi import FastAPI, Response

app = FastAPI()

@app.head("/items/", status_code=204)
def get_items_headers(response: Response):
    response.headers["X-Cat-Dog"] = "Alone in the world"

PARAMETER 	DESCRIPTION
path 	

The URL path to be used for this path operation.

For example, in http://example.com/items, the path is /items.

TYPE: str
response_model 	

The type to use for the response.

It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc.

It will be used for:

    Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema).
    Serialization: you could return an arbitrary object and the response_model would be used to serialize that object into the corresponding JSON.
    Filtering: the JSON sent to the client will only contain the data (fields) defined in the response_model. If you returned an object that contains an attribute password but the response_model does not include that field, the JSON sent to the client would not have that password.
    Validation: whatever you return will be serialized with the response_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the FastAPI docs for Response Model.

TYPE: Any DEFAULT: Default(None)
status_code 	

The default status code to be used for the response.

You could override the status code by returning a response directly.

Read more about it in the FastAPI docs for Response Status Code.

TYPE: Optional[int] DEFAULT: None
tags 	

A list of tags to be applied to the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[List[Union[str, Enum]]] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be applied to the path operation.

Read more about it in the FastAPI docs for Dependencies in path operation decorators.

TYPE: Optional[Sequence[Depends]] DEFAULT: None
summary 	

A summary for the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
description 	

A description for the path operation.

If not provided, it will be extracted automatically from the docstring of the path operation function.

It can contain Markdown.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
response_description 	

The description for the default response.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: str DEFAULT: 'Successful Response'
responses 	

Additional responses that could be returned by this path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[Dict[Union[int, str], Dict[str, Any]]] DEFAULT: None
deprecated 	

Mark this path operation as deprecated.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[bool] DEFAULT: None
operation_id 	

Custom operation ID to be used by this path operation.

By default, it is generated automatically.

If you provide a custom operation ID, you need to make sure it is unique for the whole API.

You can customize the operation ID generation with the parameter generate_unique_id_function in the FastAPI class.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Optional[str] DEFAULT: None
response_model_include 	

Configuration passed to Pydantic to include only certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_exclude 	

Configuration passed to Pydantic to exclude certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_by_alias 	

Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: True
response_model_exclude_unset 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response_model_exclude_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_defaults 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response_model_exclude_unset in that if the fields are set but contain the same default values, they will be excluded from the response.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_none 	

Configuration passed to Pydantic to define if the response data should exclude fields set to None.

This is much simpler (less smart) than response_model_exclude_unset and response_model_exclude_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
include_in_schema 	

Include this path operation in the generated OpenAPI schema.

This affects the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Query Parameters and String Validations.

TYPE: bool DEFAULT: True
response_class 	

Response class to be used for this path operation.

This will not be used if you return a response directly.

Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others.

TYPE: Type[Response] DEFAULT: Default(JSONResponse)
name 	

Name for this path operation. Only used internally.

TYPE: Optional[str] DEFAULT: None
callbacks 	

List of path operations that will be used as OpenAPI callbacks.

This is only for OpenAPI documentation, the callbacks won't be used directly.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for OpenAPI Callbacks.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
openapi_extra 	

Extra metadata to be included in the OpenAPI schema for this path operation.

Read more about it in the FastAPI docs for Path Operation Advanced Configuration.

TYPE: Optional[Dict[str, Any]] DEFAULT: None
generate_unique_id_function 	

Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI.

This is particularly useful when automatically generating clients or SDKs for your API.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Callable[[APIRoute], str] DEFAULT: Default(generate_unique_id)
Source code in fastapi/applications.py

Source code in fastapi/applications.py

patch Â¶

patch(
    path,
    *,
    response_model=Default(None),
    status_code=None,
    tags=None,
    dependencies=None,
    summary=None,
    description=None,
    response_description="Successful Response",
    responses=None,
    deprecated=None,
    operation_id=None,
    response_model_include=None,
    response_model_exclude=None,
    response_model_by_alias=True,
    response_model_exclude_unset=False,
    response_model_exclude_defaults=False,
    response_model_exclude_none=False,
    include_in_schema=True,
    response_class=Default(JSONResponse),
    name=None,
    callbacks=None,
    openapi_extra=None,
    generate_unique_id_function=Default(generate_unique_id)
)

Add a path operation using an HTTP PATCH operation.
ExampleÂ¶

from fastapi import FastAPI
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    description: str | None = None

app = FastAPI()

@app.patch("/items/")
def update_item(item: Item):
    return {"message": "Item updated in place"}

PARAMETER 	DESCRIPTION
path 	

The URL path to be used for this path operation.

For example, in http://example.com/items, the path is /items.

TYPE: str
response_model 	

The type to use for the response.

It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc.

It will be used for:

    Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema).
    Serialization: you could return an arbitrary object and the response_model would be used to serialize that object into the corresponding JSON.
    Filtering: the JSON sent to the client will only contain the data (fields) defined in the response_model. If you returned an object that contains an attribute password but the response_model does not include that field, the JSON sent to the client would not have that password.
    Validation: whatever you return will be serialized with the response_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the FastAPI docs for Response Model.

TYPE: Any DEFAULT: Default(None)
status_code 	

The default status code to be used for the response.

You could override the status code by returning a response directly.

Read more about it in the FastAPI docs for Response Status Code.

TYPE: Optional[int] DEFAULT: None
tags 	

A list of tags to be applied to the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[List[Union[str, Enum]]] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be applied to the path operation.

Read more about it in the FastAPI docs for Dependencies in path operation decorators.

TYPE: Optional[Sequence[Depends]] DEFAULT: None
summary 	

A summary for the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
description 	

A description for the path operation.

If not provided, it will be extracted automatically from the docstring of the path operation function.

It can contain Markdown.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
response_description 	

The description for the default response.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: str DEFAULT: 'Successful Response'
responses 	

Additional responses that could be returned by this path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[Dict[Union[int, str], Dict[str, Any]]] DEFAULT: None
deprecated 	

Mark this path operation as deprecated.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[bool] DEFAULT: None
operation_id 	

Custom operation ID to be used by this path operation.

By default, it is generated automatically.

If you provide a custom operation ID, you need to make sure it is unique for the whole API.

You can customize the operation ID generation with the parameter generate_unique_id_function in the FastAPI class.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Optional[str] DEFAULT: None
response_model_include 	

Configuration passed to Pydantic to include only certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_exclude 	

Configuration passed to Pydantic to exclude certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_by_alias 	

Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: True
response_model_exclude_unset 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response_model_exclude_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_defaults 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response_model_exclude_unset in that if the fields are set but contain the same default values, they will be excluded from the response.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_none 	

Configuration passed to Pydantic to define if the response data should exclude fields set to None.

This is much simpler (less smart) than response_model_exclude_unset and response_model_exclude_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
include_in_schema 	

Include this path operation in the generated OpenAPI schema.

This affects the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Query Parameters and String Validations.

TYPE: bool DEFAULT: True
response_class 	

Response class to be used for this path operation.

This will not be used if you return a response directly.

Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others.

TYPE: Type[Response] DEFAULT: Default(JSONResponse)
name 	

Name for this path operation. Only used internally.

TYPE: Optional[str] DEFAULT: None
callbacks 	

List of path operations that will be used as OpenAPI callbacks.

This is only for OpenAPI documentation, the callbacks won't be used directly.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for OpenAPI Callbacks.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
openapi_extra 	

Extra metadata to be included in the OpenAPI schema for this path operation.

Read more about it in the FastAPI docs for Path Operation Advanced Configuration.

TYPE: Optional[Dict[str, Any]] DEFAULT: None
generate_unique_id_function 	

Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI.

This is particularly useful when automatically generating clients or SDKs for your API.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Callable[[APIRoute], str] DEFAULT: Default(generate_unique_id)
Source code in fastapi/applications.py

Source code in fastapi/applications.py

trace Â¶

trace(
    path,
    *,
    response_model=Default(None),
    status_code=None,
    tags=None,
    dependencies=None,
    summary=None,
    description=None,
    response_description="Successful Response",
    responses=None,
    deprecated=None,
    operation_id=None,
    response_model_include=None,
    response_model_exclude=None,
    response_model_by_alias=True,
    response_model_exclude_unset=False,
    response_model_exclude_defaults=False,
    response_model_exclude_none=False,
    include_in_schema=True,
    response_class=Default(JSONResponse),
    name=None,
    callbacks=None,
    openapi_extra=None,
    generate_unique_id_function=Default(generate_unique_id)
)

Add a path operation using an HTTP TRACE operation.
ExampleÂ¶

from fastapi import FastAPI

app = FastAPI()

@app.trace("/items/{item_id}")
def trace_item(item_id: str):
    return None

PARAMETER 	DESCRIPTION
path 	

The URL path to be used for this path operation.

For example, in http://example.com/items, the path is /items.

TYPE: str
response_model 	

The type to use for the response.

It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc.

It will be used for:

    Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema).
    Serialization: you could return an arbitrary object and the response_model would be used to serialize that object into the corresponding JSON.
    Filtering: the JSON sent to the client will only contain the data (fields) defined in the response_model. If you returned an object that contains an attribute password but the response_model does not include that field, the JSON sent to the client would not have that password.
    Validation: whatever you return will be serialized with the response_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the FastAPI docs for Response Model.

TYPE: Any DEFAULT: Default(None)
status_code 	

The default status code to be used for the response.

You could override the status code by returning a response directly.

Read more about it in the FastAPI docs for Response Status Code.

TYPE: Optional[int] DEFAULT: None
tags 	

A list of tags to be applied to the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[List[Union[str, Enum]]] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be applied to the path operation.

Read more about it in the FastAPI docs for Dependencies in path operation decorators.

TYPE: Optional[Sequence[Depends]] DEFAULT: None
summary 	

A summary for the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
description 	

A description for the path operation.

If not provided, it will be extracted automatically from the docstring of the path operation function.

It can contain Markdown.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
response_description 	

The description for the default response.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: str DEFAULT: 'Successful Response'
responses 	

Additional responses that could be returned by this path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[Dict[Union[int, str], Dict[str, Any]]] DEFAULT: None
deprecated 	

Mark this path operation as deprecated.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[bool] DEFAULT: None
operation_id 	

Custom operation ID to be used by this path operation.

By default, it is generated automatically.

If you provide a custom operation ID, you need to make sure it is unique for the whole API.

You can customize the operation ID generation with the parameter generate_unique_id_function in the FastAPI class.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Optional[str] DEFAULT: None
response_model_include 	

Configuration passed to Pydantic to include only certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_exclude 	

Configuration passed to Pydantic to exclude certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_by_alias 	

Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: True
response_model_exclude_unset 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response_model_exclude_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_defaults 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response_model_exclude_unset in that if the fields are set but contain the same default values, they will be excluded from the response.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_none 	

Configuration passed to Pydantic to define if the response data should exclude fields set to None.

This is much simpler (less smart) than response_model_exclude_unset and response_model_exclude_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
include_in_schema 	

Include this path operation in the generated OpenAPI schema.

This affects the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Query Parameters and String Validations.

TYPE: bool DEFAULT: True
response_class 	

Response class to be used for this path operation.

This will not be used if you return a response directly.

Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others.

TYPE: Type[Response] DEFAULT: Default(JSONResponse)
name 	

Name for this path operation. Only used internally.

TYPE: Optional[str] DEFAULT: None
callbacks 	

List of path operations that will be used as OpenAPI callbacks.

This is only for OpenAPI documentation, the callbacks won't be used directly.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for OpenAPI Callbacks.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
openapi_extra 	

Extra metadata to be included in the OpenAPI schema for this path operation.

Read more about it in the FastAPI docs for Path Operation Advanced Configuration.

TYPE: Optional[Dict[str, Any]] DEFAULT: None
generate_unique_id_function 	

Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI.

This is particularly useful when automatically generating clients or SDKs for your API.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Callable[[APIRoute], str] DEFAULT: Default(generate_unique_id)
Source code in fastapi/applications.py

Source code in fastapi/applications.py

on_event Â¶

on_event(event_type)

Add an event handler for the application.

on_event is deprecated, use lifespan event handlers instead.

Read more about it in the FastAPI docs for Lifespan Events.
PARAMETER 	DESCRIPTION
event_type 	

The type of event. startup or shutdown.

TYPE: str
Source code in fastapi/applications.py

Source code in fastapi/applications.py

middleware Â¶

middleware(middleware_type)

Add a middleware to the application.

Read more about it in the FastAPI docs for Middleware.
ExampleÂ¶

import time
from typing import Awaitable, Callable

from fastapi import FastAPI, Request, Response

app = FastAPI()


@app.middleware("http")
async def add_process_time_header(
    request: Request, call_next: Callable[[Request], Awaitable[Response]]
) -> Response:
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response

PARAMETER 	DESCRIPTION
middleware_type 	

The type of middleware. Currently only supports http.

TYPE: str
Source code in fastapi/applications.py

Source code in fastapi/applications.py

exception_handler Â¶

exception_handler(exc_class_or_status_code)

Add an exception handler to the app.

Read more about it in the FastAPI docs for Handling Errors.
ExampleÂ¶

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse


class UnicornException(Exception):
    def __init__(self, name: str):
        self.name = name


app = FastAPI()


@app.exception_handler(UnicornException)
async def unicorn_exception_handler(request: Request, exc: UnicornException):
    return JSONResponse(
        status_code=418,
        content={"message": f"Oops! {exc.name} did something. There goes a rainbow..."},
    )

PARAMETER 	DESCRIPTION
exc_class_or_status_code 	

The Exception class this would handle, or a status code.

TYPE: Union[int, Type[Exception]]
Source code in fastapi/applications.py

Source code in fastapi/applications.py

Previous
Reference
Next
Request Parameters
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Request Parameters

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

     Query
     Path
     Body
     Cookie
     Header
     Form
     File

    FastAPI
    Reference

Request ParametersÂ¶

Here's the reference information for the request parameters.

These are the special functions that you can put in path operation function parameters or dependency functions with Annotated to get data from the request.

It includes:

    Query()
    Path()
    Body()
    Cookie()
    Header()
    Form()
    File()

You can import them all directly from fastapi:

from fastapi import Body, Cookie, File, Form, Header, Path, Query

fastapi.Query Â¶

Query(
    default=Undefined,
    *,
    default_factory=_Unset,
    alias=None,
    alias_priority=_Unset,
    validation_alias=None,
    serialization_alias=None,
    title=None,
    description=None,
    gt=None,
    ge=None,
    lt=None,
    le=None,
    min_length=None,
    max_length=None,
    pattern=None,
    regex=None,
    discriminator=None,
    strict=_Unset,
    multiple_of=_Unset,
    allow_inf_nan=_Unset,
    max_digits=_Unset,
    decimal_places=_Unset,
    examples=None,
    example=_Unset,
    openapi_examples=None,
    deprecated=None,
    include_in_schema=True,
    json_schema_extra=None,
    **extra
)

PARAMETER 	DESCRIPTION
default 	

Default value if the parameter field is not set.

TYPE: Any DEFAULT: Undefined
default_factory 	

A callable to generate the default value.

This doesn't affect Path parameters as the value is always required. The parameter is available only for compatibility.

TYPE: Union[Callable[[], Any], None] DEFAULT: _Unset
alias 	

An alternative name for the parameter field.

This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar.

TYPE: Optional[str] DEFAULT: None
alias_priority 	

Priority of the alias. This affects whether an alias generator is used.

TYPE: Union[int, None] DEFAULT: _Unset
validation_alias 	

'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined.

TYPE: Union[str, None] DEFAULT: None
serialization_alias 	

'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time.

TYPE: Union[str, None] DEFAULT: None
title 	

Human-readable title.

TYPE: Optional[str] DEFAULT: None
description 	

Human-readable description.

TYPE: Optional[str] DEFAULT: None
gt 	

Greater than. If set, value must be greater than this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
ge 	

Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
lt 	

Less than. If set, value must be less than this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
le 	

Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
min_length 	

Minimum length for strings.

TYPE: Optional[int] DEFAULT: None
max_length 	

Maximum length for strings.

TYPE: Optional[int] DEFAULT: None
pattern 	

RegEx pattern for strings.

TYPE: Optional[str] DEFAULT: None
regex 	

Deprecated in FastAPI 0.100.0 and Pydantic v2, use pattern instead. RegEx pattern for strings.

TYPE: Optional[str] DEFAULT: None
discriminator 	

Parameter field name for discriminating the type in a tagged union.

TYPE: Union[str, None] DEFAULT: None
strict 	

If True, strict validation is applied to the field.

TYPE: Union[bool, None] DEFAULT: _Unset
multiple_of 	

Value must be a multiple of this. Only applicable to numbers.

TYPE: Union[float, None] DEFAULT: _Unset
allow_inf_nan 	

Allow inf, -inf, nan. Only applicable to numbers.

TYPE: Union[bool, None] DEFAULT: _Unset
max_digits 	

Maximum number of allow digits for strings.

TYPE: Union[int, None] DEFAULT: _Unset
decimal_places 	

Maximum number of decimal places allowed for numbers.

TYPE: Union[int, None] DEFAULT: _Unset
examples 	

Example values for this field.

TYPE: Optional[List[Any]] DEFAULT: None
example 	

Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.

TYPE: Optional[Any] DEFAULT: _Unset
openapi_examples 	

OpenAPI-specific examples.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Swagger UI (that provides the /docs interface) has better support for the OpenAPI-specific examples than the JSON Schema examples, that's the main use case for this.

Read more about it in the FastAPI docs for Declare Request Example Data.

TYPE: Optional[Dict[str, Example]] DEFAULT: None
deprecated 	

Mark this parameter field as deprecated.

It will affect the generated OpenAPI (e.g. visible at /docs).

TYPE: Union[deprecated, str, bool, None] DEFAULT: None
include_in_schema 	

To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available.

This affects the generated OpenAPI (e.g. visible at /docs).

TYPE: bool DEFAULT: True
json_schema_extra 	

Any additional JSON schema data.

TYPE: Union[Dict[str, Any], None] DEFAULT: None
**extra 	

The extra kwargs is deprecated. Use json_schema_extra instead. Include extra fields used by the JSON Schema.

TYPE: Any DEFAULT: {}
Source code in fastapi/param_functions.py

Source code in fastapi/param_functions.py

fastapi.Path Â¶

Path(
    default=...,
    *,
    default_factory=_Unset,
    alias=None,
    alias_priority=_Unset,
    validation_alias=None,
    serialization_alias=None,
    title=None,
    description=None,
    gt=None,
    ge=None,
    lt=None,
    le=None,
    min_length=None,
    max_length=None,
    pattern=None,
    regex=None,
    discriminator=None,
    strict=_Unset,
    multiple_of=_Unset,
    allow_inf_nan=_Unset,
    max_digits=_Unset,
    decimal_places=_Unset,
    examples=None,
    example=_Unset,
    openapi_examples=None,
    deprecated=None,
    include_in_schema=True,
    json_schema_extra=None,
    **extra
)

Declare a path parameter for a path operation.

Read more about it in the FastAPI docs for Path Parameters and Numeric Validations.

from typing import Annotated

from fastapi import FastAPI, Path

app = FastAPI()


@app.get("/items/{item_id}")
async def read_items(
    item_id: Annotated[int, Path(title="The ID of the item to get")],
):
    return {"item_id": item_id}

PARAMETER 	DESCRIPTION
default 	

Default value if the parameter field is not set.

This doesn't affect Path parameters as the value is always required. The parameter is available only for compatibility.

TYPE: Any DEFAULT: ...
default_factory 	

A callable to generate the default value.

This doesn't affect Path parameters as the value is always required. The parameter is available only for compatibility.

TYPE: Union[Callable[[], Any], None] DEFAULT: _Unset
alias 	

An alternative name for the parameter field.

This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar.

TYPE: Optional[str] DEFAULT: None
alias_priority 	

Priority of the alias. This affects whether an alias generator is used.

TYPE: Union[int, None] DEFAULT: _Unset
validation_alias 	

'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined.

TYPE: Union[str, None] DEFAULT: None
serialization_alias 	

'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time.

TYPE: Union[str, None] DEFAULT: None
title 	

Human-readable title.

TYPE: Optional[str] DEFAULT: None
description 	

Human-readable description.

TYPE: Optional[str] DEFAULT: None
gt 	

Greater than. If set, value must be greater than this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
ge 	

Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
lt 	

Less than. If set, value must be less than this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
le 	

Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
min_length 	

Minimum length for strings.

TYPE: Optional[int] DEFAULT: None
max_length 	

Maximum length for strings.

TYPE: Optional[int] DEFAULT: None
pattern 	

RegEx pattern for strings.

TYPE: Optional[str] DEFAULT: None
regex 	

Deprecated in FastAPI 0.100.0 and Pydantic v2, use pattern instead. RegEx pattern for strings.

TYPE: Optional[str] DEFAULT: None
discriminator 	

Parameter field name for discriminating the type in a tagged union.

TYPE: Union[str, None] DEFAULT: None
strict 	

If True, strict validation is applied to the field.

TYPE: Union[bool, None] DEFAULT: _Unset
multiple_of 	

Value must be a multiple of this. Only applicable to numbers.

TYPE: Union[float, None] DEFAULT: _Unset
allow_inf_nan 	

Allow inf, -inf, nan. Only applicable to numbers.

TYPE: Union[bool, None] DEFAULT: _Unset
max_digits 	

Maximum number of allow digits for strings.

TYPE: Union[int, None] DEFAULT: _Unset
decimal_places 	

Maximum number of decimal places allowed for numbers.

TYPE: Union[int, None] DEFAULT: _Unset
examples 	

Example values for this field.

TYPE: Optional[List[Any]] DEFAULT: None
example 	

Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.

TYPE: Optional[Any] DEFAULT: _Unset
openapi_examples 	

OpenAPI-specific examples.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Swagger UI (that provides the /docs interface) has better support for the OpenAPI-specific examples than the JSON Schema examples, that's the main use case for this.

Read more about it in the FastAPI docs for Declare Request Example Data.

TYPE: Optional[Dict[str, Example]] DEFAULT: None
deprecated 	

Mark this parameter field as deprecated.

It will affect the generated OpenAPI (e.g. visible at /docs).

TYPE: Union[deprecated, str, bool, None] DEFAULT: None
include_in_schema 	

To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available.

This affects the generated OpenAPI (e.g. visible at /docs).

TYPE: bool DEFAULT: True
json_schema_extra 	

Any additional JSON schema data.

TYPE: Union[Dict[str, Any], None] DEFAULT: None
**extra 	

The extra kwargs is deprecated. Use json_schema_extra instead. Include extra fields used by the JSON Schema.

TYPE: Any DEFAULT: {}
Source code in fastapi/param_functions.py

Source code in fastapi/param_functions.py

fastapi.Body Â¶

Body(
    default=Undefined,
    *,
    default_factory=_Unset,
    embed=None,
    media_type="application/json",
    alias=None,
    alias_priority=_Unset,
    validation_alias=None,
    serialization_alias=None,
    title=None,
    description=None,
    gt=None,
    ge=None,
    lt=None,
    le=None,
    min_length=None,
    max_length=None,
    pattern=None,
    regex=None,
    discriminator=None,
    strict=_Unset,
    multiple_of=_Unset,
    allow_inf_nan=_Unset,
    max_digits=_Unset,
    decimal_places=_Unset,
    examples=None,
    example=_Unset,
    openapi_examples=None,
    deprecated=None,
    include_in_schema=True,
    json_schema_extra=None,
    **extra
)

PARAMETER 	DESCRIPTION
default 	

Default value if the parameter field is not set.

TYPE: Any DEFAULT: Undefined
default_factory 	

A callable to generate the default value.

This doesn't affect Path parameters as the value is always required. The parameter is available only for compatibility.

TYPE: Union[Callable[[], Any], None] DEFAULT: _Unset
embed 	

When embed is True, the parameter will be expected in a JSON body as a key instead of being the JSON body itself.

This happens automatically when more than one Body parameter is declared.

Read more about it in the FastAPI docs for Body - Multiple Parameters.

TYPE: Union[bool, None] DEFAULT: None
media_type 	

The media type of this parameter field. Changing it would affect the generated OpenAPI, but currently it doesn't affect the parsing of the data.

TYPE: str DEFAULT: 'application/json'
alias 	

An alternative name for the parameter field.

This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar.

TYPE: Optional[str] DEFAULT: None
alias_priority 	

Priority of the alias. This affects whether an alias generator is used.

TYPE: Union[int, None] DEFAULT: _Unset
validation_alias 	

'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined.

TYPE: Union[str, None] DEFAULT: None
serialization_alias 	

'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time.

TYPE: Union[str, None] DEFAULT: None
title 	

Human-readable title.

TYPE: Optional[str] DEFAULT: None
description 	

Human-readable description.

TYPE: Optional[str] DEFAULT: None
gt 	

Greater than. If set, value must be greater than this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
ge 	

Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
lt 	

Less than. If set, value must be less than this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
le 	

Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
min_length 	

Minimum length for strings.

TYPE: Optional[int] DEFAULT: None
max_length 	

Maximum length for strings.

TYPE: Optional[int] DEFAULT: None
pattern 	

RegEx pattern for strings.

TYPE: Optional[str] DEFAULT: None
regex 	

Deprecated in FastAPI 0.100.0 and Pydantic v2, use pattern instead. RegEx pattern for strings.

TYPE: Optional[str] DEFAULT: None
discriminator 	

Parameter field name for discriminating the type in a tagged union.

TYPE: Union[str, None] DEFAULT: None
strict 	

If True, strict validation is applied to the field.

TYPE: Union[bool, None] DEFAULT: _Unset
multiple_of 	

Value must be a multiple of this. Only applicable to numbers.

TYPE: Union[float, None] DEFAULT: _Unset
allow_inf_nan 	

Allow inf, -inf, nan. Only applicable to numbers.

TYPE: Union[bool, None] DEFAULT: _Unset
max_digits 	

Maximum number of allow digits for strings.

TYPE: Union[int, None] DEFAULT: _Unset
decimal_places 	

Maximum number of decimal places allowed for numbers.

TYPE: Union[int, None] DEFAULT: _Unset
examples 	

Example values for this field.

TYPE: Optional[List[Any]] DEFAULT: None
example 	

Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.

TYPE: Optional[Any] DEFAULT: _Unset
openapi_examples 	

OpenAPI-specific examples.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Swagger UI (that provides the /docs interface) has better support for the OpenAPI-specific examples than the JSON Schema examples, that's the main use case for this.

Read more about it in the FastAPI docs for Declare Request Example Data.

TYPE: Optional[Dict[str, Example]] DEFAULT: None
deprecated 	

Mark this parameter field as deprecated.

It will affect the generated OpenAPI (e.g. visible at /docs).

TYPE: Union[deprecated, str, bool, None] DEFAULT: None
include_in_schema 	

To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available.

This affects the generated OpenAPI (e.g. visible at /docs).

TYPE: bool DEFAULT: True
json_schema_extra 	

Any additional JSON schema data.

TYPE: Union[Dict[str, Any], None] DEFAULT: None
**extra 	

The extra kwargs is deprecated. Use json_schema_extra instead. Include extra fields used by the JSON Schema.

TYPE: Any DEFAULT: {}
Source code in fastapi/param_functions.py

Source code in fastapi/param_functions.py

fastapi.Cookie Â¶

Cookie(
    default=Undefined,
    *,
    default_factory=_Unset,
    alias=None,
    alias_priority=_Unset,
    validation_alias=None,
    serialization_alias=None,
    title=None,
    description=None,
    gt=None,
    ge=None,
    lt=None,
    le=None,
    min_length=None,
    max_length=None,
    pattern=None,
    regex=None,
    discriminator=None,
    strict=_Unset,
    multiple_of=_Unset,
    allow_inf_nan=_Unset,
    max_digits=_Unset,
    decimal_places=_Unset,
    examples=None,
    example=_Unset,
    openapi_examples=None,
    deprecated=None,
    include_in_schema=True,
    json_schema_extra=None,
    **extra
)

PARAMETER 	DESCRIPTION
default 	

Default value if the parameter field is not set.

TYPE: Any DEFAULT: Undefined
default_factory 	

A callable to generate the default value.

This doesn't affect Path parameters as the value is always required. The parameter is available only for compatibility.

TYPE: Union[Callable[[], Any], None] DEFAULT: _Unset
alias 	

An alternative name for the parameter field.

This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar.

TYPE: Optional[str] DEFAULT: None
alias_priority 	

Priority of the alias. This affects whether an alias generator is used.

TYPE: Union[int, None] DEFAULT: _Unset
validation_alias 	

'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined.

TYPE: Union[str, None] DEFAULT: None
serialization_alias 	

'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time.

TYPE: Union[str, None] DEFAULT: None
title 	

Human-readable title.

TYPE: Optional[str] DEFAULT: None
description 	

Human-readable description.

TYPE: Optional[str] DEFAULT: None
gt 	

Greater than. If set, value must be greater than this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
ge 	

Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
lt 	

Less than. If set, value must be less than this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
le 	

Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
min_length 	

Minimum length for strings.

TYPE: Optional[int] DEFAULT: None
max_length 	

Maximum length for strings.

TYPE: Optional[int] DEFAULT: None
pattern 	

RegEx pattern for strings.

TYPE: Optional[str] DEFAULT: None
regex 	

Deprecated in FastAPI 0.100.0 and Pydantic v2, use pattern instead. RegEx pattern for strings.

TYPE: Optional[str] DEFAULT: None
discriminator 	

Parameter field name for discriminating the type in a tagged union.

TYPE: Union[str, None] DEFAULT: None
strict 	

If True, strict validation is applied to the field.

TYPE: Union[bool, None] DEFAULT: _Unset
multiple_of 	

Value must be a multiple of this. Only applicable to numbers.

TYPE: Union[float, None] DEFAULT: _Unset
allow_inf_nan 	

Allow inf, -inf, nan. Only applicable to numbers.

TYPE: Union[bool, None] DEFAULT: _Unset
max_digits 	

Maximum number of allow digits for strings.

TYPE: Union[int, None] DEFAULT: _Unset
decimal_places 	

Maximum number of decimal places allowed for numbers.

TYPE: Union[int, None] DEFAULT: _Unset
examples 	

Example values for this field.

TYPE: Optional[List[Any]] DEFAULT: None
example 	

Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.

TYPE: Optional[Any] DEFAULT: _Unset
openapi_examples 	

OpenAPI-specific examples.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Swagger UI (that provides the /docs interface) has better support for the OpenAPI-specific examples than the JSON Schema examples, that's the main use case for this.

Read more about it in the FastAPI docs for Declare Request Example Data.

TYPE: Optional[Dict[str, Example]] DEFAULT: None
deprecated 	

Mark this parameter field as deprecated.

It will affect the generated OpenAPI (e.g. visible at /docs).

TYPE: Union[deprecated, str, bool, None] DEFAULT: None
include_in_schema 	

To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available.

This affects the generated OpenAPI (e.g. visible at /docs).

TYPE: bool DEFAULT: True
json_schema_extra 	

Any additional JSON schema data.

TYPE: Union[Dict[str, Any], None] DEFAULT: None
**extra 	

The extra kwargs is deprecated. Use json_schema_extra instead. Include extra fields used by the JSON Schema.

TYPE: Any DEFAULT: {}
Source code in fastapi/param_functions.py

Source code in fastapi/param_functions.py

fastapi.Header Â¶

Header(
    default=Undefined,
    *,
    default_factory=_Unset,
    alias=None,
    alias_priority=_Unset,
    validation_alias=None,
    serialization_alias=None,
    convert_underscores=True,
    title=None,
    description=None,
    gt=None,
    ge=None,
    lt=None,
    le=None,
    min_length=None,
    max_length=None,
    pattern=None,
    regex=None,
    discriminator=None,
    strict=_Unset,
    multiple_of=_Unset,
    allow_inf_nan=_Unset,
    max_digits=_Unset,
    decimal_places=_Unset,
    examples=None,
    example=_Unset,
    openapi_examples=None,
    deprecated=None,
    include_in_schema=True,
    json_schema_extra=None,
    **extra
)

PARAMETER 	DESCRIPTION
default 	

Default value if the parameter field is not set.

TYPE: Any DEFAULT: Undefined
default_factory 	

A callable to generate the default value.

This doesn't affect Path parameters as the value is always required. The parameter is available only for compatibility.

TYPE: Union[Callable[[], Any], None] DEFAULT: _Unset
alias 	

An alternative name for the parameter field.

This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar.

TYPE: Optional[str] DEFAULT: None
alias_priority 	

Priority of the alias. This affects whether an alias generator is used.

TYPE: Union[int, None] DEFAULT: _Unset
validation_alias 	

'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined.

TYPE: Union[str, None] DEFAULT: None
serialization_alias 	

'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time.

TYPE: Union[str, None] DEFAULT: None
convert_underscores 	

Automatically convert underscores to hyphens in the parameter field name.

Read more about it in the FastAPI docs for Header Parameters

TYPE: bool DEFAULT: True
title 	

Human-readable title.

TYPE: Optional[str] DEFAULT: None
description 	

Human-readable description.

TYPE: Optional[str] DEFAULT: None
gt 	

Greater than. If set, value must be greater than this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
ge 	

Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
lt 	

Less than. If set, value must be less than this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
le 	

Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
min_length 	

Minimum length for strings.

TYPE: Optional[int] DEFAULT: None
max_length 	

Maximum length for strings.

TYPE: Optional[int] DEFAULT: None
pattern 	

RegEx pattern for strings.

TYPE: Optional[str] DEFAULT: None
regex 	

Deprecated in FastAPI 0.100.0 and Pydantic v2, use pattern instead. RegEx pattern for strings.

TYPE: Optional[str] DEFAULT: None
discriminator 	

Parameter field name for discriminating the type in a tagged union.

TYPE: Union[str, None] DEFAULT: None
strict 	

If True, strict validation is applied to the field.

TYPE: Union[bool, None] DEFAULT: _Unset
multiple_of 	

Value must be a multiple of this. Only applicable to numbers.

TYPE: Union[float, None] DEFAULT: _Unset
allow_inf_nan 	

Allow inf, -inf, nan. Only applicable to numbers.

TYPE: Union[bool, None] DEFAULT: _Unset
max_digits 	

Maximum number of allow digits for strings.

TYPE: Union[int, None] DEFAULT: _Unset
decimal_places 	

Maximum number of decimal places allowed for numbers.

TYPE: Union[int, None] DEFAULT: _Unset
examples 	

Example values for this field.

TYPE: Optional[List[Any]] DEFAULT: None
example 	

Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.

TYPE: Optional[Any] DEFAULT: _Unset
openapi_examples 	

OpenAPI-specific examples.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Swagger UI (that provides the /docs interface) has better support for the OpenAPI-specific examples than the JSON Schema examples, that's the main use case for this.

Read more about it in the FastAPI docs for Declare Request Example Data.

TYPE: Optional[Dict[str, Example]] DEFAULT: None
deprecated 	

Mark this parameter field as deprecated.

It will affect the generated OpenAPI (e.g. visible at /docs).

TYPE: Union[deprecated, str, bool, None] DEFAULT: None
include_in_schema 	

To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available.

This affects the generated OpenAPI (e.g. visible at /docs).

TYPE: bool DEFAULT: True
json_schema_extra 	

Any additional JSON schema data.

TYPE: Union[Dict[str, Any], None] DEFAULT: None
**extra 	

The extra kwargs is deprecated. Use json_schema_extra instead. Include extra fields used by the JSON Schema.

TYPE: Any DEFAULT: {}
Source code in fastapi/param_functions.py

Source code in fastapi/param_functions.py

fastapi.Form Â¶

Form(
    default=Undefined,
    *,
    default_factory=_Unset,
    media_type="application/x-www-form-urlencoded",
    alias=None,
    alias_priority=_Unset,
    validation_alias=None,
    serialization_alias=None,
    title=None,
    description=None,
    gt=None,
    ge=None,
    lt=None,
    le=None,
    min_length=None,
    max_length=None,
    pattern=None,
    regex=None,
    discriminator=None,
    strict=_Unset,
    multiple_of=_Unset,
    allow_inf_nan=_Unset,
    max_digits=_Unset,
    decimal_places=_Unset,
    examples=None,
    example=_Unset,
    openapi_examples=None,
    deprecated=None,
    include_in_schema=True,
    json_schema_extra=None,
    **extra
)

PARAMETER 	DESCRIPTION
default 	

Default value if the parameter field is not set.

TYPE: Any DEFAULT: Undefined
default_factory 	

A callable to generate the default value.

This doesn't affect Path parameters as the value is always required. The parameter is available only for compatibility.

TYPE: Union[Callable[[], Any], None] DEFAULT: _Unset
media_type 	

The media type of this parameter field. Changing it would affect the generated OpenAPI, but currently it doesn't affect the parsing of the data.

TYPE: str DEFAULT: 'application/x-www-form-urlencoded'
alias 	

An alternative name for the parameter field.

This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar.

TYPE: Optional[str] DEFAULT: None
alias_priority 	

Priority of the alias. This affects whether an alias generator is used.

TYPE: Union[int, None] DEFAULT: _Unset
validation_alias 	

'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined.

TYPE: Union[str, None] DEFAULT: None
serialization_alias 	

'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time.

TYPE: Union[str, None] DEFAULT: None
title 	

Human-readable title.

TYPE: Optional[str] DEFAULT: None
description 	

Human-readable description.

TYPE: Optional[str] DEFAULT: None
gt 	

Greater than. If set, value must be greater than this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
ge 	

Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
lt 	

Less than. If set, value must be less than this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
le 	

Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
min_length 	

Minimum length for strings.

TYPE: Optional[int] DEFAULT: None
max_length 	

Maximum length for strings.

TYPE: Optional[int] DEFAULT: None
pattern 	

RegEx pattern for strings.

TYPE: Optional[str] DEFAULT: None
regex 	

Deprecated in FastAPI 0.100.0 and Pydantic v2, use pattern instead. RegEx pattern for strings.

TYPE: Optional[str] DEFAULT: None
discriminator 	

Parameter field name for discriminating the type in a tagged union.

TYPE: Union[str, None] DEFAULT: None
strict 	

If True, strict validation is applied to the field.

TYPE: Union[bool, None] DEFAULT: _Unset
multiple_of 	

Value must be a multiple of this. Only applicable to numbers.

TYPE: Union[float, None] DEFAULT: _Unset
allow_inf_nan 	

Allow inf, -inf, nan. Only applicable to numbers.

TYPE: Union[bool, None] DEFAULT: _Unset
max_digits 	

Maximum number of allow digits for strings.

TYPE: Union[int, None] DEFAULT: _Unset
decimal_places 	

Maximum number of decimal places allowed for numbers.

TYPE: Union[int, None] DEFAULT: _Unset
examples 	

Example values for this field.

TYPE: Optional[List[Any]] DEFAULT: None
example 	

Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.

TYPE: Optional[Any] DEFAULT: _Unset
openapi_examples 	

OpenAPI-specific examples.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Swagger UI (that provides the /docs interface) has better support for the OpenAPI-specific examples than the JSON Schema examples, that's the main use case for this.

Read more about it in the FastAPI docs for Declare Request Example Data.

TYPE: Optional[Dict[str, Example]] DEFAULT: None
deprecated 	

Mark this parameter field as deprecated.

It will affect the generated OpenAPI (e.g. visible at /docs).

TYPE: Union[deprecated, str, bool, None] DEFAULT: None
include_in_schema 	

To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available.

This affects the generated OpenAPI (e.g. visible at /docs).

TYPE: bool DEFAULT: True
json_schema_extra 	

Any additional JSON schema data.

TYPE: Union[Dict[str, Any], None] DEFAULT: None
**extra 	

The extra kwargs is deprecated. Use json_schema_extra instead. Include extra fields used by the JSON Schema.

TYPE: Any DEFAULT: {}
Source code in fastapi/param_functions.py

Source code in fastapi/param_functions.py

fastapi.File Â¶

File(
    default=Undefined,
    *,
    default_factory=_Unset,
    media_type="multipart/form-data",
    alias=None,
    alias_priority=_Unset,
    validation_alias=None,
    serialization_alias=None,
    title=None,
    description=None,
    gt=None,
    ge=None,
    lt=None,
    le=None,
    min_length=None,
    max_length=None,
    pattern=None,
    regex=None,
    discriminator=None,
    strict=_Unset,
    multiple_of=_Unset,
    allow_inf_nan=_Unset,
    max_digits=_Unset,
    decimal_places=_Unset,
    examples=None,
    example=_Unset,
    openapi_examples=None,
    deprecated=None,
    include_in_schema=True,
    json_schema_extra=None,
    **extra
)

PARAMETER 	DESCRIPTION
default 	

Default value if the parameter field is not set.

TYPE: Any DEFAULT: Undefined
default_factory 	

A callable to generate the default value.

This doesn't affect Path parameters as the value is always required. The parameter is available only for compatibility.

TYPE: Union[Callable[[], Any], None] DEFAULT: _Unset
media_type 	

The media type of this parameter field. Changing it would affect the generated OpenAPI, but currently it doesn't affect the parsing of the data.

TYPE: str DEFAULT: 'multipart/form-data'
alias 	

An alternative name for the parameter field.

This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar.

TYPE: Optional[str] DEFAULT: None
alias_priority 	

Priority of the alias. This affects whether an alias generator is used.

TYPE: Union[int, None] DEFAULT: _Unset
validation_alias 	

'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined.

TYPE: Union[str, None] DEFAULT: None
serialization_alias 	

'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time.

TYPE: Union[str, None] DEFAULT: None
title 	

Human-readable title.

TYPE: Optional[str] DEFAULT: None
description 	

Human-readable description.

TYPE: Optional[str] DEFAULT: None
gt 	

Greater than. If set, value must be greater than this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
ge 	

Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
lt 	

Less than. If set, value must be less than this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
le 	

Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers.

TYPE: Optional[float] DEFAULT: None
min_length 	

Minimum length for strings.

TYPE: Optional[int] DEFAULT: None
max_length 	

Maximum length for strings.

TYPE: Optional[int] DEFAULT: None
pattern 	

RegEx pattern for strings.

TYPE: Optional[str] DEFAULT: None
regex 	

Deprecated in FastAPI 0.100.0 and Pydantic v2, use pattern instead. RegEx pattern for strings.

TYPE: Optional[str] DEFAULT: None
discriminator 	

Parameter field name for discriminating the type in a tagged union.

TYPE: Union[str, None] DEFAULT: None
strict 	

If True, strict validation is applied to the field.

TYPE: Union[bool, None] DEFAULT: _Unset
multiple_of 	

Value must be a multiple of this. Only applicable to numbers.

TYPE: Union[float, None] DEFAULT: _Unset
allow_inf_nan 	

Allow inf, -inf, nan. Only applicable to numbers.

TYPE: Union[bool, None] DEFAULT: _Unset
max_digits 	

Maximum number of allow digits for strings.

TYPE: Union[int, None] DEFAULT: _Unset
decimal_places 	

Maximum number of decimal places allowed for numbers.

TYPE: Union[int, None] DEFAULT: _Unset
examples 	

Example values for this field.

TYPE: Optional[List[Any]] DEFAULT: None
example 	

Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.

TYPE: Optional[Any] DEFAULT: _Unset
openapi_examples 	

OpenAPI-specific examples.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Swagger UI (that provides the /docs interface) has better support for the OpenAPI-specific examples than the JSON Schema examples, that's the main use case for this.

Read more about it in the FastAPI docs for Declare Request Example Data.

TYPE: Optional[Dict[str, Example]] DEFAULT: None
deprecated 	

Mark this parameter field as deprecated.

It will affect the generated OpenAPI (e.g. visible at /docs).

TYPE: Union[deprecated, str, bool, None] DEFAULT: None
include_in_schema 	

To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available.

This affects the generated OpenAPI (e.g. visible at /docs).

TYPE: bool DEFAULT: True
json_schema_extra 	

Any additional JSON schema data.

TYPE: Union[Dict[str, Any], None] DEFAULT: None
**extra 	

The extra kwargs is deprecated. Use json_schema_extra instead. Include extra fields used by the JSON Schema.

TYPE: Any DEFAULT: {}
Source code in fastapi/param_functions.py

def File(  # noqa: N802
    default: Annotated[
        Any,
        Doc(
            """
            Default value if the parameter field is not set.
            """
        ),
    ] = Undefined,
    *,
    default_factory: Annotated[
        Union[Callable[[], Any], None],
        Doc(
            """
            A callable to generate the default value.

            This doesn't affect `Path` parameters as the value is always required.
            The parameter is available only for compatibility.
            """
        ),
    ] = _Unset,
    media_type: Annotated[
        str,
        Doc(
            """
            The media type of this parameter field. Changing it would affect the
            generated OpenAPI, but currently it doesn't affect the parsing of the data.
            """
        ),
    ] = "multipart/form-data",
    alias: Annotated[
        Optional[str],
        Doc(
            """
            An alternative name for the parameter field.

            This will be used to extract the data and for the generated OpenAPI.
            It is particularly useful when you can't use the name you want because it
            is a Python reserved keyword or similar.
            """
        ),
    ] = None,
    alias_priority: Annotated[
        Union[int, None],
        Doc(
            """
            Priority of the alias. This affects whether an alias generator is used.
            """
        ),
    ] = _Unset,
    # TODO: update when deprecating Pydantic v1, import these types
    # validation_alias: str | AliasPath | AliasChoices | None
    validation_alias: Annotated[
        Union[str, None],
        Doc(
            """
            'Whitelist' validation step. The parameter field will be the single one
            allowed by the alias or set of aliases defined.
            """
        ),
    ] = None,
    serialization_alias: Annotated[
        Union[str, None],
        Doc(
            """
            'Blacklist' validation step. The vanilla parameter field will be the
            single one of the alias' or set of aliases' fields and all the other
            fields will be ignored at serialization time.
            """
        ),
    ] = None,
    title: Annotated[
        Optional[str],
        Doc(
            """
            Human-readable title.
            """
        ),
    ] = None,
    description: Annotated[
        Optional[str],
        Doc(
            """
            Human-readable description.
            """
        ),
    ] = None,
    gt: Annotated[
        Optional[float],
        Doc(
            """
            Greater than. If set, value must be greater than this. Only applicable to
            numbers.
            """
        ),
    ] = None,
    ge: Annotated[
        Optional[float],
        Doc(
            """
            Greater than or equal. If set, value must be greater than or equal to
            this. Only applicable to numbers.
            """
        ),
    ] = None,
    lt: Annotated[
        Optional[float],
        Doc(
            """
            Less than. If set, value must be less than this. Only applicable to numbers.
            """
        ),
    ] = None,
    le: Annotated[
        Optional[float],
        Doc(
            """
            Less than or equal. If set, value must be less than or equal to this.
            Only applicable to numbers.
            """
        ),
    ] = None,
    min_length: Annotated[
        Optional[int],
        Doc(
            """
            Minimum length for strings.
            """
        ),
    ] = None,
    max_length: Annotated[
        Optional[int],
        Doc(
            """
            Maximum length for strings.
            """
        ),
    ] = None,
    pattern: Annotated[
        Optional[str],
        Doc(
            """
            RegEx pattern for strings.
            """
        ),
    ] = None,
    regex: Annotated[
        Optional[str],
        Doc(
            """
            RegEx pattern for strings.
            """
        ),
        deprecated(
            "Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
        ),
    ] = None,
    discriminator: Annotated[
        Union[str, None],
        Doc(
            """
            Parameter field name for discriminating the type in a tagged union.
            """
        ),
    ] = None,
    strict: Annotated[
        Union[bool, None],
        Doc(
            """
            If `True`, strict validation is applied to the field.
            """
        ),
    ] = _Unset,
    multiple_of: Annotated[
        Union[float, None],
        Doc(
            """
            Value must be a multiple of this. Only applicable to numbers.
            """
        ),
    ] = _Unset,
    allow_inf_nan: Annotated[
        Union[bool, None],
        Doc(
            """
            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
            """
        ),
    ] = _Unset,
    max_digits: Annotated[
        Union[int, None],
        Doc(
            """
            Maximum number of allow digits for strings.
            """
        ),
    ] = _Unset,
    decimal_places: Annotated[
        Union[int, None],
        Doc(
            """
            Maximum number of decimal places allowed for numbers.
            """
        ),
    ] = _Unset,
    examples: Annotated[
        Optional[List[Any]],
        Doc(
            """
            Example values for this field.
            """
        ),
    ] = None,
    example: Annotated[
        Optional[Any],
        deprecated(
            "Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
            "although still supported. Use examples instead."
        ),
    ] = _Unset,
    openapi_examples: Annotated[
        Optional[Dict[str, Example]],
        Doc(
            """
            OpenAPI-specific examples.

            It will be added to the generated OpenAPI (e.g. visible at `/docs`).

            Swagger UI (that provides the `/docs` interface) has better support for the
            OpenAPI-specific examples than the JSON Schema `examples`, that's the main
            use case for this.

            Read more about it in the
            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
            """
        ),
    ] = None,
    deprecated: Annotated[
        Union[deprecated, str, bool, None],
        Doc(
            """
            Mark this parameter field as deprecated.

            It will affect the generated OpenAPI (e.g. visible at `/docs`).
            """
        ),
    ] = None,
    include_in_schema: Annotated[
        bool,
        Doc(
            """
            To include (or not) this parameter field in the generated OpenAPI.
            You probably don't need it, but it's available.

            This affects the generated OpenAPI (e.g. visible at `/docs`).
            """
        ),
    ] = True,
    json_schema_extra: Annotated[
        Union[Dict[str, Any], None],
        Doc(
            """
            Any additional JSON schema data.
            """
        ),
    ] = None,
    **extra: Annotated[
        Any,
        Doc(
            """
            Include extra fields used by the JSON Schema.
            """
        ),
        deprecated(
            """
            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
            """
        ),
    ],
) -> Any:
    return params.File(
        default=default,
        default_factory=default_factory,
        media_type=media_type,
        alias=alias,
        alias_priority=alias_priority,
        validation_alias=validation_alias,
        serialization_alias=serialization_alias,
        title=title,
        description=description,
        gt=gt,
        ge=ge,
        lt=lt,
        le=le,
        min_length=min_length,
        max_length=max_length,
        pattern=pattern,
        regex=regex,
        discriminator=discriminator,
        strict=strict,
        multiple_of=multiple_of,
        allow_inf_nan=allow_inf_nan,
        max_digits=max_digits,
        decimal_places=decimal_places,
        example=example,
        examples=examples,
        openapi_examples=openapi_examples,
        deprecated=deprecated,
        include_in_schema=include_in_schema,
        json_schema_extra=json_schema_extra,
        **extra,
    )

Source code in fastapi/param_functions.py

def File(  # noqa: N802
    default: Annotated[
        Any,
        Doc(
            """
            Default value if the parameter field is not set.
            """
        ),
    ] = Undefined,
    *,
    default_factory: Annotated[
        Union[Callable[[], Any], None],
        Doc(
            """
            A callable to generate the default value.

            This doesn't affect `Path` parameters as the value is always required.
            The parameter is available only for compatibility.
            """
        ),
    ] = _Unset,
    media_type: Annotated[
        str,
        Doc(
            """
            The media type of this parameter field. Changing it would affect the
            generated OpenAPI, but currently it doesn't affect the parsing of the data.
            """
        ),
    ] = "multipart/form-data",
    alias: Annotated[
        Optional[str],
        Doc(
            """
            An alternative name for the parameter field.

            This will be used to extract the data and for the generated OpenAPI.
            It is particularly useful when you can't use the name you want because it
            is a Python reserved keyword or similar.
            """
        ),
    ] = None,
    alias_priority: Annotated[
        Union[int, None],
        Doc(
            """
            Priority of the alias. This affects whether an alias generator is used.
            """
        ),
    ] = _Unset,
    # TODO: update when deprecating Pydantic v1, import these types
    # validation_alias: str | AliasPath | AliasChoices | None
    validation_alias: Annotated[
        Union[str, None],
        Doc(
            """
            'Whitelist' validation step. The parameter field will be the single one
            allowed by the alias or set of aliases defined.
            """
        ),
    ] = None,
    serialization_alias: Annotated[
        Union[str, None],
        Doc(
            """
            'Blacklist' validation step. The vanilla parameter field will be the
            single one of the alias' or set of aliases' fields and all the other
            fields will be ignored at serialization time.
            """
        ),
    ] = None,
    title: Annotated[
        Optional[str],
        Doc(
            """
            Human-readable title.
            """
        ),
    ] = None,
    description: Annotated[
        Optional[str],
        Doc(
            """
            Human-readable description.
            """
        ),
    ] = None,
    gt: Annotated[
        Optional[float],
        Doc(
            """
            Greater than. If set, value must be greater than this. Only applicable to
            numbers.
            """
        ),
    ] = None,
    ge: Annotated[
        Optional[float],
        Doc(
            """
            Greater than or equal. If set, value must be greater than or equal to
            this. Only applicable to numbers.
            """
        ),
    ] = None,
    lt: Annotated[
        Optional[float],
        Doc(
            """
            Less than. If set, value must be less than this. Only applicable to numbers.
            """
        ),
    ] = None,
    le: Annotated[
        Optional[float],
        Doc(
            """
            Less than or equal. If set, value must be less than or equal to this.
            Only applicable to numbers.
            """
        ),
    ] = None,
    min_length: Annotated[
        Optional[int],
        Doc(
            """
            Minimum length for strings.
            """
        ),
    ] = None,
    max_length: Annotated[
        Optional[int],
        Doc(
            """
            Maximum length for strings.
            """
        ),
    ] = None,
    pattern: Annotated[
        Optional[str],
        Doc(
            """
            RegEx pattern for strings.
            """
        ),
    ] = None,
    regex: Annotated[
        Optional[str],
        Doc(
            """
            RegEx pattern for strings.
            """
        ),
        deprecated(
            "Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
        ),
    ] = None,
    discriminator: Annotated[
        Union[str, None],
        Doc(
            """
            Parameter field name for discriminating the type in a tagged union.
            """
        ),
    ] = None,
    strict: Annotated[
        Union[bool, None],
        Doc(
            """
            If `True`, strict validation is applied to the field.
            """
        ),
    ] = _Unset,
    multiple_of: Annotated[
        Union[float, None],
        Doc(
            """
            Value must be a multiple of this. Only applicable to numbers.
            """
        ),
    ] = _Unset,
    allow_inf_nan: Annotated[
        Union[bool, None],
        Doc(
            """
            Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
            """
        ),
    ] = _Unset,
    max_digits: Annotated[
        Union[int, None],
        Doc(
            """
            Maximum number of allow digits for strings.
            """
        ),
    ] = _Unset,
    decimal_places: Annotated[
        Union[int, None],
        Doc(
            """
            Maximum number of decimal places allowed for numbers.
            """
        ),
    ] = _Unset,
    examples: Annotated[
        Optional[List[Any]],
        Doc(
            """
            Example values for this field.
            """
        ),
    ] = None,
    example: Annotated[
        Optional[Any],
        deprecated(
            "Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
            "although still supported. Use examples instead."
        ),
    ] = _Unset,
    openapi_examples: Annotated[
        Optional[Dict[str, Example]],
        Doc(
            """
            OpenAPI-specific examples.

            It will be added to the generated OpenAPI (e.g. visible at `/docs`).

            Swagger UI (that provides the `/docs` interface) has better support for the
            OpenAPI-specific examples than the JSON Schema `examples`, that's the main
            use case for this.

            Read more about it in the
            [FastAPI docs for Declare Request Example Data](https://fastapi.tiangolo.com/tutorial/schema-extra-example/#using-the-openapi_examples-parameter).
            """
        ),
    ] = None,
    deprecated: Annotated[
        Union[deprecated, str, bool, None],
        Doc(
            """
            Mark this parameter field as deprecated.

            It will affect the generated OpenAPI (e.g. visible at `/docs`).
            """
        ),
    ] = None,
    include_in_schema: Annotated[
        bool,
        Doc(
            """
            To include (or not) this parameter field in the generated OpenAPI.
            You probably don't need it, but it's available.

            This affects the generated OpenAPI (e.g. visible at `/docs`).
            """
        ),
    ] = True,
    json_schema_extra: Annotated[
        Union[Dict[str, Any], None],
        Doc(
            """
            Any additional JSON schema data.
            """
        ),
    ] = None,
    **extra: Annotated[
        Any,
        Doc(
            """
            Include extra fields used by the JSON Schema.
            """
        ),
        deprecated(
            """
            The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
            """
        ),
    ],
) -> Any:
    return params.File(
        default=default,
        default_factory=default_factory,
        media_type=media_type,
        alias=alias,
        alias_priority=alias_priority,
        validation_alias=validation_alias,
        serialization_alias=serialization_alias,
        title=title,
        description=description,
        gt=gt,
        ge=ge,
        lt=lt,
        le=le,
        min_length=min_length,
        max_length=max_length,
        pattern=pattern,
        regex=regex,
        discriminator=discriminator,
        strict=strict,
        multiple_of=multiple_of,
        allow_inf_nan=allow_inf_nan,
        max_digits=max_digits,
        decimal_places=decimal_places,
        example=example,
        examples=examples,
        openapi_examples=openapi_examples,
        deprecated=deprecated,
        include_in_schema=include_in_schema,
        json_schema_extra=json_schema_extra,
        **extra,
    )

Previous
FastAPI class
Next
Status Codes
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs




Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Status Codes

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

    Example
     status
         HTTP_100_CONTINUE
         HTTP_101_SWITCHING_PROTOCOLS
         HTTP_102_PROCESSING
         HTTP_103_EARLY_HINTS
         HTTP_200_OK
         HTTP_201_CREATED
         HTTP_202_ACCEPTED
         HTTP_203_NON_AUTHORITATIVE_INFORMATION
         HTTP_204_NO_CONTENT
         HTTP_205_RESET_CONTENT
         HTTP_206_PARTIAL_CONTENT
         HTTP_207_MULTI_STATUS
         HTTP_208_ALREADY_REPORTED
         HTTP_226_IM_USED
         HTTP_300_MULTIPLE_CHOICES
         HTTP_301_MOVED_PERMANENTLY
         HTTP_302_FOUND
         HTTP_303_SEE_OTHER
         HTTP_304_NOT_MODIFIED
         HTTP_305_USE_PROXY
         HTTP_306_RESERVED
         HTTP_307_TEMPORARY_REDIRECT
         HTTP_308_PERMANENT_REDIRECT
         HTTP_400_BAD_REQUEST
         HTTP_401_UNAUTHORIZED
         HTTP_402_PAYMENT_REQUIRED
         HTTP_403_FORBIDDEN
         HTTP_404_NOT_FOUND
         HTTP_405_METHOD_NOT_ALLOWED
         HTTP_406_NOT_ACCEPTABLE
         HTTP_407_PROXY_AUTHENTICATION_REQUIRED
         HTTP_408_REQUEST_TIMEOUT
         HTTP_409_CONFLICT
         HTTP_410_GONE
         HTTP_411_LENGTH_REQUIRED
         HTTP_412_PRECONDITION_FAILED
         HTTP_413_CONTENT_TOO_LARGE
         HTTP_414_URI_TOO_LONG
         HTTP_415_UNSUPPORTED_MEDIA_TYPE
         HTTP_416_RANGE_NOT_SATISFIABLE
         HTTP_417_EXPECTATION_FAILED
         HTTP_418_IM_A_TEAPOT
         HTTP_421_MISDIRECTED_REQUEST
         HTTP_422_UNPROCESSABLE_CONTENT
         HTTP_423_LOCKED
         HTTP_424_FAILED_DEPENDENCY
         HTTP_425_TOO_EARLY
         HTTP_426_UPGRADE_REQUIRED
         HTTP_428_PRECONDITION_REQUIRED
         HTTP_429_TOO_MANY_REQUESTS
         HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE
         HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS
         HTTP_500_INTERNAL_SERVER_ERROR
         HTTP_501_NOT_IMPLEMENTED
         HTTP_502_BAD_GATEWAY
         HTTP_503_SERVICE_UNAVAILABLE
         HTTP_504_GATEWAY_TIMEOUT
         HTTP_505_HTTP_VERSION_NOT_SUPPORTED
         HTTP_506_VARIANT_ALSO_NEGOTIATES
         HTTP_507_INSUFFICIENT_STORAGE
         HTTP_508_LOOP_DETECTED
         HTTP_510_NOT_EXTENDED
         HTTP_511_NETWORK_AUTHENTICATION_REQUIRED
         WS_1000_NORMAL_CLOSURE
         WS_1001_GOING_AWAY
         WS_1002_PROTOCOL_ERROR
         WS_1003_UNSUPPORTED_DATA
         WS_1005_NO_STATUS_RCVD
         WS_1006_ABNORMAL_CLOSURE
         WS_1007_INVALID_FRAME_PAYLOAD_DATA
         WS_1008_POLICY_VIOLATION
         WS_1009_MESSAGE_TOO_BIG
         WS_1010_MANDATORY_EXT
         WS_1011_INTERNAL_ERROR
         WS_1012_SERVICE_RESTART
         WS_1013_TRY_AGAIN_LATER
         WS_1014_BAD_GATEWAY
         WS_1015_TLS_HANDSHAKE

    FastAPI
    Reference

Status CodesÂ¶

You can import the status module from fastapi:

from fastapi import status

status is provided directly by Starlette.

It contains a group of named constants (variables) with integer status codes.

For example:

    200: status.HTTP_200_OK
    403: status.HTTP_403_FORBIDDEN
    etc.

It can be convenient to quickly access HTTP (and WebSocket) status codes in your app, using autocompletion for the name without having to remember the integer status codes by memory.

Read more about it in the FastAPI docs about Response Status Code.
ExampleÂ¶

from fastapi import FastAPI, status

app = FastAPI()


@app.get("/items/", status_code=status.HTTP_418_IM_A_TEAPOT)
def read_items():
    return [{"name": "Plumbus"}, {"name": "Portal Gun"}]

fastapi.status Â¶

HTTP codes See HTTP Status Code Registry: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml

And RFC 9110 - https://www.rfc-editor.org/rfc/rfc9110
HTTP_100_CONTINUE module-attribute Â¶

HTTP_100_CONTINUE = 100

HTTP_101_SWITCHING_PROTOCOLS module-attribute Â¶

HTTP_101_SWITCHING_PROTOCOLS = 101

HTTP_102_PROCESSING module-attribute Â¶

HTTP_102_PROCESSING = 102

HTTP_103_EARLY_HINTS module-attribute Â¶

HTTP_103_EARLY_HINTS = 103

HTTP_200_OK module-attribute Â¶

HTTP_200_OK = 200

HTTP_201_CREATED module-attribute Â¶

HTTP_201_CREATED = 201

HTTP_202_ACCEPTED module-attribute Â¶

HTTP_202_ACCEPTED = 202

HTTP_203_NON_AUTHORITATIVE_INFORMATION module-attribute Â¶

HTTP_203_NON_AUTHORITATIVE_INFORMATION = 203

HTTP_204_NO_CONTENT module-attribute Â¶

HTTP_204_NO_CONTENT = 204

HTTP_205_RESET_CONTENT module-attribute Â¶

HTTP_205_RESET_CONTENT = 205

HTTP_206_PARTIAL_CONTENT module-attribute Â¶

HTTP_206_PARTIAL_CONTENT = 206

HTTP_207_MULTI_STATUS module-attribute Â¶

HTTP_207_MULTI_STATUS = 207

HTTP_208_ALREADY_REPORTED module-attribute Â¶

HTTP_208_ALREADY_REPORTED = 208

HTTP_226_IM_USED module-attribute Â¶

HTTP_226_IM_USED = 226

HTTP_300_MULTIPLE_CHOICES module-attribute Â¶

HTTP_300_MULTIPLE_CHOICES = 300

HTTP_301_MOVED_PERMANENTLY module-attribute Â¶

HTTP_301_MOVED_PERMANENTLY = 301

HTTP_302_FOUND module-attribute Â¶

HTTP_302_FOUND = 302

HTTP_303_SEE_OTHER module-attribute Â¶

HTTP_303_SEE_OTHER = 303

HTTP_304_NOT_MODIFIED module-attribute Â¶

HTTP_304_NOT_MODIFIED = 304

HTTP_305_USE_PROXY module-attribute Â¶

HTTP_305_USE_PROXY = 305

HTTP_306_RESERVED module-attribute Â¶

HTTP_306_RESERVED = 306

HTTP_307_TEMPORARY_REDIRECT module-attribute Â¶

HTTP_307_TEMPORARY_REDIRECT = 307

HTTP_308_PERMANENT_REDIRECT module-attribute Â¶

HTTP_308_PERMANENT_REDIRECT = 308

HTTP_400_BAD_REQUEST module-attribute Â¶

HTTP_400_BAD_REQUEST = 400

HTTP_401_UNAUTHORIZED module-attribute Â¶

HTTP_401_UNAUTHORIZED = 401

HTTP_402_PAYMENT_REQUIRED module-attribute Â¶

HTTP_402_PAYMENT_REQUIRED = 402

HTTP_403_FORBIDDEN module-attribute Â¶

HTTP_403_FORBIDDEN = 403

HTTP_404_NOT_FOUND module-attribute Â¶

HTTP_404_NOT_FOUND = 404

HTTP_405_METHOD_NOT_ALLOWED module-attribute Â¶

HTTP_405_METHOD_NOT_ALLOWED = 405

HTTP_406_NOT_ACCEPTABLE module-attribute Â¶

HTTP_406_NOT_ACCEPTABLE = 406

HTTP_407_PROXY_AUTHENTICATION_REQUIRED module-attribute Â¶

HTTP_407_PROXY_AUTHENTICATION_REQUIRED = 407

HTTP_408_REQUEST_TIMEOUT module-attribute Â¶

HTTP_408_REQUEST_TIMEOUT = 408

HTTP_409_CONFLICT module-attribute Â¶

HTTP_409_CONFLICT = 409

HTTP_410_GONE module-attribute Â¶

HTTP_410_GONE = 410

HTTP_411_LENGTH_REQUIRED module-attribute Â¶

HTTP_411_LENGTH_REQUIRED = 411

HTTP_412_PRECONDITION_FAILED module-attribute Â¶

HTTP_412_PRECONDITION_FAILED = 412

HTTP_413_CONTENT_TOO_LARGE module-attribute Â¶

HTTP_413_CONTENT_TOO_LARGE = 413

HTTP_414_URI_TOO_LONG module-attribute Â¶

HTTP_414_URI_TOO_LONG = 414

HTTP_415_UNSUPPORTED_MEDIA_TYPE module-attribute Â¶

HTTP_415_UNSUPPORTED_MEDIA_TYPE = 415

HTTP_416_RANGE_NOT_SATISFIABLE module-attribute Â¶

HTTP_416_RANGE_NOT_SATISFIABLE = 416

HTTP_417_EXPECTATION_FAILED module-attribute Â¶

HTTP_417_EXPECTATION_FAILED = 417

HTTP_418_IM_A_TEAPOT module-attribute Â¶

HTTP_418_IM_A_TEAPOT = 418

HTTP_421_MISDIRECTED_REQUEST module-attribute Â¶

HTTP_421_MISDIRECTED_REQUEST = 421

HTTP_422_UNPROCESSABLE_CONTENT module-attribute Â¶

HTTP_422_UNPROCESSABLE_CONTENT = 422

HTTP_423_LOCKED module-attribute Â¶

HTTP_423_LOCKED = 423

HTTP_424_FAILED_DEPENDENCY module-attribute Â¶

HTTP_424_FAILED_DEPENDENCY = 424

HTTP_425_TOO_EARLY module-attribute Â¶

HTTP_425_TOO_EARLY = 425

HTTP_426_UPGRADE_REQUIRED module-attribute Â¶

HTTP_426_UPGRADE_REQUIRED = 426

HTTP_428_PRECONDITION_REQUIRED module-attribute Â¶

HTTP_428_PRECONDITION_REQUIRED = 428

HTTP_429_TOO_MANY_REQUESTS module-attribute Â¶

HTTP_429_TOO_MANY_REQUESTS = 429

HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE module-attribute Â¶

HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE = 431

HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS module-attribute Â¶

HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS = 451

HTTP_500_INTERNAL_SERVER_ERROR module-attribute Â¶

HTTP_500_INTERNAL_SERVER_ERROR = 500

HTTP_501_NOT_IMPLEMENTED module-attribute Â¶

HTTP_501_NOT_IMPLEMENTED = 501

HTTP_502_BAD_GATEWAY module-attribute Â¶

HTTP_502_BAD_GATEWAY = 502

HTTP_503_SERVICE_UNAVAILABLE module-attribute Â¶

HTTP_503_SERVICE_UNAVAILABLE = 503

HTTP_504_GATEWAY_TIMEOUT module-attribute Â¶

HTTP_504_GATEWAY_TIMEOUT = 504

HTTP_505_HTTP_VERSION_NOT_SUPPORTED module-attribute Â¶

HTTP_505_HTTP_VERSION_NOT_SUPPORTED = 505

HTTP_506_VARIANT_ALSO_NEGOTIATES module-attribute Â¶

HTTP_506_VARIANT_ALSO_NEGOTIATES = 506

HTTP_507_INSUFFICIENT_STORAGE module-attribute Â¶

HTTP_507_INSUFFICIENT_STORAGE = 507

HTTP_508_LOOP_DETECTED module-attribute Â¶

HTTP_508_LOOP_DETECTED = 508

HTTP_510_NOT_EXTENDED module-attribute Â¶

HTTP_510_NOT_EXTENDED = 510

HTTP_511_NETWORK_AUTHENTICATION_REQUIRED module-attribute Â¶

HTTP_511_NETWORK_AUTHENTICATION_REQUIRED = 511

WebSocket codes https://www.iana.org/assignments/websocket/websocket.xml#close-code-number https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent
WS_1000_NORMAL_CLOSURE module-attribute Â¶

WS_1000_NORMAL_CLOSURE = 1000

WS_1001_GOING_AWAY module-attribute Â¶

WS_1001_GOING_AWAY = 1001

WS_1002_PROTOCOL_ERROR module-attribute Â¶

WS_1002_PROTOCOL_ERROR = 1002

WS_1003_UNSUPPORTED_DATA module-attribute Â¶

WS_1003_UNSUPPORTED_DATA = 1003

WS_1005_NO_STATUS_RCVD module-attribute Â¶

WS_1005_NO_STATUS_RCVD = 1005

WS_1006_ABNORMAL_CLOSURE module-attribute Â¶

WS_1006_ABNORMAL_CLOSURE = 1006

WS_1007_INVALID_FRAME_PAYLOAD_DATA module-attribute Â¶

WS_1007_INVALID_FRAME_PAYLOAD_DATA = 1007

WS_1008_POLICY_VIOLATION module-attribute Â¶

WS_1008_POLICY_VIOLATION = 1008

WS_1009_MESSAGE_TOO_BIG module-attribute Â¶

WS_1009_MESSAGE_TOO_BIG = 1009

WS_1010_MANDATORY_EXT module-attribute Â¶

WS_1010_MANDATORY_EXT = 1010

WS_1011_INTERNAL_ERROR module-attribute Â¶

WS_1011_INTERNAL_ERROR = 1011

WS_1012_SERVICE_RESTART module-attribute Â¶

WS_1012_SERVICE_RESTART = 1012

WS_1013_TRY_AGAIN_LATER module-attribute Â¶

WS_1013_TRY_AGAIN_LATER = 1013

WS_1014_BAD_GATEWAY module-attribute Â¶

WS_1014_BAD_GATEWAY = 1014

WS_1015_TLS_HANDSHAKE module-attribute Â¶

WS_1015_TLS_HANDSHAKE = 1015

Previous
Request Parameters
Next
UploadFile class
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
UploadFile class

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

     UploadFile
        Example
         file
         filename
         size
         headers
         content_type
         read
         write
         seek
         close

    FastAPI
    Reference

UploadFile classÂ¶

You can define path operation function parameters to be of the type UploadFile to receive files from the request.

You can import it directly from fastapi:

from fastapi import UploadFile

fastapi.UploadFile Â¶

UploadFile(file, *, size=None, filename=None, headers=None)

Bases: UploadFile

A file uploaded in a request.

Define it as a path operation function (or dependency) parameter.

If you are using a regular def function, you can use the upload_file.file attribute to access the raw standard Python file (blocking, not async), useful and needed for non-async code.

Read more about it in the FastAPI docs for Request Files.
ExampleÂ¶

from typing import Annotated

from fastapi import FastAPI, File, UploadFile

app = FastAPI()


@app.post("/files/")
async def create_file(file: Annotated[bytes, File()]):
    return {"file_size": len(file)}


@app.post("/uploadfile/")
async def create_upload_file(file: UploadFile):
    return {"filename": file.filename}

Source code in starlette/datastructures.py

Source code in starlette/datastructures.py

file instance-attribute Â¶

file

The standard Python file object (non-async).
filename instance-attribute Â¶

filename

The original file name.
size instance-attribute Â¶

size

The size of the file in bytes.
headers instance-attribute Â¶

headers

The headers of the request.
content_type instance-attribute Â¶

content_type

The content type of the request, from the headers.
read async Â¶

read(size=-1)

Read some bytes from the file.

To be awaitable, compatible with async, this is run in threadpool.
PARAMETER 	DESCRIPTION
size 	

The number of bytes to read from the file.

TYPE: int DEFAULT: -1
Source code in fastapi/datastructures.py

Source code in fastapi/datastructures.py

write async Â¶

write(data)

Write some bytes to the file.

You normally wouldn't use this from a file you read in a request.

To be awaitable, compatible with async, this is run in threadpool.
PARAMETER 	DESCRIPTION
data 	

The bytes to write to the file.

TYPE: bytes
Source code in fastapi/datastructures.py

Source code in fastapi/datastructures.py

seek async Â¶

seek(offset)

Move to a position in the file.

Any next read or write will be done from that position.

To be awaitable, compatible with async, this is run in threadpool.
PARAMETER 	DESCRIPTION
offset 	

The position in bytes to seek to in the file.

TYPE: int
Source code in fastapi/datastructures.py

Source code in fastapi/datastructures.py

close async Â¶

close()

Close the file.

To be awaitable, compatible with async, this is run in threadpool.
Source code in fastapi/datastructures.py

Source code in fastapi/datastructures.py

Previous
Status Codes
Next
Exceptions - HTTPException and WebSocketException
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs






Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
Exceptions - HTTPException and WebSocketException

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

     HTTPException
        Example
         status_code
         detail
         headers
     WebSocketException
        Example
         code
         reason

    FastAPI
    Reference

Exceptions - HTTPException and WebSocketExceptionÂ¶

These are the exceptions that you can raise to show errors to the client.

When you raise an exception, as would happen with normal Python, the rest of the execution is aborted. This way you can raise these exceptions from anywhere in the code to abort a request and show the error to the client.

You can use:

    HTTPException
    WebSocketException

These exceptions can be imported directly from fastapi:

from fastapi import HTTPException, WebSocketException

fastapi.HTTPException Â¶

HTTPException(status_code, detail=None, headers=None)

Bases: HTTPException

An HTTP exception you can raise in your own code to show errors to the client.

This is for client errors, invalid authentication, invalid data, etc. Not for server errors in your code.

Read more about it in the FastAPI docs for Handling Errors.
ExampleÂ¶

from fastapi import FastAPI, HTTPException

app = FastAPI()

items = {"foo": "The Foo Wrestlers"}


@app.get("/items/{item_id}")
async def read_item(item_id: str):
    if item_id not in items:
        raise HTTPException(status_code=404, detail="Item not found")
    return {"item": items[item_id]}

PARAMETER 	DESCRIPTION
status_code 	

HTTP status code to send to the client.

TYPE: int
detail 	

Any data to be sent to the client in the detail key of the JSON response.

TYPE: Any DEFAULT: None
headers 	

Any headers to send to the client in the response.

TYPE: Optional[Dict[str, str]] DEFAULT: None
Source code in fastapi/exceptions.py

Source code in fastapi/exceptions.py

status_code instance-attribute Â¶

status_code = status_code

detail instance-attribute Â¶

detail = detail

headers instance-attribute Â¶

headers = headers

fastapi.WebSocketException Â¶

WebSocketException(code, reason=None)

Bases: WebSocketException

A WebSocket exception you can raise in your own code to show errors to the client.

This is for client errors, invalid authentication, invalid data, etc. Not for server errors in your code.

Read more about it in the FastAPI docs for WebSockets.
ExampleÂ¶

from typing import Annotated

from fastapi import (
    Cookie,
    FastAPI,
    WebSocket,
    WebSocketException,
    status,
)

app = FastAPI()

@app.websocket("/items/{item_id}/ws")
async def websocket_endpoint(
    *,
    websocket: WebSocket,
    session: Annotated[str | None, Cookie()] = None,
    item_id: str,
):
    if session is None:
        raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        await websocket.send_text(f"Session cookie is: {session}")
        await websocket.send_text(f"Message text was: {data}, for item ID: {item_id}")

PARAMETER 	DESCRIPTION
code 	

A closing code from the valid codes defined in the specification.

TYPE: int
reason 	

The reason to close the WebSocket connection.

It is UTF-8-encoded data. The interpretation of the reason is up to the application, it is not specified by the WebSocket specification.

It could contain text that could be human-readable or interpretable by the client code, etc.

TYPE: Union[str, None] DEFAULT: None
Source code in fastapi/exceptions.py

Source code in fastapi/exceptions.py

code instance-attribute Â¶

code = code

reason instance-attribute Â¶

reason = reason or ''

Previous
UploadFile class
Next
Dependencies - Depends() and Security()
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Dependencies - Depends() and Security()

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

    Depends()
     Depends
    Security()
     Security

    FastAPI
    Reference

Dependencies - Depends() and Security()Â¶
Depends()Â¶

Dependencies are handled mainly with the special function Depends() that takes a callable.

Here is the reference for it and its parameters.

You can import it directly from fastapi:

from fastapi import Depends

fastapi.Depends Â¶

Depends(dependency=None, *, use_cache=True, scope=None)

Declare a FastAPI dependency.

It takes a single "dependable" callable (like a function).

Don't call it directly, FastAPI will call it for you.

Read more about it in the FastAPI docs for Dependencies.

Example

from typing import Annotated

from fastapi import Depends, FastAPI

app = FastAPI()


async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):
    return {"q": q, "skip": skip, "limit": limit}


@app.get("/items/")
async def read_items(commons: Annotated[dict, Depends(common_parameters)]):
    return commons

PARAMETER 	DESCRIPTION
dependency 	

A "dependable" callable (like a function).

Don't call it directly, FastAPI will call it for you, just pass the object directly.

TYPE: Optional[Callable[..., Any]] DEFAULT: None
use_cache 	

By default, after a dependency is called the first time in a request, if the dependency is declared again for the rest of the request (for example if the dependency is needed by several dependencies), the value will be re-used for the rest of the request.

Set use_cache to False to disable this behavior and ensure the dependency is called again (if declared more than once) in the same request.

TYPE: bool DEFAULT: True
scope 	

Mainly for dependencies with yield, define when the dependency function should start (the code before yield) and when it should end (the code after yield).

    "function": start the dependency before the path operation function that handles the request, end the dependency after the path operation function ends, but before the response is sent back to the client. So, the dependency function will be executed around the path operation function.
    "request": start the dependency before the path operation function that handles the request (similar to when using "function"), but end after the response is sent back to the client. So, the dependency function will be executed around the request and response cycle.

TYPE: Union[Literal['function', 'request'], None] DEFAULT: None
Source code in fastapi/param_functions.py

Source code in fastapi/param_functions.py

Security()Â¶

For many scenarios, you can handle security (authorization, authentication, etc.) with dependencies, using Depends().

But when you want to also declare OAuth2 scopes, you can use Security() instead of Depends().

You can import Security() directly from fastapi:

from fastapi import Security

fastapi.Security Â¶

Security(dependency=None, *, scopes=None, use_cache=True)

Declare a FastAPI Security dependency.

The only difference with a regular dependency is that it can declare OAuth2 scopes that will be integrated with OpenAPI and the automatic UI docs (by default at /docs).

It takes a single "dependable" callable (like a function).

Don't call it directly, FastAPI will call it for you.

Read more about it in the FastAPI docs for Security and in the FastAPI docs for OAuth2 scopes.

Example

from typing import Annotated

from fastapi import Security, FastAPI

from .db import User
from .security import get_current_active_user

app = FastAPI()

@app.get("/users/me/items/")
async def read_own_items(
    current_user: Annotated[User, Security(get_current_active_user, scopes=["items"])]
):
    return [{"item_id": "Foo", "owner": current_user.username}]

PARAMETER 	DESCRIPTION
dependency 	

A "dependable" callable (like a function).

Don't call it directly, FastAPI will call it for you, just pass the object directly.

TYPE: Optional[Callable[..., Any]] DEFAULT: None
scopes 	

OAuth2 scopes required for the path operation that uses this Security dependency.

The term "scope" comes from the OAuth2 specification, it seems to be intentionally vague and interpretable. It normally refers to permissions, in cases to roles.

These scopes are integrated with OpenAPI (and the API docs at /docs). So they are visible in the OpenAPI specification. )

TYPE: Optional[Sequence[str]] DEFAULT: None
use_cache 	

By default, after a dependency is called the first time in a request, if the dependency is declared again for the rest of the request (for example if the dependency is needed by several dependencies), the value will be re-used for the rest of the request.

Set use_cache to False to disable this behavior and ensure the dependency is called again (if declared more than once) in the same request.

TYPE: bool DEFAULT: True
Source code in fastapi/param_functions.py

Source code in fastapi/param_functions.py

Previous
Exceptions - HTTPException and WebSocketException
Next
APIRouter class
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
APIRouter class

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

     APIRouter
        Example
         websocket
            Example
         include_router
            Example
         get
            Example
         put
            Example
         post
            Example
         delete
            Example
         options
            Example
         head
            Example
         patch
            Example
         trace
            Example
         on_event

    FastAPI
    Reference

APIRouter classÂ¶

Here's the reference information for the APIRouter class, with all its parameters, attributes and methods.

You can import the APIRouter class directly from fastapi:

from fastapi import APIRouter

fastapi.APIRouter Â¶

APIRouter(
    *,
    prefix="",
    tags=None,
    dependencies=None,
    default_response_class=Default(JSONResponse),
    responses=None,
    callbacks=None,
    routes=None,
    redirect_slashes=True,
    default=None,
    dependency_overrides_provider=None,
    route_class=APIRoute,
    on_startup=None,
    on_shutdown=None,
    lifespan=None,
    deprecated=None,
    include_in_schema=True,
    generate_unique_id_function=Default(generate_unique_id)
)

Bases: Router

APIRouter class, used to group path operations, for example to structure an app in multiple files. It would then be included in the FastAPI app, or in another APIRouter (ultimately included in the app).

Read more about it in the FastAPI docs for Bigger Applications - Multiple Files.
ExampleÂ¶

from fastapi import APIRouter, FastAPI

app = FastAPI()
router = APIRouter()


@router.get("/users/", tags=["users"])
async def read_users():
    return [{"username": "Rick"}, {"username": "Morty"}]


app.include_router(router)

PARAMETER 	DESCRIPTION
prefix 	

An optional path prefix for the router.

TYPE: str DEFAULT: ''
tags 	

A list of tags to be applied to all the path operations in this router.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[List[Union[str, Enum]]] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be applied to all the path operations in this router.

Read more about it in the FastAPI docs for Bigger Applications - Multiple Files.

TYPE: Optional[Sequence[Depends]] DEFAULT: None
default_response_class 	

The default response class to be used.

Read more in the FastAPI docs for Custom Response - HTML, Stream, File, others.

TYPE: Type[Response] DEFAULT: Default(JSONResponse)
responses 	

Additional responses to be shown in OpenAPI.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Additional Responses in OpenAPI.

And in the FastAPI docs for Bigger Applications.

TYPE: Optional[Dict[Union[int, str], Dict[str, Any]]] DEFAULT: None
callbacks 	

OpenAPI callbacks that should apply to all path operations in this router.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for OpenAPI Callbacks.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
routes 	

Note: you probably shouldn't use this parameter, it is inherited from Starlette and supported for compatibility.

A list of routes to serve incoming HTTP and WebSocket requests.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
redirect_slashes 	

Whether to detect and redirect slashes in URLs when the client doesn't use the same format.

TYPE: bool DEFAULT: True
default 	

Default function handler for this router. Used to handle 404 Not Found errors.

TYPE: Optional[ASGIApp] DEFAULT: None
dependency_overrides_provider 	

Only used internally by FastAPI to handle dependency overrides.

You shouldn't need to use it. It normally points to the FastAPI app object.

TYPE: Optional[Any] DEFAULT: None
route_class 	

Custom route (path operation) class to be used by this router.

Read more about it in the FastAPI docs for Custom Request and APIRoute class.

TYPE: Type[APIRoute] DEFAULT: APIRoute
on_startup 	

A list of startup event handler functions.

You should instead use the lifespan handlers.

Read more in the FastAPI docs for lifespan.

TYPE: Optional[Sequence[Callable[[], Any]]] DEFAULT: None
on_shutdown 	

A list of shutdown event handler functions.

You should instead use the lifespan handlers.

Read more in the FastAPI docs for lifespan.

TYPE: Optional[Sequence[Callable[[], Any]]] DEFAULT: None
lifespan 	

A Lifespan context manager handler. This replaces startup and shutdown functions with a single context manager.

Read more in the FastAPI docs for lifespan.

TYPE: Optional[Lifespan[Any]] DEFAULT: None
deprecated 	

Mark all path operations in this router as deprecated.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[bool] DEFAULT: None
include_in_schema 	

To include (or not) all the path operations in this router in the generated OpenAPI.

This affects the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Query Parameters and String Validations.

TYPE: bool DEFAULT: True
generate_unique_id_function 	

Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI.

This is particularly useful when automatically generating clients or SDKs for your API.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Callable[[APIRoute], str] DEFAULT: Default(generate_unique_id)
Source code in fastapi/routing.py

Source code in fastapi/routing.py

websocket Â¶

websocket(path, name=None, *, dependencies=None)

Decorate a WebSocket function.

Read more about it in the FastAPI docs for WebSockets.

Example
ExampleÂ¶

from fastapi import APIRouter, FastAPI, WebSocket

app = FastAPI()
router = APIRouter()

@router.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        await websocket.send_text(f"Message text was: {data}")

app.include_router(router)

PARAMETER 	DESCRIPTION
path 	

WebSocket path.

TYPE: str
name 	

A name for the WebSocket. Only used internally.

TYPE: Optional[str] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be used for this WebSocket.

Read more about it in the FastAPI docs for WebSockets.

TYPE: Optional[Sequence[Depends]] DEFAULT: None
Source code in fastapi/routing.py

Source code in fastapi/routing.py

include_router Â¶

include_router(
    router,
    *,
    prefix="",
    tags=None,
    dependencies=None,
    default_response_class=Default(JSONResponse),
    responses=None,
    callbacks=None,
    deprecated=None,
    include_in_schema=True,
    generate_unique_id_function=Default(generate_unique_id)
)

Include another APIRouter in the same current APIRouter.

Read more about it in the FastAPI docs for Bigger Applications.
ExampleÂ¶

from fastapi import APIRouter, FastAPI

app = FastAPI()
internal_router = APIRouter()
users_router = APIRouter()

@users_router.get("/users/")
def read_users():
    return [{"name": "Rick"}, {"name": "Morty"}]

internal_router.include_router(users_router)
app.include_router(internal_router)

PARAMETER 	DESCRIPTION
router 	

The APIRouter to include.

TYPE: APIRouter
prefix 	

An optional path prefix for the router.

TYPE: str DEFAULT: ''
tags 	

A list of tags to be applied to all the path operations in this router.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[List[Union[str, Enum]]] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be applied to all the path operations in this router.

Read more about it in the FastAPI docs for Bigger Applications - Multiple Files.

TYPE: Optional[Sequence[Depends]] DEFAULT: None
default_response_class 	

The default response class to be used.

Read more in the FastAPI docs for Custom Response - HTML, Stream, File, others.

TYPE: Type[Response] DEFAULT: Default(JSONResponse)
responses 	

Additional responses to be shown in OpenAPI.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Additional Responses in OpenAPI.

And in the FastAPI docs for Bigger Applications.

TYPE: Optional[Dict[Union[int, str], Dict[str, Any]]] DEFAULT: None
callbacks 	

OpenAPI callbacks that should apply to all path operations in this router.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for OpenAPI Callbacks.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
deprecated 	

Mark all path operations in this router as deprecated.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[bool] DEFAULT: None
include_in_schema 	

Include (or not) all the path operations in this router in the generated OpenAPI schema.

This affects the generated OpenAPI (e.g. visible at /docs).

TYPE: bool DEFAULT: True
generate_unique_id_function 	

Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI.

This is particularly useful when automatically generating clients or SDKs for your API.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Callable[[APIRoute], str] DEFAULT: Default(generate_unique_id)
Source code in fastapi/routing.py

Source code in fastapi/routing.py

get Â¶

get(
    path,
    *,
    response_model=Default(None),
    status_code=None,
    tags=None,
    dependencies=None,
    summary=None,
    description=None,
    response_description="Successful Response",
    responses=None,
    deprecated=None,
    operation_id=None,
    response_model_include=None,
    response_model_exclude=None,
    response_model_by_alias=True,
    response_model_exclude_unset=False,
    response_model_exclude_defaults=False,
    response_model_exclude_none=False,
    include_in_schema=True,
    response_class=Default(JSONResponse),
    name=None,
    callbacks=None,
    openapi_extra=None,
    generate_unique_id_function=Default(generate_unique_id)
)

Add a path operation using an HTTP GET operation.
ExampleÂ¶

from fastapi import APIRouter, FastAPI

app = FastAPI()
router = APIRouter()

@router.get("/items/")
def read_items():
    return [{"name": "Empanada"}, {"name": "Arepa"}]

app.include_router(router)

PARAMETER 	DESCRIPTION
path 	

The URL path to be used for this path operation.

For example, in http://example.com/items, the path is /items.

TYPE: str
response_model 	

The type to use for the response.

It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc.

It will be used for:

    Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema).
    Serialization: you could return an arbitrary object and the response_model would be used to serialize that object into the corresponding JSON.
    Filtering: the JSON sent to the client will only contain the data (fields) defined in the response_model. If you returned an object that contains an attribute password but the response_model does not include that field, the JSON sent to the client would not have that password.
    Validation: whatever you return will be serialized with the response_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the FastAPI docs for Response Model.

TYPE: Any DEFAULT: Default(None)
status_code 	

The default status code to be used for the response.

You could override the status code by returning a response directly.

Read more about it in the FastAPI docs for Response Status Code.

TYPE: Optional[int] DEFAULT: None
tags 	

A list of tags to be applied to the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[List[Union[str, Enum]]] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be applied to the path operation.

Read more about it in the FastAPI docs for Dependencies in path operation decorators.

TYPE: Optional[Sequence[Depends]] DEFAULT: None
summary 	

A summary for the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
description 	

A description for the path operation.

If not provided, it will be extracted automatically from the docstring of the path operation function.

It can contain Markdown.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
response_description 	

The description for the default response.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: str DEFAULT: 'Successful Response'
responses 	

Additional responses that could be returned by this path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[Dict[Union[int, str], Dict[str, Any]]] DEFAULT: None
deprecated 	

Mark this path operation as deprecated.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[bool] DEFAULT: None
operation_id 	

Custom operation ID to be used by this path operation.

By default, it is generated automatically.

If you provide a custom operation ID, you need to make sure it is unique for the whole API.

You can customize the operation ID generation with the parameter generate_unique_id_function in the FastAPI class.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Optional[str] DEFAULT: None
response_model_include 	

Configuration passed to Pydantic to include only certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_exclude 	

Configuration passed to Pydantic to exclude certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_by_alias 	

Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: True
response_model_exclude_unset 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response_model_exclude_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_defaults 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response_model_exclude_unset in that if the fields are set but contain the same default values, they will be excluded from the response.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_none 	

Configuration passed to Pydantic to define if the response data should exclude fields set to None.

This is much simpler (less smart) than response_model_exclude_unset and response_model_exclude_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
include_in_schema 	

Include this path operation in the generated OpenAPI schema.

This affects the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Query Parameters and String Validations.

TYPE: bool DEFAULT: True
response_class 	

Response class to be used for this path operation.

This will not be used if you return a response directly.

Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others.

TYPE: Type[Response] DEFAULT: Default(JSONResponse)
name 	

Name for this path operation. Only used internally.

TYPE: Optional[str] DEFAULT: None
callbacks 	

List of path operations that will be used as OpenAPI callbacks.

This is only for OpenAPI documentation, the callbacks won't be used directly.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for OpenAPI Callbacks.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
openapi_extra 	

Extra metadata to be included in the OpenAPI schema for this path operation.

Read more about it in the FastAPI docs for Path Operation Advanced Configuration.

TYPE: Optional[Dict[str, Any]] DEFAULT: None
generate_unique_id_function 	

Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI.

This is particularly useful when automatically generating clients or SDKs for your API.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Callable[[APIRoute], str] DEFAULT: Default(generate_unique_id)
Source code in fastapi/routing.py

Source code in fastapi/routing.py

put Â¶

put(
    path,
    *,
    response_model=Default(None),
    status_code=None,
    tags=None,
    dependencies=None,
    summary=None,
    description=None,
    response_description="Successful Response",
    responses=None,
    deprecated=None,
    operation_id=None,
    response_model_include=None,
    response_model_exclude=None,
    response_model_by_alias=True,
    response_model_exclude_unset=False,
    response_model_exclude_defaults=False,
    response_model_exclude_none=False,
    include_in_schema=True,
    response_class=Default(JSONResponse),
    name=None,
    callbacks=None,
    openapi_extra=None,
    generate_unique_id_function=Default(generate_unique_id)
)

Add a path operation using an HTTP PUT operation.
ExampleÂ¶

from fastapi import APIRouter, FastAPI
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    description: str | None = None

app = FastAPI()
router = APIRouter()

@router.put("/items/{item_id}")
def replace_item(item_id: str, item: Item):
    return {"message": "Item replaced", "id": item_id}

app.include_router(router)

PARAMETER 	DESCRIPTION
path 	

The URL path to be used for this path operation.

For example, in http://example.com/items, the path is /items.

TYPE: str
response_model 	

The type to use for the response.

It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc.

It will be used for:

    Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema).
    Serialization: you could return an arbitrary object and the response_model would be used to serialize that object into the corresponding JSON.
    Filtering: the JSON sent to the client will only contain the data (fields) defined in the response_model. If you returned an object that contains an attribute password but the response_model does not include that field, the JSON sent to the client would not have that password.
    Validation: whatever you return will be serialized with the response_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the FastAPI docs for Response Model.

TYPE: Any DEFAULT: Default(None)
status_code 	

The default status code to be used for the response.

You could override the status code by returning a response directly.

Read more about it in the FastAPI docs for Response Status Code.

TYPE: Optional[int] DEFAULT: None
tags 	

A list of tags to be applied to the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[List[Union[str, Enum]]] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be applied to the path operation.

Read more about it in the FastAPI docs for Dependencies in path operation decorators.

TYPE: Optional[Sequence[Depends]] DEFAULT: None
summary 	

A summary for the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
description 	

A description for the path operation.

If not provided, it will be extracted automatically from the docstring of the path operation function.

It can contain Markdown.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
response_description 	

The description for the default response.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: str DEFAULT: 'Successful Response'
responses 	

Additional responses that could be returned by this path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[Dict[Union[int, str], Dict[str, Any]]] DEFAULT: None
deprecated 	

Mark this path operation as deprecated.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[bool] DEFAULT: None
operation_id 	

Custom operation ID to be used by this path operation.

By default, it is generated automatically.

If you provide a custom operation ID, you need to make sure it is unique for the whole API.

You can customize the operation ID generation with the parameter generate_unique_id_function in the FastAPI class.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Optional[str] DEFAULT: None
response_model_include 	

Configuration passed to Pydantic to include only certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_exclude 	

Configuration passed to Pydantic to exclude certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_by_alias 	

Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: True
response_model_exclude_unset 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response_model_exclude_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_defaults 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response_model_exclude_unset in that if the fields are set but contain the same default values, they will be excluded from the response.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_none 	

Configuration passed to Pydantic to define if the response data should exclude fields set to None.

This is much simpler (less smart) than response_model_exclude_unset and response_model_exclude_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
include_in_schema 	

Include this path operation in the generated OpenAPI schema.

This affects the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Query Parameters and String Validations.

TYPE: bool DEFAULT: True
response_class 	

Response class to be used for this path operation.

This will not be used if you return a response directly.

Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others.

TYPE: Type[Response] DEFAULT: Default(JSONResponse)
name 	

Name for this path operation. Only used internally.

TYPE: Optional[str] DEFAULT: None
callbacks 	

List of path operations that will be used as OpenAPI callbacks.

This is only for OpenAPI documentation, the callbacks won't be used directly.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for OpenAPI Callbacks.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
openapi_extra 	

Extra metadata to be included in the OpenAPI schema for this path operation.

Read more about it in the FastAPI docs for Path Operation Advanced Configuration.

TYPE: Optional[Dict[str, Any]] DEFAULT: None
generate_unique_id_function 	

Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI.

This is particularly useful when automatically generating clients or SDKs for your API.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Callable[[APIRoute], str] DEFAULT: Default(generate_unique_id)
Source code in fastapi/routing.py

Source code in fastapi/routing.py

post Â¶

post(
    path,
    *,
    response_model=Default(None),
    status_code=None,
    tags=None,
    dependencies=None,
    summary=None,
    description=None,
    response_description="Successful Response",
    responses=None,
    deprecated=None,
    operation_id=None,
    response_model_include=None,
    response_model_exclude=None,
    response_model_by_alias=True,
    response_model_exclude_unset=False,
    response_model_exclude_defaults=False,
    response_model_exclude_none=False,
    include_in_schema=True,
    response_class=Default(JSONResponse),
    name=None,
    callbacks=None,
    openapi_extra=None,
    generate_unique_id_function=Default(generate_unique_id)
)

Add a path operation using an HTTP POST operation.
ExampleÂ¶

from fastapi import APIRouter, FastAPI
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    description: str | None = None

app = FastAPI()
router = APIRouter()

@router.post("/items/")
def create_item(item: Item):
    return {"message": "Item created"}

app.include_router(router)

PARAMETER 	DESCRIPTION
path 	

The URL path to be used for this path operation.

For example, in http://example.com/items, the path is /items.

TYPE: str
response_model 	

The type to use for the response.

It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc.

It will be used for:

    Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema).
    Serialization: you could return an arbitrary object and the response_model would be used to serialize that object into the corresponding JSON.
    Filtering: the JSON sent to the client will only contain the data (fields) defined in the response_model. If you returned an object that contains an attribute password but the response_model does not include that field, the JSON sent to the client would not have that password.
    Validation: whatever you return will be serialized with the response_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the FastAPI docs for Response Model.

TYPE: Any DEFAULT: Default(None)
status_code 	

The default status code to be used for the response.

You could override the status code by returning a response directly.

Read more about it in the FastAPI docs for Response Status Code.

TYPE: Optional[int] DEFAULT: None
tags 	

A list of tags to be applied to the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[List[Union[str, Enum]]] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be applied to the path operation.

Read more about it in the FastAPI docs for Dependencies in path operation decorators.

TYPE: Optional[Sequence[Depends]] DEFAULT: None
summary 	

A summary for the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
description 	

A description for the path operation.

If not provided, it will be extracted automatically from the docstring of the path operation function.

It can contain Markdown.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
response_description 	

The description for the default response.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: str DEFAULT: 'Successful Response'
responses 	

Additional responses that could be returned by this path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[Dict[Union[int, str], Dict[str, Any]]] DEFAULT: None
deprecated 	

Mark this path operation as deprecated.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[bool] DEFAULT: None
operation_id 	

Custom operation ID to be used by this path operation.

By default, it is generated automatically.

If you provide a custom operation ID, you need to make sure it is unique for the whole API.

You can customize the operation ID generation with the parameter generate_unique_id_function in the FastAPI class.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Optional[str] DEFAULT: None
response_model_include 	

Configuration passed to Pydantic to include only certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_exclude 	

Configuration passed to Pydantic to exclude certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_by_alias 	

Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: True
response_model_exclude_unset 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response_model_exclude_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_defaults 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response_model_exclude_unset in that if the fields are set but contain the same default values, they will be excluded from the response.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_none 	

Configuration passed to Pydantic to define if the response data should exclude fields set to None.

This is much simpler (less smart) than response_model_exclude_unset and response_model_exclude_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
include_in_schema 	

Include this path operation in the generated OpenAPI schema.

This affects the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Query Parameters and String Validations.

TYPE: bool DEFAULT: True
response_class 	

Response class to be used for this path operation.

This will not be used if you return a response directly.

Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others.

TYPE: Type[Response] DEFAULT: Default(JSONResponse)
name 	

Name for this path operation. Only used internally.

TYPE: Optional[str] DEFAULT: None
callbacks 	

List of path operations that will be used as OpenAPI callbacks.

This is only for OpenAPI documentation, the callbacks won't be used directly.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for OpenAPI Callbacks.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
openapi_extra 	

Extra metadata to be included in the OpenAPI schema for this path operation.

Read more about it in the FastAPI docs for Path Operation Advanced Configuration.

TYPE: Optional[Dict[str, Any]] DEFAULT: None
generate_unique_id_function 	

Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI.

This is particularly useful when automatically generating clients or SDKs for your API.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Callable[[APIRoute], str] DEFAULT: Default(generate_unique_id)
Source code in fastapi/routing.py

Source code in fastapi/routing.py

delete Â¶

delete(
    path,
    *,
    response_model=Default(None),
    status_code=None,
    tags=None,
    dependencies=None,
    summary=None,
    description=None,
    response_description="Successful Response",
    responses=None,
    deprecated=None,
    operation_id=None,
    response_model_include=None,
    response_model_exclude=None,
    response_model_by_alias=True,
    response_model_exclude_unset=False,
    response_model_exclude_defaults=False,
    response_model_exclude_none=False,
    include_in_schema=True,
    response_class=Default(JSONResponse),
    name=None,
    callbacks=None,
    openapi_extra=None,
    generate_unique_id_function=Default(generate_unique_id)
)

Add a path operation using an HTTP DELETE operation.
ExampleÂ¶

from fastapi import APIRouter, FastAPI

app = FastAPI()
router = APIRouter()

@router.delete("/items/{item_id}")
def delete_item(item_id: str):
    return {"message": "Item deleted"}

app.include_router(router)

PARAMETER 	DESCRIPTION
path 	

The URL path to be used for this path operation.

For example, in http://example.com/items, the path is /items.

TYPE: str
response_model 	

The type to use for the response.

It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc.

It will be used for:

    Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema).
    Serialization: you could return an arbitrary object and the response_model would be used to serialize that object into the corresponding JSON.
    Filtering: the JSON sent to the client will only contain the data (fields) defined in the response_model. If you returned an object that contains an attribute password but the response_model does not include that field, the JSON sent to the client would not have that password.
    Validation: whatever you return will be serialized with the response_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the FastAPI docs for Response Model.

TYPE: Any DEFAULT: Default(None)
status_code 	

The default status code to be used for the response.

You could override the status code by returning a response directly.

Read more about it in the FastAPI docs for Response Status Code.

TYPE: Optional[int] DEFAULT: None
tags 	

A list of tags to be applied to the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[List[Union[str, Enum]]] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be applied to the path operation.

Read more about it in the FastAPI docs for Dependencies in path operation decorators.

TYPE: Optional[Sequence[Depends]] DEFAULT: None
summary 	

A summary for the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
description 	

A description for the path operation.

If not provided, it will be extracted automatically from the docstring of the path operation function.

It can contain Markdown.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
response_description 	

The description for the default response.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: str DEFAULT: 'Successful Response'
responses 	

Additional responses that could be returned by this path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[Dict[Union[int, str], Dict[str, Any]]] DEFAULT: None
deprecated 	

Mark this path operation as deprecated.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[bool] DEFAULT: None
operation_id 	

Custom operation ID to be used by this path operation.

By default, it is generated automatically.

If you provide a custom operation ID, you need to make sure it is unique for the whole API.

You can customize the operation ID generation with the parameter generate_unique_id_function in the FastAPI class.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Optional[str] DEFAULT: None
response_model_include 	

Configuration passed to Pydantic to include only certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_exclude 	

Configuration passed to Pydantic to exclude certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_by_alias 	

Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: True
response_model_exclude_unset 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response_model_exclude_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_defaults 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response_model_exclude_unset in that if the fields are set but contain the same default values, they will be excluded from the response.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_none 	

Configuration passed to Pydantic to define if the response data should exclude fields set to None.

This is much simpler (less smart) than response_model_exclude_unset and response_model_exclude_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
include_in_schema 	

Include this path operation in the generated OpenAPI schema.

This affects the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Query Parameters and String Validations.

TYPE: bool DEFAULT: True
response_class 	

Response class to be used for this path operation.

This will not be used if you return a response directly.

Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others.

TYPE: Type[Response] DEFAULT: Default(JSONResponse)
name 	

Name for this path operation. Only used internally.

TYPE: Optional[str] DEFAULT: None
callbacks 	

List of path operations that will be used as OpenAPI callbacks.

This is only for OpenAPI documentation, the callbacks won't be used directly.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for OpenAPI Callbacks.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
openapi_extra 	

Extra metadata to be included in the OpenAPI schema for this path operation.

Read more about it in the FastAPI docs for Path Operation Advanced Configuration.

TYPE: Optional[Dict[str, Any]] DEFAULT: None
generate_unique_id_function 	

Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI.

This is particularly useful when automatically generating clients or SDKs for your API.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Callable[[APIRoute], str] DEFAULT: Default(generate_unique_id)
Source code in fastapi/routing.py

Source code in fastapi/routing.py

options Â¶

options(
    path,
    *,
    response_model=Default(None),
    status_code=None,
    tags=None,
    dependencies=None,
    summary=None,
    description=None,
    response_description="Successful Response",
    responses=None,
    deprecated=None,
    operation_id=None,
    response_model_include=None,
    response_model_exclude=None,
    response_model_by_alias=True,
    response_model_exclude_unset=False,
    response_model_exclude_defaults=False,
    response_model_exclude_none=False,
    include_in_schema=True,
    response_class=Default(JSONResponse),
    name=None,
    callbacks=None,
    openapi_extra=None,
    generate_unique_id_function=Default(generate_unique_id)
)

Add a path operation using an HTTP OPTIONS operation.
ExampleÂ¶

from fastapi import APIRouter, FastAPI

app = FastAPI()
router = APIRouter()

@router.options("/items/")
def get_item_options():
    return {"additions": ["Aji", "Guacamole"]}

app.include_router(router)

PARAMETER 	DESCRIPTION
path 	

The URL path to be used for this path operation.

For example, in http://example.com/items, the path is /items.

TYPE: str
response_model 	

The type to use for the response.

It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc.

It will be used for:

    Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema).
    Serialization: you could return an arbitrary object and the response_model would be used to serialize that object into the corresponding JSON.
    Filtering: the JSON sent to the client will only contain the data (fields) defined in the response_model. If you returned an object that contains an attribute password but the response_model does not include that field, the JSON sent to the client would not have that password.
    Validation: whatever you return will be serialized with the response_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the FastAPI docs for Response Model.

TYPE: Any DEFAULT: Default(None)
status_code 	

The default status code to be used for the response.

You could override the status code by returning a response directly.

Read more about it in the FastAPI docs for Response Status Code.

TYPE: Optional[int] DEFAULT: None
tags 	

A list of tags to be applied to the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[List[Union[str, Enum]]] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be applied to the path operation.

Read more about it in the FastAPI docs for Dependencies in path operation decorators.

TYPE: Optional[Sequence[Depends]] DEFAULT: None
summary 	

A summary for the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
description 	

A description for the path operation.

If not provided, it will be extracted automatically from the docstring of the path operation function.

It can contain Markdown.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
response_description 	

The description for the default response.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: str DEFAULT: 'Successful Response'
responses 	

Additional responses that could be returned by this path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[Dict[Union[int, str], Dict[str, Any]]] DEFAULT: None
deprecated 	

Mark this path operation as deprecated.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[bool] DEFAULT: None
operation_id 	

Custom operation ID to be used by this path operation.

By default, it is generated automatically.

If you provide a custom operation ID, you need to make sure it is unique for the whole API.

You can customize the operation ID generation with the parameter generate_unique_id_function in the FastAPI class.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Optional[str] DEFAULT: None
response_model_include 	

Configuration passed to Pydantic to include only certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_exclude 	

Configuration passed to Pydantic to exclude certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_by_alias 	

Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: True
response_model_exclude_unset 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response_model_exclude_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_defaults 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response_model_exclude_unset in that if the fields are set but contain the same default values, they will be excluded from the response.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_none 	

Configuration passed to Pydantic to define if the response data should exclude fields set to None.

This is much simpler (less smart) than response_model_exclude_unset and response_model_exclude_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
include_in_schema 	

Include this path operation in the generated OpenAPI schema.

This affects the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Query Parameters and String Validations.

TYPE: bool DEFAULT: True
response_class 	

Response class to be used for this path operation.

This will not be used if you return a response directly.

Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others.

TYPE: Type[Response] DEFAULT: Default(JSONResponse)
name 	

Name for this path operation. Only used internally.

TYPE: Optional[str] DEFAULT: None
callbacks 	

List of path operations that will be used as OpenAPI callbacks.

This is only for OpenAPI documentation, the callbacks won't be used directly.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for OpenAPI Callbacks.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
openapi_extra 	

Extra metadata to be included in the OpenAPI schema for this path operation.

Read more about it in the FastAPI docs for Path Operation Advanced Configuration.

TYPE: Optional[Dict[str, Any]] DEFAULT: None
generate_unique_id_function 	

Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI.

This is particularly useful when automatically generating clients or SDKs for your API.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Callable[[APIRoute], str] DEFAULT: Default(generate_unique_id)
Source code in fastapi/routing.py

Source code in fastapi/routing.py

head Â¶

head(
    path,
    *,
    response_model=Default(None),
    status_code=None,
    tags=None,
    dependencies=None,
    summary=None,
    description=None,
    response_description="Successful Response",
    responses=None,
    deprecated=None,
    operation_id=None,
    response_model_include=None,
    response_model_exclude=None,
    response_model_by_alias=True,
    response_model_exclude_unset=False,
    response_model_exclude_defaults=False,
    response_model_exclude_none=False,
    include_in_schema=True,
    response_class=Default(JSONResponse),
    name=None,
    callbacks=None,
    openapi_extra=None,
    generate_unique_id_function=Default(generate_unique_id)
)

Add a path operation using an HTTP HEAD operation.
ExampleÂ¶

from fastapi import APIRouter, FastAPI
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    description: str | None = None

app = FastAPI()
router = APIRouter()

@router.head("/items/", status_code=204)
def get_items_headers(response: Response):
    response.headers["X-Cat-Dog"] = "Alone in the world"

app.include_router(router)

PARAMETER 	DESCRIPTION
path 	

The URL path to be used for this path operation.

For example, in http://example.com/items, the path is /items.

TYPE: str
response_model 	

The type to use for the response.

It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc.

It will be used for:

    Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema).
    Serialization: you could return an arbitrary object and the response_model would be used to serialize that object into the corresponding JSON.
    Filtering: the JSON sent to the client will only contain the data (fields) defined in the response_model. If you returned an object that contains an attribute password but the response_model does not include that field, the JSON sent to the client would not have that password.
    Validation: whatever you return will be serialized with the response_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the FastAPI docs for Response Model.

TYPE: Any DEFAULT: Default(None)
status_code 	

The default status code to be used for the response.

You could override the status code by returning a response directly.

Read more about it in the FastAPI docs for Response Status Code.

TYPE: Optional[int] DEFAULT: None
tags 	

A list of tags to be applied to the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[List[Union[str, Enum]]] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be applied to the path operation.

Read more about it in the FastAPI docs for Dependencies in path operation decorators.

TYPE: Optional[Sequence[Depends]] DEFAULT: None
summary 	

A summary for the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
description 	

A description for the path operation.

If not provided, it will be extracted automatically from the docstring of the path operation function.

It can contain Markdown.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
response_description 	

The description for the default response.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: str DEFAULT: 'Successful Response'
responses 	

Additional responses that could be returned by this path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[Dict[Union[int, str], Dict[str, Any]]] DEFAULT: None
deprecated 	

Mark this path operation as deprecated.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[bool] DEFAULT: None
operation_id 	

Custom operation ID to be used by this path operation.

By default, it is generated automatically.

If you provide a custom operation ID, you need to make sure it is unique for the whole API.

You can customize the operation ID generation with the parameter generate_unique_id_function in the FastAPI class.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Optional[str] DEFAULT: None
response_model_include 	

Configuration passed to Pydantic to include only certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_exclude 	

Configuration passed to Pydantic to exclude certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_by_alias 	

Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: True
response_model_exclude_unset 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response_model_exclude_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_defaults 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response_model_exclude_unset in that if the fields are set but contain the same default values, they will be excluded from the response.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_none 	

Configuration passed to Pydantic to define if the response data should exclude fields set to None.

This is much simpler (less smart) than response_model_exclude_unset and response_model_exclude_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
include_in_schema 	

Include this path operation in the generated OpenAPI schema.

This affects the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Query Parameters and String Validations.

TYPE: bool DEFAULT: True
response_class 	

Response class to be used for this path operation.

This will not be used if you return a response directly.

Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others.

TYPE: Type[Response] DEFAULT: Default(JSONResponse)
name 	

Name for this path operation. Only used internally.

TYPE: Optional[str] DEFAULT: None
callbacks 	

List of path operations that will be used as OpenAPI callbacks.

This is only for OpenAPI documentation, the callbacks won't be used directly.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for OpenAPI Callbacks.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
openapi_extra 	

Extra metadata to be included in the OpenAPI schema for this path operation.

Read more about it in the FastAPI docs for Path Operation Advanced Configuration.

TYPE: Optional[Dict[str, Any]] DEFAULT: None
generate_unique_id_function 	

Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI.

This is particularly useful when automatically generating clients or SDKs for your API.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Callable[[APIRoute], str] DEFAULT: Default(generate_unique_id)
Source code in fastapi/routing.py

Source code in fastapi/routing.py

patch Â¶

patch(
    path,
    *,
    response_model=Default(None),
    status_code=None,
    tags=None,
    dependencies=None,
    summary=None,
    description=None,
    response_description="Successful Response",
    responses=None,
    deprecated=None,
    operation_id=None,
    response_model_include=None,
    response_model_exclude=None,
    response_model_by_alias=True,
    response_model_exclude_unset=False,
    response_model_exclude_defaults=False,
    response_model_exclude_none=False,
    include_in_schema=True,
    response_class=Default(JSONResponse),
    name=None,
    callbacks=None,
    openapi_extra=None,
    generate_unique_id_function=Default(generate_unique_id)
)

Add a path operation using an HTTP PATCH operation.
ExampleÂ¶

from fastapi import APIRouter, FastAPI
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    description: str | None = None

app = FastAPI()
router = APIRouter()

@router.patch("/items/")
def update_item(item: Item):
    return {"message": "Item updated in place"}

app.include_router(router)

PARAMETER 	DESCRIPTION
path 	

The URL path to be used for this path operation.

For example, in http://example.com/items, the path is /items.

TYPE: str
response_model 	

The type to use for the response.

It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc.

It will be used for:

    Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema).
    Serialization: you could return an arbitrary object and the response_model would be used to serialize that object into the corresponding JSON.
    Filtering: the JSON sent to the client will only contain the data (fields) defined in the response_model. If you returned an object that contains an attribute password but the response_model does not include that field, the JSON sent to the client would not have that password.
    Validation: whatever you return will be serialized with the response_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the FastAPI docs for Response Model.

TYPE: Any DEFAULT: Default(None)
status_code 	

The default status code to be used for the response.

You could override the status code by returning a response directly.

Read more about it in the FastAPI docs for Response Status Code.

TYPE: Optional[int] DEFAULT: None
tags 	

A list of tags to be applied to the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[List[Union[str, Enum]]] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be applied to the path operation.

Read more about it in the FastAPI docs for Dependencies in path operation decorators.

TYPE: Optional[Sequence[Depends]] DEFAULT: None
summary 	

A summary for the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
description 	

A description for the path operation.

If not provided, it will be extracted automatically from the docstring of the path operation function.

It can contain Markdown.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
response_description 	

The description for the default response.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: str DEFAULT: 'Successful Response'
responses 	

Additional responses that could be returned by this path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[Dict[Union[int, str], Dict[str, Any]]] DEFAULT: None
deprecated 	

Mark this path operation as deprecated.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[bool] DEFAULT: None
operation_id 	

Custom operation ID to be used by this path operation.

By default, it is generated automatically.

If you provide a custom operation ID, you need to make sure it is unique for the whole API.

You can customize the operation ID generation with the parameter generate_unique_id_function in the FastAPI class.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Optional[str] DEFAULT: None
response_model_include 	

Configuration passed to Pydantic to include only certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_exclude 	

Configuration passed to Pydantic to exclude certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_by_alias 	

Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: True
response_model_exclude_unset 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response_model_exclude_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_defaults 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response_model_exclude_unset in that if the fields are set but contain the same default values, they will be excluded from the response.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_none 	

Configuration passed to Pydantic to define if the response data should exclude fields set to None.

This is much simpler (less smart) than response_model_exclude_unset and response_model_exclude_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
include_in_schema 	

Include this path operation in the generated OpenAPI schema.

This affects the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Query Parameters and String Validations.

TYPE: bool DEFAULT: True
response_class 	

Response class to be used for this path operation.

This will not be used if you return a response directly.

Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others.

TYPE: Type[Response] DEFAULT: Default(JSONResponse)
name 	

Name for this path operation. Only used internally.

TYPE: Optional[str] DEFAULT: None
callbacks 	

List of path operations that will be used as OpenAPI callbacks.

This is only for OpenAPI documentation, the callbacks won't be used directly.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for OpenAPI Callbacks.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
openapi_extra 	

Extra metadata to be included in the OpenAPI schema for this path operation.

Read more about it in the FastAPI docs for Path Operation Advanced Configuration.

TYPE: Optional[Dict[str, Any]] DEFAULT: None
generate_unique_id_function 	

Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI.

This is particularly useful when automatically generating clients or SDKs for your API.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Callable[[APIRoute], str] DEFAULT: Default(generate_unique_id)
Source code in fastapi/routing.py

Source code in fastapi/routing.py

trace Â¶

trace(
    path,
    *,
    response_model=Default(None),
    status_code=None,
    tags=None,
    dependencies=None,
    summary=None,
    description=None,
    response_description="Successful Response",
    responses=None,
    deprecated=None,
    operation_id=None,
    response_model_include=None,
    response_model_exclude=None,
    response_model_by_alias=True,
    response_model_exclude_unset=False,
    response_model_exclude_defaults=False,
    response_model_exclude_none=False,
    include_in_schema=True,
    response_class=Default(JSONResponse),
    name=None,
    callbacks=None,
    openapi_extra=None,
    generate_unique_id_function=Default(generate_unique_id)
)

Add a path operation using an HTTP TRACE operation.
ExampleÂ¶

from fastapi import APIRouter, FastAPI
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    description: str | None = None

app = FastAPI()
router = APIRouter()

@router.trace("/items/{item_id}")
def trace_item(item_id: str):
    return None

app.include_router(router)

PARAMETER 	DESCRIPTION
path 	

The URL path to be used for this path operation.

For example, in http://example.com/items, the path is /items.

TYPE: str
response_model 	

The type to use for the response.

It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc.

It will be used for:

    Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema).
    Serialization: you could return an arbitrary object and the response_model would be used to serialize that object into the corresponding JSON.
    Filtering: the JSON sent to the client will only contain the data (fields) defined in the response_model. If you returned an object that contains an attribute password but the response_model does not include that field, the JSON sent to the client would not have that password.
    Validation: whatever you return will be serialized with the response_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error).

Read more about it in the FastAPI docs for Response Model.

TYPE: Any DEFAULT: Default(None)
status_code 	

The default status code to be used for the response.

You could override the status code by returning a response directly.

Read more about it in the FastAPI docs for Response Status Code.

TYPE: Optional[int] DEFAULT: None
tags 	

A list of tags to be applied to the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[List[Union[str, Enum]]] DEFAULT: None
dependencies 	

A list of dependencies (using Depends()) to be applied to the path operation.

Read more about it in the FastAPI docs for Dependencies in path operation decorators.

TYPE: Optional[Sequence[Depends]] DEFAULT: None
summary 	

A summary for the path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
description 	

A description for the path operation.

If not provided, it will be extracted automatically from the docstring of the path operation function.

It can contain Markdown.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Path Operation Configuration.

TYPE: Optional[str] DEFAULT: None
response_description 	

The description for the default response.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: str DEFAULT: 'Successful Response'
responses 	

Additional responses that could be returned by this path operation.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[Dict[Union[int, str], Dict[str, Any]]] DEFAULT: None
deprecated 	

Mark this path operation as deprecated.

It will be added to the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[bool] DEFAULT: None
operation_id 	

Custom operation ID to be used by this path operation.

By default, it is generated automatically.

If you provide a custom operation ID, you need to make sure it is unique for the whole API.

You can customize the operation ID generation with the parameter generate_unique_id_function in the FastAPI class.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Optional[str] DEFAULT: None
response_model_include 	

Configuration passed to Pydantic to include only certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_exclude 	

Configuration passed to Pydantic to exclude certain fields in the response data.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: Optional[IncEx] DEFAULT: None
response_model_by_alias 	

Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: True
response_model_exclude_unset 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response_model_exclude_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_defaults 	

Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response_model_exclude_unset in that if the fields are set but contain the same default values, they will be excluded from the response.

When True, default values are omitted from the response.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
response_model_exclude_none 	

Configuration passed to Pydantic to define if the response data should exclude fields set to None.

This is much simpler (less smart) than response_model_exclude_unset and response_model_exclude_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense.

Read more about it in the FastAPI docs for Response Model - Return Type.

TYPE: bool DEFAULT: False
include_in_schema 	

Include this path operation in the generated OpenAPI schema.

This affects the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for Query Parameters and String Validations.

TYPE: bool DEFAULT: True
response_class 	

Response class to be used for this path operation.

This will not be used if you return a response directly.

Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others.

TYPE: Type[Response] DEFAULT: Default(JSONResponse)
name 	

Name for this path operation. Only used internally.

TYPE: Optional[str] DEFAULT: None
callbacks 	

List of path operations that will be used as OpenAPI callbacks.

This is only for OpenAPI documentation, the callbacks won't be used directly.

It will be added to the generated OpenAPI (e.g. visible at /docs).

Read more about it in the FastAPI docs for OpenAPI Callbacks.

TYPE: Optional[List[BaseRoute]] DEFAULT: None
openapi_extra 	

Extra metadata to be included in the OpenAPI schema for this path operation.

Read more about it in the FastAPI docs for Path Operation Advanced Configuration.

TYPE: Optional[Dict[str, Any]] DEFAULT: None
generate_unique_id_function 	

Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI.

This is particularly useful when automatically generating clients or SDKs for your API.

Read more about it in the FastAPI docs about how to Generate Clients.

TYPE: Callable[[APIRoute], str] DEFAULT: Default(generate_unique_id)
Source code in fastapi/routing.py

Source code in fastapi/routing.py

on_event Â¶

on_event(event_type)

Add an event handler for the router.

on_event is deprecated, use lifespan event handlers instead.

Read more about it in the FastAPI docs for Lifespan Events.
PARAMETER 	DESCRIPTION
event_type 	

The type of event. startup or shutdown.

TYPE: str
Source code in fastapi/routing.py

Source code in fastapi/routing.py

Previous
Dependencies - Depends() and Security()
Next
Background Tasks - BackgroundTasks
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Background Tasks - BackgroundTasks

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

     BackgroundTasks
        Example
         func
         args
         kwargs
         is_async
         tasks
         add_task

    FastAPI
    Reference

Background Tasks - BackgroundTasksÂ¶

You can declare a parameter in a path operation function or dependency function with the type BackgroundTasks, and then you can use it to schedule the execution of background tasks after the response is sent.

You can import it directly from fastapi:

from fastapi import BackgroundTasks

fastapi.BackgroundTasks Â¶

BackgroundTasks(tasks=None)

Bases: BackgroundTasks

A collection of background tasks that will be called after a response has been sent to the client.

Read more about it in the FastAPI docs for Background Tasks.
ExampleÂ¶

from fastapi import BackgroundTasks, FastAPI

app = FastAPI()


def write_notification(email: str, message=""):
    with open("log.txt", mode="w") as email_file:
        content = f"notification for {email}: {message}"
        email_file.write(content)


@app.post("/send-notification/{email}")
async def send_notification(email: str, background_tasks: BackgroundTasks):
    background_tasks.add_task(write_notification, email, message="some notification")
    return {"message": "Notification sent in the background"}

Source code in starlette/background.py

Source code in starlette/background.py

func instance-attribute Â¶

func = func

args instance-attribute Â¶

args = args

kwargs instance-attribute Â¶

kwargs = kwargs

is_async instance-attribute Â¶

is_async = is_async_callable(func)

tasks instance-attribute Â¶

tasks = list(tasks) if tasks else []

add_task Â¶

add_task(func, *args, **kwargs)

Add a function to be called in the background after the response is sent.

Read more about it in the FastAPI docs for Background Tasks.
PARAMETER 	DESCRIPTION
func 	

The function to call after the response is sent.

It can be a regular def function or an async def function.

TYPE: Callable[P, Any]
Source code in fastapi/background.py

Source code in fastapi/background.py

Previous
APIRouter class
Next
Request class
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Request class

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

     Request
         scope
         app
         url
         base_url
         headers
         query_params
         path_params
         cookies
         client
         session
         auth
         user
         state
         method
         receive
         url_for
         stream
         body
         json
         form
         close
         is_disconnected
         send_push_promise

    FastAPI
    Reference

Request classÂ¶

You can declare a parameter in a path operation function or dependency to be of type Request and then you can access the raw request object directly, without any validation, etc.

You can import it directly from fastapi:

from fastapi import Request

Tip

When you want to define dependencies that should be compatible with both HTTP and WebSockets, you can define a parameter that takes an HTTPConnection instead of a Request or a WebSocket.
fastapi.Request Â¶

Request(scope, receive=empty_receive, send=empty_send)

Bases: HTTPConnection
Source code in starlette/requests.py

Source code in starlette/requests.py

scope instance-attribute Â¶

scope = scope

app property Â¶

app

url property Â¶

url

base_url property Â¶

base_url

headers property Â¶

headers

query_params property Â¶

query_params

path_params property Â¶

path_params

cookies property Â¶

cookies

client property Â¶

client

session property Â¶

session

auth property Â¶

auth

user property Â¶

user

state property Â¶

state

method property Â¶

method

receive property Â¶

receive

url_for Â¶

url_for(name, /, **path_params)

Source code in starlette/requests.py

Source code in starlette/requests.py

stream async Â¶

stream()

Source code in starlette/requests.py

Source code in starlette/requests.py

body async Â¶

body()

Source code in starlette/requests.py

Source code in starlette/requests.py

json async Â¶

json()

Source code in starlette/requests.py

Source code in starlette/requests.py

form Â¶

form(
    *,
    max_files=1000,
    max_fields=1000,
    max_part_size=1024 * 1024
)

Source code in starlette/requests.py

Source code in starlette/requests.py

close async Â¶

close()

Source code in starlette/requests.py

Source code in starlette/requests.py

is_disconnected async Â¶

is_disconnected()

Source code in starlette/requests.py

Source code in starlette/requests.py

send_push_promise async Â¶

send_push_promise(path)

Source code in starlette/requests.py

Source code in starlette/requests.py

Previous
Background Tasks - BackgroundTasks
Next
WebSockets
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs






Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
WebSockets

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

     WebSocket
         scope
         app
         url
         base_url
         headers
         query_params
         path_params
         cookies
         client
         state
         client_state
         application_state
         url_for
         receive
         send
         accept
         receive_text
         receive_bytes
         receive_json
         iter_text
         iter_bytes
         iter_json
         send_text
         send_bytes
         send_json
         close
     WebSocketDisconnect
         code
         reason
    WebSockets - additional classes
     WebSocketDisconnect
         code
         reason
     WebSocketState
         CONNECTING
         CONNECTED
         DISCONNECTED
         RESPONSE

    FastAPI
    Reference

WebSocketsÂ¶

When defining WebSockets, you normally declare a parameter of type WebSocket and with it you can read data from the client and send data to it.

It is provided directly by Starlette, but you can import it from fastapi:

from fastapi import WebSocket

Tip

When you want to define dependencies that should be compatible with both HTTP and WebSockets, you can define a parameter that takes an HTTPConnection instead of a Request or a WebSocket.
fastapi.WebSocket Â¶

WebSocket(scope, receive, send)

Bases: HTTPConnection
Source code in starlette/websockets.py

Source code in starlette/websockets.py

scope instance-attribute Â¶

scope = scope

app property Â¶

app

url property Â¶

url

base_url property Â¶

base_url

headers property Â¶

headers

query_params property Â¶

query_params

path_params property Â¶

path_params

cookies property Â¶

cookies

client property Â¶

client

state property Â¶

state

client_state instance-attribute Â¶

client_state = CONNECTING

application_state instance-attribute Â¶

application_state = CONNECTING

url_for Â¶

url_for(name, /, **path_params)

Source code in starlette/requests.py

Source code in starlette/requests.py

receive async Â¶

receive()

Receive ASGI websocket messages, ensuring valid state transitions.
Source code in starlette/websockets.py

Source code in starlette/websockets.py

send async Â¶

send(message)

Send ASGI websocket messages, ensuring valid state transitions.
Source code in starlette/websockets.py

Source code in starlette/websockets.py

accept async Â¶

accept(subprotocol=None, headers=None)

Source code in starlette/websockets.py

Source code in starlette/websockets.py

receive_text async Â¶

receive_text()

Source code in starlette/websockets.py

Source code in starlette/websockets.py

receive_bytes async Â¶

receive_bytes()

Source code in starlette/websockets.py

Source code in starlette/websockets.py

receive_json async Â¶

receive_json(mode='text')

Source code in starlette/websockets.py

Source code in starlette/websockets.py

iter_text async Â¶

iter_text()

Source code in starlette/websockets.py

Source code in starlette/websockets.py

iter_bytes async Â¶

iter_bytes()

Source code in starlette/websockets.py

Source code in starlette/websockets.py

iter_json async Â¶

iter_json()

Source code in starlette/websockets.py

Source code in starlette/websockets.py

send_text async Â¶

send_text(data)

Source code in starlette/websockets.py

Source code in starlette/websockets.py

send_bytes async Â¶

send_bytes(data)

Source code in starlette/websockets.py

Source code in starlette/websockets.py

send_json async Â¶

send_json(data, mode='text')

Source code in starlette/websockets.py

Source code in starlette/websockets.py

close async Â¶

close(code=1000, reason=None)

Source code in starlette/websockets.py

Source code in starlette/websockets.py

When a client disconnects, a WebSocketDisconnect exception is raised, you can catch it.

You can import it directly form fastapi:

from fastapi import WebSocketDisconnect

fastapi.WebSocketDisconnect Â¶

WebSocketDisconnect(code=1000, reason=None)

Bases: Exception
Source code in starlette/websockets.py

Source code in starlette/websockets.py

code instance-attribute Â¶

code = code

reason instance-attribute Â¶

reason = reason or ''

WebSockets - additional classesÂ¶

Additional classes for handling WebSockets.

Provided directly by Starlette, but you can import it from fastapi:

from fastapi.websockets import WebSocketDisconnect, WebSocketState

fastapi.websockets.WebSocketDisconnect Â¶

WebSocketDisconnect(code=1000, reason=None)

Bases: Exception
Source code in starlette/websockets.py

Source code in starlette/websockets.py

code instance-attribute Â¶

code = code

reason instance-attribute Â¶

reason = reason or ''

fastapi.websockets.WebSocketState Â¶

Bases: Enum
CONNECTING class-attribute instance-attribute Â¶

CONNECTING = 0

CONNECTED class-attribute instance-attribute Â¶

CONNECTED = 1

DISCONNECTED class-attribute instance-attribute Â¶

DISCONNECTED = 2

RESPONSE class-attribute instance-attribute Â¶

RESPONSE = 3

Previous
Request class
Next
HTTPConnection class
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
HTTPConnection class

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

     HTTPConnection
         scope
         app
         url
         base_url
         headers
         query_params
         path_params
         cookies
         client
         session
         auth
         user
         state
         url_for

    FastAPI
    Reference

HTTPConnection classÂ¶

When you want to define dependencies that should be compatible with both HTTP and WebSockets, you can define a parameter that takes an HTTPConnection instead of a Request or a WebSocket.

You can import it from fastapi.requests:

from fastapi.requests import HTTPConnection

fastapi.requests.HTTPConnection Â¶

HTTPConnection(scope, receive=None)

Bases: Mapping[str, Any]

A base class for incoming HTTP connections, that is used to provide any functionality that is common to both Request and WebSocket.
Source code in starlette/requests.py

Source code in starlette/requests.py

scope instance-attribute Â¶

scope = scope

app property Â¶

app

url property Â¶

url

base_url property Â¶

base_url

headers property Â¶

headers

query_params property Â¶

query_params

path_params property Â¶

path_params

cookies property Â¶

cookies

client property Â¶

client

session property Â¶

session

auth property Â¶

auth

user property Â¶

user

state property Â¶

state

url_for Â¶

url_for(name, /, **path_params)

Source code in starlette/requests.py

Source code in starlette/requests.py

Previous
WebSockets
Next
Response class
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs




Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
Response class

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

     Response
         media_type
         charset
         status_code
         background
         body
         headers
         render
         init_headers
         set_cookie
         delete_cookie

    FastAPI
    Reference

Response classÂ¶

You can declare a parameter in a path operation function or dependency to be of type Response and then you can set data for the response like headers or cookies.

You can also use it directly to create an instance of it and return it from your path operations.

You can import it directly from fastapi:

from fastapi import Response

fastapi.Response Â¶

Response(
    content=None,
    status_code=200,
    headers=None,
    media_type=None,
    background=None,
)

Source code in starlette/responses.py

Source code in starlette/responses.py

media_type class-attribute instance-attribute Â¶

media_type = None

charset class-attribute instance-attribute Â¶

charset = 'utf-8'

status_code instance-attribute Â¶

status_code = status_code

background instance-attribute Â¶

background = background

body instance-attribute Â¶

body = render(content)

headers property Â¶

headers

render Â¶

render(content)

Source code in starlette/responses.py

Source code in starlette/responses.py

init_headers Â¶

init_headers(headers=None)

Source code in starlette/responses.py

Source code in starlette/responses.py

set_cookie Â¶

set_cookie(
    key,
    value="",
    max_age=None,
    expires=None,
    path="/",
    domain=None,
    secure=False,
    httponly=False,
    samesite="lax",
    partitioned=False,
)

Source code in starlette/responses.py

Source code in starlette/responses.py

delete_cookie Â¶

delete_cookie(
    key,
    path="/",
    domain=None,
    secure=False,
    httponly=False,
    samesite="lax",
)

Source code in starlette/responses.py

Source code in starlette/responses.py

Previous
HTTPConnection class
Next
Custom Response Classes - File, HTML, Redirect, Streaming, etc.
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
Custom Response Classes - File, HTML, Redirect, Streaming, etc.

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

    FastAPI Responses
     UJSONResponse
         charset
         status_code
         media_type
         body
         background
         headers
         render
         init_headers
         set_cookie
         delete_cookie
     ORJSONResponse
         charset
         status_code
         media_type
         body
         background
         headers
         render
         init_headers
         set_cookie
         delete_cookie
    Starlette Responses
     FileResponse
         chunk_size
         charset
         status_code
         media_type
         body
         background
         headers
         render
         init_headers
         set_cookie
         delete_cookie
     HTMLResponse
         charset
         status_code
         media_type
         body
         background
         headers
         render
         init_headers
         set_cookie
         delete_cookie
     JSONResponse
         charset
         status_code
         media_type
         body
         background
         headers
         render
         init_headers
         set_cookie
         delete_cookie
     PlainTextResponse
         charset
         status_code
         media_type
         body
         background
         headers
         render
         init_headers
         set_cookie
         delete_cookie
     RedirectResponse
         charset
         status_code
         media_type
         body
         background
         headers
         render
         init_headers
         set_cookie
         delete_cookie
     Response
         charset
         status_code
         media_type
         body
         background
         headers
         render
         init_headers
         set_cookie
         delete_cookie
     StreamingResponse
         body_iterator
         charset
         status_code
         media_type
         body
         background
         headers
         render
         init_headers
         set_cookie
         delete_cookie

    FastAPI
    Reference

Custom Response Classes - File, HTML, Redirect, Streaming, etc.Â¶

There are several custom response classes you can use to create an instance and return them directly from your path operations.

Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others.

You can import them directly from fastapi.responses:

from fastapi.responses import (
    FileResponse,
    HTMLResponse,
    JSONResponse,
    ORJSONResponse,
    PlainTextResponse,
    RedirectResponse,
    Response,
    StreamingResponse,
    UJSONResponse,
)

FastAPI ResponsesÂ¶

There are a couple of custom FastAPI response classes, you can use them to optimize JSON performance.
fastapi.responses.UJSONResponse Â¶

UJSONResponse(
    content,
    status_code=200,
    headers=None,
    media_type=None,
    background=None,
)

Bases: JSONResponse

JSON response using the high-performance ujson library to serialize data to JSON.

Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others.
Source code in starlette/responses.py

Source code in starlette/responses.py

charset class-attribute instance-attribute Â¶

charset = 'utf-8'

status_code instance-attribute Â¶

status_code = status_code

media_type class-attribute instance-attribute Â¶

media_type = 'application/json'

body instance-attribute Â¶

body = render(content)

background instance-attribute Â¶

background = background

headers property Â¶

headers

render Â¶

render(content)

Source code in fastapi/responses.py

Source code in fastapi/responses.py

init_headers Â¶

init_headers(headers=None)

Source code in starlette/responses.py

Source code in starlette/responses.py

set_cookie Â¶

set_cookie(
    key,
    value="",
    max_age=None,
    expires=None,
    path="/",
    domain=None,
    secure=False,
    httponly=False,
    samesite="lax",
    partitioned=False,
)

Source code in starlette/responses.py

Source code in starlette/responses.py

delete_cookie Â¶

delete_cookie(
    key,
    path="/",
    domain=None,
    secure=False,
    httponly=False,
    samesite="lax",
)

Source code in starlette/responses.py

Source code in starlette/responses.py

fastapi.responses.ORJSONResponse Â¶

ORJSONResponse(
    content,
    status_code=200,
    headers=None,
    media_type=None,
    background=None,
)

Bases: JSONResponse

JSON response using the high-performance orjson library to serialize data to JSON.

Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others.
Source code in starlette/responses.py

Source code in starlette/responses.py

charset class-attribute instance-attribute Â¶

charset = 'utf-8'

status_code instance-attribute Â¶

status_code = status_code

media_type class-attribute instance-attribute Â¶

media_type = 'application/json'

body instance-attribute Â¶

body = render(content)

background instance-attribute Â¶

background = background

headers property Â¶

headers

render Â¶

render(content)

Source code in fastapi/responses.py

Source code in fastapi/responses.py

init_headers Â¶

init_headers(headers=None)

Source code in starlette/responses.py

Source code in starlette/responses.py

set_cookie Â¶

set_cookie(
    key,
    value="",
    max_age=None,
    expires=None,
    path="/",
    domain=None,
    secure=False,
    httponly=False,
    samesite="lax",
    partitioned=False,
)

Source code in starlette/responses.py

Source code in starlette/responses.py

delete_cookie Â¶

delete_cookie(
    key,
    path="/",
    domain=None,
    secure=False,
    httponly=False,
    samesite="lax",
)

Source code in starlette/responses.py

Source code in starlette/responses.py

Starlette ResponsesÂ¶
fastapi.responses.FileResponse Â¶

FileResponse(
    path,
    status_code=200,
    headers=None,
    media_type=None,
    background=None,
    filename=None,
    stat_result=None,
    method=None,
    content_disposition_type="attachment",
)

Bases: Response
Source code in starlette/responses.py

Source code in starlette/responses.py

chunk_size class-attribute instance-attribute Â¶

chunk_size = 64 * 1024

charset class-attribute instance-attribute Â¶

charset = 'utf-8'

status_code instance-attribute Â¶

status_code = status_code

media_type instance-attribute Â¶

media_type = media_type

body instance-attribute Â¶

body = render(content)

background instance-attribute Â¶

background = background

headers property Â¶

headers

render Â¶

render(content)

Source code in starlette/responses.py

Source code in starlette/responses.py

init_headers Â¶

init_headers(headers=None)

Source code in starlette/responses.py

Source code in starlette/responses.py

set_cookie Â¶

set_cookie(
    key,
    value="",
    max_age=None,
    expires=None,
    path="/",
    domain=None,
    secure=False,
    httponly=False,
    samesite="lax",
    partitioned=False,
)

Source code in starlette/responses.py

Source code in starlette/responses.py

delete_cookie Â¶

delete_cookie(
    key,
    path="/",
    domain=None,
    secure=False,
    httponly=False,
    samesite="lax",
)

Source code in starlette/responses.py

Source code in starlette/responses.py

fastapi.responses.HTMLResponse Â¶

HTMLResponse(
    content=None,
    status_code=200,
    headers=None,
    media_type=None,
    background=None,
)

Bases: Response
Source code in starlette/responses.py

Source code in starlette/responses.py

charset class-attribute instance-attribute Â¶

charset = 'utf-8'

status_code instance-attribute Â¶

status_code = status_code

media_type class-attribute instance-attribute Â¶

media_type = 'text/html'

body instance-attribute Â¶

body = render(content)

background instance-attribute Â¶

background = background

headers property Â¶

headers

render Â¶

render(content)

Source code in starlette/responses.py

Source code in starlette/responses.py

init_headers Â¶

init_headers(headers=None)

Source code in starlette/responses.py

Source code in starlette/responses.py

set_cookie Â¶

set_cookie(
    key,
    value="",
    max_age=None,
    expires=None,
    path="/",
    domain=None,
    secure=False,
    httponly=False,
    samesite="lax",
    partitioned=False,
)

Source code in starlette/responses.py

Source code in starlette/responses.py

delete_cookie Â¶

delete_cookie(
    key,
    path="/",
    domain=None,
    secure=False,
    httponly=False,
    samesite="lax",
)

Source code in starlette/responses.py

Source code in starlette/responses.py

fastapi.responses.JSONResponse Â¶

JSONResponse(
    content,
    status_code=200,
    headers=None,
    media_type=None,
    background=None,
)

Bases: Response
Source code in starlette/responses.py

Source code in starlette/responses.py

charset class-attribute instance-attribute Â¶

charset = 'utf-8'

status_code instance-attribute Â¶

status_code = status_code

media_type class-attribute instance-attribute Â¶

media_type = 'application/json'

body instance-attribute Â¶

body = render(content)

background instance-attribute Â¶

background = background

headers property Â¶

headers

render Â¶

render(content)

Source code in starlette/responses.py

Source code in starlette/responses.py

init_headers Â¶

init_headers(headers=None)

Source code in starlette/responses.py

Source code in starlette/responses.py

set_cookie Â¶

set_cookie(
    key,
    value="",
    max_age=None,
    expires=None,
    path="/",
    domain=None,
    secure=False,
    httponly=False,
    samesite="lax",
    partitioned=False,
)

Source code in starlette/responses.py

Source code in starlette/responses.py

delete_cookie Â¶

delete_cookie(
    key,
    path="/",
    domain=None,
    secure=False,
    httponly=False,
    samesite="lax",
)

Source code in starlette/responses.py

Source code in starlette/responses.py

fastapi.responses.PlainTextResponse Â¶

PlainTextResponse(
    content=None,
    status_code=200,
    headers=None,
    media_type=None,
    background=None,
)

Bases: Response
Source code in starlette/responses.py

Source code in starlette/responses.py

charset class-attribute instance-attribute Â¶

charset = 'utf-8'

status_code instance-attribute Â¶

status_code = status_code

media_type class-attribute instance-attribute Â¶

media_type = 'text/plain'

body instance-attribute Â¶

body = render(content)

background instance-attribute Â¶

background = background

headers property Â¶

headers

render Â¶

render(content)

Source code in starlette/responses.py

Source code in starlette/responses.py

init_headers Â¶

init_headers(headers=None)

Source code in starlette/responses.py

Source code in starlette/responses.py

set_cookie Â¶

set_cookie(
    key,
    value="",
    max_age=None,
    expires=None,
    path="/",
    domain=None,
    secure=False,
    httponly=False,
    samesite="lax",
    partitioned=False,
)

Source code in starlette/responses.py

Source code in starlette/responses.py

delete_cookie Â¶

delete_cookie(
    key,
    path="/",
    domain=None,
    secure=False,
    httponly=False,
    samesite="lax",
)

Source code in starlette/responses.py

Source code in starlette/responses.py

fastapi.responses.RedirectResponse Â¶

RedirectResponse(
    url, status_code=307, headers=None, background=None
)

Bases: Response
Source code in starlette/responses.py

Source code in starlette/responses.py

charset class-attribute instance-attribute Â¶

charset = 'utf-8'

status_code instance-attribute Â¶

status_code = status_code

media_type class-attribute instance-attribute Â¶

media_type = None

body instance-attribute Â¶

body = render(content)

background instance-attribute Â¶

background = background

headers property Â¶

headers

render Â¶

render(content)

Source code in starlette/responses.py

Source code in starlette/responses.py

init_headers Â¶

init_headers(headers=None)

Source code in starlette/responses.py

Source code in starlette/responses.py

set_cookie Â¶

set_cookie(
    key,
    value="",
    max_age=None,
    expires=None,
    path="/",
    domain=None,
    secure=False,
    httponly=False,
    samesite="lax",
    partitioned=False,
)

Source code in starlette/responses.py

Source code in starlette/responses.py

delete_cookie Â¶

delete_cookie(
    key,
    path="/",
    domain=None,
    secure=False,
    httponly=False,
    samesite="lax",
)

Source code in starlette/responses.py

Source code in starlette/responses.py

fastapi.responses.Response Â¶

Response(
    content=None,
    status_code=200,
    headers=None,
    media_type=None,
    background=None,
)

Source code in starlette/responses.py

Source code in starlette/responses.py

charset class-attribute instance-attribute Â¶

charset = 'utf-8'

status_code instance-attribute Â¶

status_code = status_code

media_type class-attribute instance-attribute Â¶

media_type = None

body instance-attribute Â¶

body = render(content)

background instance-attribute Â¶

background = background

headers property Â¶

headers

render Â¶

render(content)

Source code in starlette/responses.py

Source code in starlette/responses.py

init_headers Â¶

init_headers(headers=None)

Source code in starlette/responses.py

Source code in starlette/responses.py

set_cookie Â¶

set_cookie(
    key,
    value="",
    max_age=None,
    expires=None,
    path="/",
    domain=None,
    secure=False,
    httponly=False,
    samesite="lax",
    partitioned=False,
)

Source code in starlette/responses.py

Source code in starlette/responses.py

delete_cookie Â¶

delete_cookie(
    key,
    path="/",
    domain=None,
    secure=False,
    httponly=False,
    samesite="lax",
)

Source code in starlette/responses.py

Source code in starlette/responses.py

fastapi.responses.StreamingResponse Â¶

StreamingResponse(
    content,
    status_code=200,
    headers=None,
    media_type=None,
    background=None,
)

Bases: Response
Source code in starlette/responses.py

Source code in starlette/responses.py

body_iterator instance-attribute Â¶

body_iterator

charset class-attribute instance-attribute Â¶

charset = 'utf-8'

status_code instance-attribute Â¶

status_code = status_code

media_type instance-attribute Â¶

media_type = (
    media_type if media_type is None else media_type
)

body instance-attribute Â¶

body = render(content)

background instance-attribute Â¶

background = background

headers property Â¶

headers

render Â¶

render(content)

Source code in starlette/responses.py

Source code in starlette/responses.py

init_headers Â¶

init_headers(headers=None)

Source code in starlette/responses.py

Source code in starlette/responses.py

set_cookie Â¶

set_cookie(
    key,
    value="",
    max_age=None,
    expires=None,
    path="/",
    domain=None,
    secure=False,
    httponly=False,
    samesite="lax",
    partitioned=False,
)

Source code in starlette/responses.py

Source code in starlette/responses.py

delete_cookie Â¶

delete_cookie(
    key,
    path="/",
    domain=None,
    secure=False,
    httponly=False,
    samesite="lax",
)

Source code in starlette/responses.py

Source code in starlette/responses.py

Previous
Response class
Next
Middleware
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs




Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Middleware

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

     CORSMiddleware
         app
         allow_origins
         allow_methods
         allow_headers
         allow_all_origins
         allow_all_headers
         preflight_explicit_allow_origin
         allow_origin_regex
         simple_headers
         preflight_headers
         is_allowed_origin
         preflight_response
         simple_response
         send
         allow_explicit_origin
     GZipMiddleware
         app
         minimum_size
         compresslevel
     HTTPSRedirectMiddleware
         app
     TrustedHostMiddleware
         app
         allowed_hosts
         allow_any
         www_redirect
     WSGIMiddleware
         app

    FastAPI
    Reference

MiddlewareÂ¶

There are several middlewares available provided by Starlette directly.

Read more about them in the FastAPI docs for Middleware.
fastapi.middleware.cors.CORSMiddleware Â¶

CORSMiddleware(
    app,
    allow_origins=(),
    allow_methods=("GET",),
    allow_headers=(),
    allow_credentials=False,
    allow_origin_regex=None,
    expose_headers=(),
    max_age=600,
)

Source code in starlette/middleware/cors.py

def __init__(
    self,
    app: ASGIApp,
    allow_origins: Sequence[str] = (),
    allow_methods: Sequence[str] = ("GET",),
    allow_headers: Sequence[str] = (),
    allow_credentials: bool = False,
    allow_origin_regex: str | None = None,
    expose_headers: Sequence[str] = (),
    max_age: int = 600,
) -> None:
    if "*" in allow_methods:
        allow_methods = ALL_METHODS

    compiled_allow_origin_regex = None
    if allow_origin_regex is not None:
        compiled_allow_origin_regex = re.compile(allow_origin_regex)

    allow_all_origins = "*" in allow_origins
    allow_all_headers = "*" in allow_headers
    preflight_explicit_allow_origin = not allow_all_origins or allow_credentials

    simple_headers = {}
    if allow_all_origins:
        simple_headers["Access-Control-Allow-Origin"] = "*"
    if allow_credentials:
        simple_headers["Access-Control-Allow-Credentials"] = "true"
    if expose_headers:
        simple_headers["Access-Control-Expose-Headers"] = ", ".join(expose_headers)

    preflight_headers = {}
    if preflight_explicit_allow_origin:
        # The origin value will be set in preflight_response() if it is allowed.
        preflight_headers["Vary"] = "Origin"
    else:
        preflight_headers["Access-Control-Allow-Origin"] = "*"
    preflight_headers.update(
        {
            "Access-Control-Allow-Methods": ", ".join(allow_methods),
            "Access-Control-Max-Age": str(max_age),
        }
    )
    allow_headers = sorted(SAFELISTED_HEADERS | set(allow_headers))
    if allow_headers and not allow_all_headers:
        preflight_headers["Access-Control-Allow-Headers"] = ", ".join(allow_headers)
    if allow_credentials:
        preflight_headers["Access-Control-Allow-Credentials"] = "true"

    self.app = app
    self.allow_origins = allow_origins
    self.allow_methods = allow_methods
    self.allow_headers = [h.lower() for h in allow_headers]
    self.allow_all_origins = allow_all_origins
    self.allow_all_headers = allow_all_headers
    self.preflight_explicit_allow_origin = preflight_explicit_allow_origin
    self.allow_origin_regex = compiled_allow_origin_regex
    self.simple_headers = simple_headers
    self.preflight_headers = preflight_headers

Source code in starlette/middleware/cors.py

def __init__(
    self,
    app: ASGIApp,
    allow_origins: Sequence[str] = (),
    allow_methods: Sequence[str] = ("GET",),
    allow_headers: Sequence[str] = (),
    allow_credentials: bool = False,
    allow_origin_regex: str | None = None,
    expose_headers: Sequence[str] = (),
    max_age: int = 600,
) -> None:
    if "*" in allow_methods:
        allow_methods = ALL_METHODS

    compiled_allow_origin_regex = None
    if allow_origin_regex is not None:
        compiled_allow_origin_regex = re.compile(allow_origin_regex)

    allow_all_origins = "*" in allow_origins
    allow_all_headers = "*" in allow_headers
    preflight_explicit_allow_origin = not allow_all_origins or allow_credentials

    simple_headers = {}
    if allow_all_origins:
        simple_headers["Access-Control-Allow-Origin"] = "*"
    if allow_credentials:
        simple_headers["Access-Control-Allow-Credentials"] = "true"
    if expose_headers:
        simple_headers["Access-Control-Expose-Headers"] = ", ".join(expose_headers)

    preflight_headers = {}
    if preflight_explicit_allow_origin:
        # The origin value will be set in preflight_response() if it is allowed.
        preflight_headers["Vary"] = "Origin"
    else:
        preflight_headers["Access-Control-Allow-Origin"] = "*"
    preflight_headers.update(
        {
            "Access-Control-Allow-Methods": ", ".join(allow_methods),
            "Access-Control-Max-Age": str(max_age),
        }
    )
    allow_headers = sorted(SAFELISTED_HEADERS | set(allow_headers))
    if allow_headers and not allow_all_headers:
        preflight_headers["Access-Control-Allow-Headers"] = ", ".join(allow_headers)
    if allow_credentials:
        preflight_headers["Access-Control-Allow-Credentials"] = "true"

    self.app = app
    self.allow_origins = allow_origins
    self.allow_methods = allow_methods
    self.allow_headers = [h.lower() for h in allow_headers]
    self.allow_all_origins = allow_all_origins
    self.allow_all_headers = allow_all_headers
    self.preflight_explicit_allow_origin = preflight_explicit_allow_origin
    self.allow_origin_regex = compiled_allow_origin_regex
    self.simple_headers = simple_headers
    self.preflight_headers = preflight_headers

app instance-attribute Â¶

app = app

allow_origins instance-attribute Â¶

allow_origins = allow_origins

allow_methods instance-attribute Â¶

allow_methods = allow_methods

allow_headers instance-attribute Â¶

allow_headers = [(lower()) for h in allow_headers]

allow_all_origins instance-attribute Â¶

allow_all_origins = allow_all_origins

allow_all_headers instance-attribute Â¶

allow_all_headers = allow_all_headers

preflight_explicit_allow_origin instance-attribute Â¶

preflight_explicit_allow_origin = (
    preflight_explicit_allow_origin
)

allow_origin_regex instance-attribute Â¶

allow_origin_regex = compiled_allow_origin_regex

simple_headers instance-attribute Â¶

simple_headers = simple_headers

preflight_headers instance-attribute Â¶

preflight_headers = preflight_headers

is_allowed_origin Â¶

is_allowed_origin(origin)

Source code in starlette/middleware/cors.py

Source code in starlette/middleware/cors.py

preflight_response Â¶

preflight_response(request_headers)

Source code in starlette/middleware/cors.py

Source code in starlette/middleware/cors.py

simple_response async Â¶

simple_response(scope, receive, send, request_headers)

Source code in starlette/middleware/cors.py

Source code in starlette/middleware/cors.py

send async Â¶

send(message, send, request_headers)

Source code in starlette/middleware/cors.py

Source code in starlette/middleware/cors.py

allow_explicit_origin staticmethod Â¶

allow_explicit_origin(headers, origin)

Source code in starlette/middleware/cors.py

Source code in starlette/middleware/cors.py

It can be imported from fastapi:

from fastapi.middleware.cors import CORSMiddleware

fastapi.middleware.gzip.GZipMiddleware Â¶

GZipMiddleware(app, minimum_size=500, compresslevel=9)

Source code in starlette/middleware/gzip.py

Source code in starlette/middleware/gzip.py

app instance-attribute Â¶

app = app

minimum_size instance-attribute Â¶

minimum_size = minimum_size

compresslevel instance-attribute Â¶

compresslevel = compresslevel

It can be imported from fastapi:

from fastapi.middleware.gzip import GZipMiddleware

fastapi.middleware.httpsredirect.HTTPSRedirectMiddleware Â¶

HTTPSRedirectMiddleware(app)

Source code in starlette/middleware/httpsredirect.py

Source code in starlette/middleware/httpsredirect.py

app instance-attribute Â¶

app = app

It can be imported from fastapi:

from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware

fastapi.middleware.trustedhost.TrustedHostMiddleware Â¶

TrustedHostMiddleware(
    app, allowed_hosts=None, www_redirect=True
)

Source code in starlette/middleware/trustedhost.py

Source code in starlette/middleware/trustedhost.py

app instance-attribute Â¶

app = app

allowed_hosts instance-attribute Â¶

allowed_hosts = list(allowed_hosts)

allow_any instance-attribute Â¶

allow_any = '*' in allowed_hosts

www_redirect instance-attribute Â¶

www_redirect = www_redirect

It can be imported from fastapi:

from fastapi.middleware.trustedhost import TrustedHostMiddleware

fastapi.middleware.wsgi.WSGIMiddleware Â¶

WSGIMiddleware(app)

Source code in starlette/middleware/wsgi.py

Source code in starlette/middleware/wsgi.py

app instance-attribute Â¶

app = app

It can be imported from fastapi:

from fastapi.middleware.wsgi import WSGIMiddleware

Previous
Custom Response Classes - File, HTML, Redirect, Streaming, etc.
Next
OpenAPI
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs

Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
OpenAPI

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
            OpenAPI docs
            OpenAPI models
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

    FastAPI
    Reference
    OpenAPI

OpenAPIÂ¶

There are several utilities to handle OpenAPI.

You normally don't need to use them unless you have a specific advanced use case that requires it.
Previous
Middleware
Next
OpenAPI docs
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs




Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
OpenAPI docs

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
            OpenAPI docs
            OpenAPI models
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

     get_swagger_ui_html
     get_redoc_html
     get_swagger_ui_oauth2_redirect_html
     swagger_ui_default_parameters

    FastAPI
    Reference
    OpenAPI

OpenAPI docsÂ¶

Utilities to handle OpenAPI automatic UI documentation, including Swagger UI (by default at /docs) and ReDoc (by default at /redoc).
fastapi.openapi.docs.get_swagger_ui_html Â¶

get_swagger_ui_html(
    *,
    openapi_url,
    title,
    swagger_js_url="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js",
    swagger_css_url="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css",
    swagger_favicon_url="https://fastapi.tiangolo.com/img/favicon.png",
    oauth2_redirect_url=None,
    init_oauth=None,
    swagger_ui_parameters=None
)

Generate and return the HTML that loads Swagger UI for the interactive API docs (normally served at /docs).

You would only call this function yourself if you needed to override some parts, for example the URLs to use to load Swagger UI's JavaScript and CSS.

Read more about it in the FastAPI docs for Configure Swagger UI and the FastAPI docs for Custom Docs UI Static Assets (Self-Hosting).
PARAMETER 	DESCRIPTION
openapi_url 	

The OpenAPI URL that Swagger UI should load and use.

This is normally done automatically by FastAPI using the default URL /openapi.json.

TYPE: str
title 	

The HTML <title> content, normally shown in the browser tab.

TYPE: str
swagger_js_url 	

The URL to use to load the Swagger UI JavaScript.

It is normally set to a CDN URL.

TYPE: str DEFAULT: 'https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js'
swagger_css_url 	

The URL to use to load the Swagger UI CSS.

It is normally set to a CDN URL.

TYPE: str DEFAULT: 'https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css'
swagger_favicon_url 	

The URL of the favicon to use. It is normally shown in the browser tab.

TYPE: str DEFAULT: 'https://fastapi.tiangolo.com/img/favicon.png'
oauth2_redirect_url 	

The OAuth2 redirect URL, it is normally automatically handled by FastAPI.

TYPE: Optional[str] DEFAULT: None
init_oauth 	

A dictionary with Swagger UI OAuth2 initialization configurations.

TYPE: Optional[Dict[str, Any]] DEFAULT: None
swagger_ui_parameters 	

Configuration parameters for Swagger UI.

It defaults to swagger_ui_default_parameters.

TYPE: Optional[Dict[str, Any]] DEFAULT: None
Source code in fastapi/openapi/docs.py

Source code in fastapi/openapi/docs.py

fastapi.openapi.docs.get_redoc_html Â¶

get_redoc_html(
    *,
    openapi_url,
    title,
    redoc_js_url="https://cdn.jsdelivr.net/npm/redoc@2/bundles/redoc.standalone.js",
    redoc_favicon_url="https://fastapi.tiangolo.com/img/favicon.png",
    with_google_fonts=True
)

Generate and return the HTML response that loads ReDoc for the alternative API docs (normally served at /redoc).

You would only call this function yourself if you needed to override some parts, for example the URLs to use to load ReDoc's JavaScript and CSS.

Read more about it in the FastAPI docs for Custom Docs UI Static Assets (Self-Hosting).
PARAMETER 	DESCRIPTION
openapi_url 	

The OpenAPI URL that ReDoc should load and use.

This is normally done automatically by FastAPI using the default URL /openapi.json.

TYPE: str
title 	

The HTML <title> content, normally shown in the browser tab.

TYPE: str
redoc_js_url 	

The URL to use to load the ReDoc JavaScript.

It is normally set to a CDN URL.

TYPE: str DEFAULT: 'https://cdn.jsdelivr.net/npm/redoc@2/bundles/redoc.standalone.js'
redoc_favicon_url 	

The URL of the favicon to use. It is normally shown in the browser tab.

TYPE: str DEFAULT: 'https://fastapi.tiangolo.com/img/favicon.png'
with_google_fonts 	

Load and use Google Fonts.

TYPE: bool DEFAULT: True
Source code in fastapi/openapi/docs.py

Source code in fastapi/openapi/docs.py

fastapi.openapi.docs.get_swagger_ui_oauth2_redirect_html Â¶

get_swagger_ui_oauth2_redirect_html()

Generate the HTML response with the OAuth2 redirection for Swagger UI.

You normally don't need to use or change this.
Source code in fastapi/openapi/docs.py

Source code in fastapi/openapi/docs.py

fastapi.openapi.docs.swagger_ui_default_parameters module-attribute Â¶

swagger_ui_default_parameters = {
    "dom_id": "#swagger-ui",
    "layout": "BaseLayout",
    "deepLinking": True,
    "showExtensions": True,
    "showCommonExtensions": True,
}

Default configurations for Swagger UI.

You can use it as a template to add any other configurations needed.
Previous
OpenAPI
Next
OpenAPI models
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
OpenAPI models

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
            OpenAPI docs
            OpenAPI models
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

     models
         SchemaType
         SchemaOrBool
         SecurityScheme
         BaseModelWithConfig
             model_config
             Config
                 extra
         Contact
             name
             url
             email
             model_config
             Config
                 extra
         License
             name
             identifier
             url
             model_config
             Config
                 extra
         Info
             title
             summary
             description
             termsOfService
             contact
             license
             version
             model_config
             Config
                 extra
         ServerVariable
             enum
             default
             description
             model_config
             Config
                 extra
         Server
             url
             description
             variables
             model_config
             Config
                 extra
         Reference
             ref
         Discriminator
             propertyName
             mapping
         XML
             name
             namespace
             prefix
             attribute
             wrapped
             model_config
             Config
                 extra
         ExternalDocumentation
             description
             url
             model_config
             Config
                 extra
         Schema
             schema_
             vocabulary
             id
             anchor
             dynamicAnchor
             ref
             dynamicRef
             defs
             comment
             allOf
             anyOf
             oneOf
             not_
             if_
             then
             else_
             dependentSchemas
             prefixItems
             items
             contains
             properties
             patternProperties
             additionalProperties
             propertyNames
             unevaluatedItems
             unevaluatedProperties
             type
             enum
             const
             multipleOf
             maximum
             exclusiveMaximum
             minimum
             exclusiveMinimum
             maxLength
             minLength
             pattern
             maxItems
             minItems
             uniqueItems
             maxContains
             minContains
             maxProperties
             minProperties
             required
             dependentRequired
             format
             contentEncoding
             contentMediaType
             contentSchema
             title
             description
             default
             deprecated
             readOnly
             writeOnly
             examples
             discriminator
             xml
             externalDocs
             example
             model_config
             Config
                 extra
         Example
             summary
             description
             value
             externalValue
             Config
                 extra
         ParameterInType
             query
             header
             path
             cookie
         Encoding
             contentType
             headers
             style
             explode
             allowReserved
             model_config
             Config
                 extra
         MediaType
             schema_
             example
             examples
             encoding
             model_config
             Config
                 extra
         ParameterBase
             description
             required
             deprecated
             style
             explode
             allowReserved
             schema_
             example
             examples
             content
             model_config
             Config
                 extra
         Parameter
             name
             in_
             model_config
             description
             required
             deprecated
             style
             explode
             allowReserved
             schema_
             example
             examples
             content
             Config
                 extra
         Header
             model_config
             description
             required
             deprecated
             style
             explode
             allowReserved
             schema_
             example
             examples
             content
             Config
                 extra
         RequestBody
             description
             content
             required
             model_config
             Config
                 extra
         Link
             operationRef
             operationId
             parameters
             requestBody
             description
             server
             model_config
             Config
                 extra
         Response
             description
             headers
             content
             links
             model_config
             Config
                 extra
         Operation
             tags
             summary
             description
             externalDocs
             operationId
             parameters
             requestBody
             responses
             callbacks
             deprecated
             security
             servers
             model_config
             Config
                 extra
         PathItem
             ref
             summary
             description
             get
             put
             post
             delete
             options
             head
             patch
             trace
             servers
             parameters
             model_config
             Config
                 extra
         SecuritySchemeType
             apiKey
             http
             oauth2
             openIdConnect
         SecurityBase
             type_
             description
             model_config
             Config
                 extra
         APIKeyIn
             query
             header
             cookie
         APIKey
             type_
             in_
             name
             model_config
             description
             Config
                 extra
         HTTPBase
             type_
             scheme
             model_config
             description
             Config
                 extra
         HTTPBearer
             scheme
             bearerFormat
             model_config
             type_
             description
             Config
                 extra
         OAuthFlow
             refreshUrl
             scopes
             model_config
             Config
                 extra
         OAuthFlowImplicit
             authorizationUrl
             model_config
             refreshUrl
             scopes
             Config
                 extra
         OAuthFlowPassword
             tokenUrl
             model_config
             refreshUrl
             scopes
             Config
                 extra
         OAuthFlowClientCredentials
             tokenUrl
             model_config
             refreshUrl
             scopes
             Config
                 extra
         OAuthFlowAuthorizationCode
             authorizationUrl
             tokenUrl
             model_config
             refreshUrl
             scopes
             Config
                 extra
         OAuthFlows
             implicit
             password
             clientCredentials
             authorizationCode
             model_config
             Config
                 extra
         OAuth2
             type_
             flows
             model_config
             description
             Config
                 extra
         OpenIdConnect
             type_
             openIdConnectUrl
             model_config
             description
             Config
                 extra
         Components
             schemas
             responses
             parameters
             examples
             requestBodies
             headers
             securitySchemes
             links
             callbacks
             pathItems
             model_config
             Config
                 extra
         Tag
             name
             description
             externalDocs
             model_config
             Config
                 extra
         OpenAPI
             openapi
             info
             jsonSchemaDialect
             servers
             paths
             webhooks
             components
             security
             tags
             externalDocs
             model_config
             Config
                 extra

    FastAPI
    Reference
    OpenAPI

OpenAPI modelsÂ¶

OpenAPI Pydantic models used to generate and validate the generated OpenAPI.
fastapi.openapi.models Â¶
SchemaType module-attribute Â¶

SchemaType = Literal[
    "array",
    "boolean",
    "integer",
    "null",
    "number",
    "object",
    "string",
]

SchemaOrBool module-attribute Â¶

SchemaOrBool = Union[Schema, bool]

SecurityScheme module-attribute Â¶

SecurityScheme = Union[
    APIKey, HTTPBase, OAuth2, OpenIdConnect, HTTPBearer
]

BaseModelWithConfig Â¶

Bases: BaseModel
model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

Contact Â¶

Bases: BaseModelWithConfig
name class-attribute instance-attribute Â¶

name = None

url class-attribute instance-attribute Â¶

url = None

email class-attribute instance-attribute Â¶

email = None

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

License Â¶

Bases: BaseModelWithConfig
name instance-attribute Â¶

name

identifier class-attribute instance-attribute Â¶

identifier = None

url class-attribute instance-attribute Â¶

url = None

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

Info Â¶

Bases: BaseModelWithConfig
title instance-attribute Â¶

title

summary class-attribute instance-attribute Â¶

summary = None

description class-attribute instance-attribute Â¶

description = None

termsOfService class-attribute instance-attribute Â¶

termsOfService = None

contact class-attribute instance-attribute Â¶

contact = None

license class-attribute instance-attribute Â¶

license = None

version instance-attribute Â¶

version

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

ServerVariable Â¶

Bases: BaseModelWithConfig
enum class-attribute instance-attribute Â¶

enum = None

default instance-attribute Â¶

default

description class-attribute instance-attribute Â¶

description = None

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

Server Â¶

Bases: BaseModelWithConfig
url instance-attribute Â¶

url

description class-attribute instance-attribute Â¶

description = None

variables class-attribute instance-attribute Â¶

variables = None

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

Reference Â¶

Bases: BaseModel
ref class-attribute instance-attribute Â¶

ref = Field(alias='$ref')

Discriminator Â¶

Bases: BaseModel
propertyName instance-attribute Â¶

propertyName

mapping class-attribute instance-attribute Â¶

mapping = None

XML Â¶

Bases: BaseModelWithConfig
name class-attribute instance-attribute Â¶

name = None

namespace class-attribute instance-attribute Â¶

namespace = None

prefix class-attribute instance-attribute Â¶

prefix = None

attribute class-attribute instance-attribute Â¶

attribute = None

wrapped class-attribute instance-attribute Â¶

wrapped = None

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

ExternalDocumentation Â¶

Bases: BaseModelWithConfig
description class-attribute instance-attribute Â¶

description = None

url instance-attribute Â¶

url

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

Schema Â¶

Bases: BaseModelWithConfig
schema_ class-attribute instance-attribute Â¶

schema_ = Field(default=None, alias='$schema')

vocabulary class-attribute instance-attribute Â¶

vocabulary = Field(default=None, alias='$vocabulary')

id class-attribute instance-attribute Â¶

id = Field(default=None, alias='$id')

anchor class-attribute instance-attribute Â¶

anchor = Field(default=None, alias='$anchor')

dynamicAnchor class-attribute instance-attribute Â¶

dynamicAnchor = Field(default=None, alias='$dynamicAnchor')

ref class-attribute instance-attribute Â¶

ref = Field(default=None, alias='$ref')

dynamicRef class-attribute instance-attribute Â¶

dynamicRef = Field(default=None, alias='$dynamicRef')

defs class-attribute instance-attribute Â¶

defs = Field(default=None, alias='$defs')

comment class-attribute instance-attribute Â¶

comment = Field(default=None, alias='$comment')

allOf class-attribute instance-attribute Â¶

allOf = None

anyOf class-attribute instance-attribute Â¶

anyOf = None

oneOf class-attribute instance-attribute Â¶

oneOf = None

not_ class-attribute instance-attribute Â¶

not_ = Field(default=None, alias='not')

if_ class-attribute instance-attribute Â¶

if_ = Field(default=None, alias='if')

then class-attribute instance-attribute Â¶

then = None

else_ class-attribute instance-attribute Â¶

else_ = Field(default=None, alias='else')

dependentSchemas class-attribute instance-attribute Â¶

dependentSchemas = None

prefixItems class-attribute instance-attribute Â¶

prefixItems = None

items class-attribute instance-attribute Â¶

items = None

contains class-attribute instance-attribute Â¶

contains = None

properties class-attribute instance-attribute Â¶

properties = None

patternProperties class-attribute instance-attribute Â¶

patternProperties = None

additionalProperties class-attribute instance-attribute Â¶

additionalProperties = None

propertyNames class-attribute instance-attribute Â¶

propertyNames = None

unevaluatedItems class-attribute instance-attribute Â¶

unevaluatedItems = None

unevaluatedProperties class-attribute instance-attribute Â¶

unevaluatedProperties = None

type class-attribute instance-attribute Â¶

type = None

enum class-attribute instance-attribute Â¶

enum = None

const class-attribute instance-attribute Â¶

const = None

multipleOf class-attribute instance-attribute Â¶

multipleOf = Field(default=None, gt=0)

maximum class-attribute instance-attribute Â¶

maximum = None

exclusiveMaximum class-attribute instance-attribute Â¶

exclusiveMaximum = None

minimum class-attribute instance-attribute Â¶

minimum = None

exclusiveMinimum class-attribute instance-attribute Â¶

exclusiveMinimum = None

maxLength class-attribute instance-attribute Â¶

maxLength = Field(default=None, ge=0)

minLength class-attribute instance-attribute Â¶

minLength = Field(default=None, ge=0)

pattern class-attribute instance-attribute Â¶

pattern = None

maxItems class-attribute instance-attribute Â¶

maxItems = Field(default=None, ge=0)

minItems class-attribute instance-attribute Â¶

minItems = Field(default=None, ge=0)

uniqueItems class-attribute instance-attribute Â¶

uniqueItems = None

maxContains class-attribute instance-attribute Â¶

maxContains = Field(default=None, ge=0)

minContains class-attribute instance-attribute Â¶

minContains = Field(default=None, ge=0)

maxProperties class-attribute instance-attribute Â¶

maxProperties = Field(default=None, ge=0)

minProperties class-attribute instance-attribute Â¶

minProperties = Field(default=None, ge=0)

required class-attribute instance-attribute Â¶

required = None

dependentRequired class-attribute instance-attribute Â¶

dependentRequired = None

format class-attribute instance-attribute Â¶

format = None

contentEncoding class-attribute instance-attribute Â¶

contentEncoding = None

contentMediaType class-attribute instance-attribute Â¶

contentMediaType = None

contentSchema class-attribute instance-attribute Â¶

contentSchema = None

title class-attribute instance-attribute Â¶

title = None

description class-attribute instance-attribute Â¶

description = None

default class-attribute instance-attribute Â¶

default = None

deprecated class-attribute instance-attribute Â¶

deprecated = None

readOnly class-attribute instance-attribute Â¶

readOnly = None

writeOnly class-attribute instance-attribute Â¶

writeOnly = None

examples class-attribute instance-attribute Â¶

examples = None

discriminator class-attribute instance-attribute Â¶

discriminator = None

xml class-attribute instance-attribute Â¶

xml = None

externalDocs class-attribute instance-attribute Â¶

externalDocs = None

example class-attribute instance-attribute Â¶

example = None

Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead.
model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

Example Â¶

Bases: TypedDict
summary instance-attribute Â¶

summary

description instance-attribute Â¶

description

value instance-attribute Â¶

value

externalValue instance-attribute Â¶

externalValue

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

ParameterInType Â¶

Bases: Enum
query class-attribute instance-attribute Â¶

query = 'query'

header class-attribute instance-attribute Â¶

header = 'header'

path class-attribute instance-attribute Â¶

path = 'path'

cookie class-attribute instance-attribute Â¶

cookie = 'cookie'

Encoding Â¶

Bases: BaseModelWithConfig
contentType class-attribute instance-attribute Â¶

contentType = None

headers class-attribute instance-attribute Â¶

headers = None

style class-attribute instance-attribute Â¶

style = None

explode class-attribute instance-attribute Â¶

explode = None

allowReserved class-attribute instance-attribute Â¶

allowReserved = None

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

MediaType Â¶

Bases: BaseModelWithConfig
schema_ class-attribute instance-attribute Â¶

schema_ = Field(default=None, alias='schema')

example class-attribute instance-attribute Â¶

example = None

examples class-attribute instance-attribute Â¶

examples = None

encoding class-attribute instance-attribute Â¶

encoding = None

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

ParameterBase Â¶

Bases: BaseModelWithConfig
description class-attribute instance-attribute Â¶

description = None

required class-attribute instance-attribute Â¶

required = None

deprecated class-attribute instance-attribute Â¶

deprecated = None

style class-attribute instance-attribute Â¶

style = None

explode class-attribute instance-attribute Â¶

explode = None

allowReserved class-attribute instance-attribute Â¶

allowReserved = None

schema_ class-attribute instance-attribute Â¶

schema_ = Field(default=None, alias='schema')

example class-attribute instance-attribute Â¶

example = None

examples class-attribute instance-attribute Â¶

examples = None

content class-attribute instance-attribute Â¶

content = None

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

Parameter Â¶

Bases: ParameterBase
name instance-attribute Â¶

name

in_ class-attribute instance-attribute Â¶

in_ = Field(alias='in')

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

description class-attribute instance-attribute Â¶

description = None

required class-attribute instance-attribute Â¶

required = None

deprecated class-attribute instance-attribute Â¶

deprecated = None

style class-attribute instance-attribute Â¶

style = None

explode class-attribute instance-attribute Â¶

explode = None

allowReserved class-attribute instance-attribute Â¶

allowReserved = None

schema_ class-attribute instance-attribute Â¶

schema_ = Field(default=None, alias='schema')

example class-attribute instance-attribute Â¶

example = None

examples class-attribute instance-attribute Â¶

examples = None

content class-attribute instance-attribute Â¶

content = None

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

Header Â¶

Bases: ParameterBase
model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

description class-attribute instance-attribute Â¶

description = None

required class-attribute instance-attribute Â¶

required = None

deprecated class-attribute instance-attribute Â¶

deprecated = None

style class-attribute instance-attribute Â¶

style = None

explode class-attribute instance-attribute Â¶

explode = None

allowReserved class-attribute instance-attribute Â¶

allowReserved = None

schema_ class-attribute instance-attribute Â¶

schema_ = Field(default=None, alias='schema')

example class-attribute instance-attribute Â¶

example = None

examples class-attribute instance-attribute Â¶

examples = None

content class-attribute instance-attribute Â¶

content = None

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

RequestBody Â¶

Bases: BaseModelWithConfig
description class-attribute instance-attribute Â¶

description = None

content instance-attribute Â¶

content

required class-attribute instance-attribute Â¶

required = None

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

Link Â¶

Bases: BaseModelWithConfig
operationRef class-attribute instance-attribute Â¶

operationRef = None

operationId class-attribute instance-attribute Â¶

operationId = None

parameters class-attribute instance-attribute Â¶

parameters = None

requestBody class-attribute instance-attribute Â¶

requestBody = None

description class-attribute instance-attribute Â¶

description = None

server class-attribute instance-attribute Â¶

server = None

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

Response Â¶

Bases: BaseModelWithConfig
description instance-attribute Â¶

description

headers class-attribute instance-attribute Â¶

headers = None

content class-attribute instance-attribute Â¶

content = None

links class-attribute instance-attribute Â¶

links = None

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

Operation Â¶

Bases: BaseModelWithConfig
tags class-attribute instance-attribute Â¶

tags = None

summary class-attribute instance-attribute Â¶

summary = None

description class-attribute instance-attribute Â¶

description = None

externalDocs class-attribute instance-attribute Â¶

externalDocs = None

operationId class-attribute instance-attribute Â¶

operationId = None

parameters class-attribute instance-attribute Â¶

parameters = None

requestBody class-attribute instance-attribute Â¶

requestBody = None

responses class-attribute instance-attribute Â¶

responses = None

callbacks class-attribute instance-attribute Â¶

callbacks = None

deprecated class-attribute instance-attribute Â¶

deprecated = None

security class-attribute instance-attribute Â¶

security = None

servers class-attribute instance-attribute Â¶

servers = None

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

PathItem Â¶

Bases: BaseModelWithConfig
ref class-attribute instance-attribute Â¶

ref = Field(default=None, alias='$ref')

summary class-attribute instance-attribute Â¶

summary = None

description class-attribute instance-attribute Â¶

description = None

get class-attribute instance-attribute Â¶

get = None

put class-attribute instance-attribute Â¶

put = None

post class-attribute instance-attribute Â¶

post = None

delete class-attribute instance-attribute Â¶

delete = None

options class-attribute instance-attribute Â¶

options = None

head class-attribute instance-attribute Â¶

head = None

patch class-attribute instance-attribute Â¶

patch = None

trace class-attribute instance-attribute Â¶

trace = None

servers class-attribute instance-attribute Â¶

servers = None

parameters class-attribute instance-attribute Â¶

parameters = None

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

SecuritySchemeType Â¶

Bases: Enum
apiKey class-attribute instance-attribute Â¶

apiKey = 'apiKey'

http class-attribute instance-attribute Â¶

http = 'http'

oauth2 class-attribute instance-attribute Â¶

oauth2 = 'oauth2'

openIdConnect class-attribute instance-attribute Â¶

openIdConnect = 'openIdConnect'

SecurityBase Â¶

Bases: BaseModelWithConfig
type_ class-attribute instance-attribute Â¶

type_ = Field(alias='type')

description class-attribute instance-attribute Â¶

description = None

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

APIKeyIn Â¶

Bases: Enum
query class-attribute instance-attribute Â¶

query = 'query'

header class-attribute instance-attribute Â¶

header = 'header'

cookie class-attribute instance-attribute Â¶

cookie = 'cookie'

APIKey Â¶

Bases: SecurityBase
type_ class-attribute instance-attribute Â¶

type_ = Field(default=apiKey, alias='type')

in_ class-attribute instance-attribute Â¶

in_ = Field(alias='in')

name instance-attribute Â¶

name

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

description class-attribute instance-attribute Â¶

description = None

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

HTTPBase Â¶

Bases: SecurityBase
type_ class-attribute instance-attribute Â¶

type_ = Field(default=http, alias='type')

scheme instance-attribute Â¶

scheme

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

description class-attribute instance-attribute Â¶

description = None

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

HTTPBearer Â¶

Bases: HTTPBase
scheme class-attribute instance-attribute Â¶

scheme = 'bearer'

bearerFormat class-attribute instance-attribute Â¶

bearerFormat = None

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

type_ class-attribute instance-attribute Â¶

type_ = Field(default=http, alias='type')

description class-attribute instance-attribute Â¶

description = None

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

OAuthFlow Â¶

Bases: BaseModelWithConfig
refreshUrl class-attribute instance-attribute Â¶

refreshUrl = None

scopes class-attribute instance-attribute Â¶

scopes = {}

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

OAuthFlowImplicit Â¶

Bases: OAuthFlow
authorizationUrl instance-attribute Â¶

authorizationUrl

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

refreshUrl class-attribute instance-attribute Â¶

refreshUrl = None

scopes class-attribute instance-attribute Â¶

scopes = {}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

OAuthFlowPassword Â¶

Bases: OAuthFlow
tokenUrl instance-attribute Â¶

tokenUrl

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

refreshUrl class-attribute instance-attribute Â¶

refreshUrl = None

scopes class-attribute instance-attribute Â¶

scopes = {}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

OAuthFlowClientCredentials Â¶

Bases: OAuthFlow
tokenUrl instance-attribute Â¶

tokenUrl

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

refreshUrl class-attribute instance-attribute Â¶

refreshUrl = None

scopes class-attribute instance-attribute Â¶

scopes = {}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

OAuthFlowAuthorizationCode Â¶

Bases: OAuthFlow
authorizationUrl instance-attribute Â¶

authorizationUrl

tokenUrl instance-attribute Â¶

tokenUrl

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

refreshUrl class-attribute instance-attribute Â¶

refreshUrl = None

scopes class-attribute instance-attribute Â¶

scopes = {}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

OAuthFlows Â¶

Bases: BaseModelWithConfig
implicit class-attribute instance-attribute Â¶

implicit = None

password class-attribute instance-attribute Â¶

password = None

clientCredentials class-attribute instance-attribute Â¶

clientCredentials = None

authorizationCode class-attribute instance-attribute Â¶

authorizationCode = None

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

OAuth2 Â¶

Bases: SecurityBase
type_ class-attribute instance-attribute Â¶

type_ = Field(default=oauth2, alias='type')

flows instance-attribute Â¶

flows

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

description class-attribute instance-attribute Â¶

description = None

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

OpenIdConnect Â¶

Bases: SecurityBase
type_ class-attribute instance-attribute Â¶

type_ = Field(default=openIdConnect, alias='type')

openIdConnectUrl instance-attribute Â¶

openIdConnectUrl

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

description class-attribute instance-attribute Â¶

description = None

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

Components Â¶

Bases: BaseModelWithConfig
schemas class-attribute instance-attribute Â¶

schemas = None

responses class-attribute instance-attribute Â¶

responses = None

parameters class-attribute instance-attribute Â¶

parameters = None

examples class-attribute instance-attribute Â¶

examples = None

requestBodies class-attribute instance-attribute Â¶

requestBodies = None

headers class-attribute instance-attribute Â¶

headers = None

securitySchemes class-attribute instance-attribute Â¶

securitySchemes = None

links class-attribute instance-attribute Â¶

links = None

callbacks class-attribute instance-attribute Â¶

callbacks = None

pathItems class-attribute instance-attribute Â¶

pathItems = None

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

Tag Â¶

Bases: BaseModelWithConfig
name instance-attribute Â¶

name

description class-attribute instance-attribute Â¶

description = None

externalDocs class-attribute instance-attribute Â¶

externalDocs = None

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

OpenAPI Â¶

Bases: BaseModelWithConfig
openapi instance-attribute Â¶

openapi

info instance-attribute Â¶

info

jsonSchemaDialect class-attribute instance-attribute Â¶

jsonSchemaDialect = None

servers class-attribute instance-attribute Â¶

servers = None

paths class-attribute instance-attribute Â¶

paths = None

webhooks class-attribute instance-attribute Â¶

webhooks = None

components class-attribute instance-attribute Â¶

components = None

security class-attribute instance-attribute Â¶

security = None

tags class-attribute instance-attribute Â¶

tags = None

externalDocs class-attribute instance-attribute Â¶

externalDocs = None

model_config class-attribute instance-attribute Â¶

model_config = {'extra': 'allow'}

Config Â¶
extra class-attribute instance-attribute Â¶

extra = 'allow'

Previous
OpenAPI docs
Next
Security Tools
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Security Tools

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

    API Key Security Schemes
     APIKeyCookie
        Usage
        Example
         model
         scheme_name
         auto_error
         check_api_key
     APIKeyHeader
        Usage
        Example
         model
         scheme_name
         auto_error
         check_api_key
     APIKeyQuery
        Usage
        Example
         model
         scheme_name
         auto_error
         check_api_key
    HTTP Authentication Schemes
     HTTPBasic
        Usage
        Example
         model
         scheme_name
         realm
         auto_error
     HTTPBearer
        Usage
        Example
         model
         scheme_name
         auto_error
     HTTPDigest
        Usage
        Example
         model
         scheme_name
         auto_error
    HTTP Credentials
     HTTPAuthorizationCredentials
         scheme
         credentials
     HTTPBasicCredentials
         username
         password
    OAuth2 Authentication
     OAuth2
         model
         scheme_name
         auto_error
     OAuth2AuthorizationCodeBearer
         model
         scheme_name
         auto_error
     OAuth2PasswordBearer
         model
         scheme_name
         auto_error
    OAuth2 Password Form
     OAuth2PasswordRequestForm
        Example
         grant_type
         username
         password
         scopes
         client_id
         client_secret
     OAuth2PasswordRequestFormStrict
        Example
         grant_type
         username
         password
         scopes
         client_id
         client_secret
    OAuth2 Security Scopes in Dependencies
     SecurityScopes
         scopes
         scope_str
    OpenID Connect
     OpenIdConnect
         model
         scheme_name
         auto_error

    FastAPI
    Reference

Security ToolsÂ¶

When you need to declare dependencies with OAuth2 scopes you use Security().

But you still need to define what is the dependable, the callable that you pass as a parameter to Depends() or Security().

There are multiple tools that you can use to create those dependables, and they get integrated into OpenAPI so they are shown in the automatic docs UI, they can be used by automatically generated clients and SDKs, etc.

You can import them from fastapi.security:

from fastapi.security import (
    APIKeyCookie,
    APIKeyHeader,
    APIKeyQuery,
    HTTPAuthorizationCredentials,
    HTTPBasic,
    HTTPBasicCredentials,
    HTTPBearer,
    HTTPDigest,
    OAuth2,
    OAuth2AuthorizationCodeBearer,
    OAuth2PasswordBearer,
    OAuth2PasswordRequestForm,
    OAuth2PasswordRequestFormStrict,
    OpenIdConnect,
    SecurityScopes,
)

API Key Security SchemesÂ¶
fastapi.security.APIKeyCookie Â¶

APIKeyCookie(
    *,
    name,
    scheme_name=None,
    description=None,
    auto_error=True
)

Bases: APIKeyBase

API key authentication using a cookie.

This defines the name of the cookie that should be provided in the request with the API key and integrates that into the OpenAPI documentation. It extracts the key value sent in the cookie automatically and provides it as the dependency result. But it doesn't define how to set that cookie.
UsageÂ¶

Create an instance object and use that object as the dependency in Depends().

The dependency result will be a string containing the key value.
ExampleÂ¶

from fastapi import Depends, FastAPI
from fastapi.security import APIKeyCookie

app = FastAPI()

cookie_scheme = APIKeyCookie(name="session")


@app.get("/items/")
async def read_items(session: str = Depends(cookie_scheme)):
    return {"session": session}

PARAMETER 	DESCRIPTION
name 	

Cookie name.

TYPE: str
scheme_name 	

Security scheme name.

It will be included in the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[str] DEFAULT: None
description 	

Security scheme description.

It will be included in the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[str] DEFAULT: None
auto_error 	

By default, if the cookie is not provided, APIKeyCookie will automatically cancel the request and send the client an error.

If auto_error is set to False, when the cookie is not available, instead of erroring out, the dependency result will be None.

This is useful when you want to have optional authentication.

It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in a cookie or in an HTTP Bearer token).

TYPE: bool DEFAULT: True
Source code in fastapi/security/api_key.py

Source code in fastapi/security/api_key.py

model instance-attribute Â¶

model = APIKey(
    **{"in": cookie}, name=name, description=description
)

scheme_name instance-attribute Â¶

scheme_name = scheme_name or __name__

auto_error instance-attribute Â¶

auto_error = auto_error

check_api_key staticmethod Â¶

check_api_key(api_key, auto_error)

Source code in fastapi/security/api_key.py

Source code in fastapi/security/api_key.py

fastapi.security.APIKeyHeader Â¶

APIKeyHeader(
    *,
    name,
    scheme_name=None,
    description=None,
    auto_error=True
)

Bases: APIKeyBase

API key authentication using a header.

This defines the name of the header that should be provided in the request with the API key and integrates that into the OpenAPI documentation. It extracts the key value sent in the header automatically and provides it as the dependency result. But it doesn't define how to send that key to the client.
UsageÂ¶

Create an instance object and use that object as the dependency in Depends().

The dependency result will be a string containing the key value.
ExampleÂ¶

from fastapi import Depends, FastAPI
from fastapi.security import APIKeyHeader

app = FastAPI()

header_scheme = APIKeyHeader(name="x-key")


@app.get("/items/")
async def read_items(key: str = Depends(header_scheme)):
    return {"key": key}

PARAMETER 	DESCRIPTION
name 	

Header name.

TYPE: str
scheme_name 	

Security scheme name.

It will be included in the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[str] DEFAULT: None
description 	

Security scheme description.

It will be included in the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[str] DEFAULT: None
auto_error 	

By default, if the header is not provided, APIKeyHeader will automatically cancel the request and send the client an error.

If auto_error is set to False, when the header is not available, instead of erroring out, the dependency result will be None.

This is useful when you want to have optional authentication.

It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in a header or in an HTTP Bearer token).

TYPE: bool DEFAULT: True
Source code in fastapi/security/api_key.py

Source code in fastapi/security/api_key.py

model instance-attribute Â¶

model = APIKey(
    **{"in": header}, name=name, description=description
)

scheme_name instance-attribute Â¶

scheme_name = scheme_name or __name__

auto_error instance-attribute Â¶

auto_error = auto_error

check_api_key staticmethod Â¶

check_api_key(api_key, auto_error)

Source code in fastapi/security/api_key.py

Source code in fastapi/security/api_key.py

fastapi.security.APIKeyQuery Â¶

APIKeyQuery(
    *,
    name,
    scheme_name=None,
    description=None,
    auto_error=True
)

Bases: APIKeyBase

API key authentication using a query parameter.

This defines the name of the query parameter that should be provided in the request with the API key and integrates that into the OpenAPI documentation. It extracts the key value sent in the query parameter automatically and provides it as the dependency result. But it doesn't define how to send that API key to the client.
UsageÂ¶

Create an instance object and use that object as the dependency in Depends().

The dependency result will be a string containing the key value.
ExampleÂ¶

from fastapi import Depends, FastAPI
from fastapi.security import APIKeyQuery

app = FastAPI()

query_scheme = APIKeyQuery(name="api_key")


@app.get("/items/")
async def read_items(api_key: str = Depends(query_scheme)):
    return {"api_key": api_key}

PARAMETER 	DESCRIPTION
name 	

Query parameter name.

TYPE: str
scheme_name 	

Security scheme name.

It will be included in the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[str] DEFAULT: None
description 	

Security scheme description.

It will be included in the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[str] DEFAULT: None
auto_error 	

By default, if the query parameter is not provided, APIKeyQuery will automatically cancel the request and send the client an error.

If auto_error is set to False, when the query parameter is not available, instead of erroring out, the dependency result will be None.

This is useful when you want to have optional authentication.

It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in a query parameter or in an HTTP Bearer token).

TYPE: bool DEFAULT: True
Source code in fastapi/security/api_key.py

Source code in fastapi/security/api_key.py

model instance-attribute Â¶

model = APIKey(
    **{"in": query}, name=name, description=description
)

scheme_name instance-attribute Â¶

scheme_name = scheme_name or __name__

auto_error instance-attribute Â¶

auto_error = auto_error

check_api_key staticmethod Â¶

check_api_key(api_key, auto_error)

Source code in fastapi/security/api_key.py

Source code in fastapi/security/api_key.py

HTTP Authentication SchemesÂ¶
fastapi.security.HTTPBasic Â¶

HTTPBasic(
    *,
    scheme_name=None,
    realm=None,
    description=None,
    auto_error=True
)

Bases: HTTPBase

HTTP Basic authentication.
UsageÂ¶

Create an instance object and use that object as the dependency in Depends().

The dependency result will be an HTTPBasicCredentials object containing the username and the password.

Read more about it in the FastAPI docs for HTTP Basic Auth.
ExampleÂ¶

from typing import Annotated

from fastapi import Depends, FastAPI
from fastapi.security import HTTPBasic, HTTPBasicCredentials

app = FastAPI()

security = HTTPBasic()


@app.get("/users/me")
def read_current_user(credentials: Annotated[HTTPBasicCredentials, Depends(security)]):
    return {"username": credentials.username, "password": credentials.password}

PARAMETER 	DESCRIPTION
scheme_name 	

Security scheme name.

It will be included in the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[str] DEFAULT: None
realm 	

HTTP Basic authentication realm.

TYPE: Optional[str] DEFAULT: None
description 	

Security scheme description.

It will be included in the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[str] DEFAULT: None
auto_error 	

By default, if the HTTP Basic authentication is not provided (a header), HTTPBasic will automatically cancel the request and send the client an error.

If auto_error is set to False, when the HTTP Basic authentication is not available, instead of erroring out, the dependency result will be None.

This is useful when you want to have optional authentication.

It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in HTTP Basic authentication or in an HTTP Bearer token).

TYPE: bool DEFAULT: True
Source code in fastapi/security/http.py

Source code in fastapi/security/http.py

model instance-attribute Â¶

model = HTTPBase(scheme='basic', description=description)

scheme_name instance-attribute Â¶

scheme_name = scheme_name or __name__

realm instance-attribute Â¶

realm = realm

auto_error instance-attribute Â¶

auto_error = auto_error

fastapi.security.HTTPBearer Â¶

HTTPBearer(
    *,
    bearerFormat=None,
    scheme_name=None,
    description=None,
    auto_error=True
)

Bases: HTTPBase

HTTP Bearer token authentication.
UsageÂ¶

Create an instance object and use that object as the dependency in Depends().

The dependency result will be an HTTPAuthorizationCredentials object containing the scheme and the credentials.
ExampleÂ¶

from typing import Annotated

from fastapi import Depends, FastAPI
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer

app = FastAPI()

security = HTTPBearer()


@app.get("/users/me")
def read_current_user(
    credentials: Annotated[HTTPAuthorizationCredentials, Depends(security)]
):
    return {"scheme": credentials.scheme, "credentials": credentials.credentials}

PARAMETER 	DESCRIPTION
bearerFormat 	

Bearer token format.

TYPE: Optional[str] DEFAULT: None
scheme_name 	

Security scheme name.

It will be included in the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[str] DEFAULT: None
description 	

Security scheme description.

It will be included in the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[str] DEFAULT: None
auto_error 	

By default, if the HTTP Bearer token is not provided (in an Authorization header), HTTPBearer will automatically cancel the request and send the client an error.

If auto_error is set to False, when the HTTP Bearer token is not available, instead of erroring out, the dependency result will be None.

This is useful when you want to have optional authentication.

It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in an HTTP Bearer token or in a cookie).

TYPE: bool DEFAULT: True
Source code in fastapi/security/http.py

Source code in fastapi/security/http.py

model instance-attribute Â¶

model = HTTPBearer(
    bearerFormat=bearerFormat, description=description
)

scheme_name instance-attribute Â¶

scheme_name = scheme_name or __name__

auto_error instance-attribute Â¶

auto_error = auto_error

fastapi.security.HTTPDigest Â¶

HTTPDigest(
    *, scheme_name=None, description=None, auto_error=True
)

Bases: HTTPBase

HTTP Digest authentication.
UsageÂ¶

Create an instance object and use that object as the dependency in Depends().

The dependency result will be an HTTPAuthorizationCredentials object containing the scheme and the credentials.
ExampleÂ¶

from typing import Annotated

from fastapi import Depends, FastAPI
from fastapi.security import HTTPAuthorizationCredentials, HTTPDigest

app = FastAPI()

security = HTTPDigest()


@app.get("/users/me")
def read_current_user(
    credentials: Annotated[HTTPAuthorizationCredentials, Depends(security)]
):
    return {"scheme": credentials.scheme, "credentials": credentials.credentials}

PARAMETER 	DESCRIPTION
scheme_name 	

Security scheme name.

It will be included in the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[str] DEFAULT: None
description 	

Security scheme description.

It will be included in the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[str] DEFAULT: None
auto_error 	

By default, if the HTTP Digest is not provided, HTTPDigest will automatically cancel the request and send the client an error.

If auto_error is set to False, when the HTTP Digest is not available, instead of erroring out, the dependency result will be None.

This is useful when you want to have optional authentication.

It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in HTTP Digest or in a cookie).

TYPE: bool DEFAULT: True
Source code in fastapi/security/http.py

Source code in fastapi/security/http.py

model instance-attribute Â¶

model = HTTPBase(scheme='digest', description=description)

scheme_name instance-attribute Â¶

scheme_name = scheme_name or __name__

auto_error instance-attribute Â¶

auto_error = auto_error

HTTP CredentialsÂ¶
fastapi.security.HTTPAuthorizationCredentials Â¶

Bases: BaseModel

The HTTP authorization credentials in the result of using HTTPBearer or HTTPDigest in a dependency.

The HTTP authorization header value is split by the first space.

The first part is the scheme, the second part is the credentials.

For example, in an HTTP Bearer token scheme, the client will send a header like:

Authorization: Bearer deadbeef12346

In this case:

    scheme will have the value "Bearer"
    credentials will have the value "deadbeef12346"

scheme instance-attribute Â¶

scheme

The HTTP authorization scheme extracted from the header value.
credentials instance-attribute Â¶

credentials

The HTTP authorization credentials extracted from the header value.
fastapi.security.HTTPBasicCredentials Â¶

Bases: BaseModel

The HTTP Basic credentials given as the result of using HTTPBasic in a dependency.

Read more about it in the FastAPI docs for HTTP Basic Auth.
username instance-attribute Â¶

username

The HTTP Basic username.
password instance-attribute Â¶

password

The HTTP Basic password.
OAuth2 AuthenticationÂ¶
fastapi.security.OAuth2 Â¶

OAuth2(
    *,
    flows=OAuthFlows(),
    scheme_name=None,
    description=None,
    auto_error=True
)

Bases: SecurityBase

This is the base class for OAuth2 authentication, an instance of it would be used as a dependency. All other OAuth2 classes inherit from it and customize it for each OAuth2 flow.

You normally would not create a new class inheriting from it but use one of the existing subclasses, and maybe compose them if you want to support multiple flows.

Read more about it in the FastAPI docs for Security.
PARAMETER 	DESCRIPTION
flows 	

The dictionary of OAuth2 flows.

TYPE: Union[OAuthFlows, Dict[str, Dict[str, Any]]] DEFAULT: OAuthFlows()
scheme_name 	

Security scheme name.

It will be included in the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[str] DEFAULT: None
description 	

Security scheme description.

It will be included in the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[str] DEFAULT: None
auto_error 	

By default, if no HTTP Authorization header is provided, required for OAuth2 authentication, it will automatically cancel the request and send the client an error.

If auto_error is set to False, when the HTTP Authorization header is not available, instead of erroring out, the dependency result will be None.

This is useful when you want to have optional authentication.

It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, with OAuth2 or in a cookie).

TYPE: bool DEFAULT: True
Source code in fastapi/security/oauth2.py

Source code in fastapi/security/oauth2.py

model instance-attribute Â¶

model = OAuth2(
    flows=cast(OAuthFlows, flows), description=description
)

scheme_name instance-attribute Â¶

scheme_name = scheme_name or __name__

auto_error instance-attribute Â¶

auto_error = auto_error

fastapi.security.OAuth2AuthorizationCodeBearer Â¶

OAuth2AuthorizationCodeBearer(
    authorizationUrl,
    tokenUrl,
    refreshUrl=None,
    scheme_name=None,
    scopes=None,
    description=None,
    auto_error=True,
)

Bases: OAuth2

OAuth2 flow for authentication using a bearer token obtained with an OAuth2 code flow. An instance of it would be used as a dependency.
PARAMETER 	DESCRIPTION
tokenUrl 	

The URL to obtain the OAuth2 token.

TYPE: str
refreshUrl 	

The URL to refresh the token and obtain a new one.

TYPE: Optional[str] DEFAULT: None
scheme_name 	

Security scheme name.

It will be included in the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[str] DEFAULT: None
scopes 	

The OAuth2 scopes that would be required by the path operations that use this dependency.

TYPE: Optional[Dict[str, str]] DEFAULT: None
description 	

Security scheme description.

It will be included in the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[str] DEFAULT: None
auto_error 	

By default, if no HTTP Authorization header is provided, required for OAuth2 authentication, it will automatically cancel the request and send the client an error.

If auto_error is set to False, when the HTTP Authorization header is not available, instead of erroring out, the dependency result will be None.

This is useful when you want to have optional authentication.

It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, with OAuth2 or in a cookie).

TYPE: bool DEFAULT: True
Source code in fastapi/security/oauth2.py

Source code in fastapi/security/oauth2.py

model instance-attribute Â¶

model = OAuth2(
    flows=cast(OAuthFlows, flows), description=description
)

scheme_name instance-attribute Â¶

scheme_name = scheme_name or __name__

auto_error instance-attribute Â¶

auto_error = auto_error

fastapi.security.OAuth2PasswordBearer Â¶

OAuth2PasswordBearer(
    tokenUrl,
    scheme_name=None,
    scopes=None,
    description=None,
    auto_error=True,
    refreshUrl=None,
)

Bases: OAuth2

OAuth2 flow for authentication using a bearer token obtained with a password. An instance of it would be used as a dependency.

Read more about it in the FastAPI docs for Simple OAuth2 with Password and Bearer.
PARAMETER 	DESCRIPTION
tokenUrl 	

The URL to obtain the OAuth2 token. This would be the path operation that has OAuth2PasswordRequestForm as a dependency.

TYPE: str
scheme_name 	

Security scheme name.

It will be included in the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[str] DEFAULT: None
scopes 	

The OAuth2 scopes that would be required by the path operations that use this dependency.

TYPE: Optional[Dict[str, str]] DEFAULT: None
description 	

Security scheme description.

It will be included in the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[str] DEFAULT: None
auto_error 	

By default, if no HTTP Authorization header is provided, required for OAuth2 authentication, it will automatically cancel the request and send the client an error.

If auto_error is set to False, when the HTTP Authorization header is not available, instead of erroring out, the dependency result will be None.

This is useful when you want to have optional authentication.

It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, with OAuth2 or in a cookie).

TYPE: bool DEFAULT: True
refreshUrl 	

The URL to refresh the token and obtain a new one.

TYPE: Optional[str] DEFAULT: None
Source code in fastapi/security/oauth2.py

Source code in fastapi/security/oauth2.py

model instance-attribute Â¶

model = OAuth2(
    flows=cast(OAuthFlows, flows), description=description
)

scheme_name instance-attribute Â¶

scheme_name = scheme_name or __name__

auto_error instance-attribute Â¶

auto_error = auto_error

OAuth2 Password FormÂ¶
fastapi.security.OAuth2PasswordRequestForm Â¶

OAuth2PasswordRequestForm(
    *,
    grant_type=None,
    username,
    password,
    scope="",
    client_id=None,
    client_secret=None
)

This is a dependency class to collect the username and password as form data for an OAuth2 password flow.

The OAuth2 specification dictates that for a password flow the data should be collected using form data (instead of JSON) and that it should have the specific fields username and password.

All the initialization parameters are extracted from the request.

Read more about it in the FastAPI docs for Simple OAuth2 with Password and Bearer.
ExampleÂ¶

from typing import Annotated

from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordRequestForm

app = FastAPI()


@app.post("/login")
def login(form_data: Annotated[OAuth2PasswordRequestForm, Depends()]):
    data = {}
    data["scopes"] = []
    for scope in form_data.scopes:
        data["scopes"].append(scope)
    if form_data.client_id:
        data["client_id"] = form_data.client_id
    if form_data.client_secret:
        data["client_secret"] = form_data.client_secret
    return data

Note that for OAuth2 the scope items:read is a single scope in an opaque string. You could have custom internal logic to separate it by colon characters (:) or similar, and get the two parts items and read. Many applications do that to group and organize permissions, you could do it as well in your application, just know that that it is application specific, it's not part of the specification.
PARAMETER 	DESCRIPTION
grant_type 	

The OAuth2 spec says it is required and MUST be the fixed string "password". Nevertheless, this dependency class is permissive and allows not passing it. If you want to enforce it, use instead the OAuth2PasswordRequestFormStrict dependency.

TYPE: Union[str, None] DEFAULT: None
username 	

username string. The OAuth2 spec requires the exact field name username.

TYPE: str
password 	

password string. The OAuth2 spec requires the exact field name password.

TYPE: str
scope 	

A single string with actually several scopes separated by spaces. Each scope is also a string.

For example, a single string with:

```python "items:read items:write users:read profile openid" ````

would represent the scopes:

    items:read
    items:write
    users:read
    profile
    openid

TYPE: str DEFAULT: ''
client_id 	

If there's a client_id, it can be sent as part of the form fields. But the OAuth2 specification recommends sending the client_id and client_secret (if any) using HTTP Basic auth.

TYPE: Union[str, None] DEFAULT: None
client_secret 	

If there's a client_password (and a client_id), they can be sent as part of the form fields. But the OAuth2 specification recommends sending the client_id and client_secret (if any) using HTTP Basic auth.

TYPE: Union[str, None] DEFAULT: None
Source code in fastapi/security/oauth2.py

Source code in fastapi/security/oauth2.py

grant_type instance-attribute Â¶

grant_type = grant_type

username instance-attribute Â¶

username = username

password instance-attribute Â¶

password = password

scopes instance-attribute Â¶

scopes = split()

client_id instance-attribute Â¶

client_id = client_id

client_secret instance-attribute Â¶

client_secret = client_secret

fastapi.security.OAuth2PasswordRequestFormStrict Â¶

OAuth2PasswordRequestFormStrict(
    grant_type,
    username,
    password,
    scope="",
    client_id=None,
    client_secret=None,
)

Bases: OAuth2PasswordRequestForm

This is a dependency class to collect the username and password as form data for an OAuth2 password flow.

The OAuth2 specification dictates that for a password flow the data should be collected using form data (instead of JSON) and that it should have the specific fields username and password.

All the initialization parameters are extracted from the request.

The only difference between OAuth2PasswordRequestFormStrict and OAuth2PasswordRequestForm is that OAuth2PasswordRequestFormStrict requires the client to send the form field grant_type with the value "password", which is required in the OAuth2 specification (it seems that for no particular reason), while for OAuth2PasswordRequestForm grant_type is optional.

Read more about it in the FastAPI docs for Simple OAuth2 with Password and Bearer.
ExampleÂ¶

from typing import Annotated

from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordRequestForm

app = FastAPI()


@app.post("/login")
def login(form_data: Annotated[OAuth2PasswordRequestFormStrict, Depends()]):
    data = {}
    data["scopes"] = []
    for scope in form_data.scopes:
        data["scopes"].append(scope)
    if form_data.client_id:
        data["client_id"] = form_data.client_id
    if form_data.client_secret:
        data["client_secret"] = form_data.client_secret
    return data

Note that for OAuth2 the scope items:read is a single scope in an opaque string. You could have custom internal logic to separate it by colon characters (:) or similar, and get the two parts items and read. Many applications do that to group and organize permissions, you could do it as well in your application, just know that that it is application specific, it's not part of the specification.
the OAuth2 spec says it is required and MUST be the fixed string "password".

This dependency is strict about it. If you want to be permissive, use instead the OAuth2PasswordRequestForm dependency class.

username: username string. The OAuth2 spec requires the exact field name "username". password: password string. The OAuth2 spec requires the exact field name "password". scope: Optional string. Several scopes (each one a string) separated by spaces. E.g. "items:read items:write users:read profile openid" client_id: optional string. OAuth2 recommends sending the client_id and client_secret (if any) using HTTP Basic auth, as: client_id:client_secret client_secret: optional string. OAuth2 recommends sending the client_id and client_secret (if any) using HTTP Basic auth, as: client_id:client_secret
PARAMETER 	DESCRIPTION
grant_type 	

The OAuth2 spec says it is required and MUST be the fixed string "password". This dependency is strict about it. If you want to be permissive, use instead the OAuth2PasswordRequestForm dependency class.

TYPE: str
username 	

username string. The OAuth2 spec requires the exact field name username.

TYPE: str
password 	

password string. The OAuth2 spec requires the exact field name password.

TYPE: str
scope 	

A single string with actually several scopes separated by spaces. Each scope is also a string.

For example, a single string with:

```python "items:read items:write users:read profile openid" ````

would represent the scopes:

    items:read
    items:write
    users:read
    profile
    openid

TYPE: str DEFAULT: ''
client_id 	

If there's a client_id, it can be sent as part of the form fields. But the OAuth2 specification recommends sending the client_id and client_secret (if any) using HTTP Basic auth.

TYPE: Union[str, None] DEFAULT: None
client_secret 	

If there's a client_password (and a client_id), they can be sent as part of the form fields. But the OAuth2 specification recommends sending the client_id and client_secret (if any) using HTTP Basic auth.

TYPE: Union[str, None] DEFAULT: None
Source code in fastapi/security/oauth2.py

Source code in fastapi/security/oauth2.py

grant_type instance-attribute Â¶

grant_type = grant_type

username instance-attribute Â¶

username = username

password instance-attribute Â¶

password = password

scopes instance-attribute Â¶

scopes = split()

client_id instance-attribute Â¶

client_id = client_id

client_secret instance-attribute Â¶

client_secret = client_secret

OAuth2 Security Scopes in DependenciesÂ¶
fastapi.security.SecurityScopes Â¶

SecurityScopes(scopes=None)

This is a special class that you can define in a parameter in a dependency to obtain the OAuth2 scopes required by all the dependencies in the same chain.

This way, multiple dependencies can have different scopes, even when used in the same path operation. And with this, you can access all the scopes required in all those dependencies in a single place.

Read more about it in the FastAPI docs for OAuth2 scopes.
PARAMETER 	DESCRIPTION
scopes 	

This will be filled by FastAPI.

TYPE: Optional[List[str]] DEFAULT: None
Source code in fastapi/security/oauth2.py

Source code in fastapi/security/oauth2.py

scopes instance-attribute Â¶

scopes = scopes or []

The list of all the scopes required by dependencies.
scope_str instance-attribute Â¶

scope_str = join(scopes)

All the scopes required by all the dependencies in a single string separated by spaces, as defined in the OAuth2 specification.
OpenID ConnectÂ¶
fastapi.security.OpenIdConnect Â¶

OpenIdConnect(
    *,
    openIdConnectUrl,
    scheme_name=None,
    description=None,
    auto_error=True
)

Bases: SecurityBase

OpenID Connect authentication class. An instance of it would be used as a dependency.
PARAMETER 	DESCRIPTION
openIdConnectUrl 	

The OpenID Connect URL.

TYPE: str
scheme_name 	

Security scheme name.

It will be included in the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[str] DEFAULT: None
description 	

Security scheme description.

It will be included in the generated OpenAPI (e.g. visible at /docs).

TYPE: Optional[str] DEFAULT: None
auto_error 	

By default, if no HTTP Authorization header is provided, required for OpenID Connect authentication, it will automatically cancel the request and send the client an error.

If auto_error is set to False, when the HTTP Authorization header is not available, instead of erroring out, the dependency result will be None.

This is useful when you want to have optional authentication.

It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, with OpenID Connect or in a cookie).

TYPE: bool DEFAULT: True
Source code in fastapi/security/open_id_connect_url.py

Source code in fastapi/security/open_id_connect_url.py

model instance-attribute Â¶

model = OpenIdConnect(
    openIdConnectUrl=openIdConnectUrl,
    description=description,
)

scheme_name instance-attribute Â¶

scheme_name = scheme_name or __name__

auto_error instance-attribute Â¶

auto_error = auto_error

Previous
OpenAPI models
Next
Encoders - jsonable_encoder
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs




Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
Encoders - jsonable_encoder

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

     jsonable_encoder

    FastAPI
    Reference

Encoders - jsonable_encoderÂ¶
fastapi.encoders.jsonable_encoder Â¶

jsonable_encoder(
    obj,
    include=None,
    exclude=None,
    by_alias=True,
    exclude_unset=False,
    exclude_defaults=False,
    exclude_none=False,
    custom_encoder=None,
    sqlalchemy_safe=True,
)

Convert any object to something that can be encoded in JSON.

This is used internally by FastAPI to make sure anything you return can be encoded as JSON before it is sent to the client.

You can also use it yourself, for example to convert objects before saving them in a database that supports only JSON.

Read more about it in the FastAPI docs for JSON Compatible Encoder.
PARAMETER 	DESCRIPTION
obj 	

The input object to convert to JSON.

TYPE: Any
include 	

Pydantic's include parameter, passed to Pydantic models to set the fields to include.

TYPE: Optional[IncEx] DEFAULT: None
exclude 	

Pydantic's exclude parameter, passed to Pydantic models to set the fields to exclude.

TYPE: Optional[IncEx] DEFAULT: None
by_alias 	

Pydantic's by_alias parameter, passed to Pydantic models to define if the output should use the alias names (when provided) or the Python attribute names. In an API, if you set an alias, it's probably because you want to use it in the result, so you probably want to leave this set to True.

TYPE: bool DEFAULT: True
exclude_unset 	

Pydantic's exclude_unset parameter, passed to Pydantic models to define if it should exclude from the output the fields that were not explicitly set (and that only had their default values).

TYPE: bool DEFAULT: False
exclude_defaults 	

Pydantic's exclude_defaults parameter, passed to Pydantic models to define if it should exclude from the output the fields that had the same default value, even when they were explicitly set.

TYPE: bool DEFAULT: False
exclude_none 	

Pydantic's exclude_none parameter, passed to Pydantic models to define if it should exclude from the output any fields that have a None value.

TYPE: bool DEFAULT: False
custom_encoder 	

Pydantic's custom_encoder parameter, passed to Pydantic models to define a custom encoder.

TYPE: Optional[Dict[Any, Callable[[Any], Any]]] DEFAULT: None
sqlalchemy_safe 	

Exclude from the output any fields that start with the name _sa.

This is mainly a hack for compatibility with SQLAlchemy objects, they store internal SQLAlchemy-specific state in attributes named with _sa, and those objects can't (and shouldn't be) serialized to JSON.

TYPE: bool DEFAULT: True
Source code in fastapi/encoders.py

Source code in fastapi/encoders.py

Previous
Security Tools
Next
Static Files - StaticFiles
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Static Files - StaticFiles

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

     StaticFiles
         directory
         packages
         all_directories
         html
         config_checked
         follow_symlink
         get_directories
         get_path
         get_response
         lookup_path
         file_response
         check_config
         is_not_modified

    FastAPI
    Reference

Static Files - StaticFilesÂ¶

You can use the StaticFiles class to serve static files, like JavaScript, CSS, images, etc.

Read more about it in the FastAPI docs for Static Files.

You can import it directly from fastapi.staticfiles:

from fastapi.staticfiles import StaticFiles

fastapi.staticfiles.StaticFiles Â¶

StaticFiles(
    *,
    directory=None,
    packages=None,
    html=False,
    check_dir=True,
    follow_symlink=False
)

Source code in starlette/staticfiles.py

Source code in starlette/staticfiles.py

directory instance-attribute Â¶

directory = directory

packages instance-attribute Â¶

packages = packages

all_directories instance-attribute Â¶

all_directories = get_directories(directory, packages)

html instance-attribute Â¶

html = html

config_checked instance-attribute Â¶

config_checked = False

follow_symlink instance-attribute Â¶

follow_symlink = follow_symlink

get_directories Â¶

get_directories(directory=None, packages=None)

Given directory and packages arguments, return a list of all the directories that should be used for serving static files from.
Source code in starlette/staticfiles.py

Source code in starlette/staticfiles.py

get_path Â¶

get_path(scope)

Given the ASGI scope, return the path string to serve up, with OS specific path separators, and any '..', '.' components removed.
Source code in starlette/staticfiles.py

Source code in starlette/staticfiles.py

get_response async Â¶

get_response(path, scope)

Returns an HTTP response, given the incoming path, method and request headers.
Source code in starlette/staticfiles.py

Source code in starlette/staticfiles.py

lookup_path Â¶

lookup_path(path)

Source code in starlette/staticfiles.py

Source code in starlette/staticfiles.py

file_response Â¶

file_response(
    full_path, stat_result, scope, status_code=200
)

Source code in starlette/staticfiles.py

Source code in starlette/staticfiles.py

check_config async Â¶

check_config()

Perform a one-off configuration check that StaticFiles is actually pointed at a directory, so that we can raise loud errors rather than just returning 404 responses.
Source code in starlette/staticfiles.py

Source code in starlette/staticfiles.py

is_not_modified Â¶

is_not_modified(response_headers, request_headers)

Given the request and response headers, return True if an HTTP "Not Modified" response could be returned instead.
Source code in starlette/staticfiles.py

Source code in starlette/staticfiles.py

Previous
Encoders - jsonable_encoder
Next
Templating - Jinja2Templates
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Templating - Jinja2Templates

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

     Jinja2Templates
         context_processors
         env
         get_template
         TemplateResponse

    FastAPI
    Reference

Templating - Jinja2TemplatesÂ¶

You can use the Jinja2Templates class to render Jinja templates.

Read more about it in the FastAPI docs for Templates.

You can import it directly from fastapi.templating:

from fastapi.templating import Jinja2Templates

fastapi.templating.Jinja2Templates Â¶

Jinja2Templates(
    directory: (
        str | PathLike[str] | Sequence[str | PathLike[str]]
    ),
    *,
    context_processors: (
        list[Callable[[Request], dict[str, Any]]] | None
    ) = None,
    **env_options: Any
)

Jinja2Templates(
    *,
    env: Environment,
    context_processors: (
        list[Callable[[Request], dict[str, Any]]] | None
    ) = None
)

Jinja2Templates(
    directory=None,
    *,
    context_processors=None,
    env=None,
    **env_options
)

templates = Jinja2Templates("templates")

return templates.TemplateResponse("index.html", {"request": request})
Source code in starlette/templating.py

Source code in starlette/templating.py

context_processors instance-attribute Â¶

context_processors = context_processors or []

env instance-attribute Â¶

env = _create_env(directory, **env_options)

get_template Â¶

get_template(name)

Source code in starlette/templating.py

Source code in starlette/templating.py

TemplateResponse Â¶

TemplateResponse(
    request: Request,
    name: str,
    context: dict[str, Any] | None = None,
    status_code: int = 200,
    headers: Mapping[str, str] | None = None,
    media_type: str | None = None,
    background: BackgroundTask | None = None,
) -> _TemplateResponse

TemplateResponse(
    name: str,
    context: dict[str, Any] | None = None,
    status_code: int = 200,
    headers: Mapping[str, str] | None = None,
    media_type: str | None = None,
    background: BackgroundTask | None = None,
) -> _TemplateResponse

TemplateResponse(*args, **kwargs)

Source code in starlette/templating.py

Source code in starlette/templating.py

Previous
Static Files - StaticFiles
Next
Test Client - TestClient
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs




Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Test Client - TestClient

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Reference
        FastAPI class
        Request Parameters
        Status Codes
        UploadFile class
        Exceptions - HTTPException and WebSocketException
        Dependencies - Depends() and Security()
        APIRouter class
        Background Tasks - BackgroundTasks
        Request class
        WebSockets
        HTTPConnection class
        Response class
        Custom Response Classes - File, HTML, Redirect, Streaming, etc.
        Middleware
        OpenAPI
        Security Tools
        Encoders - jsonable_encoder
        Static Files - StaticFiles
        Templating - Jinja2Templates
        Test Client - TestClient

Table of contents

     TestClient
         headers
         follow_redirects
         max_redirects
         is_closed
         trust_env
         timeout
         event_hooks
         auth
         base_url
         cookies
         params
         task
         portal
         async_backend
         app
         app_state
         build_request
         stream
         send
         close
         request
         get
         options
         head
         post
         put
         patch
         delete
         websocket_connect
         lifespan
         wait_startup
         wait_shutdown

    FastAPI
    Reference

Test Client - TestClientÂ¶

You can use the TestClient class to test FastAPI applications without creating an actual HTTP and socket connection, just communicating directly with the FastAPI code.

Read more about it in the FastAPI docs for Testing.

You can import it directly from fastapi.testclient:

from fastapi.testclient import TestClient

fastapi.testclient.TestClient Â¶

TestClient(
    app,
    base_url="http://testserver",
    raise_server_exceptions=True,
    root_path="",
    backend="asyncio",
    backend_options=None,
    cookies=None,
    headers=None,
    follow_redirects=True,
    client=("testclient", 50000),
)

Bases: Client
Source code in starlette/testclient.py

Source code in starlette/testclient.py

headers property writable Â¶

headers

HTTP headers to include when sending requests.
follow_redirects instance-attribute Â¶

follow_redirects = follow_redirects

max_redirects instance-attribute Â¶

max_redirects = max_redirects

is_closed property Â¶

is_closed

Check if the client being closed
trust_env property Â¶

trust_env

timeout property writable Â¶

timeout

event_hooks property writable Â¶

event_hooks

auth property writable Â¶

auth

Authentication class used when none is passed at the request-level.

See also Authentication.
base_url property writable Â¶

base_url

Base URL to use when sending requests with relative URLs.
cookies property writable Â¶

cookies

Cookie values to include when sending requests.
params property writable Â¶

params

Query parameters to include in the URL when sending requests.
task instance-attribute Â¶

task

portal class-attribute instance-attribute Â¶

portal = None

async_backend instance-attribute Â¶

async_backend = _AsyncBackend(
    backend=backend, backend_options=backend_options or {}
)

app instance-attribute Â¶

app = asgi_app

app_state instance-attribute Â¶

app_state = {}

build_request Â¶

build_request(
    method,
    url,
    *,
    content=None,
    data=None,
    files=None,
    json=None,
    params=None,
    headers=None,
    cookies=None,
    timeout=USE_CLIENT_DEFAULT,
    extensions=None
)

Build and return a request instance.

    The params, headers and cookies arguments are merged with any values set on the client.
    The url argument is merged with any base_url set on the client.

See also: Request instances
Source code in httpx/_client.py

Source code in httpx/_client.py

stream Â¶

stream(
    method,
    url,
    *,
    content=None,
    data=None,
    files=None,
    json=None,
    params=None,
    headers=None,
    cookies=None,
    auth=USE_CLIENT_DEFAULT,
    follow_redirects=USE_CLIENT_DEFAULT,
    timeout=USE_CLIENT_DEFAULT,
    extensions=None
)

Alternative to httpx.request() that streams the response body instead of loading it into memory at once.

Parameters: See httpx.request.

See also: Streaming Responses
Source code in httpx/_client.py

Source code in httpx/_client.py

send Â¶

send(
    request,
    *,
    stream=False,
    auth=USE_CLIENT_DEFAULT,
    follow_redirects=USE_CLIENT_DEFAULT
)

Send a request.

The request is sent as-is, unmodified.

Typically you'll want to build one with Client.build_request() so that any client-level configuration is merged into the request, but passing an explicit httpx.Request() is supported as well.

See also: Request instances
Source code in httpx/_client.py

Source code in httpx/_client.py

close Â¶

close()

Close transport and proxies.
Source code in httpx/_client.py

Source code in httpx/_client.py

request Â¶

request(
    method,
    url,
    *,
    content=None,
    data=None,
    files=None,
    json=None,
    params=None,
    headers=None,
    cookies=None,
    auth=USE_CLIENT_DEFAULT,
    follow_redirects=USE_CLIENT_DEFAULT,
    timeout=USE_CLIENT_DEFAULT,
    extensions=None
)

Source code in starlette/testclient.py

Source code in starlette/testclient.py

get Â¶

get(
    url,
    *,
    params=None,
    headers=None,
    cookies=None,
    auth=USE_CLIENT_DEFAULT,
    follow_redirects=USE_CLIENT_DEFAULT,
    timeout=USE_CLIENT_DEFAULT,
    extensions=None
)

Source code in starlette/testclient.py

Source code in starlette/testclient.py

options Â¶

options(
    url,
    *,
    params=None,
    headers=None,
    cookies=None,
    auth=USE_CLIENT_DEFAULT,
    follow_redirects=USE_CLIENT_DEFAULT,
    timeout=USE_CLIENT_DEFAULT,
    extensions=None
)

Source code in starlette/testclient.py

Source code in starlette/testclient.py

head Â¶

head(
    url,
    *,
    params=None,
    headers=None,
    cookies=None,
    auth=USE_CLIENT_DEFAULT,
    follow_redirects=USE_CLIENT_DEFAULT,
    timeout=USE_CLIENT_DEFAULT,
    extensions=None
)

Source code in starlette/testclient.py

Source code in starlette/testclient.py

post Â¶

post(
    url,
    *,
    content=None,
    data=None,
    files=None,
    json=None,
    params=None,
    headers=None,
    cookies=None,
    auth=USE_CLIENT_DEFAULT,
    follow_redirects=USE_CLIENT_DEFAULT,
    timeout=USE_CLIENT_DEFAULT,
    extensions=None
)

Source code in starlette/testclient.py

Source code in starlette/testclient.py

put Â¶

put(
    url,
    *,
    content=None,
    data=None,
    files=None,
    json=None,
    params=None,
    headers=None,
    cookies=None,
    auth=USE_CLIENT_DEFAULT,
    follow_redirects=USE_CLIENT_DEFAULT,
    timeout=USE_CLIENT_DEFAULT,
    extensions=None
)

Source code in starlette/testclient.py

Source code in starlette/testclient.py

patch Â¶

patch(
    url,
    *,
    content=None,
    data=None,
    files=None,
    json=None,
    params=None,
    headers=None,
    cookies=None,
    auth=USE_CLIENT_DEFAULT,
    follow_redirects=USE_CLIENT_DEFAULT,
    timeout=USE_CLIENT_DEFAULT,
    extensions=None
)

Source code in starlette/testclient.py

Source code in starlette/testclient.py

delete Â¶

delete(
    url,
    *,
    params=None,
    headers=None,
    cookies=None,
    auth=USE_CLIENT_DEFAULT,
    follow_redirects=USE_CLIENT_DEFAULT,
    timeout=USE_CLIENT_DEFAULT,
    extensions=None
)

Source code in starlette/testclient.py

Source code in starlette/testclient.py

websocket_connect Â¶

websocket_connect(url, subprotocols=None, **kwargs)

Source code in starlette/testclient.py

Source code in starlette/testclient.py

lifespan async Â¶

lifespan()

Source code in starlette/testclient.py

Source code in starlette/testclient.py

wait_startup async Â¶

wait_startup()

Source code in starlette/testclient.py

Source code in starlette/testclient.py

wait_shutdown async Â¶

wait_shutdown()

Source code in starlette/testclient.py

Source code in starlette/testclient.py

Previous
Templating - Jinja2Templates
Next
FastAPI People
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
FastAPI People

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

Table of contents

    Creator
    Team
    FastAPI Experts
        FastAPI Experts - Last Month
        FastAPI Experts - 3 Months
        FastAPI Experts - 6 Months
        FastAPI Experts - 1 Year
        FastAPI Experts - All Time
    Top Contributors
    Top Translators
    Top Translation Reviewers
    Sponsors
        Gold Sponsors
        Silver Sponsors
        Bronze Sponsors
        Individual Sponsors
    About the data - technical details

FastAPI PeopleÂ¶

FastAPI has an amazing community that welcomes people from all backgrounds.
CreatorÂ¶

Hey! ğŸ‘‹

This is me:
@tiangolo
Answers: 1900
Pull Requests: 794

I'm the creator of FastAPI. You can read more about that in Help FastAPI - Get Help - Connect with the author.

...But here I want to show you the community.

FastAPI receives a lot of support from the community. And I want to highlight their contributions.

These are the people that:

    Help others with questions in GitHub.
    Create Pull Requests.
    Review Pull Requests, especially important for translations.
    Help manage the repository (team members).

All these tasks help maintain the repository.

A round of applause to them. ğŸ‘ ğŸ™‡
TeamÂ¶

This is the current list of team members. ğŸ˜

They have different levels of involvement and permissions, they can perform repository management tasks and together we manage the FastAPI repository.
@tiangolo
@Kludex
@alejsdev
@svlandeg
@YuriiMotov
@patrick91
@luzzodev

Although the team members have the permissions to perform privileged tasks, all the help from others maintaining FastAPI is very much appreciated! ğŸ™‡â€â™‚ï¸
FastAPI ExpertsÂ¶

These are the users that have been helping others the most with questions in GitHub. ğŸ™‡

They have proven to be FastAPI Experts by helping many others. âœ¨

Tip

You could become an official FastAPI Expert too!

Just help others with questions in GitHub. ğŸ¤“

You can see the FastAPI Experts for:

    Last Month ğŸ¤“
    3 Months ğŸ˜
    6 Months ğŸ§
    1 Year ğŸ§‘â€ğŸ”¬
    All Time ğŸ§™

FastAPI Experts - Last MonthÂ¶

These are the users that have been helping others the most with questions in GitHub during the last month. ğŸ¤“
@YuriiMotov
Questions replied: 17
@valentinDruzhinin
Questions replied: 5
@yinziyan1206
Questions replied: 4
@luzzodev
Questions replied: 2
FastAPI Experts - 3 MonthsÂ¶

These are the users that have been helping others the most with questions in GitHub during the last 3 months. ğŸ˜
@YuriiMotov
Questions replied: 397
@valentinDruzhinin
Questions replied: 24
@luzzodev
Questions replied: 17
@raceychan
Questions replied: 6
@yinziyan1206
Questions replied: 5
@DoctorJohn
Questions replied: 5
@sachinh35
Questions replied: 4
@eqsdxr
Questions replied: 4
@Jelle-tenB
Questions replied: 3
FastAPI Experts - 6 MonthsÂ¶

These are the users that have been helping others the most with questions in GitHub during the last 6 months. ğŸ§
@YuriiMotov
Questions replied: 763
@luzzodev
Questions replied: 45
@valentinDruzhinin
Questions replied: 24
@alv2017
Questions replied: 16
@sachinh35
Questions replied: 9
@yauhen-sobaleu
Questions replied: 9
@JavierSanchezCastro
Questions replied: 6
@raceychan
Questions replied: 6
@yinziyan1206
Questions replied: 5
FastAPI Experts - 1 YearÂ¶

These are the users that have been helping others the most with questions in GitHub during the last year. ğŸ§‘â€ğŸ”¬
@YuriiMotov
Questions replied: 824
@luzzodev
Questions replied: 89
@Kludex
Questions replied: 50
@sinisaos
Questions replied: 33
@alv2017
Questions replied: 26
@valentinDruzhinin
Questions replied: 24
@JavierSanchezCastro
Questions replied: 24
@jgould22
Questions replied: 17
@Kfir-G
Questions replied: 13
@sehraramiz
Questions replied: 11
@sachinh35
Questions replied: 9
@yauhen-sobaleu
Questions replied: 9
@estebanx64
Questions replied: 7
@ceb10n
Questions replied: 7
@yvallois
Questions replied: 7
@raceychan
Questions replied: 6
@yinziyan1206
Questions replied: 5
@DoctorJohn
Questions replied: 5
@n8sty
Questions replied: 5
FastAPI Experts - All TimeÂ¶

Here are the all time FastAPI Experts. ğŸ¤“ğŸ¤¯

These are the users that have helped others the most with questions in GitHub through all time. ğŸ§™
@YuriiMotov
Questions replied: 971
@Kludex
Questions replied: 654
@jgould22
Questions replied: 263
@dmontagu
Questions replied: 240
@Mause
Questions replied: 219
@ycd
Questions replied: 216
@JarroVGIT
Questions replied: 190
@euri10
Questions replied: 153
@iudeen
Questions replied: 128
@phy25
Questions replied: 126
@JavierSanchezCastro
Questions replied: 94
@luzzodev
Questions replied: 89
@raphaelauv
Questions replied: 83
@ArcLightSlavik
Questions replied: 71
@ghandic
Questions replied: 71
@n8sty
Questions replied: 67
@falkben
Questions replied: 59
@yinziyan1206
Questions replied: 54
@sm-Fifteen
Questions replied: 49
@acidjunk
Questions replied: 49
@adriangb
Questions replied: 46
@Dustyposa
Questions replied: 45
@insomnes
Questions replied: 45
@frankie567
Questions replied: 43
@odiseo0
Questions replied: 43
@sinisaos
Questions replied: 41
@includeamin
Questions replied: 40
@STeveShary
Questions replied: 37
@chbndrhnns
Questions replied: 37
@krishnardt
Questions replied: 35
@panla
Questions replied: 32
@prostomarkeloff
Questions replied: 28
@hasansezertasan
Questions replied: 27
@alv2017
Questions replied: 26
@dbanty
Questions replied: 26
@wshayes
Questions replied: 25
@valentinDruzhinin
Questions replied: 24
@SirTelemak
Questions replied: 23
@connebs
Questions replied: 22
@nymous
Questions replied: 22
@chrisK824
Questions replied: 22
@rafsaf
Questions replied: 21
@nsidnev
Questions replied: 20
@chris-allnutt
Questions replied: 20
@ebottos94
Questions replied: 20
@estebanx64
Questions replied: 19
@sehraramiz
Questions replied: 18
@retnikt
Questions replied: 18
Top ContributorsÂ¶

Here are the Top Contributors. ğŸ‘·

These users have created the most Pull Requests that have been merged.

They have contributed source code, documentation, etc. ğŸ“¦
@alejsdev
Pull Requests: 52
@Kludex
Pull Requests: 25
@dmontagu
Pull Requests: 17
@YuriiMotov
Pull Requests: 15
@nilslindemann
Pull Requests: 14
@euri10
Pull Requests: 13
@svlandeg
Pull Requests: 13
@kantandane
Pull Requests: 13
@zhaohan-dong
Pull Requests: 11
@mariacamilagl
Pull Requests: 9
@handabaldeep
Pull Requests: 9
@vishnuvskvkl
Pull Requests: 8
@alissadb
Pull Requests: 6
@alv2017
Pull Requests: 6
@wshayes
Pull Requests: 5
@samuelcolvin
Pull Requests: 5
@waynerv
Pull Requests: 5
@krishnamadhavan
Pull Requests: 5
@jekirl
Pull Requests: 4
@hitrust
Pull Requests: 4
@ShahriyarR
Pull Requests: 4
@adriangb
Pull Requests: 4
@iudeen
Pull Requests: 4
@musicinmybrain
Pull Requests: 4
@philipokiokio
Pull Requests: 4
@AlexWendland
Pull Requests: 4
@divums
Pull Requests: 3
@prostomarkeloff
Pull Requests: 3
@frankie567
Pull Requests: 3
@nsidnev
Pull Requests: 3
@pawamoy
Pull Requests: 3
@patrickmckenna
Pull Requests: 3
@hukkin
Pull Requests: 3
@marcosmmb
Pull Requests: 3
@Serrones
Pull Requests: 3
@uriyyo
Pull Requests: 3
@andrew222651
Pull Requests: 3
@rkbeatss
Pull Requests: 3
@asheux
Pull Requests: 3
@blkst8
Pull Requests: 3
@ghandic
Pull Requests: 3
@TeoZosa
Pull Requests: 3
@graingert
Pull Requests: 3
@jaystone776
Pull Requests: 3
@zanieb
Pull Requests: 3
@MicaelJarniac
Pull Requests: 3

There are hundreds of other contributors, you can see them all in the FastAPI GitHub Contributors page. ğŸ‘·
Top TranslatorsÂ¶

These are the Top Translators. ğŸŒ

These users have created the most Pull Requests with translations to other languages that have been merged.
@nilslindemann
Translations: 124
@jaystone776
Translations: 46
@valentinDruzhinin
Translations: 29
@ceb10n
Translations: 27
@tokusumi
Translations: 23
@SwftAlpc
Translations: 23
@hasansezertasan
Translations: 22
@waynerv
Translations: 20
@AlertRED
Translations: 16
@hard-coders
Translations: 15
@Joao-Pedro-P-Holanda
Translations: 14
@codingjenny
Translations: 14
@Xewus
Translations: 13
@Zhongheng-Cheng
Translations: 13
@Smlep
Translations: 11
@marcelomarkus
Translations: 11
@KaniKim
Translations: 10
@Vincy1230
Translations: 9
@rjNemo
Translations: 8
@xzmeng
Translations: 8
@pablocm83
Translations: 8
@ptt3199
Translations: 7
@NinaHwang
Translations: 6
@batlopes
Translations: 6
@lucasbalieiro
Translations: 6
@Alexandrhub
Translations: 6
@Serrones
Translations: 5
@RunningIkkyu
Translations: 5
@Attsun1031
Translations: 5
@rostik1410
Translations: 5
@alv2017
Translations: 5
@komtaki
Translations: 4
@JulianMaurin
Translations: 4
@stlucasgarcia
Translations: 4
@ComicShrimp
Translations: 4
@BilalAlpaslan
Translations: 4
@axel584
Translations: 4
@tamtam-fitness
Translations: 4
@Limsunoh
Translations: 4
@kwang1215
Translations: 4
@k94-ishi
Translations: 4
@Mohammad222PR
Translations: 4
@NavesSapnis
Translations: 4
@jfunez
Translations: 3
@ycd
Translations: 3
@mariacamilagl
Translations: 3
@maoyibo
Translations: 3
@blt232018
Translations: 3
@magiskboy
Translations: 3
Top Translation ReviewersÂ¶

These users are the Top Translation Reviewers. ğŸ•µï¸

I only speak a few languages (and not very well ğŸ˜…). So, the reviewers are the ones that have the power to approve translations of the documentation. Without them, there wouldn't be documentation in several other languages.
@s111d
Reviews: 147
@Xewus
Reviews: 140
@sodaMelon
Reviews: 127
@ceb10n
Reviews: 116
@tokusumi
Reviews: 104
@hasansezertasan
Reviews: 95
@hard-coders
Reviews: 93
@alv2017
Reviews: 88
@nazarepiedady
Reviews: 86
@AlertRED
Reviews: 81
@Alexandrhub
Reviews: 68
@waynerv
Reviews: 63
@cassiobotaro
Reviews: 62
@nilslindemann
Reviews: 59
@mattwang44
Reviews: 59
@Laineyzhang55
Reviews: 48
@Kludex
Reviews: 47
@komtaki
Reviews: 45
@rostik1410
Reviews: 42
@svlandeg
Reviews: 42
@alperiox
Reviews: 42
@Rishat-F
Reviews: 42
@Winand
Reviews: 40
@YuriiMotov
Reviews: 40
@solomein-sv
Reviews: 38
@JavierSanchezCastro
Reviews: 38
@alejsdev
Reviews: 37
@stlucasgarcia
Reviews: 36
@SwftAlpc
Reviews: 36
@timothy-jeong
Reviews: 36
@mezgoodle
Reviews: 35
@rjNemo
Reviews: 34
@codingjenny
Reviews: 34
@akarev0
Reviews: 33
@romashevchenko
Reviews: 32
@LorhanSohaky
Reviews: 30
@Vincy1230
Reviews: 30
@black-redoc
Reviews: 29
@pedabraham
Reviews: 28
@Smlep
Reviews: 28
@dedkot01
Reviews: 28
@hsuanchi
Reviews: 28
@dpinezich
Reviews: 28
@maoyibo
Reviews: 27
@0417taehyun
Reviews: 27
@BilalAlpaslan
Reviews: 26
@junah201
Reviews: 26
@zy7y
Reviews: 25
@mycaule
Reviews: 25
SponsorsÂ¶

These are the Sponsors. ğŸ˜

They are supporting my work with FastAPI (and others), mainly through GitHub Sponsors.
Gold SponsorsÂ¶

Silver SponsorsÂ¶

Bronze SponsorsÂ¶

Individual SponsorsÂ¶
@greptileai
@BoostryJP
@mercedes-benz
@Ponte-Energy-Partners
@acsone
@Trivie
@takashi-yoneya
@mainframeindustries
@alixlahuec
@Partho
@primer-io
@xsalagarcia
@upciti
@GonnaFlyMethod
@ChargeStorm
@DanielYang59
@nilslindemann
@samuelcolvin
@vincentkoc
@otosky
@ramonalmeidam
@roboflow
@dudikbender
@ehaca
@raphaellaude
@timlrx
@Leay15
@Karine-Bauch
@jugeeem
@connorpark24
@patsatsia
@anthonycepeda
@patricioperezv
@chickenandstats
@kaoru0310
@DelfinaCare
@knallgelb
@dblackrun
@zsinx6
@kennywakeland
@aacayaco
@anomaly
@mj0331
@gorhack
@Ryandaydev
@jaredtrog
@oliverxchen
@jstanden
@paulcwatts
@robintw
@pamelafox
@wshayes
@koxudaxi
@falkben
@mintuhouse
@dodo5522
@wdwinslow
@jsoques
@dannywade
@khadrawy
@mjohnsey
@enguy-hub
@ashi-agrawal
@RaamEEIL
@ternaus
@eseglem
@FernandoCelmer
@Rehket
@hiancdtrsnm
@manoelpqueiroz
@ceb10n
@pawamoy
@siavashyj
@mobyw
@ArtyomVancyan
@caviri
@hgalytoby
@johnl28
@hoenie-ams
@joerambo
@engineerjoe440
@bnkc
@petercool
@PunRabbit
@PelicanQ
@my3
@danielunderwood
@rangulvers
@ddanier
@bryanculbertson
@slafs
@tochikuji
@miguelgr
@WillHogan
@hard-coders
@mntolia
@Zuzah
@TheR1D
@joshuatz
@nisutec
@sdevkota
@Baghdady92
@KentShikama
@katnoria
@harsh183
@moonape1226
@xncbf
@DMantis
@morzan1001
@larsyngvelundin
@andrecorumba
@KOZ39
@rwxd
@hippoley
@CoderDeltaLAN
@chris1ding1
@onestn
@Rubinskiy
@nayasinghania
@Toothwitch
@andreagrandi
@Olegt0rr
@msserpa
About the data - technical detailsÂ¶

The main intention of this page is to highlight the effort of the community to help others.

Especially including efforts that are normally less visible, and in many cases more arduous, like helping others with questions and reviewing Pull Requests with translations.

The data is calculated each month, you can read the source code here.

Here I'm also highlighting contributions from sponsors.

I also reserve the right to update the algorithm, sections, thresholds, etc (just in case ğŸ¤·).
Previous
Test Client - TestClient
Next
Resources
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Resources

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Resources
        Help FastAPI - Get Help
        Development - Contributing
        Full Stack FastAPI Template
        External Links and Articles
        FastAPI and friends newsletter
        Repository Management Tasks

    FastAPI
    Resources

ResourcesÂ¶

Additional resources, external links, articles and more. âœˆï¸
Previous
FastAPI People
Next
Help FastAPI - Get Help
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Help FastAPI - Get Help

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Resources
        Help FastAPI - Get Help
        Development - Contributing
        Full Stack FastAPI Template
        External Links and Articles
        FastAPI and friends newsletter
        Repository Management Tasks

Table of contents

    Subscribe to the newsletter
    Follow FastAPI on X (Twitter)
    Star FastAPI in GitHub
    Watch the GitHub repository for releases
    Connect with the author
    Tweet about FastAPI
    Vote for FastAPI
    Help others with questions in GitHub
        Understand the question
        Reproduce the problem
        Suggest solutions
        Ask to close
    Watch the GitHub repository
    Ask Questions
    Review Pull Requests
        Understand the problem
        Don't worry about style
        Check the code
        Tests
    Create a Pull Request
    Help Maintain FastAPI
    Join the chat
        Don't use the chat for questions
    Sponsor the author

    FastAPI
    Resources

Help FastAPI - Get HelpÂ¶

Do you like FastAPI?

Would you like to help FastAPI, other users, and the author?

Or would you like to get help with FastAPI?

There are very simple ways to help (several involve just one or two clicks).

And there are several ways to get help too.
Subscribe to the newsletterÂ¶

You can subscribe to the (infrequent) FastAPI and friends newsletter to stay updated about:

    News about FastAPI and friends ğŸš€
    Guides ğŸ“
    Features âœ¨
    Breaking changes ğŸš¨
    Tips and tricks âœ…

Follow FastAPI on X (Twitter)Â¶

Follow @fastapi on X (Twitter) to get the latest news about FastAPI. ğŸ¦
Star FastAPI in GitHubÂ¶

You can "star" FastAPI in GitHub (clicking the star button at the top right): https://github.com/fastapi/fastapi. â­ï¸

By adding a star, other users will be able to find it more easily and see that it has been already useful for others.
Watch the GitHub repository for releasesÂ¶

You can "watch" FastAPI in GitHub (clicking the "watch" button at the top right): https://github.com/fastapi/fastapi. ğŸ‘€

There you can select "Releases only".

By doing it, you will receive notifications (in your email) whenever there's a new release (a new version) of FastAPI with bug fixes and new features.
Connect with the authorÂ¶

You can connect with me (SebastiÃ¡n RamÃ­rez / tiangolo), the author.

You can:

    Follow me on GitHub.
        See other Open Source projects I have created that could help you.
        Follow me to see when I create a new Open Source project.
    Follow me on X (Twitter) or Mastodon.
        Tell me how you use FastAPI (I love to hear that).
        Hear when I make announcements or release new tools.
        You can also follow @fastapi on X (Twitter) (a separate account).
    Follow me on LinkedIn.
        Hear when I make announcements or release new tools (although I use X (Twitter) more often ğŸ¤·â€â™‚).
    Read what I write (or follow me) on Dev.to or Medium.
        Read other ideas, articles, and read about tools I have created.
        Follow me to read when I publish something new.

Tweet about FastAPIÂ¶

Tweet about FastAPI and let me and others know why you like it. ğŸ‰

I love to hear about how FastAPI is being used, what you have liked in it, in which project/company are you using it, etc.
Vote for FastAPIÂ¶

    Vote for FastAPI in Slant.
    Vote for FastAPI in AlternativeTo.
    Say you use FastAPI on StackShare.

Help others with questions in GitHubÂ¶

You can try and help others with their questions in:

    GitHub Discussions
    GitHub Issues

In many cases you might already know the answer for those questions. ğŸ¤“

If you are helping a lot of people with their questions, you will become an official FastAPI Expert. ğŸ‰

Just remember, the most important point is: try to be kind. People come with their frustrations and in many cases don't ask in the best way, but try as best as you can to be kind. ğŸ¤—

The idea is for the FastAPI community to be kind and welcoming. At the same time, don't accept bullying or disrespectful behavior towards others. We have to take care of each other.

Here's how to help others with questions (in discussions or issues):
Understand the questionÂ¶

    Check if you can understand what is the purpose and use case of the person asking.

    Then check if the question (the vast majority are questions) is clear.

    In many cases the question asked is about an imaginary solution from the user, but there might be a better one. If you can understand the problem and use case better, you might be able to suggest a better alternative solution.

    If you can't understand the question, ask for more details.

Reproduce the problemÂ¶

For most of the cases and most of the questions there's something related to the person's original code.

In many cases they will only copy a fragment of the code, but that's not enough to reproduce the problem.

    You can ask them to provide a minimal, reproducible, example, that you can copy-paste and run locally to see the same error or behavior they are seeing, or to understand their use case better.

    If you are feeling too generous, you can try to create an example like that yourself, just based on the description of the problem. Just keep in mind that this might take a lot of time and it might be better to ask them to clarify the problem first.

Suggest solutionsÂ¶

    After being able to understand the question, you can give them a possible answer.

    In many cases, it's better to understand their underlying problem or use case, because there might be a better way to solve it than what they are trying to do.

Ask to closeÂ¶

If they reply, there's a high chance you would have solved their problem, congrats, you're a hero! ğŸ¦¸

    Now, if that solved their problem, you can ask them to:
        In GitHub Discussions: mark the comment as the answer.
        In GitHub Issues: close the issue.

Watch the GitHub repositoryÂ¶

You can "watch" FastAPI in GitHub (clicking the "watch" button at the top right): https://github.com/fastapi/fastapi. ğŸ‘€

If you select "Watching" instead of "Releases only" you will receive notifications when someone creates a new issue or question. You can also specify that you only want to be notified about new issues, or discussions, or PRs, etc.

Then you can try and help them solve those questions.
Ask QuestionsÂ¶

You can create a new question in the GitHub repository, for example to:

    Ask a question or ask about a problem.
    Suggest a new feature.

Note: if you do it, then I'm going to ask you to also help others. ğŸ˜‰
Review Pull RequestsÂ¶

You can help me review pull requests from others.

Again, please try your best to be kind. ğŸ¤—

Here's what to keep in mind and how to review a pull request:
Understand the problemÂ¶

    First, make sure you understand the problem that the pull request is trying to solve. It might have a longer discussion in a GitHub Discussion or issue.

    There's also a good chance that the pull request is not actually needed because the problem can be solved in a different way. Then you can suggest or ask about that.

Don't worry about styleÂ¶

    Don't worry too much about things like commit message styles, I will squash and merge customizing the commit manually.

    Also don't worry about style rules, there are already automatized tools checking that.

And if there's any other style or consistency need, I'll ask directly for that, or I'll add commits on top with the needed changes.
Check the codeÂ¶

    Check and read the code, see if it makes sense, run it locally and see if it actually solves the problem.

    Then comment saying that you did that, that's how I will know you really checked it.

Info

Unfortunately, I can't simply trust PRs that just have several approvals.

Several times it has happened that there are PRs with 3, 5 or more approvals, probably because the description is appealing, but when I check the PRs, they are actually broken, have a bug, or don't solve the problem they claim to solve. ğŸ˜…

So, it's really important that you actually read and run the code, and let me know in the comments that you did. ğŸ¤“

    If the PR can be simplified in a way, you can ask for that, but there's no need to be too picky, there might be a lot of subjective points of view (and I will have my own as well ğŸ™ˆ), so it's better if you can focus on the fundamental things.

TestsÂ¶

    Help me check that the PR has tests.

    Check that the tests fail before the PR. ğŸš¨

    Then check that the tests pass after the PR. âœ…

    Many PRs don't have tests, you can remind them to add tests, or you can even suggest some tests yourself. That's one of the things that consume most time and you can help a lot with that.

    Then also comment what you tried, that way I'll know that you checked it. ğŸ¤“

Create a Pull RequestÂ¶

You can contribute to the source code with Pull Requests, for example:

    To fix a typo you found on the documentation.
    To share an article, video, or podcast you created or found about FastAPI by editing this file.
        Make sure you add your link to the start of the corresponding section.
    To help translate the documentation to your language.
        You can also help to review the translations created by others.
    To propose new documentation sections.
    To fix an existing issue/bug.
        Make sure to add tests.
    To add a new feature.
        Make sure to add tests.
        Make sure to add documentation if it's relevant.

Help Maintain FastAPIÂ¶

Help me maintain FastAPI! ğŸ¤“

There's a lot of work to do, and for most of it, YOU can do it.

The main tasks that you can do right now are:

    Help others with questions in GitHub (see the section above).
    Review Pull Requests (see the section above).

Those two tasks are what consume time the most. That's the main work of maintaining FastAPI.

If you can help me with that, you are helping me maintain FastAPI and making sure it keeps advancing faster and better. ğŸš€
Join the chatÂ¶

Join the ğŸ‘¥ Discord chat server ğŸ‘¥ and hang out with others in the FastAPI community.

Tip

For questions, ask them in GitHub Discussions, there's a much better chance you will receive help by the FastAPI Experts.

Use the chat only for other general conversations.
Don't use the chat for questionsÂ¶

Keep in mind that as chats allow more "free conversation", it's easy to ask questions that are too general and more difficult to answer, so, you might not receive answers.

In GitHub, the template will guide you to write the right question so that you can more easily get a good answer, or even solve the problem yourself even before asking. And in GitHub I can make sure I always answer everything, even if it takes some time. I can't personally do that with the chat systems. ğŸ˜…

Conversations in the chat systems are also not as easily searchable as in GitHub, so questions and answers might get lost in the conversation. And only the ones in GitHub count to become a FastAPI Expert, so you will most probably receive more attention in GitHub.

On the other side, there are thousands of users in the chat systems, so there's a high chance you'll find someone to talk to there, almost all the time. ğŸ˜„
Sponsor the authorÂ¶

If your product/company depends on or is related to FastAPI and you want to reach its users, you can sponsor the author (me) through GitHub sponsors. Depending on the tier, you could get some extra benefits, like a badge in the docs. ğŸ

Thanks! ğŸš€
Previous
Resources
Next
Development - Contributing
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs

Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
Development - Contributing

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Resources
        Help FastAPI - Get Help
        Development - Contributing
        Full Stack FastAPI Template
        External Links and Articles
        FastAPI and friends newsletter
        Repository Management Tasks

Table of contents

    Developing
        Virtual environment
        Install requirements
        Using your local FastAPI
        Format the code
    Tests
    Docs
        Docs live
            Typer CLI (optional)
        Docs Structure
        Docs for tests
            Apps and docs at the same time
        Translations
            Tips and guidelines
            Existing language
            Don't Translate these Pages
            Request a New Language
            New Language
            Preview the result
            Translation specific tips and guidelines

    FastAPI
    Resources

Development - ContributingÂ¶

First, you might want to see the basic ways to help FastAPI and get help.
DevelopingÂ¶

If you already cloned the fastapi repository and you want to deep dive in the code, here are some guidelines to set up your environment.
Virtual environmentÂ¶

Follow the instructions to create and activate a virtual environment for the internal code of fastapi.
Install requirementsÂ¶

After activating the environment, install the required packages:
pip
uv

pip install -r requirements.txt
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100%
restart â†»

It will install all the dependencies and your local FastAPI in your local environment.
Using your local FastAPIÂ¶

If you create a Python file that imports and uses FastAPI, and run it with the Python from your local environment, it will use your cloned local FastAPI source code.

And if you update that local FastAPI source code when you run that Python file again, it will use the fresh version of FastAPI you just edited.

That way, you don't have to "install" your local version to be able to test every change.

Technical Details

This only happens when you install using this included requirements.txt instead of running pip install fastapi directly.

That is because inside the requirements.txt file, the local version of FastAPI is marked to be installed in "editable" mode, with the -e option.
Format the codeÂ¶

There is a script that you can run that will format and clean all your code:


It will also auto-sort all your imports.
TestsÂ¶

There is a script that you can run locally to test all the code and generate coverage reports in HTML:


This command generates a directory ./htmlcov/, if you open the file ./htmlcov/index.html in your browser, you can explore interactively the regions of code that are covered by the tests, and notice if there is any region missing.
DocsÂ¶

First, make sure you set up your environment as described above, that will install all the requirements.
Docs liveÂ¶

During local development, there is a script that builds the site and checks for any changes, live-reloading:






It will serve the documentation on http://127.0.0.1:8008.

That way, you can edit the documentation/source files and see the changes live.

Tip

Alternatively, you can perform the same steps that scripts does manually.

Go into the language directory, for the main docs in English it's at docs/en/:

$ cd docs/en/

Then run mkdocs in that directory:

$ mkdocs serve --dev-addr 127.0.0.1:8008

Typer CLI (optional)Â¶

The instructions here show you how to use the script at ./scripts/docs.py with the python program directly.

But you can also use Typer CLI, and you will get autocompletion in your terminal for the commands after installing completion.

If you install Typer CLI, you can install completion with:





Docs StructureÂ¶

The documentation uses MkDocs.

And there are extra tools/scripts in place to handle translations in ./scripts/docs.py.

Tip

You don't need to see the code in ./scripts/docs.py, you just use it in the command line.

All the documentation is in Markdown format in the directory ./docs/en/.

Many of the tutorials have blocks of code.

In most of the cases, these blocks of code are actual complete applications that can be run as is.

In fact, those blocks of code are not written inside the Markdown, they are Python files in the ./docs_src/ directory.

And those Python files are included/injected in the documentation when generating the site.
Docs for testsÂ¶

Most of the tests actually run against the example source files in the documentation.

This helps to make sure that:

    The documentation is up-to-date.
    The documentation examples can be run as is.
    Most of the features are covered by the documentation, ensured by test coverage.

Apps and docs at the same timeÂ¶

If you run the examples with, e.g.:




as Uvicorn by default will use the port 8000, the documentation on port 8008 won't clash.
TranslationsÂ¶

Attention

Update on Translations

We're updating the way we handle documentation translations.

Until now, we invited community members to translate pages via pull requests, which were then reviewed by at least two native speakers. While this has helped bring FastAPI to many more users, weâ€™ve also run into several challenges - some languages have only a few translated pages, others are outdated and hard to maintain over time. To improve this, weâ€™re working on automation tools ğŸ¤– to manage translations more efficiently. Once ready, documentation will be machine-translated and still reviewed by at least two native speakers âœ… before publishing. This will allow us to keep translations up-to-date while reducing the review burden on maintainers.

Whatâ€™s changing now:

    ğŸš« Weâ€™re no longer accepting new community-submitted translation PRs.

    â³ Existing open PRs will be reviewed and can still be merged if completed within the next 3 weeks (since July 11 2025).

    ğŸŒ In the future, we will only support languages where at least three active native speakers are available to review and maintain translations.

This transition will help us keep translations more consistent and timely while better supporting our contributors ğŸ™Œ. Thank you to everyone who has contributed so far â€” your help has been invaluable! ğŸ’–

Help with translations is VERY MUCH appreciated! And it can't be done without the help from the community. ğŸŒ ğŸš€

Here are the steps to help with translations.
Tips and guidelinesÂ¶

    Check the currently existing pull requests for your language. You can filter the pull requests by the ones with the label for your language. For example, for Spanish, the label is lang-es.

    Review those pull requests, requesting changes or approving them. For the languages I don't speak, I'll wait for several others to review the translation before merging.

Tip

You can add comments with change suggestions to existing pull requests.

Check the docs about adding a pull request review to approve it or request changes.

    Check if there's a GitHub Discussion to coordinate translations for your language. You can subscribe to it, and when there's a new pull request to review, an automatic comment will be added to the discussion.

    If you translate pages, add a single pull request per page translated. That will make it much easier for others to review it.

    To check the 2-letter code for the language you want to translate, you can use the table List of ISO 639-1 codes.

Existing languageÂ¶

Let's say you want to translate a page for a language that already has translations for some pages, like Spanish.

In the case of Spanish, the 2-letter code is es. So, the directory for Spanish translations is located at docs/es/.

Tip

The main ("official") language is English, located at docs/en/.

Now run the live server for the docs in Spanish:






Tip

Alternatively, you can perform the same steps that scripts does manually.

Go into the language directory, for the Spanish translations it's at docs/es/:

$ cd docs/es/

Then run mkdocs in that directory:

$ mkdocs serve --dev-addr 127.0.0.1:8008

Now you can go to http://127.0.0.1:8008 and see your changes live.

You will see that every language has all the pages. But some pages are not translated and have an info box at the top, about the missing translation.

Now let's say that you want to add a translation for the section Features.

    Copy the file at:

docs/en/docs/features.md

    Paste it in exactly the same location but for the language you want to translate, e.g.:

docs/es/docs/features.md

Tip

Notice that the only change in the path and file name is the language code, from en to es.

If you go to your browser you will see that now the docs show your new section (the info box at the top is gone). ğŸ‰

Now you can translate it all and see how it looks as you save the file.
Don't Translate these PagesÂ¶

ğŸš¨ Don't translate:

    Files under reference/
    release-notes.md
    fastapi-people.md
    external-links.md
    newsletter.md
    management-tasks.md
    management.md
    contributing.md

Some of these files are updated very frequently and a translation would always be behind, or they include the main content from English source files, etc.
Request a New LanguageÂ¶

Let's say that you want to request translations for a language that is not yet translated, not even some pages. For example, Latin.

If there is no discussion for that language, you can start by requesting the new language. For that, you can follow these steps:

    Create a new discussion following the template.
    Get a few native speakers to comment on the discussion and commit to help review translations for that language.

Once there are several people in the discussion, the FastAPI team can evaluate it and can make it an official translation.

Then the docs will be automatically translated using AI, and the team of native speakers can review the translation, and help tweak the AI prompts.

Once there's a new translation, for example if docs are updated or there's a new section, there will be a comment in the same discussion with the link to the new translation to review.
New LanguageÂ¶

Note

These steps will be performed by the FastAPI team.

Checking the link from above (List of ISO 639-1 codes), you can see that the 2-letter code for Latin is la.

Now you can create a new directory for the new language, running the following script:




Now you can check in your code editor the newly created directory docs/la/.

That command created a file docs/la/mkdocs.yml with a simple config that inherits everything from the en version:

INHERIT: ../en/mkdocs.yml

Tip

You could also simply create that file with those contents manually.

That command also created a dummy file docs/la/index.md for the main page, you can start by translating that one.

You can continue with the previous instructions for an "Existing Language" for that process.

You can make the first pull request with those two files, docs/la/mkdocs.yml and docs/la/index.md. ğŸ‰
Preview the resultÂ¶

As already mentioned above, you can use the ./scripts/docs.py with the live command to preview the results (or mkdocs serve).

Once you are done, you can also test it all as it would look online, including all the other languages.

To do that, first build all the docs:






This builds all those independent MkDocs sites for each language, combines them, and generates the final output at ./site/.

Then you can serve that with the command serve:







Translation specific tips and guidelinesÂ¶

    Translate only the Markdown documents (.md). Do not translate the code examples at ./docs_src.

    In code blocks within the Markdown document, translate comments (# a comment), but leave the rest unchanged.

    Do not change anything enclosed in "``" (inline code).

    In lines starting with /// translate only the text part after |. Leave the rest unchanged.

    You can translate info boxes like /// warning with for example /// warning | Achtung. But do not change the word immediately after the ///, it determines the color of the info box.

    Do not change the paths in links to images, code files, Markdown documents.

    However, when a Markdown document is translated, the #hash-parts in links to its headings may change. Update these links if possible.
        Search for such links in the translated document using the regex #[^# ].
        Search in all documents already translated into your language for your-translated-document.md. For example VS Code has an option "Edit" -> "Find in Files".
        When translating a document, do not "pre-translate" #hash-parts that link to headings in untranslated documents.

Previous
Help FastAPI - Get Help
Next
Full Stack FastAPI Template
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs




Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Full Stack FastAPI Template

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Resources
        Help FastAPI - Get Help
        Development - Contributing
        Full Stack FastAPI Template
        External Links and Articles
        FastAPI and friends newsletter
        Repository Management Tasks

Table of contents

    Full Stack FastAPI Template - Technology Stack and Features

    FastAPI
    Resources

Full Stack FastAPI TemplateÂ¶

Templates, while typically come with a specific setup, are designed to be flexible and customizable. This allows you to modify and adapt them to your project's requirements, making them an excellent starting point. ğŸ

You can use this template to get started, as it includes a lot of the initial set up, security, database and some API endpoints already done for you.

GitHub Repository: Full Stack FastAPI Template
Full Stack FastAPI Template - Technology Stack and FeaturesÂ¶

    âš¡ FastAPI for the Python backend API.
        ğŸ§° SQLModel for the Python SQL database interactions (ORM).
        ğŸ” Pydantic, used by FastAPI, for the data validation and settings management.
        ğŸ’¾ PostgreSQL as the SQL database.
    ğŸš€ React for the frontend.
        ğŸ’ƒ Using TypeScript, hooks, Vite, and other parts of a modern frontend stack.
        ğŸ¨ Chakra UI for the frontend components.
        ğŸ¤– An automatically generated frontend client.
        ğŸ§ª Playwright for End-to-End testing.
        ğŸ¦‡ Dark mode support.
    ğŸ‹ Docker Compose for development and production.
    ğŸ”’ Secure password hashing by default.
    ğŸ”‘ JWT token authentication.
    ğŸ“« Email based password recovery.
    âœ… Tests with Pytest.
    ğŸ“ Traefik as a reverse proxy / load balancer.
    ğŸš¢ Deployment instructions using Docker Compose, including how to set up a frontend Traefik proxy to handle automatic HTTPS certificates.
    ğŸ­ CI (continuous integration) and CD (continuous deployment) based on GitHub Actions.

Previous
Development - Contributing
Next
External Links and Articles
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
External Links and Articles

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Resources
        Help FastAPI - Get Help
        Development - Contributing
        Full Stack FastAPI Template
        External Links and Articles
        FastAPI and friends newsletter
        Repository Management Tasks

Table of contents

    Articles
        English
        German
        Japanese
        Portuguese
        Russian
        Vietnamese
        Taiwanese
        Spanish
    Podcasts
        English
    Talks
        English
        Taiwanese
    GitHub Repositories

    FastAPI
    Resources

External Links and ArticlesÂ¶

FastAPI has a great community constantly growing.

There are many posts, articles, tools, and projects, related to FastAPI.

Here's an incomplete list of some of them.

Tip

If you have an article, project, tool, or anything related to FastAPI that is not yet listed here, create a Pull Request adding it.
ArticlesÂ¶
EnglishÂ¶

    Getting started with logging in FastAPI by Apitally.

    How to profile a FastAPI asynchronous request by Balthazar Rouberol.

    Deploy a Serverless FastAPI App with Neon Postgres and AWS App Runner at any scale by Stephen Siegert - Neon.

    Building a Machine Learning Microservice with FastAPI by Kurtis Pykes - NVIDIA.

    Booking Appointments with Twilio, Notion, and FastAPI by Ravgeet Dhillon - Twilio.

    Write a Python data layer with Azure Cosmos DB and FastAPI by Abhinav Tripathi - Microsoft Blogs.

    10 Tips for adding SQLAlchemy to FastAPI by Donny Peeters.

    Tips on migrating from Flask to FastAPI and vice-versa by Jessica Temporal.

    Explore How to Effectively Use JWT With FastAPI by Ankit Anchlia.

    Instrument FastAPI with OpenTelemetry tracing and visualize traces in Grafana Tempo. by NicolÃ³ Lino.

    ML serving and monitoring with FastAPI and Evidently by Mikhail Rozhkov, Elena Samuylova.

    FastAPI Tutorial in Visual Studio Code by Visual Studio Code Team.

    FastAPI application monitoring made easy by Apitally.

    Building a RESTful API with FastAPI: Secure Signup and Login Functionality Included by John Philip.

    Building a CRUD API with FastAPI and Supabase by Keshav Malik.

    Build an SMS Spam Classifier Serverless Database with FaunaDB and FastAPI by Adejumo Ridwan Suleiman.

    FastAPI lambda container: serverless simplified by Raf Rasenberg.

    Authorization on FastAPI with Casbin by Teresa N. Fontanella De Santis.

    How to monitor FastAPI application performance using Python agent by New Relic.

    Building the Poll App From Django Tutorial With FastAPI And React by Jean-Baptiste Rocher.

    Seamless FastAPI Configuration with ConfZ by Silvan Melchior.

    5 Advanced Features of FastAPI You Should Try by Kaustubh Gupta.

    Deploying ML Models as API Using FastAPI and Heroku by Kaustubh Gupta.

    Using GitHub Actions to Deploy a FastAPI Project to Heroku by Somraj Saha.

    How to Create A Fake Certificate Authority And Generate TLS Certs for FastAPI by @pystar.

    Building a realtime ticket booking solution with Kafka, FastAPI, and Ably by Ben Gamble.

    Building simple E-Commerce with NuxtJS and FastAPI by Shahriyar(Shako) Rzayev.

    Serve a machine learning model using Sklearn, FastAPI and Docker by Rodrigo Arenas.

    Building an API with FastAPI and Supabase and Deploying on Deta by Yashasvi Singh.

    Deploy FastAPI on Ubuntu and Serve using Caddy 2 Web Server by Navule Pavan Kumar Rao.

    Python Facebook messenger webhook with FastAPI on Glitch by Patrick Ladon.

    Deploy a dockerized FastAPI application to AWS by Valon Januzaj.

    FastAPI for Flask Users by Amit Chaudhary.

    How to monitor your FastAPI service by Louis Guitton.

    Creating a CRUD App with FastAPI (Part one) by Precious Ndubueze.

    Build And Host Fast Data Science Applications Using FastAPI by Farhad Malik.

    Deploy FastAPI on Azure App Service by Navule Pavan Kumar Rao.

    Machine learning model serving in Python using FastAPI and streamlit by Davide Fiocco.

    Introducing Dispatch by Netflix.

    Using FastAPI with Django by Stavros Korokithakis.

    Build a Secure Twilio Webhook with Python and FastAPI by Twilio.

    Build a web API from scratch with FastAPI - the workshop by SebastiÃ¡n RamÃ­rez (tiangolo).

    FastAPI + Zeit.co = ğŸš€ by Paul Sec.

    Build simple API service with Python FastAPI â€” Part 1 by cuongld2.

    Microservice in Python using FastAPI by Paurakh Sharma Humagain.

    Real-time Notifications with Python and Postgres by Guillermo Cruz.

    Create and Deploy FastAPI app to Heroku without using Docker by Navule Pavan Kumar Rao.

    Another Boilerplate to FastAPI: Azure Pipeline CI + Pytest by Arthur Henrique.

    Deploy Machine Learning Models with Keras, FastAPI, Redis and Docker by Shane Soh.

    Towards Data Science: Deploying Iris Classifications with FastAPI and Docker by Mandy Gu.

    TestDriven.io: Developing and Testing an Asynchronous API with FastAPI and Pytest by Michael Herman.

    How To Deploy Tensorflow 2.0 Models As An API Service With FastAPI & Docker by Bernard Brenyah.

    Why I'm Leaving Flask by Dylan Anthony.

    Using Docker Compose to deploy a lightweight Python REST API with a job queue by Mike Moritz.

    A FastAPI and Swagger UI visual cheatsheet by @euri10.

    Uber: Ludwig v0.2 Adds New Features and Other Improvements to its Deep Learning Toolbox [including a FastAPI server] by Uber Engineering.

    How to Deploy a Machine Learning Model by Maarten Grootendorst.

    JWT Authentication with FastAPI and AWS Cognito by Johannes Gontrum.

    Top 5 Asynchronous Web Frameworks for Python by Ankush Thakur.

    Deploying a scikit-learn model with ONNX and FastAPI by Nico Axtmann.

    FastAPI authentication revisited: Enabling API key authentication by Nils de Bruin.

    FastAPI and Scikit-Learn: Easily Deploy Models by Nick Cortale.

    Introduction to the fastapi python framework by Errieta Kostala.

    FastAPIâ€Šâ€”â€ŠHow to add basic and cookie authentication by Nils de Bruin.

    FastAPIâ€Šâ€”â€ŠGoogle as an external authentication provider by Nils de Bruin.

    FastAPI/Starlette debug vs prod by William Hayes.

    Developing FastAPI Application using K8s & AWS by Mukul Mantosh.

    Fastapi, Docker(Docker compose) and Postgres by KrishNa.

    Deployment using Docker, Lambda, Aurora, CDK & GH Actions by Devon Ray.

    Mastering Soft Delete: Advanced SQLAlchemy Techniques by Shubhendra Kushwaha.

    Role based row filtering: Advanced SQLAlchemy Techniques by Shubhendra Kushwaha.

GermanÂ¶

    Domain-driven Design mit Python und FastAPI by Marcel Sander (actidoo).

    Inbetriebnahme eines scikit-learn-Modells mit ONNX und FastAPI by Nico Axtmann.

    REST-API Programmieren mittels Python und dem FastAPI Modul by Felix SchÃ¼rmeyer.

JapaneseÂ¶

    [FastAPI] Pythonè£½ã®ASGI Web ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ FastAPIã«å…¥é–€ã™ã‚‹ by @bee2.

    Pythonã®Web frameworkã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒ (Django, Flask, responder, FastAPI, japronto) by @bee2.

    ã€ç¬¬4å›ã€‘FastAPIãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«: toDoã‚¢ãƒ—ãƒªã‚’ä½œã£ã¦ã¿ã‚ˆã†ã€ç®¡ç†è€…ãƒšãƒ¼ã‚¸æ”¹è‰¯ç·¨ã€‘ by ãƒ©ã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ¡ãƒ‡ã‚£ã‚¢ç·¨é›†éƒ¨.

    ã€ç¬¬3å›ã€‘FastAPIãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«: toDoã‚¢ãƒ—ãƒªã‚’ä½œã£ã¦ã¿ã‚ˆã†ã€èªè¨¼ãƒ»ãƒ¦ãƒ¼ã‚¶ç™»éŒ²ç·¨ã€‘ by ãƒ©ã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ¡ãƒ‡ã‚£ã‚¢ç·¨é›†éƒ¨.

    ã€ç¬¬2å›ã€‘FastAPIãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«: ToDoã‚¢ãƒ—ãƒªã‚’ä½œã£ã¦ã¿ã‚ˆã†ã€ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰ç·¨ã€‘ by ãƒ©ã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ¡ãƒ‡ã‚£ã‚¢ç·¨é›†éƒ¨.

    ã€ç¬¬1å›ã€‘FastAPIãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«: ToDoã‚¢ãƒ—ãƒªã‚’ä½œã£ã¦ã¿ã‚ˆã†ã€ç’°å¢ƒæ§‹ç¯‰ç·¨ã€‘ by ãƒ©ã‚¤ãƒˆã‚³ãƒ¼ãƒ‰ãƒ¡ãƒ‡ã‚£ã‚¢ç·¨é›†éƒ¨.

    ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰é–‹ç™ºè€…å‘ã‘ã®Dockerã«ã‚ˆã‚‹Pythoné–‹ç™ºç’°å¢ƒæ§‹ç¯‰ by Hikaru Takahashi.

    FastAPIã§POSTã•ã‚ŒãŸJSONã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹bodyã‚’å—ã‘å–ã‚‹ by @angel_katayoku.

    FastAPIã‚’MySQLã¨æ¥ç¶šã—ã¦Dockerã§ç®¡ç†ã—ã¦ã¿ã‚‹ by @angel_katayoku.

    FastAPIã§CORSã‚’å›é¿ by @angel_katayoku.

    pythonè£½ã®æœ€æ–°APIãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ FastAPI ã‚’è§¦ã£ã¦ã¿ãŸ by @ryoryomaru.

    FastAPIï½œDBæ¥ç¶šã—ã¦CRUDã™ã‚‹Pythonè£½APIã‚µãƒ¼ãƒãƒ¼ã‚’æ§‹ç¯‰ by @mtitg.

PortugueseÂ¶

    FastAPI do ZERO by Eduardo Mendes.

    Dicas para migrar uma aplicaÃ§Ã£o de Flask para FastAPI e vice-versa by Jessica Temporal.

RussianÂ¶

    FastAPI: Ğ·Ğ½Ğ°ĞºĞ¾Ğ¼Ğ¸Ğ¼ÑÑ Ñ Ñ„Ñ€ĞµĞ¹Ğ¼Ğ²Ğ¾Ñ€ĞºĞ¾Ğ¼ by Troy KÃ¶hler.

    ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ Ğ’Ñ‹ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ FastAPI? by prostomarkeloff.

    ĞœĞµĞ»ĞºĞ°Ñ Ğ¿Ğ¸Ñ‚Ğ¾Ğ½ÑÑ‡Ğ°Ñ Ñ€Ğ°Ğ´Ğ¾ÑÑ‚ÑŒ #2: Starlette - Ğ¡Ğ¾Ğ»Ğ¸Ğ´Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¸Ğ¼Ğ¾Ñ‡ĞºĞ° â€“ FastAPI by Andrey Korchak.

VietnameseÂ¶

    FASTAPI: TRIá»‚N KHAI Báº°NG DOCKER by Nguyá»…n NhÃ¢n.

TaiwaneseÂ¶

    Tortoise ORM / FastAPI æ•´åˆå¿«é€Ÿç­†è¨˜ by Leon.

SpanishÂ¶

    Tutorial de FastAPI, Â¿el mejor framework de Python? by Eduardo Zepeda.

PodcastsÂ¶
EnglishÂ¶

    Why FastAPI Became Pythonâ€™s Fastestâ€‘Growing Framework â€“ Chat with SebastiÃ¡n RamÃ­rez by Behind the Commit.

    Starting With FastAPI and Examining Python's Import System - Episode 72 by Real Python.

    Do you dare to press "."? - Episode 247 - Dan #6: SQLModel - use the same models for SQL and FastAPI by Python Bytes FM.

    Build The Next Generation Of Python Web Applications With FastAPI - Episode 259 - interview to SebastÃ­an RamÃ­rez (tiangolo) by Podcast.__init__.

    FastAPI on PythonBytes by Python Bytes FM.

TalksÂ¶
EnglishÂ¶

    Keynote: Behind the scenes of FastAPI and friends for developers and builders â€” SebastiÃ¡n RamÃ­rez by SebastiÃ¡n RamÃ­rez (tiangolo).

    PyCon AU 2023: Testing asynchronous applications with FastAPI and pytest by Jeny Sadadia.

    [VIRTUAL] Py.Amsterdam's flying Software Circus: Intro to FastAPI by SebastiÃ¡n RamÃ­rez (tiangolo).

    PyConBY 2020: Serve ML models easily with FastAPI by SebastiÃ¡n RamÃ­rez (tiangolo).

    PyCon UK 2019: FastAPI from the ground up by Chris Withers.

TaiwaneseÂ¶

    PyCon TW 2024: å…¨æ–¹ä½å¼·åŒ– Python æœå‹™å¯è§€æ¸¬æ€§ï¼šä»¥ FastAPI å’Œ Grafana Stack ç‚ºä¾‹ by Blueswen.

GitHub RepositoriesÂ¶

Most starred GitHub repositories with the topic fastapi:

â˜… 38779 - full-stack-fastapi-template by @fastapi.

â˜… 32726 - Hello-Python by @mouredev.

â˜… 21779 - serve by @jina-ai.

â˜… 20028 - HivisionIDPhotos by @Zeyi-Lin.

â˜… 17038 - sqlmodel by @fastapi.

â˜… 14786 - Douyin_TikTok_Download_API by @Evil0ctal.

â˜… 13968 - fastapi-best-practices by @zhanymkanov.

â˜… 12171 - machine-learning-zoomcamp by @DataTalksClub.

â˜… 10976 - fastapi_mcp by @tadata-org.

â˜… 10618 - awesome-fastapi by @mjhea0.

â˜… 10243 - SurfSense by @MODSetter.

â˜… 9062 - XHS-Downloader by @JoeanAmier.

â˜… 8892 - FastUI by @pydantic.

â˜… 8084 - polar by @polarsource.

â˜… 7494 - FileCodeBox by @vastsa.

â˜… 7128 - nonebot2 by @nonebot.

â˜… 6155 - hatchet by @hatchet-dev.

â˜… 5754 - serge by @serge-chat.

â˜… 5683 - fastapi-users by @fastapi-users.

â˜… 4452 - strawberry by @strawberry-graphql.

â˜… 4296 - chatgpt-web-share by @chatpire.

â˜… 4235 - poem by @poem-web.

â˜… 4174 - dynaconf by @dynaconf.

â˜… 4094 - atrilabs-engine by @Atri-Labs.

â˜… 3875 - Kokoro-FastAPI by @remsky.

â˜… 3717 - logfire by @pydantic.

â˜… 3615 - LitServe by @Lightning-AI.

â˜… 3554 - datamodel-code-generator by @koxudaxi.

â˜… 3521 - huma by @danielgtaylor.

â˜… 3497 - fastapi-admin by @fastapi-admin.

â˜… 3476 - farfalle by @rashadphz.

â˜… 3310 - tracecat by @TracecatHQ.

â˜… 3134 - opyrator by @ml-tooling.

â˜… 3108 - docarray by @docarray.

â˜… 2945 - fastapi-realworld-example-app by @nsidnev.

â˜… 2809 - uvicorn-gunicorn-fastapi-docker by @tiangolo.

â˜… 2784 - devpush by @hunvreus.

â˜… 2763 - mcp-context-forge by @IBM.

â˜… 2630 - best-of-web-python by @ml-tooling.

â˜… 2464 - fastapi-react by @Buuntu.

â˜… 2453 - FastAPI-template by @s3rius.

â˜… 2444 - RasaGPT by @paulpierre.

â˜… 2423 - sqladmin by @aminalaee.

â˜… 2325 - nextpy by @dot-agent.

â˜… 2292 - supabase-py by @supabase.

â˜… 2214 - 30-Days-of-Python by @codingforentrepreneurs.

â˜… 2212 - Yuxi-Know by @xerrors.

â˜… 2191 - langserve by @langchain-ai.

â˜… 2185 - fastapi-utils by @fastapiutils.

â˜… 2111 - solara by @widgetti.

â˜… 2011 - mangum by @Kludex.

â˜… 1826 - agentkit by @BCG-X-Official.

â˜… 1815 - python-week-2022 by @rochacbruno.

â˜… 1787 - manage-fastapi by @ycd.

â˜… 1780 - ormar by @collerek.

â˜… 1758 - vue-fastapi-admin by @mizhexiaoxiao.

â˜… 1731 - openapi-python-client by @openapi-generators.

â˜… 1711 - piccolo by @piccolo-orm.

â˜… 1677 - fastapi-cache by @long2ice.

â˜… 1669 - slowapi by @laurentS.

â˜… 1632 - langchain-serve by @jina-ai.

â˜… 1621 - termpair by @cs01.

â˜… 1596 - FastAPI-boilerplate by @benavlabs.

â˜… 1573 - coronavirus-tracker-api by @ExpDev07.

â˜… 1553 - fastapi-crudrouter by @awtkns.

â˜… 1485 - awesome-fastapi-projects by @Kludex.

â˜… 1473 - fastapi-pagination by @uriyyo.

â˜… 1470 - bracket by @evroon.

â˜… 1456 - fastapi-langgraph-agent-production-ready-template by @wassim249.

â˜… 1424 - fastapi-boilerplate by @teamhide.

â˜… 1420 - awesome-python-resources by @DjangoEx.

â˜… 1363 - fastapi-amis-admin by @amisadmin.

â˜… 1362 - fastcrud by @benavlabs.

â˜… 1345 - budgetml by @ebhy.

â˜… 1315 - fastapi-tutorial by @liaogx.

â˜… 1311 - fastapi_best_architecture by @fastapi-practices.

â˜… 1270 - fastapi-code-generator by @koxudaxi.

â˜… 1264 - prometheus-fastapi-instrumentator by @trallnag.

â˜… 1243 - bedrock-chat by @aws-samples.

â˜… 1238 - bolt-python by @slackapi.

â˜… 1209 - fastapi_production_template by @zhanymkanov.

â˜… 1200 - fastapi-scaff by @atpuxiner.

â˜… 1173 - langchain-extract by @langchain-ai.

â˜… 1162 - fastapi-alembic-sqlmodel-async by @jonra1993.

â˜… 1137 - odmantic by @art049.

â˜… 1129 - restish by @rest-sh.

â˜… 1065 - kubetorch by @run-house.

â˜… 1039 - flock by @Onelevenvy.

â˜… 1017 - authx by @yezz123.

â˜… 997 - autollm by @viddexa.

â˜… 993 - lanarky by @ajndkr.

â˜… 974 - RuoYi-Vue3-FastAPI by @insistence.

â˜… 972 - aktools by @akfamily.

â˜… 965 - titiler by @developmentseed.

â˜… 953 - secure by @TypeError.

â˜… 949 - energy-forecasting by @iusztinpaul.

â˜… 942 - every-pdf by @DDULDDUCK.

â˜… 933 - langcorn by @msoedov.

â˜… 923 - fastapi-observability by @blueswen.
Previous
Full Stack FastAPI Template
Next
FastAPI and friends newsletter
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
FastAPI and friends newsletter

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Resources
        Help FastAPI - Get Help
        Development - Contributing
        Full Stack FastAPI Template
        External Links and Articles
        FastAPI and friends newsletter
        Repository Management Tasks

    FastAPI
    Resources

FastAPI and friends newsletterÂ¶
Previous
External Links and Articles
Next
Repository Management Tasks
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
Repository Management Tasks

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    Resources
        Help FastAPI - Get Help
        Development - Contributing
        Full Stack FastAPI Template
        External Links and Articles
        FastAPI and friends newsletter
        Repository Management Tasks

Table of contents

    Be Nice
        When Things are Difficult
    Edit PR Titles
    Add Labels to PRs
    Add Labels to Translation PRs
    Merge Translation PRs
    First Translation PR
    Review PRs
    FastAPI People PRs
    External Links PRs
    Dependabot PRs
    Mark GitHub Discussions Answers

    FastAPI
    Resources

Repository Management TasksÂ¶

These are the tasks that can be performed to manage the FastAPI repository by team members.

Tip

This section is useful only to a handful of people, team members with permissions to manage the repository. You can probably skip it. ğŸ˜‰

...so, you are a team member of FastAPI? Wow, you are so cool! ğŸ˜

You can help with everything on Help FastAPI - Get Help the same ways as external contributors. But additionally, there are some tasks that only you (as part of the team) can perform.

Here are the general instructions for the tasks you can perform.

Thanks a lot for your help. ğŸ™‡
Be NiceÂ¶

First of all, be nice. ğŸ˜Š

You probably are super nice if you were added to the team, but it's worth mentioning it. ğŸ¤“
When Things are DifficultÂ¶

When things are great, everything is easier, so that doesn't need much instructions. But when things are difficult, here are some guidelines.

Try to find the good side. In general, if people are not being unfriendly, try to thank their effort and interest, even if you disagree with the main subject (discussion, PR), just thank them for being interested in the project, or for having dedicated some time to try to do something.

It's difficult to convey emotion in text, use emojis to help. ğŸ˜…

In discussions and PRs, in many cases, people bring their frustration and show it without filter, in many cases exaggerating, complaining, being entitled, etc. That's really not nice, and when it happens, it lowers our priority to solve their problems. But still, try to breath, and be gentle with your answers.

Try to avoid using bitter sarcasm or potentially passive-aggressive comments. If something is wrong, it's better to be direct (try to be gentle) than sarcastic.

Try to be as specific and objective as possible, avoid generalizations.

For conversations that are more difficult, for example to reject a PR, you can ask me (@tiangolo) to handle it directly.
Edit PR TitlesÂ¶

    Edit the PR title to start with an emoji from gitmoji.
        Use the emoji character, not the GitHub code. So, use ğŸ› instead of :bug:. This is so that it shows up correctly outside of GitHub, for example in the release notes.
        For translations use the ğŸŒ emoji ("globe with meridians").
    Start the title with a verb. For example Add, Refactor, Fix, etc. This way the title will say the action that the PR does. Like Add support for teleporting, instead of Teleporting wasn't working, so this PR fixes it.
    Edit the text of the PR title to start in "imperative", like giving an order. So, instead of Adding support for teleporting use Add support for teleporting.
    Try to make the title descriptive about what it achieves. If it's a feature, try to describe it, for example Add support for teleporting instead of Create TeleportAdapter class.
    Do not finish the title with a period (.).
    When the PR is for a translation, start with the ğŸŒ and then Add {language} translation for and then the translated file path. For example:

ğŸŒ Add Spanish translation for `docs/es/docs/teleporting.md`

Once the PR is merged, a GitHub Action (latest-changes) will use the PR title to update the latest changes automatically.

So, having a nice PR title will not only look nice in GitHub, but also in the release notes. ğŸ“
Add Labels to PRsÂ¶

The same GitHub Action latest-changes uses one label in the PR to decide the section in the release notes to put this PR in.

Make sure you use a supported label from the latest-changes list of labels:

    breaking: Breaking Changes
        Existing code will break if they update the version without changing their code. This rarely happens, so this label is not frequently used.
    security: Security Fixes
        This is for security fixes, like vulnerabilities. It would almost never be used.
    feature: Features
        New features, adding support for things that didn't exist before.
    bug: Fixes
        Something that was supported didn't work, and this fixes it. There are many PRs that claim to be bug fixes because the user is doing something in an unexpected way that is not supported, but they considered it what should be supported by default. Many of these are actually features or refactors. But in some cases there's an actual bug.
    refactor: Refactors
        This is normally for changes to the internal code that don't change the behavior. Normally it improves maintainability, or enables future features, etc.
    upgrade: Upgrades
        This is for upgrades to direct dependencies from the project, or extra optional dependencies, normally in pyproject.toml. So, things that would affect final users, they would end up receiving the upgrade in their code base once they update. But this is not for upgrades to internal dependencies used for development, testing, docs, etc. Those internal dependencies, normally in requirements.txt files or GitHub Action versions should be marked as internal, not upgrade.
    docs: Docs
        Changes in docs. This includes updating the docs, fixing typos. But it doesn't include changes to translations.
        You can normally quickly detect it by going to the "Files changed" tab in the PR and checking if the updated file(s) starts with docs/en/docs. The original version of the docs is always in English, so in docs/en/docs.
    lang-all: Translations
        Use this for translations. You can normally quickly detect it by going to the "Files changed" tab in the PR and checking if the updated file(s) starts with docs/{some lang}/docs but not docs/en/docs. For example, docs/es/docs.
    internal: Internal
        Use this for changes that only affect how the repo is managed. For example upgrades to internal dependencies, changes in GitHub Actions or scripts, etc.

Tip

Some tools like Dependabot, will add some labels, like dependencies, but have in mind that this label is not used by the latest-changes GitHub Action, so it won't be used in the release notes. Please make sure one of the labels above is added.
Add Labels to Translation PRsÂ¶

When there's a PR for a translation, apart from adding the lang-all label, also add a label for the language.

There will be a label for each language using the language code, like lang-{lang code}, for example, lang-es for Spanish, lang-fr for French, etc.

    Add the specific language label.
    Add the label awaiting-review.

The label awaiting-review is special, only used for translations. A GitHub Action will detect it, then it will read the language label, and it will update the GitHub Discussions managing the translations for that language to notify people that there's a new translation to review.

Once a native speaker comes, reviews the PR, and approves it, the GitHub Action will come and remove the awaiting-review label, and add the approved-1 label.

This way, we can notice when there are new translations ready, because they have the approved-1 label.
Merge Translation PRsÂ¶

For Spanish, as I'm a native speaker and it's a language close to me, I will give it a final review myself and in most cases tweak the PR a bit before merging it.

For the other languages, confirm that:

    The title is correct following the instructions above.
    It has the labels lang-all and lang-{lang code}.
    The PR changes only one Markdown file adding a translation.
        Or in some cases, at most two files, if they are small, for the same language, and people reviewed them.
        If it's the first translation for that language, it will have additional mkdocs.yml files, for those cases follow the instructions below.
    The PR doesn't add any additional or extraneous files.
    The translation seems to have a similar structure as the original English file.
    The translation doesn't seem to change the original content, for example with obvious additional documentation sections.
    The translation doesn't use different Markdown structures, for example adding HTML tags when the original didn't have them.
    The "admonition" sections, like tip, info, etc. are not changed or translated. For example:

/// tip

This is a tip.

///

looks like this:

Tip

This is a tip.

...it could be translated as:

/// tip

Esto es un consejo.

///

...but needs to keep the exact tip keyword. If it was translated to consejo, like:

/// consejo

Esto es un consejo.

///

it would change the style to the default one, it would look like:

/// consejo

Esto es un consejo.

///

Those don't have to be translated, but if they are, they need to be written as:

/// tip | consejo

Esto es un consejo.

///

Which looks like:

consejo

Esto es un consejo.
First Translation PRÂ¶

When there's a first translation for a language, it will have a docs/{lang code}/docs/index.md translated file and a docs/{lang code}/mkdocs.yml.

For example, for Bosnian, it would be:

    docs/bs/docs/index.md
    docs/bs/mkdocs.yml

The mkdocs.yml file will have only the following content:

INHERIT: ../en/mkdocs.yml

The language code would normally be in the ISO 639-1 list of language codes.

In any case, the language code should be in the file docs/language_names.yml.

There won't be yet a label for the language code, for example, if it was Bosnian, there wouldn't be a lang-bs. Before creating the label and adding it to the PR, create the GitHub Discussion:

    Go to the Translations GitHub Discussions
    Create a new discussion with the title Bosnian Translations (or the language name in English)
    A description of:

## Bosnian translations

This is the issue to track translations of the docs to Bosnian. ğŸš€

Here are the [PRs to review with the label `lang-bs`](https://github.com/fastapi/fastapi/pulls?q=is%3Apr+is%3Aopen+sort%3Aupdated-desc+label%3Alang-bs+label%3A%22awaiting-review%22). ğŸ¤“

Update "Bosnian" with the new language.

And update the search link to point to the new language label that will be created, like lang-bs.

Create and add the label to that new Discussion just created, like lang-bs.

Then go back to the PR, and add the label, like lang-bs, and lang-all and awaiting-review.

Now the GitHub action will automatically detect the label lang-bs and will post in that Discussion that this PR is waiting to be reviewed.
Review PRsÂ¶

If a PR doesn't explain what it does or why, ask for more information.

A PR should have a specific use case that it is solving.

    If the PR is for a feature, it should have docs.
        Unless it's a feature we want to discourage, like support for a corner case that we don't want users to use.
    The docs should include a source example file, not write Python directly in Markdown.
    If the source example(s) file can have different syntax for Python 3.8, 3.9, 3.10, there should be different versions of the file, and they should be shown in tabs in the docs.
    There should be tests testing the source example.
    Before the PR is applied, the new tests should fail.
    After applying the PR, the new tests should pass.
    Coverage should stay at 100%.
    If you see the PR makes sense, or we discussed it and considered it should be accepted, you can add commits on top of the PR to tweak it, to add docs, tests, format, refactor, remove extra files, etc.
    Feel free to comment in the PR to ask for more information, to suggest changes, etc.
    Once you think the PR is ready, move it in the internal GitHub project for me to review it.

FastAPI People PRsÂ¶

Every month, a GitHub Action updates the FastAPI People data. Those PRs look like this one: ğŸ‘¥ Update FastAPI People.

If the tests are passing, you can merge it right away.
External Links PRsÂ¶

When people add external links they edit this file external_links.yml.

    Make sure the new link is in the correct category (e.g. "Podcasts") and language (e.g. "Japanese").
    A new link should be at the top of its list.
    The link URL should work (it should not return a 404).
    The content of the link should be about FastAPI.
    The new addition should have these fields:
        author: The name of the author.
        link: The URL with the content.
        title: The title of the link (the title of the article, podcast, etc).

After checking all these things and ensuring the PR has the right labels, you can merge it.
Dependabot PRsÂ¶

Dependabot will create PRs to update dependencies for several things, and those PRs all look similar, but some are way more delicate than others.

    If the PR is for a direct dependency, so, Dependabot is modifying pyproject.toml, don't merge it. ğŸ˜± Let me check it first. There's a good chance that some additional tweaks or updates are needed.
    If the PR updates one of the internal dependencies, for example it's modifying requirements.txt files, or GitHub Action versions, if the tests are passing, the release notes (shown in a summary in the PR) don't show any obvious potential breaking change, you can merge it. ğŸ˜

Mark GitHub Discussions AnswersÂ¶

When a question in GitHub Discussions has been answered, mark the answer by clicking "Mark as answer".

You can filter discussions by Questions that are Unanswered.
Previous
FastAPI and friends newsletter
Next
About
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
About

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    About
        Alternatives, Inspiration and Comparisons
        History, Design and Future
        Benchmarks
        Repository Management

    FastAPI
    About

AboutÂ¶

About FastAPI, its design, inspiration and more. ğŸ¤“
Previous
Repository Management Tasks
Next
Alternatives, Inspiration and Comparisons
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow FastAPI on LinkedIn to stay updated
logo
FastAPI
Alternatives, Inspiration and Comparisons

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    About
        Alternatives, Inspiration and Comparisons
        History, Design and Future
        Benchmarks
        Repository Management

Table of contents

    Intro
    Previous tools
        Django
        Django REST Framework
        Flask
        Requests
        Swagger / OpenAPI
        Flask REST frameworks
        Marshmallow
        Webargs
        APISpec
        Flask-apispec
        NestJS (and Angular)
        Sanic
        Falcon
        Molten
        Hug
        APIStar (<= 0.5)
    Used by FastAPI
        Pydantic
        Starlette
        Uvicorn
    Benchmarks and speed

    FastAPI
    About

Alternatives, Inspiration and ComparisonsÂ¶

What inspired FastAPI, how it compares to alternatives and what it learned from them.
IntroÂ¶

FastAPI wouldn't exist if not for the previous work of others.

There have been many tools created before that have helped inspire its creation.

I have been avoiding the creation of a new framework for several years. First I tried to solve all the features covered by FastAPI using many different frameworks, plug-ins, and tools.

But at some point, there was no other option than creating something that provided all these features, taking the best ideas from previous tools, and combining them in the best way possible, using language features that weren't even available before (Python 3.6+ type hints).
Previous toolsÂ¶
DjangoÂ¶

It's the most popular Python framework and is widely trusted. It is used to build systems like Instagram.

It's relatively tightly coupled with relational databases (like MySQL or PostgreSQL), so, having a NoSQL database (like Couchbase, MongoDB, Cassandra, etc) as the main store engine is not very easy.

It was created to generate the HTML in the backend, not to create APIs used by a modern frontend (like React, Vue.js and Angular) or by other systems (like IoT devices) communicating with it.
Django REST FrameworkÂ¶

Django REST framework was created to be a flexible toolkit for building Web APIs using Django underneath, to improve its API capabilities.

It is used by many companies including Mozilla, Red Hat and Eventbrite.

It was one of the first examples of automatic API documentation, and this was specifically one of the first ideas that inspired "the search for" FastAPI.

Note

Django REST Framework was created by Tom Christie. The same creator of Starlette and Uvicorn, on which FastAPI is based.

Inspired FastAPI to

Have an automatic API documentation web user interface.
FlaskÂ¶

Flask is a "microframework", it doesn't include database integrations nor many of the things that come by default in Django.

This simplicity and flexibility allow doing things like using NoSQL databases as the main data storage system.

As it is very simple, it's relatively intuitive to learn, although the documentation gets somewhat technical at some points.

It is also commonly used for other applications that don't necessarily need a database, user management, or any of the many features that come pre-built in Django. Although many of these features can be added with plug-ins.

This decoupling of parts, and being a "microframework" that could be extended to cover exactly what is needed was a key feature that I wanted to keep.

Given the simplicity of Flask, it seemed like a good match for building APIs. The next thing to find was a "Django REST Framework" for Flask.

Inspired FastAPI to

Be a micro-framework. Making it easy to mix and match the tools and parts needed.

Have a simple and easy to use routing system.
RequestsÂ¶

FastAPI is not actually an alternative to Requests. Their scope is very different.

It would actually be common to use Requests inside of a FastAPI application.

But still, FastAPI got quite some inspiration from Requests.

Requests is a library to interact with APIs (as a client), while FastAPI is a library to build APIs (as a server).

They are, more or less, at opposite ends, complementing each other.

Requests has a very simple and intuitive design, it's very easy to use, with sensible defaults. But at the same time, it's very powerful and customizable.

That's why, as said in the official website:

    Requests is one of the most downloaded Python packages of all time

The way you use it is very simple. For example, to do a GET request, you would write:

response = requests.get("http://example.com/some/url")

The FastAPI counterpart API path operation could look like:

@app.get("/some/url")
def read_url():
    return {"message": "Hello World"}

See the similarities in requests.get(...) and @app.get(...).

Inspired FastAPI to

    Have a simple and intuitive API.
    Use HTTP method names (operations) directly, in a straightforward and intuitive way.
    Have sensible defaults, but powerful customizations.

Swagger / OpenAPIÂ¶

The main feature I wanted from Django REST Framework was the automatic API documentation.

Then I found that there was a standard to document APIs, using JSON (or YAML, an extension of JSON) called Swagger.

And there was a web user interface for Swagger APIs already created. So, being able to generate Swagger documentation for an API would allow using this web user interface automatically.

At some point, Swagger was given to the Linux Foundation, to be renamed OpenAPI.

That's why when talking about version 2.0 it's common to say "Swagger", and for version 3+ "OpenAPI".

Inspired FastAPI to

Adopt and use an open standard for API specifications, instead of a custom schema.

And integrate standards-based user interface tools:

    Swagger UI
    ReDoc

These two were chosen for being fairly popular and stable, but doing a quick search, you could find dozens of alternative user interfaces for OpenAPI (that you can use with FastAPI).
Flask REST frameworksÂ¶

There are several Flask REST frameworks, but after investing the time and work into investigating them, I found that many are discontinued or abandoned, with several standing issues that made them unfit.
MarshmallowÂ¶

One of the main features needed by API systems is data "serialization" which is taking data from the code (Python) and converting it into something that can be sent through the network. For example, converting an object containing data from a database into a JSON object. Converting datetime objects into strings, etc.

Another big feature needed by APIs is data validation, making sure that the data is valid, given certain parameters. For example, that some field is an int, and not some random string. This is especially useful for incoming data.

Without a data validation system, you would have to do all the checks by hand, in code.

These features are what Marshmallow was built to provide. It is a great library, and I have used it a lot before.

But it was created before there existed Python type hints. So, to define every schema you need to use specific utils and classes provided by Marshmallow.

Inspired FastAPI to

Use code to define "schemas" that provide data types and validation, automatically.
WebargsÂ¶

Another big feature required by APIs is parsing data from incoming requests.

Webargs is a tool that was made to provide that on top of several frameworks, including Flask.

It uses Marshmallow underneath to do the data validation. And it was created by the same developers.

It's a great tool and I have used it a lot too, before having FastAPI.

Info

Webargs was created by the same Marshmallow developers.

Inspired FastAPI to

Have automatic validation of incoming request data.
APISpecÂ¶

Marshmallow and Webargs provide validation, parsing and serialization as plug-ins.

But documentation is still missing. Then APISpec was created.

It is a plug-in for many frameworks (and there's a plug-in for Starlette too).

The way it works is that you write the definition of the schema using YAML format inside the docstring of each function handling a route.

And it generates OpenAPI schemas.

That's how it works in Flask, Starlette, Responder, etc.

But then, we have again the problem of having a micro-syntax, inside of a Python string (a big YAML).

The editor can't help much with that. And if we modify parameters or Marshmallow schemas and forget to also modify that YAML docstring, the generated schema would be obsolete.

Info

APISpec was created by the same Marshmallow developers.

Inspired FastAPI to

Support the open standard for APIs, OpenAPI.
Flask-apispecÂ¶

It's a Flask plug-in, that ties together Webargs, Marshmallow and APISpec.

It uses the information from Webargs and Marshmallow to automatically generate OpenAPI schemas, using APISpec.

It's a great tool, very underrated. It should be way more popular than many Flask plug-ins out there. It might be due to its documentation being too concise and abstract.

This solved having to write YAML (another syntax) inside of Python docstrings.

This combination of Flask, Flask-apispec with Marshmallow and Webargs was my favorite backend stack until building FastAPI.

Using it led to the creation of several Flask full-stack generators. These are the main stacks I (and several external teams) have been using up to now:

    https://github.com/tiangolo/full-stack
    https://github.com/tiangolo/full-stack-flask-couchbase
    https://github.com/tiangolo/full-stack-flask-couchdb

And these same full-stack generators were the base of the FastAPI Project Generators.

Info

Flask-apispec was created by the same Marshmallow developers.

Inspired FastAPI to

Generate the OpenAPI schema automatically, from the same code that defines serialization and validation.
NestJS (and Angular)Â¶

This isn't even Python, NestJS is a JavaScript (TypeScript) NodeJS framework inspired by Angular.

It achieves something somewhat similar to what can be done with Flask-apispec.

It has an integrated dependency injection system, inspired by Angular 2. It requires pre-registering the "injectables" (like all the other dependency injection systems I know), so, it adds to the verbosity and code repetition.

As the parameters are described with TypeScript types (similar to Python type hints), editor support is quite good.

But as TypeScript data is not preserved after compilation to JavaScript, it cannot rely on the types to define validation, serialization and documentation at the same time. Due to this and some design decisions, to get validation, serialization and automatic schema generation, it's needed to add decorators in many places. So, it becomes quite verbose.

It can't handle nested models very well. So, if the JSON body in the request is a JSON object that has inner fields that in turn are nested JSON objects, it cannot be properly documented and validated.

Inspired FastAPI to

Use Python types to have great editor support.

Have a powerful dependency injection system. Find a way to minimize code repetition.
SanicÂ¶

It was one of the first extremely fast Python frameworks based on asyncio. It was made to be very similar to Flask.

Technical Details

It used uvloop instead of the default Python asyncio loop. That's what made it so fast.

It clearly inspired Uvicorn and Starlette, that are currently faster than Sanic in open benchmarks.

Inspired FastAPI to

Find a way to have a crazy performance.

That's why FastAPI is based on Starlette, as it is the fastest framework available (tested by third-party benchmarks).
FalconÂ¶

Falcon is another high performance Python framework, it is designed to be minimal, and work as the foundation of other frameworks like Hug.

It is designed to have functions that receive two parameters, one "request" and one "response". Then you "read" parts from the request, and "write" parts to the response. Because of this design, it is not possible to declare request parameters and bodies with standard Python type hints as function parameters.

So, data validation, serialization, and documentation, have to be done in code, not automatically. Or they have to be implemented as a framework on top of Falcon, like Hug. This same distinction happens in other frameworks that are inspired by Falcon's design, of having one request object and one response object as parameters.

Inspired FastAPI to

Find ways to get great performance.

Along with Hug (as Hug is based on Falcon) inspired FastAPI to declare a response parameter in functions.

Although in FastAPI it's optional, and is used mainly to set headers, cookies, and alternative status codes.
MoltenÂ¶

I discovered Molten in the first stages of building FastAPI. And it has quite similar ideas:

    Based on Python type hints.
    Validation and documentation from these types.
    Dependency Injection system.

It doesn't use a data validation, serialization and documentation third-party library like Pydantic, it has its own. So, these data type definitions would not be reusable as easily.

It requires a little bit more verbose configurations. And as it is based on WSGI (instead of ASGI), it is not designed to take advantage of the high performance provided by tools like Uvicorn, Starlette and Sanic.

The dependency injection system requires pre-registration of the dependencies and the dependencies are solved based on the declared types. So, it's not possible to declare more than one "component" that provides a certain type.

Routes are declared in a single place, using functions declared in other places (instead of using decorators that can be placed right on top of the function that handles the endpoint). This is closer to how Django does it than to how Flask (and Starlette) does it. It separates in the code things that are relatively tightly coupled.

Inspired FastAPI to

Define extra validations for data types using the "default" value of model attributes. This improves editor support, and it was not available in Pydantic before.

This actually inspired updating parts of Pydantic, to support the same validation declaration style (all this functionality is now already available in Pydantic).
HugÂ¶

Hug was one of the first frameworks to implement the declaration of API parameter types using Python type hints. This was a great idea that inspired other tools to do the same.

It used custom types in its declarations instead of standard Python types, but it was still a huge step forward.

It also was one of the first frameworks to generate a custom schema declaring the whole API in JSON.

It was not based on a standard like OpenAPI and JSON Schema. So it wouldn't be straightforward to integrate it with other tools, like Swagger UI. But again, it was a very innovative idea.

It has an interesting, uncommon feature: using the same framework, it's possible to create APIs and also CLIs.

As it is based on the previous standard for synchronous Python web frameworks (WSGI), it can't handle Websockets and other things, although it still has high performance too.

Info

Hug was created by Timothy Crosley, the same creator of isort, a great tool to automatically sort imports in Python files.

Ideas inspiring FastAPI

Hug inspired parts of APIStar, and was one of the tools I found most promising, alongside APIStar.

Hug helped inspiring FastAPI to use Python type hints to declare parameters, and to generate a schema defining the API automatically.

Hug inspired FastAPI to declare a response parameter in functions to set headers and cookies.
APIStar (<= 0.5)Â¶

Right before deciding to build FastAPI I found APIStar server. It had almost everything I was looking for and had a great design.

It was one of the first implementations of a framework using Python type hints to declare parameters and requests that I ever saw (before NestJS and Molten). I found it more or less at the same time as Hug. But APIStar used the OpenAPI standard.

It had automatic data validation, data serialization and OpenAPI schema generation based on the same type hints in several places.

Body schema definitions didn't use the same Python type hints like Pydantic, it was a bit more similar to Marshmallow, so, editor support wouldn't be as good, but still, APIStar was the best available option.

It had the best performance benchmarks at the time (only surpassed by Starlette).

At first, it didn't have an automatic API documentation web UI, but I knew I could add Swagger UI to it.

It had a dependency injection system. It required pre-registration of components, as other tools discussed above. But still, it was a great feature.

I was never able to use it in a full project, as it didn't have security integration, so, I couldn't replace all the features I was having with the full-stack generators based on Flask-apispec. I had in my backlog of projects to create a pull request adding that functionality.

But then, the project's focus shifted.

It was no longer an API web framework, as the creator needed to focus on Starlette.

Now APIStar is a set of tools to validate OpenAPI specifications, not a web framework.

Info

APIStar was created by Tom Christie. The same guy that created:

    Django REST Framework
    Starlette (in which FastAPI is based)
    Uvicorn (used by Starlette and FastAPI)

Inspired FastAPI to

Exist.

The idea of declaring multiple things (data validation, serialization and documentation) with the same Python types, that at the same time provided great editor support, was something I considered a brilliant idea.

And after searching for a long time for a similar framework and testing many different alternatives, APIStar was the best option available.

Then APIStar stopped to exist as a server and Starlette was created, and was a new better foundation for such a system. That was the final inspiration to build FastAPI.

I consider FastAPI a "spiritual successor" to APIStar, while improving and increasing the features, typing system, and other parts, based on the learnings from all these previous tools.
Used by FastAPIÂ¶
PydanticÂ¶

Pydantic is a library to define data validation, serialization and documentation (using JSON Schema) based on Python type hints.

That makes it extremely intuitive.

It is comparable to Marshmallow. Although it's faster than Marshmallow in benchmarks. And as it is based on the same Python type hints, the editor support is great.

FastAPI uses it to

Handle all the data validation, data serialization and automatic model documentation (based on JSON Schema).

FastAPI then takes that JSON Schema data and puts it in OpenAPI, apart from all the other things it does.
StarletteÂ¶

Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high-performance asyncio services.

It is very simple and intuitive. It's designed to be easily extensible, and have modular components.

It has:

    Seriously impressive performance.
    WebSocket support.
    In-process background tasks.
    Startup and shutdown events.
    Test client built on HTTPX.
    CORS, GZip, Static Files, Streaming responses.
    Session and Cookie support.
    100% test coverage.
    100% type annotated codebase.
    Few hard dependencies.

Starlette is currently the fastest Python framework tested. Only surpassed by Uvicorn, which is not a framework, but a server.

Starlette provides all the basic web microframework functionality.

But it doesn't provide automatic data validation, serialization or documentation.

That's one of the main things that FastAPI adds on top, all based on Python type hints (using Pydantic). That, plus the dependency injection system, security utilities, OpenAPI schema generation, etc.

Technical Details

ASGI is a new "standard" being developed by Django core team members. It is still not a "Python standard" (a PEP), although they are in the process of doing that.

Nevertheless, it is already being used as a "standard" by several tools. This greatly improves interoperability, as you could switch Uvicorn for any other ASGI server (like Daphne or Hypercorn), or you could add ASGI compatible tools, like python-socketio.

FastAPI uses it to

Handle all the core web parts. Adding features on top.

The class FastAPI itself inherits directly from the class Starlette.

So, anything that you can do with Starlette, you can do it directly with FastAPI, as it is basically Starlette on steroids.
UvicornÂ¶

Uvicorn is a lightning-fast ASGI server, built on uvloop and httptools.

It is not a web framework, but a server. For example, it doesn't provide tools for routing by paths. That's something that a framework like Starlette (or FastAPI) would provide on top.

It is the recommended server for Starlette and FastAPI.

FastAPI recommends it as

The main web server to run FastAPI applications.

You can also use the --workers command line option to have an asynchronous multi-process server.

Check more details in the Deployment section.
Benchmarks and speedÂ¶

To understand, compare, and see the difference between Uvicorn, Starlette and FastAPI, check the section about Benchmarks.
Previous
About
Next
History, Design and Future
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs

Skip to content
Subscribe to the FastAPI and friends newsletter ğŸ‰
logo
FastAPI
History, Design and Future

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    About
        Alternatives, Inspiration and Comparisons
        History, Design and Future
        Benchmarks
        Repository Management

Table of contents

    Alternatives
    Investigation
    Design
    Requirements
    Development
    Future

    FastAPI
    About

History, Design and FutureÂ¶

Some time ago, a FastAPI user asked:

    Whatâ€™s the history of this project? It seems to have come from nowhere to awesome in a few weeks [...]

Here's a little bit of that history.
AlternativesÂ¶

I have been creating APIs with complex requirements for several years (Machine Learning, distributed systems, asynchronous jobs, NoSQL databases, etc), leading several teams of developers.

As part of that, I needed to investigate, test and use many alternatives.

The history of FastAPI is in great part the history of its predecessors.

As said in the section Alternatives:

    FastAPI wouldn't exist if not for the previous work of others.

    There have been many tools created before that have helped inspire its creation.

    I have been avoiding the creation of a new framework for several years. First I tried to solve all the features covered by FastAPI using many different frameworks, plug-ins, and tools.

    But at some point, there was no other option than creating something that provided all these features, taking the best ideas from previous tools, and combining them in the best way possible, using language features that weren't even available before (Python 3.6+ type hints).

InvestigationÂ¶

By using all the previous alternatives I had the chance to learn from all of them, take ideas, and combine them in the best way I could find for myself and the teams of developers I have worked with.

For example, it was clear that ideally it should be based on standard Python type hints.

Also, the best approach was to use already existing standards.

So, before even starting to code FastAPI, I spent several months studying the specs for OpenAPI, JSON Schema, OAuth2, etc. Understanding their relationship, overlap, and differences.
DesignÂ¶

Then I spent some time designing the developer "API" I wanted to have as a user (as a developer using FastAPI).

I tested several ideas in the most popular Python editors: PyCharm, VS Code, Jedi based editors.

By the last Python Developer Survey, that covers about 80% of the users.

It means that FastAPI was specifically tested with the editors used by 80% of the Python developers. And as most of the other editors tend to work similarly, all its benefits should work for virtually all editors.

That way I could find the best ways to reduce code duplication as much as possible, to have completion everywhere, type and error checks, etc.

All in a way that provided the best development experience for all the developers.
RequirementsÂ¶

After testing several alternatives, I decided that I was going to use Pydantic for its advantages.

Then I contributed to it, to make it fully compliant with JSON Schema, to support different ways to define constraint declarations, and to improve editor support (type checks, autocompletion) based on the tests in several editors.

During the development, I also contributed to Starlette, the other key requirement.
DevelopmentÂ¶

By the time I started creating FastAPI itself, most of the pieces were already in place, the design was defined, the requirements and tools were ready, and the knowledge about the standards and specifications was clear and fresh.
FutureÂ¶

By this point, it's already clear that FastAPI with its ideas is being useful for many people.

It is being chosen over previous alternatives for suiting many use cases better.

Many developers and teams already depend on FastAPI for their projects (including me and my team).

But still, there are many improvements and features to come.

FastAPI has a great future ahead.

And your help is greatly appreciated.
Previous
Alternatives, Inspiration and Comparisons
Next
Benchmarks
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs


Skip to content
Join the FastAPI Cloud waiting list ğŸš€
logo
FastAPI
Benchmarks

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    About
        Alternatives, Inspiration and Comparisons
        History, Design and Future
        Benchmarks
        Repository Management

Table of contents

    Benchmarks and speed

    FastAPI
    About

BenchmarksÂ¶

Independent TechEmpower benchmarks show FastAPI applications running under Uvicorn as one of the fastest Python frameworks available, only below Starlette and Uvicorn themselves (used internally by FastAPI).

But when checking benchmarks and comparisons you should keep the following in mind.
Benchmarks and speedÂ¶

When you check the benchmarks, it is common to see several tools of different types compared as equivalent.

Specifically, to see Uvicorn, Starlette and FastAPI compared together (among many other tools).

The simpler the problem solved by the tool, the better performance it will get. And most of the benchmarks don't test the additional features provided by the tool.

The hierarchy is like:

    Uvicorn: an ASGI server
        Starlette: (uses Uvicorn) a web microframework
            FastAPI: (uses Starlette) an API microframework with several additional features for building APIs, with data validation, etc.

    Uvicorn:
        Will have the best performance, as it doesn't have much extra code apart from the server itself.
        You wouldn't write an application in Uvicorn directly. That would mean that your code would have to include more or less, at least, all the code provided by Starlette (or FastAPI). And if you did that, your final application would have the same overhead as having used a framework and minimizing your app code and bugs.
        If you are comparing Uvicorn, compare it against Daphne, Hypercorn, uWSGI, etc. Application servers.
    Starlette:
        Will have the next best performance, after Uvicorn. In fact, Starlette uses Uvicorn to run. So, it probably can only get "slower" than Uvicorn by having to execute more code.
        But it provides you the tools to build simple web applications, with routing based on paths, etc.
        If you are comparing Starlette, compare it against Sanic, Flask, Django, etc. Web frameworks (or microframeworks).
    FastAPI:
        The same way that Starlette uses Uvicorn and cannot be faster than it, FastAPI uses Starlette, so it cannot be faster than it.
        FastAPI provides more features on top of Starlette. Features that you almost always need when building APIs, like data validation and serialization. And by using it, you get automatic documentation for free (the automatic documentation doesn't even add overhead to running applications, it is generated on startup).
        If you didn't use FastAPI and used Starlette directly (or another tool, like Sanic, Flask, Responder, etc) you would have to implement all the data validation and serialization yourself. So, your final application would still have the same overhead as if it was built using FastAPI. And in many cases, this data validation and serialization is the biggest amount of code written in applications.
        So, by using FastAPI you are saving development time, bugs, lines of code, and you would probably get the same performance (or better) you would if you didn't use it (as you would have to implement it all in your code).
        If you are comparing FastAPI, compare it against a web application framework (or set of tools) that provides data validation, serialization and documentation, like Flask-apispec, NestJS, Molten, etc. Frameworks with integrated automatic data validation, serialization and documentation.

Previous
History, Design and Future
Next
Repository Management
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs






Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
Repository Management

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

    About
        Alternatives, Inspiration and Comparisons
        History, Design and Future
        Benchmarks
        Repository Management

Table of contents

    Owner
    Team
    FastAPI Experts
    External Contributions

    FastAPI
    About

Repository ManagementÂ¶

Here's a short description of how the FastAPI repository is managed and maintained.
OwnerÂ¶

I, @tiangolo, am the creator and owner of the FastAPI repository. ğŸ¤“

I normally give the final review to each PR before merging them. I make the final decisions on the project, I'm the BDFL. ğŸ˜…
TeamÂ¶

There's a team of people that help manage and maintain the project. ğŸ˜

They have different levels of permissions and specific instructions.

Some of the tasks they can perform include:

    Adding labels to PRs.
    Editing PR titles.
    Adding commits on top of PRs to tweak them.
    Mark answers in GitHub Discussions questions, etc.
    Merge some specific types of PRs.

You can see the current team members in FastAPI People - Team.

Joining the team is by invitation only, and I could update or remove permissions, instructions, or membership.
FastAPI ExpertsÂ¶

The people that help others the most in GitHub Discussions can become FastAPI Experts.

This is normally the best way to contribute to the project.
External ContributionsÂ¶

External contributions are very welcome and appreciated, including answering questions, submitting PRs, etc. ğŸ™‡â€â™‚ï¸

There are many ways to help maintain FastAPI.
Previous
Benchmarks
Next
Release Notes
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



Skip to content
Follow @fastapi on X (Twitter) to stay updated
logo
FastAPI
Release Notes

    en - English
    de - Deutsch
    es - espaÃ±ol
    fa - ÙØ§Ø±Ø³ÛŒ
    fr - franÃ§ais
    ja - æ—¥æœ¬èª
    ko - í•œêµ­ì–´
    pt - portuguÃªs
    ru - Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
    tr - TÃ¼rkÃ§e
    uk - ÑƒĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°
    vi - Tiáº¿ng Viá»‡t
    zh - ç®€ä½“ä¸­æ–‡
    zh-hant - ç¹é«”ä¸­æ–‡
    ğŸ˜‰

Type to start searching
fastapi/fastapi

    0.121.2
    92.1k
    8.2k

    FastAPI
    Features
    Learn
    Reference
    FastAPI People
    Resources
    About
    Release Notes

Table of contents

    Latest Changes
        Docs
    0.121.2
        Fixes
        Docs
        Translations
    0.121.1
        Fixes
        Docs
        Internal
    0.121.0
        Features
        Internal
    0.120.4
        Fixes
    0.120.3
        Refactors
        Docs
    0.120.2
        Fixes
        Internal
    0.120.1
        Upgrades
        Internal
    0.120.0
        Translations
        Internal
    0.119.1
        Fixes
        Docs
        Internal
    0.119.0
        Features
    0.118.3
        Upgrades
    0.118.2
        Fixes
        Internal
    0.118.1
        Upgrades
        Docs
        Translations
        Internal
    0.118.0
        Fixes
        Docs
        Translations
        Internal
    0.117.1
        Fixes
    0.117.0
        Features
        Fixes
        Refactors
        Docs
        Translations
        Internal
    0.116.2
        Upgrades
        Docs
        Translations
        Internal
    0.116.1
        Upgrades
        Docs
        Internal
    0.116.0
        Features
        Translations
        Internal
    0.115.14
        Fixes
        Docs
        Translations
        Internal
    0.115.13
        Fixes
        Refactors
        Upgrades
        Docs
        Translations
        Internal
    0.115.12
        Fixes
        Docs
        Translations
        Internal
    0.115.11
        Fixes
        Translations
        Internal
    0.115.10
        Fixes
        Upgrades
        Translations
    0.115.9
        Fixes
        Refactors
        Docs
        Translations
        Internal
    0.115.8
        Fixes
        Refactors
        Docs
        Translations
        Internal
    0.115.7
        Upgrades
        Refactors
        Docs
        Translations
        Internal
    0.115.6
        Fixes
        Refactors
        Docs
        Translations
        Internal
    0.115.5
        Refactors
        Docs
        Translations
        Internal
    0.115.4
        Refactors
        Docs
        Translations
        Internal
    0.115.3
        Upgrades
        Docs
        Translations
        Internal
    0.115.2
        Upgrades
    0.115.1
        Fixes
        Refactors
        Docs
        Translations
        Internal
    0.115.0
        Highlights
            Query Parameter Models
            Header Parameter Models
            Cookie Parameter Models
            Forbid Extra Query (Cookie, Header) Parameters
        Features
        Translations
        Internal
    0.114.2
        Fixes
        Translations
        Internal
    0.114.1
        Refactors
        Docs
        Translations
        Internal
    0.114.0
        Features
        Docs
        Internal
    0.113.0
        Features
        Internal
    0.112.4
        Refactors
        Internal
    0.112.3
        Refactors
        Docs
        Translations
        Internal
    0.112.2
        Fixes
        Refactors
        Docs
        Translations
        Internal
    0.112.1
        Upgrades
        Docs
        Translations
        Internal
    0.112.0
        Breaking Changes
            Summary
            Other Changes
            Technical Details
        Docs
        Translations
        Internal
    0.111.1
        Upgrades
        Docs
        Translations
        Internal
    0.111.0
        Features
        Refactors
    0.110.3
        Docs
        Translations
        Internal
    0.110.2
        Fixes
        Refactors
        Docs
        Translations
        Internal
    0.110.1
        Fixes
        Refactors
        Upgrades
        Docs
        Translations
        Internal
    0.110.0
        Breaking Changes
        Docs
        Translations
    0.109.2
        Upgrades
        Translations
        Internal
    0.109.1
        Security fixes
        Features
        Refactors
        Docs
        Translations
        Internal
    0.109.0
        Features
        Upgrades
        Docs
        Translations
        Internal
    0.108.0
        Upgrades
    0.107.0
        Upgrades
        Docs
    0.106.0
        Breaking Changes
        Dependencies with yield, HTTPException and Background Tasks
        Features
        Internal
    0.105.0
        Features
        Refactors
        Docs
        Internal
    0.104.1
        Fixes
        Docs
        Internal
    0.104.0
    Features
    Upgrades
        Internal
    0.103.2
        Refactors
        Translations
        Internal
    0.103.1
        Fixes
        Docs
        Translations
        Refactors
        Internal
    0.103.0
        Features
        Docs
    0.102.0
        Features
        Refactors
        Docs
        Internal
    0.101.1
        Fixes
        Refactors
        Docs
        Translations
        Internal
    0.101.0
        Features
        Refactors
        Upgrades
        Translations
        Internal
    0.100.1
        Fixes
        Docs
        Translations
        Internal
    0.100.0
        Migration
        Pydantic v1
        Changes
    0.99.1
        Fixes
        Docs
    0.99.0
        Features
        Docs
        Translations
        Internal
    0.98.0
        Features
        Docs
        Translations
        Internal
    0.97.0
        Features
        Refactors
        Upgrades
        Internal
    0.96.1
        Fixes
        Upgrades
        Refactors
        Docs
        Translations
        Internal
    0.96.0
        Features
        Docs
        Translations
        Internal
    0.95.2
        Translations
        Internal
    0.95.1
        Fixes
        Docs
        Translations
        Internal
    0.95.0
        Highlights
        Features
        Docs
    0.94.1
        Fixes
    0.94.0
        Upgrades
        Docs
        Translations
        Internal
    0.93.0
        Features
        Docs
        Translations
        Internal
    0.92.0
        Upgrades
    0.91.0
        Upgrades
    0.90.1
        Upgrades
        Docs
        Translations
        Internal
    0.90.0
        Upgrades
        Docs
        Translations
        Internal
    0.89.1
        Fixes
        Docs
        Translations
    0.89.0
        Features
        Docs
        Translations
        Internal
    0.88.0
        Upgrades
        Docs
        Translations
        Internal
    0.87.0
        Features
        Docs
        Translations
        Internal
    0.86.0
        Features
        Fixes
        Docs
        Translations
        Internal
    0.85.2
        Docs
        Translations
        Internal
    0.85.1
        Fixes
        Docs
        Internal
    0.85.0
        Features
        Internal
    0.84.0
        Breaking Changes
    0.83.0
        Features
        Fixes
        Docs
        Internal
    0.82.0
        Features
        Fixes
        Docs
        Translations
        Internal
    0.81.0
        Features
        Fixes
        Docs
        Translations
        Internal
    0.80.0
        Breaking Changes - Fixes
        Fixes
        Translations
    0.79.1
        Fixes
        Docs
        Translations
        Internal
    0.79.0
        Fixes - Breaking Changes
        Translations
        Internal
    0.78.0
        Features
        Docs
        Translations
        Internal
    0.77.1
        Upgrades
        Docs
        Translations
        Internal
    0.77.0
        Upgrades
        Docs
        Translations
    0.76.0
        Upgrades
        Internal
    0.75.2
        Fixes
        Upgrades
        Internal
    0.75.1
        Translations
        Internal
    0.75.0
        Features
    0.74.1
        Features
    0.74.0
        Breaking Changes
        Features
        Internal
    0.73.0
        Features
        Docs
        Fixes
        Internal
    0.72.0
        Features
        Docs
        Translations
        Internal
    0.71.0
        Features
        Internal
    0.70.1
        Fixes
        Translations
        Internal
    0.70.0
        Breaking Changes - Upgrade
    0.69.0
        Breaking Changes - Upgrade
        Features
        Docs
        Translations
        Internal
    0.68.2
        Features
        Docs
        Translations
        Internal
    0.68.1
        Translations
        Internal
    0.68.0
        Features
        Docs
        Translations
        Internal
    0.67.0
        Features
        Docs
        Internal
    0.66.1
        Translations
        Internal
    0.66.0
        Features
        Fixes
        Translations
    0.65.3
        Fixes
        Translations
        Internal
    0.65.2
        Security fixes
        Internal
    0.65.1
        Security fixes
    0.65.0
        Breaking Changes - Upgrade
        Translations
        Internal
    0.64.0
        Features
        Fixes
        Docs
        Translations
        Internal
    0.63.0
        Features
        Breaking changes
        Fixes
        Docs
        Translations
        Internal
    0.62.0
        Features
        Breaking Changes
        Docs
        Translations
        Internal
    0.61.2
        Fixes
        Docs
        Translations
        Internal
    0.61.1
        Fixes
        Docs
        Translations
        Internal
    0.61.0
        Features
        Breaking Changes
        Docs
        Internal
    0.60.2
    0.60.1
    0.60.0
    0.59.0
    0.58.1
    0.58.0
    0.57.0
    0.56.1
    0.56.0
    0.55.1
    0.55.0
    0.54.2
    0.54.1
    0.54.0
    0.53.2
    0.53.1
    0.53.0
    0.52.0
    0.51.0
    0.50.0
    0.49.2
    0.49.1
    0.49.0
    0.48.0
    0.47.1
    0.47.0
    0.46.0
    0.45.0
    0.44.1
    0.44.0
    0.43.0
    0.42.0
    0.41.0
    0.40.0
    0.39.0
    0.38.1
    0.38.0
    0.37.0
    0.36.0
    0.35.0
    0.34.0
    0.33.0
    0.32.0
    0.31.0
    0.30.1
    0.30.0
    0.29.1
    0.29.0
    0.28.0
    0.27.2
    0.27.1
    0.27.0
    0.26.0
    0.25.0
    0.24.0
    0.23.0
    0.22.0
    0.21.0
    0.20.1
    0.20.0
    0.19.0
    0.18.0
    0.17.0
    0.16.0
    0.15.0
    0.14.0
    0.13.0
    0.12.1
    0.12.0
    0.11.0
    0.10.3
    0.10.2
    0.10.1
    0.10.0
    0.9.1
    0.9.0
    0.8.0
    0.7.1
    0.7.0
    0.6.4
    0.6.3
    0.6.2
    0.6.1
    0.6.0
    0.5.1
    0.5.0
    0.4.0
    0.3.0
    0.2.1
    0.2.0
    0.1.19

Release NotesÂ¶
Latest ChangesÂ¶
DocsÂ¶

    ğŸ“ Add missing hash part. PR #14369 by @nilslindemann.
    ğŸ“ Fix typos in code comments. PR #14364 by @Edge-Seven.
    ğŸ“ Add docs for using FastAPI Cloud. PR #14359 by @tiangolo.

0.121.2Â¶
FixesÂ¶

    ğŸ› Fix handling of JSON Schema attributes named "$ref". PR #14349 by @tiangolo.

DocsÂ¶

    ğŸ“ Add EuroPython talk & podcast episode with SebastiÃ¡n RamÃ­rez. PR #14260 by @clytaemnestra.
    âœï¸ Fix links and add missing permalink in docs. PR #14217 by @YuriiMotov.

TranslationsÂ¶

    ğŸŒ Update Portuguese translations with LLM prompt. PR #14228 by @ceb10n.
    ğŸ”¨ Add Portuguese translations LLM prompt. PR #14208 by @ceb10n.
    ğŸŒ Sync Russian docs. PR #14331 by @YuriiMotov.
    ğŸŒ Sync German docs. PR #14317 by @nilslindemann.

0.121.1Â¶
FixesÂ¶

    ğŸ› Fix Depends(func, scope='function') for top level (parameterless) dependencies. PR #14301 by @luzzodev.

DocsÂ¶

    ğŸ“ Upate docs for advanced dependencies with yield, noting the changes in 0.121.0, adding scope. PR #14287 by @tiangolo.

InternalÂ¶

    â¬† Bump ruff from 0.13.2 to 0.14.3. PR #14276 by @dependabot[bot].
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #14289 by @pre-commit-ci[bot].

0.121.0Â¶
FeaturesÂ¶

    âœ¨ Add support for dependencies with scopes, support scope="request" for dependencies with yield that exit before the response is sent. PR #14262 by @tiangolo.
        New docs: Dependencies with yield - Early exit and scope.

InternalÂ¶

    ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR #14273 by @tiangolo.
    ğŸ‘¥ Update FastAPI People - Sponsors. PR #14274 by @tiangolo.
    ğŸ‘¥ Update FastAPI GitHub topic repositories. PR #14280 by @tiangolo.
    â¬† Bump mkdocs-macros-plugin from 1.4.0 to 1.4.1. PR #14277 by @dependabot[bot].
    â¬† Bump mkdocstrings[python] from 0.26.1 to 0.30.1. PR #14279 by @dependabot[bot].

0.120.4Â¶
FixesÂ¶

    ğŸ› Fix security schemes in OpenAPI when added at the top level app. PR #14266 by @YuriiMotov.

0.120.3Â¶
RefactorsÂ¶

    â™»ï¸ Reduce internal cyclic recursion in dependencies, from 2 functions calling each other to 1 calling itself. PR #14256 by @tiangolo.
    â™»ï¸ Refactor internals of dependencies, simplify code and remove get_param_sub_dependant. PR #14255 by @tiangolo.
    â™»ï¸ Refactor internals of dependencies, simplify using dataclasses. PR #14254 by @tiangolo.

DocsÂ¶

    ğŸ“ Update note for untranslated pages. PR #14257 by @YuriiMotov.

0.120.2Â¶
FixesÂ¶

    ğŸ› Fix separation of schemas with nested models introduced in 0.119.0. PR #14246 by @tiangolo.

InternalÂ¶

    ğŸ”§ Add sponsor: SerpApi. PR #14248 by @tiangolo.
    â¬† Bump actions/download-artifact from 5 to 6. PR #14236 by @dependabot[bot].
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #14237 by @pre-commit-ci[bot].
    â¬† Bump actions/upload-artifact from 4 to 5. PR #14235 by @dependabot[bot].

0.120.1Â¶
UpgradesÂ¶

    â¬†ï¸ Bump Starlette to <0.50.0. PR #14234 by @YuriiMotov.

InternalÂ¶

    ğŸ”§ Add license and license-files to pyproject.toml, remove License from classifiers. PR #14230 by @YuriiMotov.

0.120.0Â¶

There are no major nor breaking changes in this release. â˜•ï¸

The internal reference documentation now uses annotated_doc.Doc instead of typing_extensions.Doc, this adds a new (very small) dependency on annotated-doc, a package made just to provide that Doc documentation utility class.

I would expect typing_extensions.Doc to be deprecated and then removed at some point from typing_extensions, for that reason there's the new annotated-doc micro-package. If you are curious about this, you can read more in the repo for annotated-doc.

This new version 0.120.0 only contains that transition to the new home package for that utility class Doc.
TranslationsÂ¶

    ğŸŒ Sync German docs. PR #14188 by @nilslindemann.

InternalÂ¶

    â• Migrate internal reference documentation from typing_extensions.Doc to annotated_doc.Doc. PR #14222 by @tiangolo.
    ğŸ› ï¸ Update German LLM prompt and test file. PR #14189 by @nilslindemann.
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #14181 by @pre-commit-ci[bot].

0.119.1Â¶
FixesÂ¶

    ğŸ› Fix internal Pydantic v1 compatibility (warnings) for Python 3.14 and Pydantic 2.12.1. PR #14186 by @svlandeg.

DocsÂ¶

    ğŸ“ Replace starlette.io by starlette.dev and uvicorn.org by uvicorn.dev. PR #14176 by @Kludex.

InternalÂ¶

    ğŸ”§ Add sponsor Requestly. PR #14205 by @tiangolo.
    ğŸ”§ Configure reminder for waiting label in issue-manager. PR #14156 by @YuriiMotov.

0.119.0Â¶

FastAPI now (temporarily) supports both Pydantic v2 models and pydantic.v1 models at the same time in the same app, to make it easier for any FastAPI apps still using Pydantic v1 to gradually but quickly migrate to Pydantic v2.

from fastapi import FastAPI
from pydantic import BaseModel as BaseModelV2
from pydantic.v1 import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None


class ItemV2(BaseModelV2):
    title: str
    summary: str | None = None


app = FastAPI()


@app.post("/items/", response_model=ItemV2)
def create_item(item: Item):
    return {"title": item.name, "summary": item.description}

Adding this feature was a big effort with the main objective of making it easier for the few applications still stuck in Pydantic v1 to migrate to Pydantic v2.

And with this, support for Pydantic v1 is now deprecated and will be removed from FastAPI in a future version soon.

Note: have in mind that the Pydantic team already stopped supporting Pydantic v1 for recent versions of Python, starting with Python 3.14.

You can read in the docs more about how to Migrate from Pydantic v1 to Pydantic v2.
FeaturesÂ¶

    âœ¨ Add support for from pydantic.v1 import BaseModel, mixed Pydantic v1 and v2 models in the same app. PR #14168 by @tiangolo.

0.118.3Â¶
UpgradesÂ¶

    â¬†ï¸ Add support for Python 3.14. PR #14165 by @svlandeg.

0.118.2Â¶
FixesÂ¶

    ğŸ› Fix tagged discriminated union not recognized as body field. PR #12942 by @frankie567.

InternalÂ¶

    â¬† Bump astral-sh/setup-uv from 6 to 7. PR #14167 by @dependabot[bot].

0.118.1Â¶
UpgradesÂ¶

    ğŸ‘½ï¸ Ensure compatibility with Pydantic 2.12.0. PR #14036 by @cjwatson.

DocsÂ¶

    ğŸ“ Add External Link: Getting started with logging in FastAPI. PR #14152 by @itssimon.

TranslationsÂ¶

    ğŸ”¨ Add Russian translations LLM prompt. PR #13936 by @tiangolo.
    ğŸŒ Sync German docs. PR #14149 by @nilslindemann.
    ğŸŒ Add Russian translations for missing pages (LLM-generated). PR #14135 by @YuriiMotov.
    ğŸŒ Update Russian translations for existing pages (LLM-generated). PR #14123 by @YuriiMotov.
    ğŸŒ Remove configuration files for inactive translations. PR #14130 by @tiangolo.

InternalÂ¶

    ğŸ”¨ Move local coverage logic to its own script. PR #14166 by @tiangolo.
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #14161 by @pre-commit-ci[bot].
    â¬† Bump griffe-typingdoc from 0.2.8 to 0.2.9. PR #14144 by @dependabot[bot].
    â¬† Bump mkdocs-macros-plugin from 1.3.9 to 1.4.0. PR #14145 by @dependabot[bot].
    â¬† Bump markdown-include-variants from 0.0.4 to 0.0.5. PR #14146 by @dependabot[bot].
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #14126 by @pre-commit-ci[bot].
    ğŸ‘¥ Update FastAPI GitHub topic repositories. PR #14150 by @tiangolo.
    ğŸ‘¥ Update FastAPI People - Sponsors. PR #14139 by @tiangolo.
    ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR #14138 by @tiangolo.
    â¬† Bump ruff from 0.12.7 to 0.13.2. PR #14147 by @dependabot[bot].
    â¬† Bump sqlmodel from 0.0.24 to 0.0.25. PR #14143 by @dependabot[bot].
    â¬† Bump tiangolo/issue-manager from 0.5.1 to 0.6.0. PR #14148 by @dependabot[bot].
    ğŸ‘· Update docs previews comment, single comment, add failure status. PR #14129 by @tiangolo.
    ğŸ”¨ Modify mkdocs_hooks.py to add title to page's metadata (remove permalinks in social cards). PR #14125 by @YuriiMotov.

0.118.0Â¶
FixesÂ¶

    ğŸ› Fix support for StreamingResponses with dependencies with yield or UploadFiles, close after the response is done. PR #14099 by @tiangolo.

Before FastAPI 0.118.0, if you used a dependency with yield, it would run the exit code after the path operation function returned but right before sending the response.

This change also meant that if you returned a StreamingResponse, the exit code of the dependency with yield would have been already run.

For example, if you had a database session in a dependency with yield, the StreamingResponse would not be able to use that session while streaming data because the session would have already been closed in the exit code after yield.

This behavior was reverted in 0.118.0, to make the exit code after yield be executed after the response is sent.

You can read more about it in the docs for Advanced Dependencies - Dependencies with yield, HTTPException, except and Background Tasks. Including what you could do if you wanted to close a database session earlier, before returning the response to the client.
DocsÂ¶

    ğŸ“ Update tutorial/security/oauth2-jwt/ to use pwdlib with Argon2 instead of passlib. PR #13917 by @Neizvestnyj.
    âœï¸ Fix typos in OAuth2 password request forms. PR #14112 by @alv2017.
    ğŸ“ Update contributing guidelines for installing requirements. PR #14095 by @alejsdev.

TranslationsÂ¶

    ğŸŒ Sync German docs. PR #14098 by @nilslindemann.

InternalÂ¶

    â¬† [pre-commit.ci] pre-commit autoupdate. PR #14103 by @pre-commit-ci[bot].
    â™»ï¸ Refactor sponsor image handling. PR #14102 by @alejsdev.
    ğŸ› Fix sponsor display issue by hiding element on image error. PR #14097 by @alejsdev.
    ğŸ› Hide sponsor badge when sponsor image is not displayed. PR #14096 by @alejsdev.

0.117.1Â¶
FixesÂ¶

    ğŸ› Fix validation error when File is declared after Form parameter. PR #11194 by @thomasleveil.

0.117.0Â¶
FeaturesÂ¶

    âœ¨ Allow None as return type for bodiless responses. PR #9425 by @hofrob.
    âœ¨ Allow array values for OpenAPI schema type field. PR #13639 by @sammasak.
    âœ¨ Add OpenAPI external_docs parameter to FastAPI. PR #13713 by @cmtoro.

FixesÂ¶

    âš¡ï¸ Fix default_factory for response model field with Pydantic V1. PR #9704 by @vvanglro.
    ğŸ› Fix inconsistent processing of model docstring formfeed char with Pydantic V1. PR #6039 by @MaxwellPayne.
    ğŸ› Fix jsonable_encoder alters json_encoders of Pydantic v1 objects. PR #4972 by @aboubacs.
    ğŸ› Reenable allow_arbitrary_types when only 1 argument is used on the API endpoint. PR #13694 by @rmawatson.
    ğŸ› Fix inspect.getcoroutinefunction() can break testing with unittest.mock.patch(). PR #14022 by @secrett2633.

RefactorsÂ¶

    â™»ï¸ Create dependency-cache dict in solve_dependencies only if None (don't re-create if empty). PR #13689 by @bokshitsky.
    âœ… Enable test case for duplicated headers in test_tutorial/test_header_params/test_tutorial003.py. PR #13864 by @Amogha-ark.
    ğŸ“Œ Pin httpx to >=0.23.0,<1.0.0. PR #14086 by @YuriiMotov.

DocsÂ¶

    ğŸ“ Add note about Cookies and JavaScript on tutorial/cookie-params.md. PR #13510 by @Kludex.
    ğŸ“ Remove outdated formatting from path-params-numeric-validations.md for languages en, es and uk.. PR #14059 by @svlandeg.
    ğŸ“ Fix and Improve English Documentation. PR #14048 by @nilslindemann.

TranslationsÂ¶

    ğŸ“ Update prompts and German translation. PR #14015 by @nilslindemann.

InternalÂ¶

    âœ… Simplify tests for response_model. PR #14062 by @dynamicy.
    ğŸš¨ Install pydantic.mypy plugin. PR #14081 by @svlandeg.
    âœ… Add LLM test file. PR #14049 by @nilslindemann.
    ğŸ”¨ Update translations script. PR #13968 by @YuriiMotov.
    ğŸ› ï¸ Update docs.py generate-readme command to remove permalinks from headers. PR #14055 by @YuriiMotov.
    â¬†ï¸ Update mypy to 1.14.1. PR #12970 by @tamird.

0.116.2Â¶
UpgradesÂ¶

    â¬†ï¸ Upgrade Starlette supported version range to >=0.40.0,<0.49.0. PR #14077 by @musicinmybrain.

DocsÂ¶

    ğŸ“ Add documentation for Behind a Proxy - Proxy Forwarded Headers, using --forwarded-allow-ips="*". PR #14028 by @tiangolo.
    ğŸ“ Add deprecation info block about dict() in docs/tutorial/body.md. PR #13906 by @jomkv.
    ğŸ“ Fix Twitter to be X (Twitter) everywhere in documentation. PR #13809 by @valentinDruzhinin.
    ğŸ› Prevent scroll-to-top on restart/fast buttons in termynal.js. PR #13714 by @Ashish-Pandey62.
    ğŸ“ Update testing events documentation. PR #13259 by @z0z0r4.
    ğŸ“ Remove obsolete url field in error responses in docs. PR #13655 by @Taoup.
    ğŸ“ Bring the scope claim in line with the standard in docs_src/security/tutorial005.py. PR #11189 by @DurandA.
    ğŸ“ Update TrustedHostMiddleware Documentation. PR #11441 by @soulee-dev.
    ğŸ“ Remove links to site callbackhell.com that doesn't exist anymore. PR #14006 by @dennybiasiolli.
    ğŸ“ Add permalinks to headers in English docs. PR #13993 by @YuriiMotov.
    ğŸ“ Update docs/en/docs/advanced/generate-clients.md. PR #13793 by @mrlubos.
    ğŸ“ Add discussion template for new language translation requests. PR #13535 by @alejsdev.

TranslationsÂ¶

    ğŸ“ Fix code include for Pydantic models example in docs/zh/docs/python-types.md. PR #13997 by @anfreshman.
    ğŸŒ Update Portuguese Translation for docs/pt/docs/async.md. PR #13863 by @EdmilsonRodrigues.
    ğŸ“ Fix highlight line in docs/ja/docs/tutorial/body.md. PR #13927 by @KoyoMiyazaki.
    ğŸŒ Add Persian translation for docs/fa/docs/environment-variables.md. PR #13923 by @Mohammad222PR.
    ğŸŒ Add Persian translation for docs/fa/docs/python-types.md. PR #13524 by @Mohammad222PR.
    ğŸŒ Update Portuguese Translation for docs/pt/docs/project-generation.md. PR #13875 by @EdmilsonRodrigues.
    ğŸŒ Add Persian translation for docs/fa/docs/async.md. PR #13541 by @Mohammad222PR.
    ğŸŒ Add Bangali translation for docs/bn/about/index.md. PR #13882 by @sajjadrahman56.

InternalÂ¶

    â¬† Bump pyjwt from 2.8.0 to 2.9.0. PR #13960 by @dependabot[bot].
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #14080 by @pre-commit-ci[bot].
    â¬† Bump actions/setup-python from 5 to 6. PR #14042 by @dependabot[bot].
    â¬† Bump actions/labeler from 5 to 6. PR #14046 by @dependabot[bot].
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #14056 by @pre-commit-ci[bot].
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #14035 by @pre-commit-ci[bot].
    â¬† Bump pypa/gh-action-pypi-publish from 1.12.4 to 1.13.0. PR #14041 by @dependabot[bot].
    ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR #14029 by @tiangolo.
    ğŸ‘¥ Update FastAPI People - Sponsors. PR #14030 by @tiangolo.
    ğŸ‘¥ Update FastAPI GitHub topic repositories. PR #14031 by @tiangolo.
    ğŸ‘¥ Update FastAPI People - Experts. PR #14034 by @tiangolo.
    ğŸ‘· Detect and label merge conflicts on PRs automatically. PR #14045 by @svlandeg.
    ğŸ”§ Update sponsors: remove Platform.sh. PR #14027 by @tiangolo.
    ğŸ”§ Update sponsors: remove Mobb. PR #14026 by @tiangolo.
    ğŸ› ï¸ Update mkdocs_hooks to handle headers with permalinks when building docs. PR #14025 by @tiangolo.
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #14016 by @pre-commit-ci[bot].
    â¬† Bump mkdocs-macros-plugin from 1.3.7 to 1.3.9. PR #14003 by @YuriiMotov.
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #13999 by @pre-commit-ci[bot].
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #13983 by @pre-commit-ci[bot].
    â¬† Bump actions/checkout from 4 to 5. PR #13986 by @dependabot[bot].
    ğŸ”§ Update Speakeasy sponsor graphic. PR #13971 by @chailandau.
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #13969 by @pre-commit-ci[bot].
    â¬† Bump actions/download-artifact from 4 to 5. PR #13975 by @dependabot[bot].
    ğŸ‘¥ Update FastAPI People - Experts. PR #13963 by @tiangolo.
    â¬† Bump ruff from 0.11.2 to 0.12.7. PR #13957 by @dependabot[bot].
    â¬† Bump cairosvg from 2.7.1 to 2.8.2. PR #13959 by @dependabot[bot].
    â¬† Bump pydantic-ai from 0.0.30 to 0.4.10. PR #13958 by @dependabot[bot].
    ğŸ‘¥ Update FastAPI GitHub topic repositories. PR #13962 by @tiangolo.
    â¬† Bump mkdocs-material from 9.6.15 to 9.6.16. PR #13961 by @dependabot[bot].
    â¬† Bump tiangolo/latest-changes from 0.3.2 to 0.4.0. PR #13952 by @dependabot[bot].
    ğŸ‘¥ Update FastAPI People - Sponsors. PR #13956 by @tiangolo.
    ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR #13955 by @tiangolo.
    ğŸ”§ Update sponsors: Databento link and sponsors_badge data. PR #13954 by @tiangolo.
    ğŸ”§ Update sponsors: Add Railway. PR #13953 by @tiangolo.
    âš’ï¸ Update translate script, update prompt to minimize generated diff. PR #13947 by @YuriiMotov.
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #13943 by @pre-commit-ci[bot].
    âš’ï¸ Tweak translate script and CI. PR #13939 by @tiangolo.
    ğŸ‘· Add CI to translate with LLMs. PR #13937 by @tiangolo.
    âš’ï¸ Update translate script, show and update outdated translations. PR #13933 by @tiangolo.
    ğŸ”¨ Refactor translate script with extra feedback (prints). PR #13932 by @tiangolo.
    ğŸ”¨ Update translations script to remove old (removed) files. PR #13928 by @tiangolo.
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #13894 by @pre-commit-ci[bot].
    â¬† Update httpx requirement to >=0.23.0,<0.29.0. PR #13114 by @yan12125.
    ğŸ”§ Update sponsors: Add Mobb. PR #13916 by @tiangolo.
    ğŸ‘¥ Update FastAPI People - Experts. PR #13889 by @tiangolo.
    ğŸ”¨ Update FastAPI People sleep interval, use external settings. PR #13888 by @tiangolo.

0.116.1Â¶
UpgradesÂ¶

    â¬†ï¸ Upgrade Starlette supported version range to >=0.40.0,<0.48.0. PR #13884 by @tiangolo.

DocsÂ¶

    ğŸ“ Add notification about impending changes in Translations to docs/en/docs/contributing.md. PR #13886 by @YuriiMotov.

InternalÂ¶

    â¬† [pre-commit.ci] pre-commit autoupdate. PR #13871 by @pre-commit-ci[bot].

0.116.0Â¶
FeaturesÂ¶

    âœ¨ Add support for deploying to FastAPI Cloud with fastapi deploy. PR #13870 by @tiangolo.

Installing fastapi[standard] now includes fastapi-cloud-cli.

This will allow you to deploy to FastAPI Cloud with the fastapi deploy command.

If you want to install fastapi with the standard dependencies but without fastapi-cloud-cli, you can install instead fastapi[standard-no-fastapi-cloud-cli].
TranslationsÂ¶

    ğŸŒ Add Russian translation for docs/ru/docs/advanced/response-directly.md. PR #13801 by @NavesSapnis.
    ğŸŒ Add Russian translation for docs/ru/docs/advanced/additional-status-codes.md. PR #13799 by @NavesSapnis.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/body-updates.md. PR #13804 by @valentinDruzhinin.

InternalÂ¶

    â¬† Bump pillow from 11.1.0 to 11.3.0. PR #13852 by @dependabot[bot].
    ğŸ‘¥ Update FastAPI People - Sponsors. PR #13846 by @tiangolo.
    ğŸ‘¥ Update FastAPI GitHub topic repositories. PR #13848 by @tiangolo.
    â¬† Bump mkdocs-material from 9.6.1 to 9.6.15. PR #13849 by @dependabot[bot].
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #13843 by @pre-commit-ci[bot].
    ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR #13845 by @tiangolo.

0.115.14Â¶
FixesÂ¶

    ğŸ› Fix support for unions when using Form. PR #13827 by @patrick91.

DocsÂ¶

    âœï¸ Fix grammar mistake in docs/en/docs/advanced/response-directly.md. PR #13800 by @NavesSapnis.
    ğŸ“ Update Speakeasy URL to Speakeasy Sandbox. PR #13697 by @ndimares.

TranslationsÂ¶

    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/response-model.md. PR #13792 by @valentinDruzhinin.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/security/index.md. PR #13805 by @valentinDruzhinin.
    âœï¸ Fix typo in docs/ja/docs/tutorial/encoder.md. PR #13815 by @ruzia.
    âœï¸ Fix typo in docs/ja/docs/tutorial/handling-errors.md. PR #13814 by @ruzia.
    âœï¸ Fix typo in docs/ja/docs/tutorial/body-fields.md. PR #13802 by @ruzia.
    ğŸŒ Add Russian translation for docs/ru/docs/advanced/index.md. PR #13797 by @NavesSapnis.

InternalÂ¶

    â¬† [pre-commit.ci] pre-commit autoupdate. PR #13823 by @pre-commit-ci[bot].

0.115.13Â¶
FixesÂ¶

    ğŸ› Fix truncating the model's description with form feed (\f) character for Pydantic V2. PR #13698 by @YuriiMotov.

RefactorsÂ¶

    âœ¨ Add refreshUrl parameter in OAuth2PasswordBearer. PR #11460 by @snosratiershad.
    ğŸš¸ Set format to password for fields password and client_secret in OAuth2PasswordRequestForm, make docs show password fields for passwords. PR #11032 by @Thodoris1999.
    âœ… Simplify tests for settings. PR #13505 by @valentinDruzhinin.
    âœ… Simplify tests for validate_response_recursive. PR #13507 by @valentinDruzhinin.

UpgradesÂ¶

    â¬†ï¸ Update ReDoc to version 2.x. PR #9700 by @joakimnordling.

DocsÂ¶

    ğŸ“ Add annotations to HTTP middleware example. PR #11530 by @Kilo59.
    ğŸ“ Clarify in CORS docs that wildcards and credentials are mutually exclusive. PR #9829 by @dfioravanti.
    âœï¸ Fix typo in docstring. PR #13532 by @comp64.
    ğŸ“ Clarify guidance on using async def without await. PR #13642 by @swastikpradhan1999.
    ğŸ“ Update exclude-parameters-from-openapi documentation links. PR #13600 by @timonrieger.
    ğŸ“ Clarify the middleware execution order in docs. PR #13699 by @YuriiMotov.
    ğŸ± Update Drawio diagrams SVGs, single file per diagram, sans-serif font. PR #13706 by @tiangolo.
    ğŸ“ Update docs for "Help FastAPI", simplify and reduce "sponsor" section. PR #13670 by @tiangolo.
    ğŸ“ Remove unnecessary bullet from docs. PR #13641 by @Adamowoc.
    âœï¸ Fix syntax error in docs/en/docs/tutorial/handling-errors.md. PR #13623 by @gsheni.
    ğŸ“ Fix typo in documentation. PR #13599 by @Taoup.
    ğŸ“ Fix liblab client generation doc link. PR #13571 by @EFord36.
    âœï¸ Fix talk information typo. PR #13544 by @blueswen.
    ğŸ“ Add External Link: Taiwanese talk on FastAPI with observability . PR #13527 by @blueswen.

TranslationsÂ¶

    ğŸŒ Add Russian Translation for docs/ru/docs/advanced/response-change-status-code.md. PR #13791 by @NavesSapnis.
    ğŸŒ Add Persian translation for docs/fa/docs/learn/index.md. PR #13518 by @Mohammad222PR.
    ğŸŒ Add Korean translation for docs/ko/docs/advanced/sub-applications.md. PR #4543 by @NinaHwang.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/schema-extra-example.md. PR #13769 by @valentinDruzhinin.
    âœï¸ Remove redundant words in docs/zh/docs/python-types.md. PR #13774 by @CharleeWa.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/query-param-models.md. PR #13748 by @valentinDruzhinin.
    ğŸŒ Add Bengali translation for docs/bn/docs/environment-variables.md. PR #13629 by @SakibSibly.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/query-params-str-validations.md page. PR #13546 by @valentinDruzhinin.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/cookie-param-models.md. PR #13616 by @EgorOnishchuk.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/extra-models.md. PR #13063 by @timothy-jeong.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/path-params-numeric-validations.md page. PR #13548 by @valentinDruzhinin.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/middleware.md page. PR #13520 by @valentinDruzhinin.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/background-tasks.md page. PR #13502 by @valentinDruzhinin.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/cors.md page. PR #13519 by @valentinDruzhinin.
    ğŸŒ Update Korean translation for docs/ko/docs/advanced/events.md. PR #13487 by @bom1215.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/handling-errors.md page. PR #13420 by @valentinDruzhinin.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/request-form-models.md. PR #13552 by @EgorOnishchuk.
    ğŸ“ Fix internal anchor link in Spanish deployment docs. PR #13737 by @fabianfalon.
    ğŸŒ Update Korean translation for docs/ko/docs/virtual-environments.md. PR #13630 by @sungchan1.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/header-param-models.md. PR #13526 by @minaton-ru.
    ğŸŒ Update Chinese translation for docs/zh/docs/tutorial/index.md. PR #13374 by @Zhongheng-Cheng.
    ğŸŒ Update Chinese translation for docs/zh/docs/deployment/manually.md. PR #13324 by @Zhongheng-Cheng.
    ğŸŒ Update Chinese translation for docs/zh/docs/deployment/server-workers.md. PR #13292 by @Zhongheng-Cheng.
    ğŸŒ Update Chinese translation for docs/zh/docs/tutorial/first-steps.md. PR #13348 by @Zhongheng-Cheng.

InternalÂ¶

    ğŸ”¨ Resolve Pydantic deprecation warnings in internal script. PR #13696 by @emmanuel-ferdman.
    ğŸ”§ Update sponsors: remove Porter. PR #13783 by @tiangolo.
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #13781 by @pre-commit-ci[bot].
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #13757 by @pre-commit-ci[bot].
    â¬† Bump griffe-typingdoc from 0.2.7 to 0.2.8. PR #13751 by @dependabot[bot].
    ğŸ± Update sponsors: Dribia badge size. PR #13773 by @tiangolo.
    ğŸ”§ Update sponsors: add Dribia. PR #13771 by @tiangolo.
    â¬† Bump typer from 0.15.3 to 0.16.0. PR #13752 by @dependabot[bot].
    ğŸ‘¥ Update FastAPI GitHub topic repositories. PR #13754 by @tiangolo.
    ğŸ‘¥ Update FastAPI People - Sponsors. PR #13750 by @tiangolo.
    ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR #13749 by @tiangolo.
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #13736 by @pre-commit-ci[bot].
    ğŸ”§ Update sponsors: Add InterviewPal. PR #13728 by @tiangolo.
    ğŸ”§ Remove Google Analytics. PR #13727 by @tiangolo.
    ğŸ”§ Update sponsors: remove MongoDB. PR #13725 by @tiangolo.
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #13711 by @pre-commit-ci[bot].
    ğŸ”§ Update sponsors: add Subtotal. PR #13701 by @tiangolo.
    ğŸ”§ Update sponsors: remove deepset / Haystack. PR #13700 by @tiangolo.
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #13688 by @pre-commit-ci[bot].
    ğŸ‘¥ Update FastAPI People - Experts. PR #13671 by @tiangolo.
    â¬† Bump typer from 0.12.5 to 0.15.3. PR #13666 by @dependabot[bot].
    â¬† Bump sqlmodel from 0.0.23 to 0.0.24. PR #13665 by @dependabot[bot].
    ğŸ”§ Update Sponsors: Zuplo logo and alt text. PR #13645 by @martyndavies.
    ğŸ‘¥ Update FastAPI GitHub topic repositories. PR #13667 by @tiangolo.
    ğŸ”§ Update links for LinkedIn and bottom. PR #13669 by @tiangolo.
    ğŸ”§ Update sponsors: remove Bump.sh and Coherence. PR #13668 by @tiangolo.
    ğŸ‘¥ Update FastAPI People - Sponsors. PR #13664 by @tiangolo.
    ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR #13662 by @tiangolo.
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #13656 by @pre-commit-ci[bot].
    âœ… Use inline-snapshot to support different Pydantic versions in the test suite. PR #12534 by @15r10nk.
    â¬† Bump astral-sh/setup-uv from 5 to 6. PR #13648 by @dependabot[bot].
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #13634 by @pre-commit-ci[bot].
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #13619 by @pre-commit-ci[bot].
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #13594 by @pre-commit-ci[bot].
    ğŸ‘¥ Update FastAPI People - Experts. PR #13568 by @tiangolo.
    ğŸ‘¥ Update FastAPI GitHub topic repositories. PR #13565 by @tiangolo.
    ğŸ‘¥ Update FastAPI People - Sponsors. PR #13559 by @tiangolo.
    ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR #13558 by @tiangolo.
    â¬† Bump dirty-equals from 0.8.0 to 0.9.0. PR #13561 by @dependabot[bot].
    ğŸ”§ Clean up docs/en/mkdocs.yml configuration file. PR #13542 by @svlandeg.
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #12986 by @pre-commit-ci[bot].

0.115.12Â¶
FixesÂ¶

    ğŸ› Fix convert_underscores=False for header Pydantic models. PR #13515 by @tiangolo.

DocsÂ¶

    ğŸ“ Update docs/en/docs/tutorial/middleware.md. PR #13444 by @Rishat-F.
    ğŸ‘¥ Update FastAPI People - Experts. PR #13493 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/metadata.md page. PR #13459 by @valentinDruzhinin.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/response-status-code.md page. PR #13462 by @valentinDruzhinin.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/cookie-param-models.md page. PR #13460 by @valentinDruzhinin.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/header-param-models.md page. PR #13461 by @valentinDruzhinin.
    ğŸŒ Add Japanese translation for docs/ja/docs/virtual-environments.md. PR #13304 by @k94-ishi.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/security/oauth2-jwt.md. PR #13333 by @yes0ng.
    ğŸŒ Add Vietnamese translation for docs/vi/docs/deployment/cloud.md. PR #13407 by @ptt3199.

InternalÂ¶

    â¬† Bump pydantic-ai from 0.0.15 to 0.0.30. PR #13438 by @dependabot[bot].
    â¬† Bump sqlmodel from 0.0.22 to 0.0.23. PR #13437 by @dependabot[bot].
    â¬† Bump black from 24.10.0 to 25.1.0. PR #13436 by @dependabot[bot].
    â¬† Bump ruff to 0.9.4. PR #13299 by @dependabot[bot].
    ğŸ”§ Update sponsors: pause TestDriven. PR #13446 by @tiangolo.

0.115.11Â¶
FixesÂ¶

    ğŸ› Add docs examples and tests (support) for Annotated custom validations, like AfterValidator, revert #13440. PR #13442 by @tiangolo.
        New docs: Query Parameters and String Validations - Custom Validation.

TranslationsÂ¶

    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/middleware.md. PR #13412 by @alv2017.

InternalÂ¶

    ğŸ‘¥ Update FastAPI GitHub topic repositories. PR #13439 by @tiangolo.
    ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR #13432 by @tiangolo.
    ğŸ‘¥ Update FastAPI People - Sponsors. PR #13433 by @tiangolo.

0.115.10Â¶
FixesÂ¶

    â™»ï¸ Update internal annotation usage for compatibility with Pydantic 2.11. PR #13314 by @Viicos.

UpgradesÂ¶

    â¬†ï¸ Bump Starlette to allow up to 0.46.0: >=0.40.0,<0.47.0. PR #13426 by @musicinmybrain.

TranslationsÂ¶

    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/debugging.md. PR #13370 by @valentinDruzhinin.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/query-params.md. PR #13362 by @valentinDruzhinin.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/path-params.md. PR #13354 by @valentinDruzhinin.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/cookie-param-models.md. PR #13330 by @k94-ishi.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/body-multiple-params.md. PR #13408 by @valentinDruzhinin.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/query-param-models.md. PR #13323 by @k94-ishi.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/body-nested-models.md. PR #13409 by @valentinDruzhinin.
    ğŸŒ Add Vietnamese translation for docs/vi/docs/deployment/versions.md. PR #13406 by @ptt3199.
    ğŸŒ Add Vietnamese translation for docs/vi/docs/deployment/index.md. PR #13405 by @ptt3199.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/request-forms.md. PR #13383 by @valentinDruzhinin.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/testing.md. PR #13371 by @valentinDruzhinin.

0.115.9Â¶
FixesÂ¶

    ğŸ› Ensure that HTTPDigest only raises an exception when auto_error is True. PR #2939 by @arthurio.

RefactorsÂ¶

    âœ… Simplify tests for query_params_str_validations. PR #13218 by @alv2017.
    âœ… Simplify tests for app_testing. PR #13220 by @alv2017.
    âœ… Simplify tests for dependency_testing. PR #13223 by @alv2017.

DocsÂ¶

    ğŸ± Update sponsors: CodeRabbit logo. PR #13424 by @tiangolo.
    ğŸ©º Unify the badges across all tutorial translations. PR #13329 by @svlandeg.
    ğŸ“ Fix typos in virtual environments documentation. PR #13396 by @bullet-ant.
    ğŸ› Fix issue with Swagger theme change example in the official tutorial. PR #13289 by @Zerohertz.
    ğŸ“ Add more precise description of HTTP status code range in docs. PR #13347 by @DanielYang59.
    ğŸ”¥ Remove manual type annotations in JWT tutorial to avoid typing expectations (JWT doesn't provide more types). PR #13378 by @tiangolo.
    ğŸ“ Update docs for Query Params and String Validations, remove obsolete Ellipsis docs (...). PR #13377 by @tiangolo.
    âœï¸ Remove duplicate title in docs body-multiple-params. PR #13345 by @DanielYang59.
    ğŸ“ Fix test badge. PR #13313 by @esadek.

TranslationsÂ¶

    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/header-params.md. PR #13381 by @valentinDruzhinin.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/request-files.md. PR #13395 by @valentinDruzhinin.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/request-form-models.md. PR #13384 by @valentinDruzhinin.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/request-forms-and-files.md. PR #13386 by @valentinDruzhinin.
    ğŸŒ Update Korean translation for docs/ko/docs/help-fastapi.md. PR #13262 by @Zerohertz.
    ğŸŒ Add Korean translation for docs/ko/docs/advanced/custom-response.md. PR #13265 by @11kkw.
    ğŸŒ Update Korean translation for docs/ko/docs/tutorial/security/simple-oauth2.md. PR #13335 by @yes0ng.
    ğŸŒ Add Russian translation for docs/ru/docs/advanced/response-cookies.md. PR #13327 by @Stepakinoyan.
    ğŸŒ Add Vietnamese translation for docs/vi/docs/tutorial/static-files.md. PR #11291 by @ptt3199.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/dependencies/dependencies-with-yield.md. PR #13257 by @11kkw.
    ğŸŒ Add Vietnamese translation for docs/vi/docs/virtual-environments.md. PR #13282 by @ptt3199.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/static-files.md. PR #13285 by @valentinDruzhinin.
    ğŸŒ Add Vietnamese translation for docs/vi/docs/environment-variables.md. PR #13287 by @ptt3199.
    ğŸŒ Add Vietnamese translation for docs/vi/docs/fastapi-cli.md. PR #13294 by @ptt3199.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/features.md. PR #13308 by @valentinDruzhinin.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/learn/index.md. PR #13306 by @valentinDruzhinin.
    ğŸŒ Update Portuguese Translation for docs/pt/docs/deployment/https.md. PR #13317 by @Joao-Pedro-P-Holanda.
    ğŸŒ Update Portuguese Translation for docs/pt/docs/index.md. PR #13328 by @ceb10n.
    ğŸŒ Add Russian translation for docs/ru/docs/advanced/websockets.md. PR #13279 by @Rishat-F.

InternalÂ¶

    âœ… Fix a minor bug in the test tests/test_modules_same_name_body/test_main.py. PR #13411 by @alv2017.
    ğŸ‘· Use wrangler-action v3. PR #13415 by @joakimnordling.
    ğŸ”§ Update sponsors: add CodeRabbit. PR #13402 by @tiangolo.
    ğŸ”§ Update team: Add Ludovico. PR #13390 by @tiangolo.
    ğŸ”§ Update sponsors: Add LambdaTest. PR #13389 by @tiangolo.
    â¬† Bump cloudflare/wrangler-action from 3.13 to 3.14. PR #13350 by @dependabot[bot].
    â¬† Bump mkdocs-material from 9.5.18 to 9.6.1. PR #13301 by @dependabot[bot].
    â¬† Bump pillow from 11.0.0 to 11.1.0. PR #13300 by @dependabot[bot].
    ğŸ‘¥ Update FastAPI People - Sponsors. PR #13295 by @tiangolo.
    ğŸ‘¥ Update FastAPI People - Experts. PR #13303 by @tiangolo.
    ğŸ‘¥ Update FastAPI GitHub topic repositories. PR #13302 by @tiangolo.
    ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR #13293 by @tiangolo.
    â¬† Bump inline-snapshot from 0.18.1 to 0.19.3. PR #13298 by @dependabot[bot].
    ğŸ”§ Update sponsors, add Permit. PR #13288 by @tiangolo.

0.115.8Â¶
FixesÂ¶

    ğŸ› Fix OAuth2PasswordRequestForm and OAuth2PasswordRequestFormStrict fixed grant_type "password" RegEx. PR #9783 by @skarfie123.

RefactorsÂ¶

    âœ… Simplify tests for body_multiple_params . PR #13237 by @alejsdev.
    â™»ï¸ Move duplicated code portion to a static method in the APIKeyBase super class. PR #3142 by @ShahriyarR.
    âœ… Simplify tests for request_files. PR #13182 by @alejsdev.

DocsÂ¶

    ğŸ“ Change the word "unwrap" to "unpack" in docs/en/docs/tutorial/extra-models.md. PR #13061 by @timothy-jeong.
    ğŸ“ Update Request Body's tutorial002 to deal with tax=0 case. PR #13230 by @togogh.
    ğŸ‘¥ Update FastAPI People - Experts. PR #13269 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Add Japanese translation for docs/ja/docs/environment-variables.md. PR #13226 by @k94-ishi.
    ğŸŒ Add Russian translation for docs/ru/docs/advanced/async-tests.md. PR #13227 by @Rishat-F.
    ğŸŒ Update Russian translation for docs/ru/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md. PR #13252 by @Rishat-F.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/bigger-applications.md. PR #13154 by @alv2017.

InternalÂ¶

    â¬†ï¸ Add support for Python 3.13. PR #13274 by @tiangolo.
    â¬†ï¸ Upgrade AnyIO max version for tests, new range: >=3.2.1,<5.0.0. PR #13273 by @tiangolo.
    ğŸ”§ Update Sponsors badges. PR #13271 by @tiangolo.
    â™»ï¸ Fix notify_translations.py empty env var handling for PR label events vs workflow_dispatch. PR #13272 by @tiangolo.
    â™»ï¸ Refactor and move scripts/notify_translations.py, no need for a custom GitHub Action. PR #13270 by @tiangolo.
    ğŸ”¨ Update FastAPI People Experts script, refactor and optimize data fetching to handle rate limits. PR #13267 by @tiangolo.
    â¬† Bump pypa/gh-action-pypi-publish from 1.12.3 to 1.12.4. PR #13251 by @dependabot[bot].

0.115.7Â¶
UpgradesÂ¶

    â¬†ï¸ Upgrade python-multipart to >=0.0.18. PR #13219 by @DanielKusyDev.
    â¬†ï¸ Bump Starlette to allow up to 0.45.0: >=0.40.0,<0.46.0. PR #13117 by @Kludex.
    â¬†ï¸ Upgrade jinja2 to >=3.1.5. PR #13194 by @DanielKusyDev.

RefactorsÂ¶

    âœ… Simplify tests for websockets. PR #13202 by @alejsdev.
    âœ… Simplify tests for request_form_models . PR #13183 by @alejsdev.
    âœ… Simplify tests for separate_openapi_schemas. PR #13201 by @alejsdev.
    âœ… Simplify tests for security. PR #13200 by @alejsdev.
    âœ… Simplify tests for schema_extra_example. PR #13197 by @alejsdev.
    âœ… Simplify tests for request_model. PR #13195 by @alejsdev.
    âœ… Simplify tests for request_forms_and_files. PR #13185 by @alejsdev.
    âœ… Simplify tests for request_forms. PR #13184 by @alejsdev.
    âœ… Simplify tests for path_query_params. PR #13181 by @alejsdev.
    âœ… Simplify tests for path_operation_configurations. PR #13180 by @alejsdev.
    âœ… Simplify tests for header_params. PR #13179 by @alejsdev.
    âœ… Simplify tests for extra_models. PR #13178 by @alejsdev.
    âœ… Simplify tests for extra_data_types. PR #13177 by @alejsdev.
    âœ… Simplify tests for cookie_params. PR #13176 by @alejsdev.
    âœ… Simplify tests for dependencies. PR #13174 by @alejsdev.
    âœ… Simplify tests for body_updates. PR #13172 by @alejsdev.
    âœ… Simplify tests for body_nested_models. PR #13171 by @alejsdev.
    âœ… Simplify tests for body_multiple_params. PR #13170 by @alejsdev.
    âœ… Simplify tests for body_fields. PR #13169 by @alejsdev.
    âœ… Simplify tests for body. PR #13168 by @alejsdev.
    âœ… Simplify tests for bigger_applications. PR #13167 by @alejsdev.
    âœ… Simplify tests for background_tasks. PR #13166 by @alejsdev.
    âœ… Simplify tests for additional_status_codes. PR #13149 by @tiangolo.

DocsÂ¶

    âœï¸ Update Strawberry integration docs. PR #13155 by @kinuax.
    ğŸ”¥ Remove unused Peewee tutorial files. PR #13158 by @alejsdev.
    ğŸ“ Update image in body-nested-model docs. PR #11063 by @untilhamza.
    ğŸ“ Update fastapi-cli UI examples in docs. PR #13107 by @Zhongheng-Cheng.
    ğŸ‘· Add new GitHub Action to update contributors, translators, and translation reviewers. PR #13136 by @tiangolo.
    âœï¸ Fix typo in docs/en/docs/virtual-environments.md. PR #13124 by @tiangolo.
    âœï¸ Fix error in docs/en/docs/contributing.md. PR #12899 by @kingsubin.
    ğŸ“ Minor corrections in docs/en/docs/tutorial/sql-databases.md. PR #13081 by @alv2017.
    ğŸ“ Update includes in docs/ru/docs/tutorial/query-param-models.md. PR #12994 by @alejsdev.
    âœï¸ Fix typo in README installation instructions. PR #13011 by @dave-hay.
    ğŸ“ Update docs for fastapi-cli. PR #13031 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Update Portuguese Translation for docs/pt/docs/tutorial/request-forms.md. PR #13216 by @Joao-Pedro-P-Holanda.
    ğŸŒ Update Portuguese translation for docs/pt/docs/advanced/settings.md. PR #13209 by @ceb10n.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/security/oauth2-jwt.md. PR #13205 by @ceb10n.
    ğŸŒ Add Indonesian translation for docs/id/docs/index.md. PR #13191 by @gerry-sabar.
    ğŸŒ Add Indonesian translation for docs/id/docs/tutorial/static-files.md. PR #13092 by @guspan-tanadi.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/security/get-current-user.md. PR #13188 by @ceb10n.
    ğŸŒ Remove Wrong Portuguese translations location for docs/pt/docs/advanced/benchmarks.md. PR #13187 by @ceb10n.
    ğŸŒ Update Portuguese translations. PR #13156 by @nillvitor.
    ğŸŒ Update Russian translation for docs/ru/docs/tutorial/security/first-steps.md. PR #13159 by @Yarous.
    âœï¸ Delete unnecessary backspace in docs/ja/docs/tutorial/path-params-numeric-validations.md. PR #12238 by @FakeDocument.
    ğŸŒ Update Chinese translation for docs/zh/docs/fastapi-cli.md. PR #13102 by @Zhongheng-Cheng.
    ğŸŒ Add new Spanish translations for all docs with new LLM-assisted system using PydanticAI. PR #13122 by @tiangolo.
    ğŸŒ Update existing Spanish translations using the new LLM-assisted system using PydanticAI. PR #13118 by @tiangolo.
    ğŸŒ Update Chinese translation for docs/zh/docs/advanced/security/oauth2-scopes.md. PR #13110 by @ChenPu2002.
    ğŸŒ Add Indonesian translation for docs/id/docs/tutorial/path-params.md. PR #13086 by @gerry-sabar.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/sql-databases.md. PR #13093 by @GeumBinLee.
    ğŸŒ Update Chinese translation for docs/zh/docs/async.md. PR #13095 by @Zhongheng-Cheng.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/openapi-webhooks.md. PR #13091 by @Zhongheng-Cheng.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/async-tests.md. PR #13074 by @Zhongheng-Cheng.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/fastapi-cli.md. PR #13020 by @ykertytsky.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/events.md. PR #12512 by @ZhibangYue.
    ğŸŒ Add Russian translation for /docs/ru/docs/tutorial/sql-databases.md. PR #13079 by @alv2017.
    ğŸŒ Update Chinese translation for docs/zh/docs/advanced/testing-dependencies.md. PR #13066 by @Zhongheng-Cheng.
    ğŸŒ Update Traditional Chinese translation for docs/zh-hant/docs/tutorial/index.md. PR #13075 by @codingjenny.
    ğŸŒ Add Chinese translation for docs/zh/docs/tutorial/sql-databases.md. PR #13051 by @Zhongheng-Cheng.
    ğŸŒ Update Chinese translation for docs/zh/docs/tutorial/query-params-str-validations.md. PR #12928 by @Vincy1230.
    ğŸŒ Add Chinese translation for docs/zh/docs/tutorial/header-param-models.md. PR #13040 by @Zhongheng-Cheng.
    ğŸŒ Update Chinese translation for docs/zh/docs/tutorial/path-params.md. PR #12926 by @Vincy1230.
    ğŸŒ Update Chinese translation for docs/zh/docs/tutorial/first-steps.md. PR #12923 by @Vincy1230.
    ğŸŒ Update Russian translation for docs/ru/docs/deployment/docker.md. PR #13048 by @anklav24.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/generate-clients.md. PR #13030 by @vitumenezes.
    ğŸŒ Add Indonesian translation for docs/id/docs/tutorial/first-steps.md. PR #13042 by @gerry-sabar.
    ğŸŒ Add Chinese translation for docs/zh/docs/tutorial/cookie-param-models.md. PR #13038 by @Zhongheng-Cheng.
    ğŸŒ Add Chinese translation for docs/zh/docs/tutorial/request-form-models.md. PR #13045 by @Zhongheng-Cheng.
    ğŸŒ Add Russian translation for docs/ru/docs/virtual-environments.md. PR #13026 by @alv2017.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/testing.md. PR #12968 by @jts8257.
    ğŸŒ Add Korean translation for docs/ko/docs/advanced/async-test.md. PR #12918 by @icehongssii.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/security/oauth2-jwt.md. PR #10601 by @AlertRED.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/security/simple-oauth2.md. PR #10599 by @AlertRED.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/security/get-current-user.md. PR #10594 by @AlertRED.
    ğŸŒ Add Traditional Chinese translation for docs/zh-hant/docs/features.md. PR #12441 by @codingjenny.
    ğŸŒ Add Traditional Chinese translation for docs/zh-hant/docs/virtual-environments.md. PR #12791 by @Vincy1230.
    ğŸŒ Add Korean translation for docs/ko/docs/advanced/templates.md. PR #12726 by @Heumhub.
    ğŸŒ Add Russian translation for docs/ru/docs/fastapi-cli.md. PR #13041 by @alv2017.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/cookie-param-models.md. PR #13000 by @hard-coders.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/header-param-models.md. PR #13001 by @hard-coders.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/request-form-models.md. PR #13002 by @hard-coders.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/request-forms.md. PR #13003 by @hard-coders.
    ğŸŒ Add Korean translation for docs/ko/docs/resources/index.md. PR #13004 by @hard-coders.
    ğŸŒ Add Korean translation for docs/ko/docs/how-to/configure-swagger-ui.md. PR #12898 by @nahyunkeem.
    ğŸŒ Add Korean translation to docs/ko/docs/advanced/additional-status-codes.md. PR #12715 by @nahyunkeem.
    ğŸŒ Add Traditional Chinese translation for docs/zh-hant/docs/tutorial/first-steps.md. PR #12467 by @codingjenny.

InternalÂ¶

    ğŸ”§ Add Pydantic 2 trove classifier. PR #13199 by @johnthagen.
    ğŸ‘¥ Update FastAPI People - Sponsors. PR #13231 by @tiangolo.
    ğŸ‘· Refactor FastAPI People Sponsors to use 2 tokens. PR #13228 by @tiangolo.
    ğŸ‘· Update token for FastAPI People - Sponsors. PR #13225 by @tiangolo.
    ğŸ‘· Add independent CI automation for FastAPI People - Sponsors. PR #13221 by @tiangolo.
    ğŸ‘· Add retries to Smokeshow. PR #13151 by @tiangolo.
    ğŸ”§ Update Speakeasy sponsor graphic. PR #13147 by @chailandau.
    ğŸ‘¥ Update FastAPI GitHub topic repositories. PR #13146 by @tiangolo.
    ğŸ‘·â€â™€ï¸ Add script for GitHub Topic Repositories and update External Links. PR #13135 by @alejsdev.
    ğŸ‘¥ Update FastAPI People - Contributors and Translators. PR #13145 by @tiangolo.
    â¬† Bump markdown-include-variants from 0.0.3 to 0.0.4. PR #13129 by @dependabot[bot].
    â¬† Bump inline-snapshot from 0.14.0 to 0.18.1. PR #13132 by @dependabot[bot].
    â¬† Bump mkdocs-macros-plugin from 1.0.5 to 1.3.7. PR #13133 by @dependabot[bot].
    ğŸ”¨ Add internal scripts to generate language translations with PydanticAI, include Spanish prompt. PR #13123 by @tiangolo.
    â¬† Bump astral-sh/setup-uv from 4 to 5. PR #13096 by @dependabot[bot].
    ğŸ”§ Update sponsors: rename CryptAPI to BlockBee. PR #13078 by @tiangolo.
    â¬† Bump pypa/gh-action-pypi-publish from 1.12.2 to 1.12.3. PR #13055 by @dependabot[bot].
    â¬† Bump types-ujson from 5.7.0.1 to 5.10.0.20240515. PR #13018 by @dependabot[bot].
    â¬† Bump black from 24.3.0 to 24.10.0. PR #13014 by @dependabot[bot].
    â¬† Bump inline-snapshot from 0.13.0 to 0.14.0. PR #13017 by @dependabot[bot].
    â¬† Bump dirty-equals from 0.6.0 to 0.8.0. PR #13015 by @dependabot[bot].
    â¬† Bump cloudflare/wrangler-action from 3.12 to 3.13. PR #12996 by @dependabot[bot].
    â¬† Bump astral-sh/setup-uv from 3 to 4. PR #12982 by @dependabot[bot].
    ğŸ”§ Remove duplicate actions/checkout in notify-translations.yml. PR #12915 by @tinyboxvk.
    ğŸ”§ Update team members. PR #13033 by @tiangolo.
    ğŸ“ Update sponsors: remove Codacy. PR #13032 by @tiangolo.

0.115.6Â¶
FixesÂ¶

    ğŸ› Preserve traceback when an exception is raised in sync dependency with yield. PR #5823 by @sombek.

RefactorsÂ¶

    â™»ï¸ Update tests and internals for compatibility with Pydantic >=2.10. PR #12971 by @tamird.

DocsÂ¶

    ğŸ“ Update includes format in docs with an automated script. PR #12950 by @tiangolo.
    ğŸ“ Update includes for docs/de/docs/advanced/using-request-directly.md. PR #12685 by @alissadb.
    ğŸ“ Update includes for docs/de/docs/how-to/conditional-openapi.md. PR #12689 by @alissadb.

TranslationsÂ¶

    ğŸŒ Add Traditional Chinese translation for docs/zh-hant/docs/async.md. PR #12990 by @ILoveSorasakiHina.
    ğŸŒ Add Traditional Chinese translation for docs/zh-hant/docs/tutorial/query-param-models.md. PR #12932 by @Vincy1230.
    ğŸŒ Add Korean translation for docs/ko/docs/advanced/testing-dependencies.md. PR #12992 by @Limsunoh.
    ğŸŒ Add Korean translation for docs/ko/docs/advanced/websockets.md. PR #12991 by @kwang1215.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/response-model.md. PR #12933 by @AndreBBM.
    ğŸŒ Add Korean translation for docs/ko/docs/advanced/middlewares.md. PR #12753 by @nahyunkeem.
    ğŸŒ Add Korean translation for docs/ko/docs/advanced/openapi-webhooks.md. PR #12752 by @saeye.
    ğŸŒ Add Chinese translation for docs/zh/docs/tutorial/query-param-models.md. PR #12931 by @Vincy1230.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/query-param-models.md. PR #12445 by @gitgernit.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/query-param-models.md. PR #12940 by @jts8257.
    ğŸ”¥ Remove obsolete tutorial translation to Chinese for docs/zh/docs/tutorial/sql-databases.md, it references files that are no longer on the repo. PR #12949 by @tiangolo.

InternalÂ¶

    â¬† [pre-commit.ci] pre-commit autoupdate. PR #12954 by @pre-commit-ci[bot].

0.115.5Â¶
RefactorsÂ¶

    â™»ï¸ Update internal checks to support Pydantic 2.10. PR #12914 by @tiangolo.

DocsÂ¶

    ğŸ“ Update includes for docs/en/docs/tutorial/body.md. PR #12757 by @gsheni.
    ğŸ“ Update includes in docs/en/docs/advanced/testing-dependencies.md. PR #12647 by @AyushSinghal1794.
    ğŸ“ Update includes for docs/en/docs/tutorial/metadata.md. PR #12773 by @Nimitha-jagadeesha.
    ğŸ“ Update docs/en/docs/tutorial/dependencies/dependencies-with-yield.md. PR #12045 by @xuvjso.
    ğŸ“ Update includes for docs/en/docs/tutorial/dependencies/global-dependencies.md. PR #12653 by @vishnuvskvkl.
    ğŸ“ Update includes for docs/en/docs/tutorial/body-updates.md. PR #12712 by @davioc.
    ğŸ“ Remove mention of Celery in the project generators. PR #12742 by @david-caro.
    ğŸ“ Update includes in docs/en/docs/tutorial/header-param-models.md. PR #12814 by @zhaohan-dong.
    ğŸ“ Update contributing.md docs, include note to not translate this page. PR #12841 by @tiangolo.
    ğŸ“ Update includes in docs/en/docs/tutorial/request-forms.md. PR #12648 by @vishnuvskvkl.
    ğŸ“ Update includes in docs/en/docs/tutorial/request-form-models.md. PR #12649 by @vishnuvskvkl.
    ğŸ“ Update includes in docs/en/docs/tutorial/security/oauth2-jwt.md. PR #12650 by @OCE1960.
    ğŸ“ Update includes in docs/vi/docs/tutorial/first-steps.md. PR #12754 by @MxPy.
    ğŸ“ Update includes for docs/pt/docs/advanced/wsgi.md. PR #12769 by @Nimitha-jagadeesha.
    ğŸ“ Update includes for docs/en/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md. PR #12815 by @handabaldeep.
    ğŸ“ Update includes for docs/en/docs/tutorial/dependencies/classes-as-dependencies.md. PR #12813 by @handabaldeep.
    âœï¸ Fix error in docs/en/docs/tutorial/middleware.md. PR #12819 by @alejsdev.
    ğŸ“ Update includes for docs/en/docs/tutorial/security/get-current-user.md. PR #12645 by @OCE1960.
    ğŸ“ Update includes for docs/en/docs/tutorial/security/first-steps.md. PR #12643 by @OCE1960.
    ğŸ“ Update includes in docs/de/docs/advanced/additional-responses.md. PR #12821 by @zhaohan-dong.
    ğŸ“ Update includes in docs/en/docs/advanced/generate-clients.md. PR #12642 by @AyushSinghal1794.
    ğŸ“ Fix admonition double quotes with new syntax. PR #12835 by @tiangolo.
    ğŸ“ Update includes in docs/zh/docs/advanced/additional-responses.md. PR #12828 by @zhaohan-dong.
    ğŸ“ Update includes in docs/en/docs/tutorial/path-params-numeric-validations.md. PR #12825 by @zhaohan-dong.
    ğŸ“ Update includes for docs/en/docs/advanced/testing-websockets.md. PR #12761 by @hamidrasti.
    ğŸ“ Update includes for docs/en/docs/advanced/using-request-directly.md. PR #12760 by @hamidrasti.
    ğŸ“ Update includes for docs/advanced/wsgi.md. PR #12758 by @hamidrasti.
    ğŸ“ Update includes in docs/de/docs/tutorial/middleware.md. PR #12729 by @paintdog.
    ğŸ“ Update includes for docs/en/docs/tutorial/schema-extra-example.md. PR #12822 by @tiangolo.
    ğŸ“ Update includes in docs/fr/docs/advanced/additional-responses.md. PR #12634 by @fegmorte.
    ğŸ“ Update includes in docs/fr/docs/advanced/path-operation-advanced-configuration.md. PR #12633 by @kantandane.
    ğŸ“ Update includes in docs/fr/docs/advanced/response-directly.md. PR #12632 by @kantandane.
    ğŸ“ Update includes for docs/en/docs/tutorial/header-params.md. PR #12640 by @vishnuvskvkl.
    ğŸ“ Update includes in docs/en/docs/tutorial/cookie-param-models.md. PR #12639 by @vishnuvskvkl.
    ğŸ“ Update includes for docs/en/docs/tutorial/extra-models.md. PR #12638 by @vishnuvskvkl.
    ğŸ“ Update includes for docs/en/docs/tutorial/cors.md. PR #12637 by @vishnuvskvkl.
    ğŸ“ Update includes for docs/en/docs/tutorial/dependencies/sub-dependencies.md. PR #12810 by @handabaldeep.
    ğŸ“ Update includes in docs/en/docs/tutorial/body-nested-models.md. PR #12812 by @zhaohan-dong.
    ğŸ“ Update includes in docs/en/docs/tutorial/path-operation-configuration.md. PR #12809 by @AlexWendland.
    ğŸ“ Update includes in docs/en/docs/tutorial/request-files.md. PR #12818 by @zhaohan-dong.
    ğŸ“ Update includes for docs/en/docs/tutorial/query-param-models.md. PR #12817 by @handabaldeep.
    ğŸ“ Update includes in docs/en/docs/tutorial/path-params.md. PR #12811 by @AlexWendland.
    ğŸ“ Update includes in docs/en/docs/tutorial/response-model.md. PR #12621 by @kantandane.
    ğŸ“ Update includes in docs/en/docs/advanced/websockets.md. PR #12606 by @vishnuvskvkl.
    ğŸ“ Updates include for docs/en/docs/tutorial/cookie-params.md. PR #12808 by @handabaldeep.
    ğŸ“ Update includes in docs/en/docs/tutorial/middleware.md. PR #12807 by @AlexWendland.
    ğŸ“ Update includes in docs/en/docs/advanced/sub-applications.md. PR #12806 by @zhaohan-dong.
    ğŸ“ Update includes in docs/en/docs/advanced/response-headers.md. PR #12805 by @zhaohan-dong.
    ğŸ“ Update includes in docs/fr/docs/tutorial/first-steps.md. PR #12594 by @kantandane.
    ğŸ“ Update includes in docs/en/docs/advanced/response-cookies.md. PR #12804 by @zhaohan-dong.
    ğŸ“ Update includes in docs/en/docs/advanced/path-operation-advanced-configuration.md. PR #12802 by @zhaohan-dong.
    ğŸ“ Update includes for docs/en/docs/advanced/response-directly.md. PR #12803 by @handabaldeep.
    ğŸ“ Update includes in docs/zh/docs/tutorial/background-tasks.md. PR #12798 by @zhaohan-dong.
    ğŸ“ Update includes for docs/de/docs/tutorial/body-multiple-params.md. PR #12699 by @alissadb.
    ğŸ“ Update includes in docs/em/docs/tutorial/body-updates.md. PR #12799 by @AlexWendland.
    ğŸ“ Update includes docs/en/docs/advanced/response-change-status-code.md. PR #12801 by @handabaldeep.
    ğŸ“ Update includes docs/en/docs/advanced/openapi-callbacks.md. PR #12800 by @handabaldeep.
    ğŸ“ Update includes in docs/fr/docs/tutorial/body-multiple-params.md. PR #12598 by @kantandane.
    ğŸ“ Update includes in docs/en/docs/tutorial/body-multiple-params.md. PR #12593 by @Tashanam-Shahbaz.
    ğŸ“ Update includes in docs/pt/docs/tutorial/background-tasks.md. PR #12736 by @bhunao.
    ğŸ“ Update includes for docs/en/docs/advanced/custom-response.md. PR #12797 by @handabaldeep.
    ğŸ“ Update includes for docs/pt/docs/python-types.md. PR #12671 by @ceb10n.
    ğŸ“ Update includes for docs/de/docs/python-types.md. PR #12660 by @alissadb.
    ğŸ“ Update includes for docs/de/docs/advanced/dataclasses.md. PR #12658 by @alissadb.
    ğŸ“ Update includes in docs/fr/docs/tutorial/path-params.md. PR #12592 by @kantandane.
    ğŸ“ Update includes for docs/de/docs/how-to/configure-swagger-ui.md. PR #12690 by @alissadb.
    ğŸ“ Update includes in docs/en/docs/advanced/security/oauth2-scopes.md. PR #12572 by @krishnamadhavan.
    ğŸ“ Update includes for docs/en/docs/how-to/conditional-openapi.md. PR #12624 by @rabinlamadong.
    ğŸ“ Update includes in docs/en/docs/tutorial/dependencies/index.md. PR #12615 by @bharara.
    ğŸ“ Update includes in docs/en/docs/tutorial/response-status-code.md. PR #12620 by @kantandane.
    ğŸ“ Update includes in docs/en/docs/how-to/custom-docs-ui-assets.md. PR #12623 by @rabinlamadong.
    ğŸ“ Update includes in docs/en/docs/advanced/openapi-webhooks.md. PR #12605 by @salmantec.
    ğŸ“ Update includes in docs/en/docs/advanced/events.md. PR #12604 by @salmantec.
    ğŸ“ Update includes in docs/en/docs/advanced/dataclasses.md. PR #12603 by @salmantec.
    ğŸ“ Update includes in docs/es/docs/tutorial/cookie-params.md. PR #12602 by @antonyare93.
    ğŸ“ Update includes in docs/fr/docs/tutorial/path-params-numeric-validations.md. PR #12601 by @kantandane.
    ğŸ“ Update includes in docs/fr/docs/tutorial/background-tasks.md. PR #12600 by @kantandane.
    ğŸ“ Update includes in docs/en/docs/tutorial/encoder.md. PR #12597 by @tonyjly.
    ğŸ“ Update includes in docs/en/docs/how-to/custom-docs-ui-assets.md. PR #12557 by @philipokiokio.
    ğŸ¨ Adjust spacing. PR #12635 by @alejsdev.
    ğŸ“ Update includes in docs/en/docs/how-to/custom-request-and-route.md. PR #12560 by @philipokiokio.

TranslationsÂ¶

    ğŸŒ Add Korean translation for docs/ko/docs/advanced/testing-websockets.md. PR #12739 by @Limsunoh.
    ğŸŒ Add Traditional Chinese translation for docs/zh-hant/docs/environment-variables.md. PR #12785 by @Vincy1230.
    ğŸŒ Add Chinese translation for docs/zh/docs/environment-variables.md. PR #12784 by @Vincy1230.
    ğŸŒ Add Korean translation for ko/docs/advanced/response-headers.md. PR #12740 by @kwang1215.
    ğŸŒ Add Chinese translation for docs/zh/docs/virtual-environments.md. PR #12790 by @Vincy1230.
    ğŸŒ Add Korean translation for /docs/ko/docs/environment-variables.md. PR #12526 by @Tolerblanc.
    ğŸŒ Add Korean translation for docs/ko/docs/history-design-future.md. PR #12646 by @saeye.
    ğŸŒ Add Korean translation for docs/ko/docs/advanced/advanced-dependencies.md. PR #12675 by @kim-sangah.
    ğŸŒ Add Korean translation for docs/ko/docs/how-to/conditional-openapi.md. PR #12731 by @sptcnl.
    ğŸŒ Add Korean translation for docs/ko/docs/advanced/using_request_directly.md. PR #12738 by @kwang1215.
    ğŸŒ Add Korean translation for docs/ko/docs/advanced/testing-events.md. PR #12741 by @9zimin9.
    ğŸŒ Add Korean translation for docs/ko/docs/security/index.md. PR #12743 by @kim-sangah.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/path-operation-advanced-configuration.md. PR #12762 by @Joao-Pedro-P-Holanda.
    ğŸŒ Add Korean translation for docs/ko/docs/advanced/wsgi.md. PR #12659 by @Limsunoh.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/websockets.md. PR #12703 by @devfernandoa.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/security/simple-oauth2.md. PR #12520 by @LidiaDomingos.
    ğŸŒ Add Korean translation for docs/ko/docs/advanced/response-directly.md. PR #12674 by @9zimin9.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/middleware.md. PR #12704 by @devluisrodrigues.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/openapi-callbacks.md. PR #12705 by @devfernandoa.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/request-files.md. PR #12706 by @devluisrodrigues.
    ğŸŒ Add Portuguese Translation for docs/pt/docs/advanced/custom-response.md. PR #12631 by @Joao-Pedro-P-Holanda.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/metadata.md. PR #12538 by @LinkolnR.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/metadata.md. PR #12541 by @kwang1215.
    ğŸŒ Add Korean Translation for docs/ko/docs/advanced/response-cookies.md. PR #12546 by @kim-sangah.
    ğŸŒ Add Korean translation for docs/ko/docs/fastapi-cli.md. PR #12515 by @dhdld.
    ğŸŒ Add Korean Translation for docs/ko/docs/advanced/response-change-status-code.md. PR #12547 by @9zimin9.

InternalÂ¶

    â¬† [pre-commit.ci] pre-commit autoupdate. PR #12907 by @pre-commit-ci[bot].
    ğŸ”¨ Update docs preview script to show previous version and English version. PR #12856 by @tiangolo.
    â¬† Bump tiangolo/latest-changes from 0.3.1 to 0.3.2. PR #12794 by @dependabot[bot].
    â¬† Bump pypa/gh-action-pypi-publish from 1.12.0 to 1.12.2. PR #12788 by @dependabot[bot].
    â¬† Bump pypa/gh-action-pypi-publish from 1.11.0 to 1.12.0. PR #12781 by @dependabot[bot].
    â¬† Bump cloudflare/wrangler-action from 3.11 to 3.12. PR #12777 by @dependabot[bot].
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #12766 by @pre-commit-ci[bot].
    â¬† Bump pypa/gh-action-pypi-publish from 1.10.3 to 1.11.0. PR #12721 by @dependabot[bot].
    â¬† Update pre-commit requirement from <4.0.0,>=2.17.0 to >=2.17.0,<5.0.0. PR #12749 by @dependabot[bot].
    â¬† Bump typer from 0.12.3 to 0.12.5. PR #12748 by @dependabot[bot].
    â¬† Update flask requirement from <3.0.0,>=1.1.2 to >=1.1.2,<4.0.0. PR #12747 by @dependabot[bot].
    â¬† Bump pillow from 10.4.0 to 11.0.0. PR #12746 by @dependabot[bot].
    â¬† Update pytest requirement from <8.0.0,>=7.1.3 to >=7.1.3,<9.0.0. PR #12745 by @dependabot[bot].
    ğŸ”§ Update sponsors: add Render. PR #12733 by @tiangolo.
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #12707 by @pre-commit-ci[bot].

0.115.4Â¶
RefactorsÂ¶

    â™»ï¸ Update logic to import and check python-multipart for compatibility with newer version. PR #12627 by @tiangolo.

DocsÂ¶

    ğŸ“ Update includes in docs/fr/docs/tutorial/body.md. PR #12596 by @kantandane.
    ğŸ“ Update includes in docs/fr/docs/tutorial/debugging.md. PR #12595 by @kantandane.
    ğŸ“ Update includes in docs/fr/docs/tutorial/query-params-str-validations.md. PR #12591 by @kantandane.
    ğŸ“ Update includes in docs/fr/docs/tutorial/query-params.md. PR #12589 by @kantandane.
    ğŸ“ Update includes in docs/en/tutorial/body-fields.md. PR #12588 by @lucaromagnoli.
    ğŸ“ Update includes in docs/de/docs/tutorial/response-status-code.md. PR #12585 by @abejaranoh.
    ğŸ“ Update includes in docs/en/docs/tutorial/body.md. PR #12586 by @lucaromagnoli.
    ğŸ“ Update includes in docs/en/docs/advanced/behind-a-proxy.md. PR #12583 by @imjuanleonard.
    ğŸ“ Update includes syntax for docs/pl/docs/tutorial/first-steps.md. PR #12584 by @sebkozlo.
    ğŸ“ Update includes in docs/en/docs/advanced/middleware.md. PR #12582 by @montanarograziano.
    ğŸ“ Update includes in docs/en/docs/advanced/additional-status-codes.md. PR #12577 by @krishnamadhavan.
    ğŸ“ Update includes in docs/en/docs/advanced/advanced-dependencies.md. PR #12578 by @krishnamadhavan.
    ğŸ“ Update includes in docs/en/docs/advanced/additional-responses.md. PR #12576 by @krishnamadhavan.
    ğŸ“ Update includes in docs/en/docs/tutorial/static-files.md. PR #12575 by @lucaromagnoli.
    ğŸ“ Update includes in docs/en/docs/advanced/async-tests.md. PR #12568 by @krishnamadhavan.
    ğŸ“ Update includes in docs/pt/docs/advanced/behind-a-proxy.md. PR #12563 by @asmioglou.
    ğŸ“ Update includes in docs/de/docs/advanced/security/http-basic-auth.md. PR #12561 by @Nimitha-jagadeesha.
    ğŸ“ Update includes in docs/en/docs/tutorial/background-tasks.md. PR #12559 by @FarhanAliRaza.
    ğŸ“ Update includes in docs/fr/docs/python-types.md. PR #12558 by @Ismailtlem.
    ğŸ“ Update includes in docs/en/docs/how-to/graphql.md. PR #12564 by @philipokiokio.
    ğŸ“ Update includes in docs/en/docs/how-to/extending-openapi.md. PR #12562 by @philipokiokio.
    ğŸ“ Update includes for docs/en/docs/how-to/configure-swagger-ui.md. PR #12556 by @tiangolo.
    ğŸ“ Update includes for docs/en/docs/how-to/separate-openapi-schemas.md. PR #12555 by @tiangolo.
    ğŸ“ Update includes for docs/en/docs/advanced/security/http-basic-auth.md. PR #12553 by @tiangolo.
    ğŸ“ Update includes in docs/en/docs/tutorial/first-steps.md. PR #12552 by @tiangolo.
    ğŸ“ Update includes in docs/en/docs/python-types.md. PR #12551 by @tiangolo.
    ğŸ“ Fix link in OAuth2 docs. PR #12550 by @tiangolo.
    ğŸ“ Add External Link: FastAPI do Zero. PR #12533 by @rennerocha.
    ğŸ“ Fix minor typos. PR #12516 by @kkirsche.
    ğŸŒ Fix rendering issue in translations. PR #12509 by @alejsdev.

TranslationsÂ¶

    ğŸ“ Update includes in docs/de/docs/advanced/async-tests.md. PR #12567 by @imjuanleonard.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/sql-databases.md. PR #12530 by @ilacftemp.
    ğŸŒ Add Korean translation for docs/ko/docs/benchmarks.md. PR #12540 by @Limsunoh.
    ğŸŒ Add Portuguese translation for docs/pt/docs/how-to/separate-openapi-schemas.md. PR #12518 by @ilacftemp.
    ğŸŒ Update Traditional Chinese translation for docs/zh-hant/docs/deployment/index.md. PR #12521 by @codingjenny.
    ğŸŒ Update Traditional Chinese translation for docs/zh-hant/docs/deployment/cloud.md. PR #12522 by @codingjenny.
    ğŸŒ Update Traditional Chinese translation for docs/zh-hant/docs/how-to/index.md. PR #12523 by @codingjenny.
    ğŸŒ Update Traditional Chinese translation for docs/zh-hant/docs/tutorial/index.md. PR #12524 by @codingjenny.
    ğŸŒ Add Traditional Chinese translation for docs/zh-hant/docs/how-to/index.md. PR #12468 by @codingjenny.
    ğŸŒ Add Traditional Chinese translation for docs/zh-hant/docs/tutorial/index.md. PR #12466 by @codingjenny.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/header-param-models.md. PR #12437 by @Joao-Pedro-P-Holanda.
    ğŸŒ Add Portuguese translation for docs/pt/docs/how-to/extending-openapi.md. PR #12470 by @ilacftemp.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/dataclasses.md. PR #12475 by @leoscarlato.
    ğŸŒ Add Portuguese translation for docs/pt/docs/how-to/custom-request-and-route.md. PR #12483 by @devfernandoa.

InternalÂ¶

    â¬† Bump cloudflare/wrangler-action from 3.9 to 3.11. PR #12544 by @dependabot[bot].
    ğŸ‘· Update GitHub Action to deploy docs previews to handle missing deploy comments. PR #12527 by @tiangolo.
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #12505 by @pre-commit-ci[bot].

0.115.3Â¶
UpgradesÂ¶

    â¬†ï¸ Upgrade Starlette to >=0.40.0,<0.42.0. PR #12469 by @defnull.

DocsÂ¶

    ğŸ“ Fix broken link in docs. PR #12495 by @eltonjncorreia.

TranslationsÂ¶

    ğŸŒ Add Traditional Chinese translation for docs/zh-hant/docs/fastapi-cli.md. PR #12444 by @codingjenny.
    ğŸŒ Add Traditional Chinese translation for docs/zh-hant/docs/deployment/index.md. PR #12439 by @codingjenny.
    ğŸŒ Add Portuguese translation for docs/pt/docs/how-to/testing-database.md. PR #12472 by @GuilhermeRameh.
    ğŸŒ Add Portuguese translation for docs/pt/docs/how-to/custom-docs-ui-assets.md. PR #12473 by @devluisrodrigues.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/response-headers.md. PR #12458 by @leonardopaloschi.
    ğŸŒ Add Traditional Chinese translation for docs/zh-hant/docs/deployment/cloud.md. PR #12440 by @codingjenny.
    ğŸŒ Update Portuguese translation for docs/pt/docs/python-types.md. PR #12428 by @ceb10n.
    ğŸŒ Add Russian translation for docs/ru/docs/environment-variables.md. PR #12436 by @wisderfin.
    ğŸŒ Add Traditional Chinese translation for docs/zh-hant/docs/resources/index.md. PR #12443 by @codingjenny.
    ğŸŒ Add Traditional Chinese translation for docs/zh-hant/docs/about/index.md. PR #12438 by @codingjenny.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/query-param-models.md. PR #12414 by @ceb10n.
    ğŸŒ Remove Portuguese translation for docs/pt/docs/deployment.md. PR #12427 by @ceb10n.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/body-updates.md. PR #12381 by @andersonrocha0.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/response-cookies.md. PR #12417 by @Paulofalcao2002.

InternalÂ¶

    ğŸ‘· Update issue manager workflow . PR #12457 by @alejsdev.
    ğŸ”§ Update team, include YuriiMotov ğŸš€. PR #12453 by @tiangolo.
    ğŸ‘· Refactor label-approved, make it an internal script instead of an external GitHub Action. PR #12280 by @tiangolo.
    ğŸ‘· Fix smokeshow, checkout files on CI. PR #12434 by @tiangolo.
    ğŸ‘· Use uv in CI. PR #12281 by @tiangolo.
    â¬† Update httpx requirement from <0.25.0,>=0.23.0 to >=0.23.0,<0.28.0. PR #11509 by @dependabot[bot].

0.115.2Â¶
UpgradesÂ¶

    â¬†ï¸ Upgrade Starlette to >=0.37.2,<0.41.0. PR #12431 by @tiangolo.

0.115.1Â¶
FixesÂ¶

    ğŸ› Fix openapi generation with responses kwarg. PR #10895 by @flxdot.
    ğŸ› Remove Required shadowing from fastapi using Pydantic v2. PR #12197 by @pachewise.

RefactorsÂ¶

    â™»ï¸ Update type annotations for improved python-multipart. PR #12407 by @tiangolo.

DocsÂ¶

    âœ¨ Add new tutorial for SQL databases with SQLModel. PR #12285 by @tiangolo.
    ğŸ“ Add External Link: How to profile a FastAPI asynchronous request. PR #12389 by @brouberol.
    ğŸ”§ Remove base_path for mdx_include Markdown extension in MkDocs. PR #12391 by @tiangolo.
    ğŸ“ Update link to Swagger UI configuration docs. PR #12264 by @makisukurisu.
    ğŸ“ Adding links for Playwright and Vite in docs/project-generation.md. PR #12274 by @kayqueGovetri.
    ğŸ“ Fix small typos in the documentation. PR #12213 by @svlandeg.

TranslationsÂ¶

    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/cookie-param-models.md. PR #12298 by @ceb10n.
    ğŸŒ Add Portuguese translation for docs/pt/docs/how-to/graphql.md. PR #12215 by @AnandaCampelo.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/security/oauth2-scopes.md. PR #12263 by @ceb10n.
    ğŸŒ Add Portuguese translation for docs/pt/docs/deployment/concepts.md. PR #12219 by @marcelomarkus.
    ğŸŒ Add Portuguese translation for docs/pt/docs/how-to/conditional-openapi.md. PR #12221 by @marcelomarkus.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/response-directly.md. PR #12266 by @Joao-Pedro-P-Holanda.
    ğŸŒ Update Portuguese translation for docs/pt/docs/tutorial/cookie-params.md. PR #12297 by @ceb10n.
    ğŸŒ Fix Korean translation for docs/ko/docs/tutorial/index.md. PR #12278 by @kkotipy.
    ğŸŒ Update Portuguese translation for docs/pt/docs/advanced/security/http-basic-auth.md. PR #12275 by @andersonrocha0.
    ğŸŒ Add Portuguese translation for docs/pt/docs/deployment/cloud.md. PR #12217 by @marcelomarkus.
    âœï¸ Fix typo in docs/es/docs/python-types.md. PR #12235 by @JavierSanchezCastro.
    ğŸŒ Add Dutch translation for docs/nl/docs/environment-variables.md. PR #12200 by @maxscheijen.
    ğŸŒ Add Portuguese translation for docs/pt/docs/deployment/manually.md. PR #12210 by @JoaoGustavoRogel.
    ğŸŒ Add Portuguese translation for docs/pt/docs/deployment/server-workers.md. PR #12220 by @marcelomarkus.
    ğŸŒ Add Portuguese translation for docs/pt/docs/how-to/configure-swagger-ui.md. PR #12222 by @marcelomarkus.

InternalÂ¶

    â¬† [pre-commit.ci] pre-commit autoupdate. PR #12396 by @pre-commit-ci[bot].
    ğŸ”¨ Add script to generate variants of files. PR #12405 by @tiangolo.
    ğŸ”§ Add speakeasy-api to sponsors_badge.yml. PR #12404 by @tiangolo.
    â• Add docs dependency: markdown-include-variants. PR #12399 by @tiangolo.
    ğŸ“ Fix extra mdx-base-path paths. PR #12397 by @tiangolo.
    ğŸ‘· Tweak labeler to not override custom labels. PR #12398 by @tiangolo.
    ğŸ‘· Update worfkow deploy-docs-notify URL. PR #12392 by @tiangolo.
    ğŸ‘· Update Cloudflare GitHub Action. PR #12387 by @tiangolo.
    â¬† Bump pypa/gh-action-pypi-publish from 1.10.1 to 1.10.3. PR #12386 by @dependabot[bot].
    â¬† Bump mkdocstrings[python] from 0.25.1 to 0.26.1. PR #12371 by @dependabot[bot].
    â¬† Bump griffe-typingdoc from 0.2.6 to 0.2.7. PR #12370 by @dependabot[bot].
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #12331 by @pre-commit-ci[bot].
    ğŸ”§ Update sponsors, remove Fine.dev. PR #12271 by @tiangolo.
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #12253 by @pre-commit-ci[bot].
    âœï¸ Fix docstring typos in http security. PR #12223 by @albertvillanova.

0.115.0Â¶
HighlightsÂ¶

Now you can declare Query, Header, and Cookie parameters with Pydantic models. ğŸ‰
Query Parameter ModelsÂ¶

Use Pydantic models for Query parameters:

from typing import Annotated, Literal

from fastapi import FastAPI, Query
from pydantic import BaseModel, Field

app = FastAPI()


class FilterParams(BaseModel):
    limit: int = Field(100, gt=0, le=100)
    offset: int = Field(0, ge=0)
    order_by: Literal["created_at", "updated_at"] = "created_at"
    tags: list[str] = []


@app.get("/items/")
async def read_items(filter_query: Annotated[FilterParams, Query()]):
    return filter_query

Read the new docs: Query Parameter Models.
Header Parameter ModelsÂ¶

Use Pydantic models for Header parameters:

from typing import Annotated

from fastapi import FastAPI, Header
from pydantic import BaseModel

app = FastAPI()


class CommonHeaders(BaseModel):
    host: str
    save_data: bool
    if_modified_since: str | None = None
    traceparent: str | None = None
    x_tag: list[str] = []


@app.get("/items/")
async def read_items(headers: Annotated[CommonHeaders, Header()]):
    return headers

Read the new docs: Header Parameter Models.
Cookie Parameter ModelsÂ¶

Use Pydantic models for Cookie parameters:

from typing import Annotated

from fastapi import Cookie, FastAPI
from pydantic import BaseModel

app = FastAPI()


class Cookies(BaseModel):
    session_id: str
    fatebook_tracker: str | None = None
    googall_tracker: str | None = None


@app.get("/items/")
async def read_items(cookies: Annotated[Cookies, Cookie()]):
    return cookies

Read the new docs: Cookie Parameter Models.
Forbid Extra Query (Cookie, Header) ParametersÂ¶

Use Pydantic models to restrict extra values for Query parameters (also applies to Header and Cookie parameters).

To achieve it, use Pydantic's model_config = {"extra": "forbid"}:

from typing import Annotated, Literal

from fastapi import FastAPI, Query
from pydantic import BaseModel, Field

app = FastAPI()


class FilterParams(BaseModel):
    model_config = {"extra": "forbid"}

    limit: int = Field(100, gt=0, le=100)
    offset: int = Field(0, ge=0)
    order_by: Literal["created_at", "updated_at"] = "created_at"
    tags: list[str] = []


@app.get("/items/")
async def read_items(filter_query: Annotated[FilterParams, Query()]):
    return filter_query

This applies to Query, Header, and Cookie parameters, read the new docs:

    Forbid Extra Query Parameters
    Forbid Extra Headers
    Forbid Extra Cookies

FeaturesÂ¶

    âœ¨ Add support for Pydantic models for parameters using Query, Cookie, Header. PR #12199 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/security/http-basic-auth.md. PR #12195 by @ceb10n.

InternalÂ¶

    â¬† [pre-commit.ci] pre-commit autoupdate. PR #12204 by @pre-commit-ci[bot].

0.114.2Â¶
FixesÂ¶

    ğŸ› Fix form field regression with alias. PR #12194 by @Wurstnase.

TranslationsÂ¶

    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/request-form-models.md. PR #12175 by @ceb10n.
    ğŸŒ Add Chinese translation for docs/zh/docs/project-generation.md. PR #12170 by @waketzheng.
    ğŸŒ Add Dutch translation for docs/nl/docs/python-types.md. PR #12158 by @maxscheijen.

InternalÂ¶

    ğŸ’¡ Add comments with instructions for Playwright screenshot scripts. PR #12193 by @tiangolo.
    â• Add inline-snapshot for tests. PR #12189 by @tiangolo.

0.114.1Â¶
RefactorsÂ¶

    âš¡ï¸ Improve performance in request body parsing with a cache for internal model fields. PR #12184 by @tiangolo.

DocsÂ¶

    ğŸ“ Remove duplicate line in docs for docs/en/docs/environment-variables.md. PR #12169 by @prometek.

TranslationsÂ¶

    ğŸŒ Add Portuguese translation for docs/pt/docs/virtual-environments.md. PR #12163 by @marcelomarkus.
    ğŸŒ Add Portuguese translation for docs/pt/docs/environment-variables.md. PR #12162 by @marcelomarkus.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/testing.md. PR #12164 by @marcelomarkus.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/debugging.md. PR #12165 by @marcelomarkus.
    ğŸŒ Add Korean translation for docs/ko/docs/project-generation.md. PR #12157 by @BORA040126.

InternalÂ¶

    â¬† Bump tiangolo/issue-manager from 0.5.0 to 0.5.1. PR #12173 by @dependabot[bot].
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #12176 by @pre-commit-ci[bot].
    ğŸ‘· Update issue-manager.yml. PR #12159 by @tiangolo.
    âœï¸ Fix typo in fastapi/params.py. PR #12143 by @surreal30.

0.114.0Â¶

You can restrict form fields to only include those declared in a Pydantic model and forbid any extra field sent in the request using Pydantic's model_config = {"extra": "forbid"}:

from typing import Annotated

from fastapi import FastAPI, Form
from pydantic import BaseModel

app = FastAPI()


class FormData(BaseModel):
    username: str
    password: str
    model_config = {"extra": "forbid"}


@app.post("/login/")
async def login(data: Annotated[FormData, Form()]):
    return data

Read the new docs: Form Models - Forbid Extra Form Fields.
FeaturesÂ¶

    âœ¨ Add support for forbidding extra form fields with Pydantic models. PR #12134 by @tiangolo.

DocsÂ¶

    ğŸ“ Update docs, Form Models section title, to match config name. PR #12152 by @tiangolo.

InternalÂ¶

    âœ… Update internal tests for latest Pydantic, including CI tweaks to install the latest Pydantic. PR #12147 by @tiangolo.

0.113.0Â¶

Now you can declare form fields with Pydantic models:

from typing import Annotated

from fastapi import FastAPI, Form
from pydantic import BaseModel

app = FastAPI()


class FormData(BaseModel):
    username: str
    password: str


@app.post("/login/")
async def login(data: Annotated[FormData, Form()]):
    return data

Read the new docs: Form Models.
FeaturesÂ¶

    âœ¨ Add support for Pydantic models in Form parameters. PR #12129 by @tiangolo.

InternalÂ¶

    ğŸ”§ Update sponsors: Coherence link. PR #12130 by @tiangolo.

0.112.4Â¶

This release is mainly a big internal refactor to enable adding support for Pydantic models for Form fields, but that feature comes in the next release.

This release shouldn't affect apps using FastAPI in any way. You don't even have to upgrade to this version yet. It's just a checkpoint. ğŸ¤“
RefactorsÂ¶

    â™»ï¸ Refactor deciding if embed body fields, do not overwrite fields, compute once per router, refactor internals in preparation for Pydantic models in Form, Query and others. PR #12117 by @tiangolo.

InternalÂ¶

    âªï¸ Temporarily revert "âœ¨ Add support for Pydantic models in Form parameters" to make a checkpoint release. PR #12128 by @tiangolo. Restored by PR #12129.
    âœ¨ Add support for Pydantic models in Form parameters. PR #12127 by @tiangolo. Reverted by PR #12128 to make a checkpoint release with only refactors. Restored by PR #12129.

0.112.3Â¶

This release is mainly internal refactors, it shouldn't affect apps using FastAPI in any way. You don't even have to upgrade to this version yet. There are a few bigger releases coming right after. ğŸš€
RefactorsÂ¶

    â™»ï¸ Refactor internal check_file_field(), rename to ensure_multipart_is_installed() to clarify its purpose. PR #12106 by @tiangolo.
    â™»ï¸ Rename internal create_response_field() to create_model_field() as it's used for more than response models. PR #12103 by @tiangolo.
    â™»ï¸ Refactor and simplify internal data from solve_dependencies() using dataclasses. PR #12100 by @tiangolo.
    â™»ï¸ Refactor and simplify internal analyze_param() to structure data with dataclasses instead of tuple. PR #12099 by @tiangolo.
    â™»ï¸ Refactor and simplify dependencies data structures with dataclasses. PR #12098 by @tiangolo.

DocsÂ¶

    ğŸ“ Add External Link: Techniques and applications of SQLAlchemy global filters in FastAPI. PR #12109 by @TheShubhendra.
    ğŸ“ Add note about time.perf_counter() in middlewares. PR #12095 by @tiangolo.
    ğŸ“ Tweak middleware code sample time.time() to time.perf_counter(). PR #11957 by @domdent.
    ğŸ”§ Update sponsors: Coherence. PR #12093 by @tiangolo.
    ğŸ“ Fix async test example not to trigger DeprecationWarning. PR #12084 by @marcinsulikowski.
    ğŸ“ Update docs_src/path_params_numeric_validations/tutorial006.py. PR #11478 by @MuhammadAshiqAmeer.
    ğŸ“ Update comma in docs/en/docs/async.md. PR #12062 by @Alec-Gillis.
    ğŸ“ Update docs about serving FastAPI: ASGI servers, Docker containers, etc.. PR #12069 by @tiangolo.
    ğŸ“ Clarify response_class parameter, validations, and returning a response directly. PR #12067 by @tiangolo.
    ğŸ“ Fix minor typos and issues in the documentation. PR #12063 by @svlandeg.
    ğŸ“ Add note in Docker docs about ensuring graceful shutdowns and lifespan events with CMD exec form. PR #11960 by @GPla.

TranslationsÂ¶

    ğŸŒ Add Dutch translation for docs/nl/docs/features.md. PR #12101 by @maxscheijen.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/testing-events.md. PR #12108 by @ceb10n.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/security/index.md. PR #12114 by @ceb10n.
    ğŸŒ Add Dutch translation for docs/nl/docs/index.md. PR #12042 by @svlandeg.
    ğŸŒ Update Chinese translation for docs/zh/docs/how-to/index.md. PR #12070 by @synthpop123.

InternalÂ¶

    â¬† [pre-commit.ci] pre-commit autoupdate. PR #12115 by @pre-commit-ci[bot].
    â¬† Bump pypa/gh-action-pypi-publish from 1.10.0 to 1.10.1. PR #12120 by @dependabot[bot].
    â¬† Bump pillow from 10.3.0 to 10.4.0. PR #12105 by @dependabot[bot].
    ğŸ’š Set include-hidden-files to True when using the upload-artifact GH action. PR #12118 by @svlandeg.
    â¬† Bump pypa/gh-action-pypi-publish from 1.9.0 to 1.10.0. PR #12112 by @dependabot[bot].
    ğŸ”§ Update sponsors link: Coherence. PR #12097 by @tiangolo.
    ğŸ”§ Update labeler config to handle sponsorships data. PR #12096 by @tiangolo.
    ğŸ”§ Update sponsors, remove Kong. PR #12085 by @tiangolo.
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #12076 by @pre-commit-ci[bot].
    ğŸ‘· Update latest-changes GitHub Action. PR #12073 by @tiangolo.

0.112.2Â¶
FixesÂ¶

    ğŸ› Fix allow_inf_nan option for Param and Body classes. PR #11867 by @giunio-prc.
    ğŸ› Ensure that app.include_router merges nested lifespans. PR #9630 by @Lancetnik.

RefactorsÂ¶

    ğŸ¨ Fix typing annotation for semi-internal FastAPI.add_api_route(). PR #10240 by @ordinary-jamie.
    â¬†ï¸ Upgrade version of Ruff and reformat. PR #12032 by @tiangolo.

DocsÂ¶

    ğŸ“ Fix a typo in docs/en/docs/virtual-environments.md. PR #12064 by @aymenkrifa.
    ğŸ“ Add docs about Environment Variables and Virtual Environments. PR #12054 by @tiangolo.
    ğŸ“ Add Asyncer mention in async docs. PR #12037 by @tiangolo.
    ğŸ“ Move the Features docs to the top level to improve the main page menu. PR #12036 by @tiangolo.
    âœï¸ Fix import typo in reference example for Security. PR #11168 by @0shah0.
    ğŸ“ Highlight correct line in tutorial docs/en/docs/tutorial/body-multiple-params.md. PR #11978 by @svlandeg.
    ğŸ”¥ Remove Sentry link from Advanced Middleware docs. PR #12031 by @alejsdev.
    ğŸ“ Clarify management tasks for translations, multiples files in one PR. PR #12030 by @tiangolo.
    ğŸ“ Edit the link to the OpenAPI "Responses Object" and "Response Object" sections in the "Additional Responses in OpenAPI" section. PR #11996 by @VaitoSoi.
    ğŸ”¨ Specify email-validator dependency with dash. PR #11515 by @jirikuncar.
    ğŸŒ Add Spanish translation for docs/es/docs/project-generation.md. PR #11947 by @alejsdev.
    ğŸ“ Fix minor typo. PR #12026 by @MicaelJarniac.
    ğŸ“ Several docs improvements, tweaks, and clarifications. PR #11390 by @nilslindemann.
    ğŸ“ Add missing compresslevel parameter on docs for GZipMiddleware. PR #11350 by @junah201.
    ğŸ“ Fix inconsistent response code when item already exists in docs for testing. PR #11818 by @lokomilo.
    ğŸ“ Update docs/en/docs/tutorial/body.md with Python 3.10 union type example. PR #11415 by @rangzen.

TranslationsÂ¶

    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/request_file.md. PR #12018 by @Joao-Pedro-P-Holanda.
    ğŸŒ Add Japanese translation for docs/ja/docs/learn/index.md. PR #11592 by @ukwhatn.
    ğŸ“ Update Spanish translation docs for consistency. PR #12044 by @alejsdev.
    ğŸŒ Update Chinese translation for docs/zh/docs/tutorial/dependencies/dependencies-with-yield.md. PR #12028 by @xuvjso.
    ğŸ“ Update FastAPI People, do not translate to have the most recent info. PR #12034 by @tiangolo.
    ğŸŒ Update Urdu translation for docs/ur/docs/benchmarks.md. PR #10046 by @AhsanSheraz.

InternalÂ¶

    â¬† [pre-commit.ci] pre-commit autoupdate. PR #12046 by @pre-commit-ci[bot].
    ğŸ”§ Update coverage config files. PR #12035 by @tiangolo.
    ğŸ”¨ Standardize shebang across shell scripts. PR #11942 by @gitworkflows.
    â¬† Update sqlalchemy requirement from <1.4.43,>=1.3.18 to >=1.3.18,<2.0.33. PR #11979 by @dependabot[bot].
    ğŸ”Š Remove old ignore warnings. PR #11950 by @tiangolo.
    â¬†ï¸ Upgrade griffe-typingdoc for the docs. PR #12029 by @tiangolo.
    ğŸ™ˆ Add .coverage* to .gitignore. PR #11940 by @gitworkflows.
    âš™ï¸ Record and show test coverage contexts (what test covers which line). PR #11518 by @slafs.

0.112.1Â¶
UpgradesÂ¶

    â¬†ï¸ Allow Starlette 0.38.x, update the pin to >=0.37.2,<0.39.0. PR #11876 by @musicinmybrain.

DocsÂ¶

    ğŸ“ Update docs section about "Don't Translate these Pages". PR #12022 by @tiangolo.
    ğŸ“ Add documentation for non-translated pages and scripts to verify them. PR #12020 by @tiangolo.
    ğŸ“ Update docs about discussions questions. PR #11985 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/bigger-applications.md. PR #11971 by @marcelomarkus.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/testing-websockets.md. PR #11994 by @ceb10n.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/testing-dependencies.md. PR #11995 by @ceb10n.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/using-request-directly.md. PR #11956 by @ceb10n.
    ğŸŒ Add French translation for docs/fr/docs/tutorial/body-multiple-params.md. PR #11796 by @pe-brian.
    ğŸŒ Update Chinese translation for docs/zh/docs/tutorial/query-params.md. PR #11557 by @caomingpei.
    ğŸŒ Update typo in Chinese translation for docs/zh/docs/advanced/testing-dependencies.md. PR #11944 by @bestony.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/sub-applications.md and docs/pt/docs/advanced/behind-a-proxy.md. PR #11856 by @marcelomarkus.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/cors.md and docs/pt/docs/tutorial/middleware.md. PR #11916 by @wesinalves.
    ğŸŒ Add French translation for docs/fr/docs/tutorial/path-params-numeric-validations.md. PR #11788 by @pe-brian.

InternalÂ¶

    â¬† Bump pypa/gh-action-pypi-publish from 1.8.14 to 1.9.0. PR #11727 by @dependabot[bot].
    ğŸ”§ Add changelog URL to pyproject.toml, shows in PyPI. PR #11152 by @Pierre-VF.
    ğŸ‘· Do not sync labels as it overrides manually added labels. PR #12024 by @tiangolo.
    ğŸ‘·ğŸ» Update Labeler GitHub Actions. PR #12019 by @tiangolo.
    ğŸ”§ Update configs for MkDocs for languages and social cards. PR #12016 by @tiangolo.
    ğŸ‘· Update permissions and config for labeler GitHub Action. PR #12008 by @tiangolo.
    ğŸ‘·ğŸ» Add GitHub Action label-checker. PR #12005 by @tiangolo.
    ğŸ‘· Add label checker GitHub Action. PR #12004 by @tiangolo.
    ğŸ‘· Update GitHub Action add-to-project. PR #12002 by @tiangolo.
    ğŸ”§ Update labeler GitHub Action. PR #12001 by @tiangolo.
    ğŸ‘· Add GitHub Action labeler. PR #12000 by @tiangolo.
    ğŸ‘· Add GitHub Action add-to-project. PR #11999 by @tiangolo.
    ğŸ“ Update admonitions in docs missing. PR #11998 by @tiangolo.
    ğŸ”¨ Update docs.py script to enable dirty reload conditionally. PR #11986 by @tiangolo.
    ğŸ”§ Update MkDocs instant previews. PR #11982 by @tiangolo.
    ğŸ› Fix deploy docs previews script to handle mkdocs.yml files. PR #11984 by @tiangolo.
    ğŸ’¡ Add comment about custom Termynal line-height. PR #11976 by @tiangolo.
    ğŸ‘· Add alls-green for test-redistribute. PR #11974 by @tiangolo.
    ğŸ‘· Update docs-previews to handle no docs changes. PR #11975 by @tiangolo.
    ğŸ”¨ Refactor script deploy_docs_status.py to account for deploy URLs with or without trailing slash. PR #11965 by @tiangolo.
    ğŸ”’ï¸ Update permissions for deploy-docs action. PR #11964 by @tiangolo.
    ğŸ‘·ğŸ» Add deploy docs status and preview links to PRs. PR #11961 by @tiangolo.
    ğŸ”§ Update docs setup with latest configs and plugins. PR #11953 by @tiangolo.
    ğŸ”‡ Ignore warning from attrs in Trio. PR #11949 by @tiangolo.

0.112.0Â¶
Breaking ChangesÂ¶

    â™»ï¸ Add support for pip install "fastapi[standard]" with standard dependencies and python -m fastapi. PR #11935 by @tiangolo.

SummaryÂ¶

Install with:

pip install "fastapi[standard]"

Other ChangesÂ¶

    This adds support for calling the CLI as:

python -m fastapi

    And it upgrades fastapi-cli[standard] >=0.0.5.

Technical DetailsÂ¶

Before this, fastapi would include the standard dependencies, with Uvicorn and the fastapi-cli, etc.

And fastapi-slim would not include those standard dependencies.

Now fastapi doesn't include those standard dependencies unless you install with pip install "fastapi[standard]".

Before, you would install pip install fastapi, now you should include the standard optional dependencies (unless you want to exclude one of those): pip install "fastapi[standard]".

This change is because having the standard optional dependencies installed by default was being inconvenient to several users, and having to install instead fastapi-slim was not being a feasible solution.

Discussed here: #11522 and here: #11525
DocsÂ¶

    âœï¸ Fix typos in docs. PR #11926 by @jianghuyiyuan.
    ğŸ“ Tweak management docs. PR #11918 by @tiangolo.
    ğŸšš Rename GitHub links from tiangolo/fastapi to fastapi/fastapi. PR #11913 by @tiangolo.
    ğŸ“ Add docs about FastAPI team and project management. PR #11908 by @tiangolo.
    ğŸ“ Re-structure docs main menu. PR #11904 by @tiangolo.
    ğŸ“ Update Speakeasy URL. PR #11871 by @ndimares.

TranslationsÂ¶

    ğŸŒ Update Portuguese translation for docs/pt/docs/alternatives.md. PR #11931 by @ceb10n.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/dependencies/sub-dependencies.md. PR #10515 by @AlertRED.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/response-change-status-code.md. PR #11863 by @ceb10n.
    ğŸŒ Add Portuguese translation for docs/pt/docs/reference/background.md. PR #11849 by @lucasbalieiro.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/dependencies/dependencies-with-yield.md. PR #11848 by @Joao-Pedro-P-Holanda.
    ğŸŒ Add Portuguese translation for docs/pt/docs/reference/apirouter.md. PR #11843 by @lucasbalieiro.

InternalÂ¶

    ğŸ”§ Update sponsors: add liblab. PR #11934 by @tiangolo.
    ğŸ‘· Update GitHub Action label-approved permissions. PR #11933 by @tiangolo.
    ğŸ‘· Refactor GitHub Action to comment docs deployment URLs and update token. PR #11925 by @tiangolo.
    ğŸ‘· Update tokens for GitHub Actions. PR #11924 by @tiangolo.
    ğŸ‘· Update token permissions to comment deployment URL in docs. PR #11917 by @tiangolo.
    ğŸ‘· Update token permissions for GitHub Actions. PR #11915 by @tiangolo.
    ğŸ‘· Update GitHub Actions token usage. PR #11914 by @tiangolo.
    ğŸ‘· Update GitHub Action to notify translations with label approved-1. PR #11907 by @tiangolo.
    ğŸ”§ Update sponsors, remove Reflex. PR #11875 by @tiangolo.
    ğŸ”§ Update sponsors: remove TalkPython. PR #11861 by @tiangolo.
    ğŸ”¨ Update docs Termynal scripts to not include line nums for local dev. PR #11854 by @tiangolo.

0.111.1Â¶
UpgradesÂ¶

    â– Remove orjson and ujson from default dependencies. PR #11842 by @tiangolo.
        These dependencies are still installed when you install with pip install "fastapi[all]". But they are not included in pip install fastapi.
    ğŸ“ Restored Swagger-UI links to use the latest version possible. PR #11459 by @UltimateLobster.

DocsÂ¶

    âœï¸ Rewording in docs/en/docs/fastapi-cli.md. PR #11716 by @alejsdev.
    ğŸ“ Update Hypercorn links in all the docs. PR #11744 by @kittydoor.
    ğŸ“ Update docs with Ariadne reference from Starlette to FastAPI. PR #11797 by @DamianCzajkowski.
    ğŸ“ Update fastapi instrumentation external link. PR #11317 by @softwarebloat.
    âœï¸ Fix links to alembic example repo in docs. PR #11628 by @augiwan.
    âœï¸ Update docs/en/docs/fastapi-cli.md. PR #11715 by @alejsdev.
    ğŸ“ Update External Links . PR #11500 by @devon2018.
    ğŸ“ Add External Link: Tutorial de FastAPI, Â¿el mejor framework de Python?. PR #11618 by @EduardoZepeda.
    ğŸ“ Fix typo in docs/en/docs/tutorial/body-multiple-params.md. PR #11698 by @mwb-u.
    ğŸ“ Add External Link: Deploy a Serverless FastAPI App with Neon Postgres and AWS App Runner at any scale. PR #11633 by @ananis25.
    ğŸ“ Update security/first-steps.md. PR #11674 by @alejsdev.
    ğŸ“ Update security/first-steps.md. PR #11673 by @alejsdev.
    ğŸ“ Update note in path-params-numeric-validations.md. PR #11672 by @alejsdev.
    ğŸ“ Tweak intro docs about Annotated and Query() params. PR #11664 by @tiangolo.
    ğŸ“ Update JWT auth documentation to use PyJWT instead of pyhon-jose. PR #11589 by @estebanx64.
    ğŸ“ Update docs. PR #11603 by @alejsdev.
    âœï¸ Fix typo: convert every 're-use' to 'reuse'.. PR #11598 by @hasansezertasan.
    âœï¸ Fix typo in fastapi/applications.py. PR #11593 by @petarmaric.
    âœï¸ Fix link in fastapi-cli.md. PR #11524 by @svlandeg.

TranslationsÂ¶

    ğŸŒ Add Spanish translation for docs/es/docs/how-to/graphql.md. PR #11697 by @camigomezdev.
    ğŸŒ Add Portuguese translation for docs/pt/docs/reference/index.md. PR #11840 by @lucasbalieiro.
    ğŸŒ Fix link in German translation. PR #11836 by @anitahammer.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/dependencies/sub-dependencies.md. PR #11792 by @Joao-Pedro-P-Holanda.
    ğŸŒ Add Turkish translation for docs/tr/docs/tutorial/request-forms.md. PR #11553 by @hasansezertasan.
    ğŸŒ Add Portuguese translation for docs/pt/docs/reference/exceptions.md. PR #11834 by @lucasbalieiro.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/dependencies/global-dependencies.md. PR #11826 by @Joao-Pedro-P-Holanda.
    ğŸŒ Add Portuguese translation for docs/pt/docs/how-to/general.md. PR #11825 by @lucasbalieiro.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/async-tests.md. PR #11808 by @ceb10n.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/first-steps.md. PR #11809 by @vkhoroshchak.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/dependencies/dependencies-in-path-operation-operators.md. PR #11804 by @Joao-Pedro-P-Holanda.
    ğŸŒ Add Chinese translation for docs/zh/docs/fastapi-cli.md. PR #11786 by @logan2d5.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/openapi-webhooks.md. PR #11791 by @ceb10n.
    ğŸŒ Update Chinese translation for docs/tutorial/security/oauth2-jwt.md. PR #11781 by @logan2d5.
    ğŸ“ Fix image missing in French translation for docs/fr/docs/async.md . PR #11787 by @pe-brian.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/advanced-dependencies.md. PR #11775 by @ceb10n.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/dependencies/classes-as-dependencies.md. PR #11768 by @Joao-Pedro-P-Holanda.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/additional-status-codes.md. PR #11753 by @ceb10n.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/dependencies/index.md. PR #11757 by @Joao-Pedro-P-Holanda.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/settings.md. PR #11739 by @Joao-Pedro-P-Holanda.
    ğŸŒ Add French translation for docs/fr/docs/learn/index.md. PR #11712 by @benjaminvandammeholberton.
    ğŸŒ Add Portuguese translation for docs/pt/docs/how-to/index.md. PR #11731 by @vhsenna.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/additional-responses.md. PR #11736 by @ceb10n.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/benchmarks.md. PR #11713 by @ceb10n.
    ğŸŒ Fix Korean translation for docs/ko/docs/tutorial/response-status-code.md. PR #11718 by @nayeonkinn.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/extra-data-types.md. PR #11711 by @nayeonkinn.
    ğŸŒ Fix Korean translation for docs/ko/docs/tutorial/body-nested-models.md. PR #11710 by @nayeonkinn.
    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/fastapi-cli.md. PR #11641 by @ayr-ton.
    ğŸŒ Add Traditional Chinese translation for docs/zh-hant/docs/fastapi-people.md. PR #11639 by @hsuanchi.
    ğŸŒ Add Turkish translation for docs/tr/docs/advanced/index.md. PR #11606 by @hasansezertasan.
    ğŸŒ Add Turkish translation for docs/tr/docs/deployment/cloud.md. PR #11610 by @hasansezertasan.
    ğŸŒ Add Turkish translation for docs/tr/docs/advanced/security/index.md. PR #11609 by @hasansezertasan.
    ğŸŒ Add Turkish translation for docs/tr/docs/advanced/testing-websockets.md. PR #11608 by @hasansezertasan.
    ğŸŒ Add Turkish translation for docs/tr/docs/how-to/general.md. PR #11607 by @hasansezertasan.
    ğŸŒ Update Chinese translation for docs/zh/docs/advanced/templates.md. PR #11620 by @chaoless.
    ğŸŒ Add Turkish translation for docs/tr/docs/deployment/index.md. PR #11605 by @hasansezertasan.
    ğŸŒ Add Turkish translation for docs/tr/docs/tutorial/static-files.md. PR #11599 by @hasansezertasan.
    ğŸŒ Polish translation for docs/pl/docs/fastapi-people.md. PR #10196 by @isulim.
    ğŸŒ Add Turkish translation for docs/tr/docs/advanced/wsgi.md. PR #11575 by @hasansezertasan.
    ğŸŒ Add Turkish translation for docs/tr/docs/tutorial/cookie-params.md. PR #11561 by @hasansezertasan.
    ğŸŒ Add Russian translation for docs/ru/docs/about/index.md. PR #10961 by @s111d.
    ğŸŒ Update Chinese translation for docs/zh/docs/tutorial/sql-databases.md. PR #11539 by @chaoless.
    ğŸŒ Add Chinese translation for docs/zh/docs/how-to/configure-swagger-ui.md. PR #11501 by @Lucas-lyh.
    ğŸŒ Update Chinese translation for /docs/advanced/security/http-basic-auth.md. PR #11512 by @nick-cjyx9.

InternalÂ¶

    â™»ï¸ Simplify internal docs script. PR #11777 by @gitworkflows.
    ğŸ”§ Update sponsors: add Fine. PR #11784 by @tiangolo.
    ğŸ”§ Tweak sponsors: Kong URL. PR #11765 by @tiangolo.
    ğŸ”§ Tweak sponsors: Kong URL. PR #11764 by @tiangolo.
    ğŸ”§ Update sponsors, add Stainless. PR #11763 by @tiangolo.
    ğŸ”§ Update sponsors, add Zuplo. PR #11729 by @tiangolo.
    ğŸ”§ Update Sponsor link: Coherence. PR #11730 by @tiangolo.
    ğŸ‘¥ Update FastAPI People. PR #11669 by @tiangolo.
    ğŸ”§ Add sponsor Kong. PR #11662 by @tiangolo.
    ğŸ‘· Update Smokeshow, fix sync download artifact and smokeshow configs. PR #11563 by @tiangolo.
    ğŸ‘· Update Smokeshow download artifact GitHub Action. PR #11562 by @tiangolo.
    ğŸ‘· Update GitHub actions to download and upload artifacts to v4, for docs and coverage. PR #11550 by @tamird.
    ğŸ‘· Tweak CI for test-redistribute, add needed env vars for slim. PR #11549 by @tiangolo.
    ğŸ‘¥ Update FastAPI People. PR #11511 by @tiangolo.

0.111.0Â¶
FeaturesÂ¶

    âœ¨ Add FastAPI CLI, the new fastapi command. PR #11522 by @tiangolo.
        New docs: FastAPI CLI.

Try it out with:

$ pip install --upgrade fastapi

$ fastapi dev main.py


 â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FastAPI CLI - Development mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
 â”‚                                                     â”‚
 â”‚  Serving at: http://127.0.0.1:8000                  â”‚
 â”‚                                                     â”‚
 â”‚  API docs: http://127.0.0.1:8000/docs               â”‚
 â”‚                                                     â”‚
 â”‚  Running in development mode, for production use:   â”‚
 â”‚                                                     â”‚
 â”‚  fastapi run                                        â”‚
 â”‚                                                     â”‚
 â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

INFO:     Will watch for changes in these directories: ['/home/user/code/awesomeapp']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [2248755] using WatchFiles
INFO:     Started server process [2248757]
INFO:     Waiting for application startup.
INFO:     Application startup complete.

RefactorsÂ¶

    ğŸ”§ Add configs and setup for fastapi-slim including optional extras fastapi-slim[standard], and fastapi including by default the same standard extras. PR #11503 by @tiangolo.

0.110.3Â¶
DocsÂ¶

    ğŸ“ Update references to Python version, FastAPI supports all the current versions, no need to make the version explicit. PR #11496 by @tiangolo.
    âœï¸ Fix typo in fastapi/security/api_key.py. PR #11481 by @ch33zer.
    âœï¸ Fix typo in security/http.py. PR #11455 by @omarmoo5.

TranslationsÂ¶

    ğŸŒ Add Traditional Chinese translation for docs/zh-hant/benchmarks.md. PR #11484 by @KNChiu.
    ğŸŒ Update Chinese translation for docs/zh/docs/fastapi-people.md. PR #11476 by @billzhong.
    ğŸŒ Add Chinese translation for docs/zh/docs/how-to/index.md and docs/zh/docs/how-to/general.md. PR #11443 by @billzhong.
    ğŸŒ Add Spanish translation for cookie-params docs/es/docs/tutorial/cookie-params.md. PR #11410 by @fabianfalon.

InternalÂ¶

    â¬† Bump mkdocstrings[python] from 0.23.0 to 0.24.3. PR #11469 by @dependabot[bot].
    ğŸ”¨ Update internal scripts and remove unused ones. PR #11499 by @tiangolo.
    ğŸ”§ Migrate from Hatch to PDM for the internal build. PR #11498 by @tiangolo.
    â¬†ï¸ Upgrade MkDocs Material and re-enable cards. PR #11466 by @tiangolo.
    â¬† Bump pillow from 10.2.0 to 10.3.0. PR #11403 by @dependabot[bot].
    ğŸ”§ Ungroup dependabot updates. PR #11465 by @tiangolo.

0.110.2Â¶
FixesÂ¶

    ğŸ› Fix support for query parameters with list types, handle JSON encoding Pydantic UndefinedType. PR #9929 by @arjwilliams.

RefactorsÂ¶

    â™»ï¸ Simplify Pydantic configs in OpenAPI models in fastapi/openapi/models.py. PR #10886 by @JoeTanto2.
    âœ¨ Add support for Pydantic's 2.7 new deprecated Field parameter, remove URL from validation errors response. PR #11461 by @tiangolo.

DocsÂ¶

    ğŸ“ Fix types in examples under docs_src/extra_data_types. PR #10535 by @nilslindemann.
    ğŸ“ Update references to UJSON. PR #11464 by @tiangolo.
    ğŸ“ Tweak docs and translations links, typos, format. PR #11389 by @nilslindemann.
    ğŸ“ Fix typo in docs/es/docs/async.md. PR #11400 by @fabianfalon.
    ğŸ“ Update OpenAPI client generation docs to use @hey-api/openapi-ts. PR #11339 by @jordanshatford.

TranslationsÂ¶

    ğŸŒ Update Chinese translation for docs/zh/docs/index.html. PR #11430 by @waketzheng.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md. PR #11411 by @anton2yakovlev.
    ğŸŒ Add Portuguese translations for learn/index.md resources/index.md help/index.md about/index.md. PR #10807 by @nazarepiedady.
    ğŸŒ Update Russian translations for deployments docs. PR #11271 by @Lufa1u.
    ğŸŒ Add Bengali translations for docs/bn/docs/python-types.md. PR #11376 by @imtiaz101325.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/security/simple-oauth2.md. PR #5744 by @KdHyeon0661.
    ğŸŒ Add Korean translation for docs/ko/docs/help-fastapi.md. PR #4139 by @kty4119.
    ğŸŒ Add Korean translation for docs/ko/docs/advanced/events.md. PR #5087 by @pers0n4.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/path-operation-configuration.md. PR #1954 by @SwftAlpc.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/request-forms-and-files.md. PR #1946 by @SwftAlpc.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/dependencies/dependencies-with-yield.md. PR #10532 by @AlertRED.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/debugging.md. PR #5695 by @JungWooGeon.

InternalÂ¶

    â¬†ï¸ Upgrade version of typer for docs. PR #11393 by @tiangolo.

0.110.1Â¶
FixesÂ¶

    ğŸ› Fix parameterless Depends() with generics. PR #9479 by @nzig.

RefactorsÂ¶

    â™»ï¸ Update mypy. PR #11049 by @k0t3n.
    â™»ï¸ Simplify string format with f-strings in fastapi/applications.py. PR #11335 by @igeni.

UpgradesÂ¶

    â¬†ï¸ Upgrade Starlette to >=0.37.2,<0.38.0, remove Starlette filterwarning for internal tests. PR #11266 by @nothielf.

DocsÂ¶

    ğŸ“ Tweak docs and translations links and remove old docs translations. PR #11381 by @tiangolo.
    âœï¸ Fix typo in fastapi/security/oauth2.py. PR #11368 by @shandongbinzhou.
    ğŸ“ Update links to Pydantic docs to point to new website. PR #11328 by @alejsdev.
    âœï¸ Fix typo in docs/en/docs/tutorial/extra-models.md. PR #11329 by @alejsdev.
    ğŸ“ Update project-generation.md. PR #11326 by @alejsdev.
    ğŸ“ Update External Links. PR #11327 by @alejsdev.
    ğŸ”¥ Remove link to Pydantic's benchmark, on other i18n pages.. PR #11224 by @hirotoKirimaru.
    âœï¸ Fix typos in docstrings. PR #11295 by @davidhuser.
    ğŸ› ï¸ Improve Node.js script in docs to generate TypeScript clients. PR #11293 by @alejsdev.
    ğŸ“ Update examples for tests to replace "inexistent" for "nonexistent". PR #11220 by @Homesteady.
    ğŸ“ Update python-multipart GitHub link in all docs from https://andrew-d.github.io/python-multipart/ to https://github.com/Kludex/python-multipart. PR #11239 by @joshjhans.

TranslationsÂ¶

    ğŸŒ Add German translation for docs/de/docs/tutorial/response-status-code.md. PR #10357 by @nilslindemann.
    ğŸŒ Update Chinese translation for docs/zh/docs/tutorial/query-params.md. PR #3480 by @jaystone776.
    ğŸŒ Update Chinese translation for docs/zh/docs/tutorial/body.md. PR #3481 by @jaystone776.
    ğŸŒ Update Chinese translation for docs/zh/docs/tutorial/path-params.md. PR #3479 by @jaystone776.
    ğŸŒ Update Chinese translation for docs/tutorial/body-fields.md. PR #3496 by @jaystone776.
    ğŸŒ Update Chinese translation for docs/tutorial/extra-models.md. PR #3497 by @jaystone776.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/metadata.md. PR #2667 by @tokusumi.
    ğŸŒ Add German translation for docs/de/docs/contributing.md. PR #10487 by @nilslindemann.
    ğŸŒ Update Japanese translation of docs/ja/docs/tutorial/query-params.md. PR #10808 by @urushio.
    ğŸŒ Update Chinese translation for docs/zh/docs/tutorial/security/get-current-user.md. PR #3842 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/openapi-callbacks.md. PR #3825 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/extending-openapi.md. PR #3823 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/testing-dependencies.md. PR #3819 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/custom-request-and-route.md. PR #3816 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/external-links.md. PR #3833 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/templates.md. PR #3812 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/sub-applications.md. PR #3811 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/async-sql-databases.md. PR #3805 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/middleware.md. PR #3804 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/dataclasses.md. PR #3803 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/using-request-directly.md. PR #3802 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/security/http-basic-auth.md. PR #3801 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/security/oauth2-scopes.md. PR #3800 by @jaystone776.
    ğŸŒ Update Chinese translation for docs/zh/docs/tutorial/cookie-params.md. PR #3486 by @jaystone776.
    ğŸŒ Update Chinese translation for docs/zh/docs/tutorial/header-params.md. PR #3487 by @jaystone776.
    ğŸŒ Update Chinese translation for docs/tutorial/response-status-code.md. PR #3498 by @jaystone776.
    ğŸŒ Add German translation for docs/de/docs/tutorial/security/first-steps.md. PR #10432 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/events.md. PR #10693 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/deployment/cloud.md. PR #10746 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/behind-a-proxy.md. PR #10675 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/help-fastapi.md. PR #10455 by @nilslindemann.
    ğŸŒ Update German translation for docs/de/docs/python-types.md. PR #10287 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/path-params.md. PR #10290 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/handling-errors.md. PR #10379 by @nilslindemann.
    ğŸŒ Update German translation for docs/de/docs/index.md. PR #10283 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/security/http-basic-auth.md. PR #10651 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/bigger-applications.md. PR #10554 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/path-operation-advanced-configuration.md. PR #10612 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/static-files.md. PR #10584 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/security/oauth2-jwt.md. PR #10522 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/response-model.md. PR #10345 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/extra-models.md. PR #10351 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/body-updates.md. PR #10396 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/alternatives.md. PR #10855 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/templates.md. PR #10678 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/security/oauth2-scopes.md. PR #10643 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/async-tests.md. PR #10708 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/metadata.md. PR #10581 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/testing.md. PR #10586 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/schema-extra-example.md. PR #10597 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/index.md. PR #10611 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/response-directly.md. PR #10618 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/additional-responses.md. PR #10626 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/response-cookies.md. PR #10627 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/response-headers.md. PR #10628 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/response-change-status-code.md. PR #10632 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/advanced-dependencies.md. PR #10633 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/security/index.md. PR #10635 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/using-request-directly.md. PR #10653 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/dataclasses.md. PR #10667 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/middleware.md. PR #10668 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/sub-applications.md. PR #10671 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/websockets.md. PR #10687 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/testing-websockets.md. PR #10703 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/testing-events.md. PR #10704 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/testing-dependencies.md. PR #10706 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/openapi-callbacks.md. PR #10710 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/settings.md. PR #10709 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/wsgi.md. PR #10713 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/deployment/index.md. PR #10733 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/deployment/https.md. PR #10737 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/deployment/manually.md. PR #10738 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/deployment/concepts.md. PR #10744 by @nilslindemann.
    ğŸŒ Update German translation for docs/de/docs/features.md. PR #10284 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/deployment/server-workers.md. PR #10747 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/deployment/docker.md. PR #10759 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/how-to/index.md. PR #10769 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/how-to/general.md. PR #10770 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/how-to/graphql.md. PR #10788 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/how-to/custom-request-and-route.md. PR #10789 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/how-to/conditional-openapi.md. PR #10790 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/how-to/separate-openapi-schemas.md. PR #10796 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/how-to/configure-swagger-ui.md. PR #10804 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/how-to/custom-docs-ui-assets.md. PR #10803 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/reference/parameters.md. PR #10814 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/reference/status.md. PR #10815 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/reference/uploadfile.md. PR #10816 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/reference/exceptions.md. PR #10817 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/reference/dependencies.md. PR #10818 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/reference/apirouter.md. PR #10819 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/reference/websockets.md. PR #10822 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/reference/httpconnection.md. PR #10823 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/reference/response.md. PR #10824 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/reference/middleware.md. PR #10837 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/reference/openapi/*.md. PR #10838 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/reference/security/index.md. PR #10839 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/reference/staticfiles.md. PR #10841 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/reference/testclient.md. PR #10843 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/project-generation.md. PR #10851 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/history-design-future.md. PR #10865 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/dependencies/dependencies-with-yield.md. PR #10422 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/dependencies/global-dependencies.md. PR #10420 by @nilslindemann.
    ğŸŒ Update German translation for docs/de/docs/fastapi-people.md. PR #10285 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/dependencies/sub-dependencies.md. PR #10409 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/security/index.md. PR #10429 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md. PR #10411 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/extra-data-types.md. PR #10534 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/security/simple-oauth2.md. PR #10504 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/security/get-current-user.md. PR #10439 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/request-forms-and-files.md. PR #10368 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/encoder.md. PR #10385 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/request-forms.md. PR #10361 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/deployment/versions.md. PR #10491 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/async.md. PR #10449 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/cookie-params.md. PR #10323 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/dependencies/classes-as-dependencies.md. PR #10407 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/dependencies/index.md. PR #10399 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/header-params.md. PR #10326 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/path-params-numeric-validations.md. PR #10307 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/query-params-str-validations.md. PR #10304 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/request-files.md. PR #10364 by @nilslindemann.
    :globe_with_meridians: Add Portuguese translation for docs/pt/docs/advanced/templates.md. PR #11338 by @SamuelBFavarin.
    ğŸŒ Add Bengali translations for docs/bn/docs/learn/index.md. PR #11337 by @imtiaz101325.
    ğŸŒ Fix Korean translation for docs/ko/docs/index.md. PR #11296 by @choi-haram.
    ğŸŒ Add Korean translation for docs/ko/docs/about/index.md. PR #11299 by @choi-haram.
    ğŸŒ Add Korean translation for docs/ko/docs/advanced/index.md. PR #9613 by @ElliottLarsen.
    ğŸŒ Add German translation for docs/de/docs/how-to/extending-openapi.md. PR #10794 by @nilslindemann.
    ğŸŒ Update Chinese translation for docs/zh/docs/tutorial/metadata.md. PR #11286 by @jackleeio.
    ğŸŒ Update Chinese translation for docs/zh/docs/contributing.md. PR #10887 by @Aruelius.
    ğŸŒ Add Azerbaijani translation for docs/az/docs/fastapi-people.md. PR #11195 by @vusallyv.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/dependencies/index.md. PR #11223 by @kohiry.
    ğŸŒ Update Chinese translation for docs/zh/docs/tutorial/query-params.md. PR #11242 by @jackleeio.
    ğŸŒ Add Azerbaijani translation for docs/az/learn/index.md. PR #11192 by @vusallyv.

InternalÂ¶

    ğŸ‘¥ Update FastAPI People. PR #11387 by @tiangolo.
    â¬† Bump actions/cache from 3 to 4. PR #10988 by @dependabot[bot].
    â¬† Bump pypa/gh-action-pypi-publish from 1.8.11 to 1.8.14. PR #11318 by @dependabot[bot].
    â¬† Bump pillow from 10.1.0 to 10.2.0. PR #11011 by @dependabot[bot].
    â¬† Bump black from 23.3.0 to 24.3.0. PR #11325 by @dependabot[bot].
    ğŸ‘· Add cron to run test once a week on monday. PR #11377 by @estebanx64.
    â• Replace mkdocs-markdownextradata-plugin with mkdocs-macros-plugin. PR #11383 by @tiangolo.
    ğŸ‘· Disable MkDocs insiders social plugin while an issue in MkDocs Material is handled. PR #11373 by @tiangolo.
    ğŸ‘· Fix logic for when to install and use MkDocs Insiders. PR #11372 by @tiangolo.
    ğŸ‘· Do not use Python packages cache for publish. PR #11366 by @tiangolo.
    ğŸ‘· Add CI to test sdists for redistribution (e.g. Linux distros). PR #11365 by @tiangolo.
    ğŸ‘· Update build-docs GitHub Action path filter. PR #11354 by @tiangolo.
    ğŸ”§ Update Ruff config, add extra ignore rule from SQLModel. PR #11353 by @tiangolo.
    â¬†ï¸ Upgrade configuration for Ruff v0.2.0. PR #11075 by @charliermarsh.
    ğŸ”§ Update sponsors, add MongoDB. PR #11346 by @tiangolo.
    â¬† Bump dorny/paths-filter from 2 to 3. PR #11028 by @dependabot[bot].
    â¬† Bump dawidd6/action-download-artifact from 3.0.0 to 3.1.4. PR #11310 by @dependabot[bot].
    â™»ï¸ Refactor computing FastAPI People, include 3 months, 6 months, 1 year, based on comment date, not discussion date. PR #11304 by @tiangolo.
    ğŸ‘¥ Update FastAPI People. PR #11228 by @tiangolo.
    ğŸ”¥ Remove Jina AI QA Bot from the docs. PR #11268 by @nan-wang.
    ğŸ”§ Update sponsors, remove Jina, remove Powens, move TestDriven.io. PR #11213 by @tiangolo.

0.110.0Â¶
Breaking ChangesÂ¶

    ğŸ› Fix unhandled growing memory for internal server errors, refactor dependencies with yield and except to require raising again as in regular Python. PR #11191 by @tiangolo.
        This is a breaking change (and only slightly) if you used dependencies with yield, used except in those dependencies, and didn't raise again.
        This was reported internally by @rushilsrivastava as a memory leak when the server had unhandled exceptions that would produce internal server errors, the memory allocated before that point would not be released.
        Read the new docs: Dependencies with yield and except.

In short, if you had dependencies that looked like:

def my_dep():
    try:
        yield
    except SomeException:
        pass

Now you need to make sure you raise again after except, just as you would in regular Python:

def my_dep():
    try:
        yield
    except SomeException:
        raise

DocsÂ¶

    âœï¸ Fix minor typos in docs/ko/docs/. PR #11126 by @KaniKim.
    âœï¸ Fix minor typo in fastapi/applications.py. PR #11099 by @JacobHayes.

TranslationsÂ¶

    ğŸŒ Add German translation for docs/de/docs/reference/background.md. PR #10820 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/reference/templating.md. PR #10842 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/external-links.md. PR #10852 by @nilslindemann.
    ğŸŒ Update Turkish translation for docs/tr/docs/tutorial/query-params.md. PR #11162 by @hasansezertasan.
    ğŸŒ Add German translation for docs/de/docs/reference/encoders.md. PR #10840 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/reference/responses.md. PR #10825 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/reference/request.md. PR #10821 by @nilslindemann.
    ğŸŒ Add Turkish translation for docs/tr/docs/tutorial/query-params.md. PR #11078 by @emrhnsyts.
    ğŸŒ Add German translation for docs/de/docs/reference/fastapi.md. PR #10813 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/newsletter.md. PR #10853 by @nilslindemann.
    ğŸŒ Add Traditional Chinese translation for docs/zh-hant/docs/learn/index.md. PR #11142 by @hsuanchi.
    ğŸŒ Add Korean translation for /docs/ko/docs/tutorial/dependencies/global-dependencies.md. PR #11123 by @riroan.
    ğŸŒ Add Korean translation for /docs/ko/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md. PR #11124 by @riroan.
    ğŸŒ Add Korean translation for /docs/ko/docs/tutorial/schema-extra-example.md. PR #11121 by @KaniKim.
    ğŸŒ Add Korean translation for /docs/ko/docs/tutorial/body-fields.md. PR #11112 by @KaniKim.
    ğŸŒ Add Korean translation for /docs/ko/docs/tutorial/cookie-params.md. PR #11118 by @riroan.
    ğŸŒ Update Korean translation for /docs/ko/docs/dependencies/index.md. PR #11114 by @KaniKim.
    ğŸŒ Update Korean translation for /docs/ko/docs/deployment/docker.md. PR #11113 by @KaniKim.
    ğŸŒ Update Turkish translation for docs/tr/docs/tutorial/first-steps.md. PR #11094 by @hasansezertasan.
    ğŸŒ Add Spanish translation for docs/es/docs/advanced/security/index.md. PR #2278 by @Xaraxx.
    ğŸŒ Add Spanish translation for docs/es/docs/advanced/response-headers.md. PR #2276 by @Xaraxx.
    ğŸŒ Add Spanish translation for docs/es/docs/deployment/index.md and ~/deployment/versions.md. PR #9669 by @pabloperezmoya.
    ğŸŒ Add Spanish translation for docs/es/docs/benchmarks.md. PR #10928 by @pablocm83.
    ğŸŒ Add Spanish translation for docs/es/docs/advanced/response-change-status-code.md. PR #11100 by @alejsdev.

0.109.2Â¶
UpgradesÂ¶

    â¬†ï¸ Upgrade version of Starlette to >= 0.36.3. PR #11086 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Update Turkish translation for docs/tr/docs/fastapi-people.md. PR #10547 by @alperiox.

InternalÂ¶

    ğŸ± Add new FastAPI logo. PR #11090 by @tiangolo.

0.109.1Â¶
Security fixesÂ¶

    â¬†ï¸ Upgrade minimum version of python-multipart to >=0.0.7 to fix a vulnerability when using form data with a ReDos attack. You can also simply upgrade python-multipart.

Read more in the advisory: Content-Type Header ReDoS.
FeaturesÂ¶

    âœ¨ Include HTTP 205 in status codes with no body. PR #10969 by @tiangolo.

RefactorsÂ¶

    âœ… Refactor tests for duplicate operation ID generation for compatibility with other tools running the FastAPI test suite. PR #10876 by @emmettbutler.
    â™»ï¸ Simplify string format with f-strings in fastapi/utils.py. PR #10576 by @eukub.
    ğŸ”§ Fix Ruff configuration unintentionally enabling and re-disabling mccabe complexity check. PR #10893 by @jiridanek.
    âœ… Re-enable test in tests/test_tutorial/test_header_params/test_tutorial003.py after fix in Starlette. PR #10904 by @ooknimm.

DocsÂ¶

    ğŸ“ Tweak wording in help-fastapi.md. PR #11040 by @tiangolo.
    ğŸ“ Tweak docs for Behind a Proxy. PR #11038 by @tiangolo.
    ğŸ“ Add External Link: 10 Tips for adding SQLAlchemy to FastAPI. PR #11036 by @Donnype.
    ğŸ“ Add External Link: Tips on migrating from Flask to FastAPI and vice-versa. PR #11029 by @jtemporal.
    ğŸ“ Deprecate old tutorials: Peewee, Couchbase, encode/databases. PR #10979 by @tiangolo.
    âœï¸ Fix typo in fastapi/security/oauth2.py. PR #10972 by @RafalSkolasinski.
    ğŸ“ Update HTTPException details in docs/en/docs/tutorial/handling-errors.md. PR #5418 by @papb.
    âœï¸ A few tweaks in docs/de/docs/tutorial/first-steps.md. PR #10959 by @nilslindemann.
    âœï¸ Fix link in docs/en/docs/advanced/async-tests.md. PR #10960 by @nilslindemann.
    âœï¸ Fix typos for Spanish documentation. PR #10957 by @jlopezlira.
    ğŸ“ Add warning about lifespan functions and backwards compatibility with events. PR #10734 by @jacob-indigo.
    âœï¸ Fix broken link in docs/tutorial/sql-databases.md in several languages. PR #10716 by @theoohoho.
    âœï¸ Remove broken links from external_links.yml. PR #10943 by @Torabek.
    ğŸ“ Update template docs with more info about url_for. PR #5937 by @EzzEddin.
    ğŸ“ Update usage of Token model in security docs. PR #9313 by @piotrszacilowski.
    âœï¸ Update highlighted line in docs/en/docs/tutorial/bigger-applications.md. PR #5490 by @papb.
    ğŸ“ Add External Link: Explore How to Effectively Use JWT With FastAPI. PR #10212 by @aanchlia.
    ğŸ“ Add hyperlink to docs/en/docs/tutorial/static-files.md. PR #10243 by @hungtsetse.
    ğŸ“ Add External Link: Instrument a FastAPI service adding tracing with OpenTelemetry and send/show traces in Grafana Tempo. PR #9440 by @softwarebloat.
    ğŸ“ Review and rewording of en/docs/contributing.md. PR #10480 by @nilslindemann.
    ğŸ“ Add External Link: ML serving and monitoring with FastAPI and Evidently. PR #9701 by @mnrozhkov.
    ğŸ“ Reword in docs, from "have in mind" to "keep in mind". PR #10376 by @malicious.
    ğŸ“ Add External Link: Talk by Jeny Sadadia. PR #10265 by @JenySadadia.
    ğŸ“ Add location info to tutorial/bigger-applications.md. PR #10552 by @nilslindemann.
    âœï¸ Fix Pydantic method name in docs/en/docs/advanced/path-operation-advanced-configuration.md. PR #10826 by @ahmedabdou14.

TranslationsÂ¶

    ğŸŒ Add Spanish translation for docs/es/docs/external-links.md. PR #10933 by @pablocm83.
    ğŸŒ Update Korean translation for docs/ko/docs/tutorial/first-steps.md, docs/ko/docs/tutorial/index.md, docs/ko/docs/tutorial/path-params.md, and docs/ko/docs/tutorial/query-params.md. PR #4218 by @SnowSuno.
    ğŸŒ Add Chinese translation for docs/zh/docs/tutorial/dependencies/dependencies-with-yield.md. PR #10870 by @zhiquanchi.
    ğŸŒ Add Chinese translation for docs/zh/docs/deployment/concepts.md. PR #10282 by @xzmeng.
    ğŸŒ Add Azerbaijani translation for docs/az/docs/index.md. PR #11047 by @aykhans.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/middleware.md. PR #2829 by @JeongHyeongKim.
    ğŸŒ Add German translation for docs/de/docs/tutorial/body-nested-models.md. PR #10313 by @nilslindemann.
    ğŸŒ Add Persian translation for docs/fa/docs/tutorial/middleware.md. PR #9695 by @mojtabapaso.
    ğŸŒ Update Farsi translation for docs/fa/docs/index.md. PR #10216 by @theonlykingpin.
    ğŸŒ Add German translation for docs/de/docs/tutorial/body-fields.md. PR #10310 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/body.md. PR #10295 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/body-multiple-params.md. PR #10308 by @nilslindemann.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/security/get-current-user.md. PR #2681 by @sh0nk.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/advanced-dependencies.md. PR #3798 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/events.md. PR #3815 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/behind-a-proxy.md. PR #3820 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/testing-events.md. PR #3818 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/testing-websockets.md. PR #3817 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/testing-database.md. PR #3821 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/deployment/deta.md. PR #3837 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/history-design-future.md. PR #3832 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/project-generation.md. PR #3831 by @jaystone776.
    ğŸŒ Add Chinese translation for docs/zh/docs/deployment/docker.md. PR #10296 by @xzmeng.
    ğŸŒ Update Spanish translation for docs/es/docs/features.md. PR #10884 by @pablocm83.
    ğŸŒ Add Spanish translation for docs/es/docs/newsletter.md. PR #10922 by @pablocm83.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/background-tasks.md. PR #5910 by @junah201.
    :globe_with_meridians: Add Turkish translation for docs/tr/docs/alternatives.md. PR #10502 by @alperiox.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/dependencies/index.md. PR #10989 by @KaniKim.
    ğŸŒ Add Korean translation for /docs/ko/docs/tutorial/body.md. PR #11000 by @KaniKim.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/schema-extra-example.md. PR #4065 by @luccasmmg.
    ğŸŒ Add Turkish translation for docs/tr/docs/history-design-future.md. PR #11012 by @hasansezertasan.
    ğŸŒ Add Turkish translation for docs/tr/docs/resources/index.md. PR #11020 by @hasansezertasan.
    ğŸŒ Add Turkish translation for docs/tr/docs/how-to/index.md. PR #11021 by @hasansezertasan.
    ğŸŒ Add German translation for docs/de/docs/tutorial/query-params.md. PR #10293 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/benchmarks.md. PR #10866 by @nilslindemann.
    ğŸŒ Add Turkish translation for docs/tr/docs/learn/index.md. PR #11014 by @hasansezertasan.
    ğŸŒ Add Persian translation for docs/fa/docs/tutorial/security/index.md. PR #9945 by @mojtabapaso.
    ğŸŒ Add Turkish translation for docs/tr/docs/help/index.md. PR #11013 by @hasansezertasan.
    ğŸŒ Add Turkish translation for docs/tr/docs/about/index.md. PR #11006 by @hasansezertasan.
    ğŸŒ Update Turkish translation for docs/tr/docs/benchmarks.md. PR #11005 by @hasansezertasan.
    ğŸŒ Add Italian translation for docs/it/docs/index.md. PR #5233 by @matteospanio.
    ğŸŒ Add Korean translation for docs/ko/docs/help/index.md. PR #10983 by @KaniKim.
    ğŸŒ Add Korean translation for docs/ko/docs/features.md. PR #10976 by @KaniKim.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/security/get-current-user.md. PR #5737 by @KdHyeon0661.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/security/first-steps.md. PR #10541 by @AlertRED.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/handling-errors.md. PR #10375 by @AlertRED.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/encoder.md. PR #10374 by @AlertRED.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/body-updates.md. PR #10373 by @AlertRED.
    ğŸŒ Russian translation: updated fastapi-people.md.. PR #10255 by @NiKuma0.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/security/index.md. PR #5798 by @3w36zj6.
    ğŸŒ Add German translation for docs/de/docs/advanced/generate-clients.md. PR #10725 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/openapi-webhooks.md. PR #10712 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/custom-response.md. PR #10624 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/advanced/additional-status-codes.md. PR #10617 by @nilslindemann.
    ğŸŒ Add German translation for docs/de/docs/tutorial/middleware.md. PR #10391 by @JohannesJungbluth.
    ğŸŒ Add German translation for introduction documents. PR #10497 by @nilslindemann.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/encoder.md. PR #1955 by @SwftAlpc.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/extra-data-types.md. PR #1932 by @SwftAlpc.
    ğŸŒ Add Turkish translation for docs/tr/docs/async.md. PR #5191 by @BilalAlpaslan.
    ğŸŒ Add Turkish translation for docs/tr/docs/project-generation.md. PR #5192 by @BilalAlpaslan.
    ğŸŒ Add Korean translation for docs/ko/docs/deployment/docker.md. PR #5657 by @nearnear.
    ğŸŒ Add Korean translation for docs/ko/docs/deployment/server-workers.md. PR #4935 by @jujumilk3.
    ğŸŒ Add Korean translation for docs/ko/docs/deployment/index.md. PR #4561 by @jujumilk3.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/path-operation-configuration.md. PR #3639 by @jungsu-kwon.
    ğŸŒ Modify the description of zh - Traditional Chinese. PR #10889 by @cherinyy.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/static-files.md. PR #2957 by @jeesang7.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/response-model.md. PR #2766 by @hard-coders.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/body-multiple-params.md. PR #2461 by @PandaHun.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/query-params-str-validations.md. PR #2415 by @hard-coders.
    ğŸŒ Add Korean translation for docs/ko/docs/python-types.md. PR #2267 by @jrim.
    ğŸŒ Add Korean translation for docs/ko/docs/tutorial/body-nested-models.md. PR #2506 by @hard-coders.
    ğŸŒ Add Korean translation for docs/ko/docs/learn/index.md. PR #10977 by @KaniKim.
    ğŸŒ Initialize translations for Traditional Chinese. PR #10505 by @hsuanchi.
    âœï¸ Tweak the german translation of docs/de/docs/tutorial/index.md. PR #10962 by @nilslindemann.
    âœï¸ Fix typo error in docs/ko/docs/tutorial/path-params.md. PR #10758 by @2chanhaeng.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/dependencies/dependencies-with-yield.md. PR #1961 by @SwftAlpc.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md. PR #1960 by @SwftAlpc.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/dependencies/sub-dependencies.md. PR #1959 by @SwftAlpc.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/background-tasks.md. PR #2668 by @tokusumi.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/dependencies/index.md and docs/ja/docs/tutorial/dependencies/classes-as-dependencies.md. PR #1958 by @SwftAlpc.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/response-model.md. PR #1938 by @SwftAlpc.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/body-multiple-params.md. PR #1903 by @SwftAlpc.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/path-params-numeric-validations.md. PR #1902 by @SwftAlpc.
    ğŸŒ Add Japanese translation for docs/ja/docs/python-types.md. PR #1899 by @SwftAlpc.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/handling-errors.md. PR #1953 by @SwftAlpc.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/response-status-code.md. PR #1942 by @SwftAlpc.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/extra-models.md. PR #1941 by @SwftAlpc.
    ğŸŒ Add Japanese tranlsation for docs/ja/docs/tutorial/schema-extra-example.md. PR #1931 by @SwftAlpc.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/body-nested-models.md. PR #1930 by @SwftAlpc.
    ğŸŒ Add Japanese translation for docs/ja/docs/tutorial/body-fields.md. PR #1923 by @SwftAlpc.
    ğŸŒ Add German translation for docs/de/docs/tutorial/index.md. PR #9502 by @fhabers21.
    ğŸŒ Add German translation for docs/de/docs/tutorial/background-tasks.md. PR #10566 by @nilslindemann.
    âœï¸ Fix typo in docs/ru/docs/index.md. PR #10672 by @Delitel-WEB.
    âœï¸ Fix typos in docs/zh/docs/tutorial/extra-data-types.md. PR #10727 by @HiemalBeryl.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/dependencies/classes-as-dependencies.md. PR #10410 by @AlertRED.

InternalÂ¶

    ğŸ‘¥ Update FastAPI People. PR #11074 by @tiangolo.
    ğŸ”§ Update sponsors: add Coherence. PR #11066 by @tiangolo.
    ğŸ‘· Upgrade GitHub Action issue-manager. PR #11056 by @tiangolo.
    ğŸ± Update sponsors: TalkPython badge. PR #11052 by @tiangolo.
    ğŸ”§ Update sponsors: TalkPython badge image. PR #11048 by @tiangolo.
    ğŸ”§ Update sponsors, remove Deta. PR #11041 by @tiangolo.
    ğŸ’„ Fix CSS breaking RTL languages (erroneously introduced by a previous RTL PR). PR #11039 by @tiangolo.
    ğŸ”§ Add Italian to mkdocs.yml. PR #11016 by @alejsdev.
    ğŸ”¨ Verify mkdocs.yml languages in CI, update docs.py. PR #11009 by @tiangolo.
    ğŸ”§ Update config in label-approved.yml to accept translations with 1 reviewer. PR #11007 by @alejsdev.
    ğŸ‘· Add changes-requested handling in GitHub Action issue manager. PR #10971 by @tiangolo.
    ğŸ”§ Group dependencies on dependabot updates. PR #10952 by @Kludex.
    â¬† Bump actions/setup-python from 4 to 5. PR #10764 by @dependabot[bot].
    â¬† Bump pypa/gh-action-pypi-publish from 1.8.10 to 1.8.11. PR #10731 by @dependabot[bot].
    â¬† Bump dawidd6/action-download-artifact from 2.28.0 to 3.0.0. PR #10777 by @dependabot[bot].
    ğŸ”§ Add support for translations to languages with a longer code name, like zh-hant. PR #10950 by @tiangolo.

0.109.0Â¶
FeaturesÂ¶

    âœ¨ Add support for Python 3.12. PR #10666 by @Jamim.

UpgradesÂ¶

    â¬†ï¸ Upgrade Starlette to >=0.35.0,<0.36.0. PR #10938 by @tiangolo.

DocsÂ¶

    âœï¸ Fix typo in docs/en/docs/alternatives.md. PR #10931 by @s111d.
    ğŸ“ Replace email with username in docs_src/security/tutorial007 code examples. PR #10649 by @nilslindemann.
    ğŸ“ Add VS Code tutorial link. PR #10592 by @nilslindemann.
    ğŸ“ Add notes about Pydantic v2's new .model_dump(). PR #10929 by @tiangolo.
    ğŸ“ Fix broken link in docs/en/docs/tutorial/sql-databases.md. PR #10765 by @HurSungYun.
    ğŸ“ Add External Link: FastAPI application monitoring made easy. PR #10917 by @tiangolo.
    âœ¨ Generate automatic language names for docs translations. PR #5354 by @jakul.
    âœï¸ Fix typos in docs/en/docs/alternatives.md and docs/en/docs/tutorial/dependencies/index.md. PR #10906 by @s111d.
    âœï¸ Fix typos in docs/en/docs/tutorial/dependencies/dependencies-with-yield.md. PR #10834 by @Molkree.
    ğŸ“ Add article: "Building a RESTful API with FastAPI: Secure Signup and Login Functionality Included". PR #9733 by @dxphilo.
    ğŸ“ Add warning about lifecycle events with AsyncClient. PR #4167 by @andrew-chang-dewitt.
    âœï¸ Fix typos in /docs/reference/exceptions.md and /en/docs/reference/status.md. PR #10809 by @clarencepenz.
    âœï¸ Fix typo in openapi-callbacks.md. PR #10673 by @kayjan.
    âœï¸ Fix typo in fastapi/routing.py . PR #10520 by @sepsh.
    ğŸ“ Replace HTTP code returned in case of existing user error in docs for testing. PR #4482 by @TristanMarion.
    ğŸ“ Add blog for FastAPI & Supabase. PR #6018 by @theinfosecguy.
    ğŸ“ Update example source files for SQL databases with SQLAlchemy. PR #9508 by @s-mustafa.
    ğŸ“ Update code examples in docs for body, replace name create_item with update_item when appropriate. PR #5913 by @OttoAndrey.
    âœï¸ Fix typo in dependencies with yield source examples. PR #10847 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Add Bengali translation for docs/bn/docs/index.md. PR #9177 by @Fahad-Md-Kamal.
    âœï¸ Update Python version in index.md in several languages. PR #10711 by @tamago3keran.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/request-forms-and-files.md. PR #10347 by @AlertRED.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/index.md. PR #10362 by @rostik1410.
    âœï¸ Update Python version in docs/ko/docs/index.md. PR #10680 by @Eeap.
    ğŸŒ Add Persian translation for docs/fa/docs/features.md. PR #5887 by @amirilf.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/additional-responses.md. PR #10325 by @ShuibeiC.
    ğŸŒ Fix typos in Russian translations for docs/ru/docs/tutorial/background-tasks.md, docs/ru/docs/tutorial/body-nested-models.md, docs/ru/docs/tutorial/debugging.md, docs/ru/docs/tutorial/testing.md. PR #10311 by @AlertRED.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/request-files.md. PR #10332 by @AlertRED.
    ğŸŒ Add Chinese translation for docs/zh/docs/deployment/server-workers.md. PR #10292 by @xzmeng.
    ğŸŒ Add Chinese translation for docs/zh/docs/deployment/cloud.md. PR #10291 by @xzmeng.
    ğŸŒ Add Chinese translation for docs/zh/docs/deployment/manually.md. PR #10279 by @xzmeng.
    ğŸŒ Add Chinese translation for docs/zh/docs/deployment/https.md. PR #10277 by @xzmeng.
    ğŸŒ Add Chinese translation for docs/zh/docs/deployment/index.md. PR #10275 by @xzmeng.
    ğŸŒ Add German translation for docs/de/docs/tutorial/first-steps.md. PR #9530 by @fhabers21.
    ğŸŒ Update Turkish translation for docs/tr/docs/index.md. PR #10444 by @hasansezertasan.
    ğŸŒ Add Chinese translation for docs/zh/docs/learn/index.md. PR #10479 by @KAZAMA-DREAM.
    ğŸŒ Add Russian translation for docs/ru/docs/learn/index.md. PR #10539 by @AlertRED.
    ğŸŒ Update SQLAlchemy instruction in Chinese translation docs/zh/docs/tutorial/sql-databases.md. PR #9712 by @Royc30ne.
    ğŸŒ Add Turkish translation for docs/tr/docs/external-links.md. PR #10549 by @hasansezertasan.
    ğŸŒ Add Spanish translation for docs/es/docs/learn/index.md. PR #10885 by @pablocm83.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/body-fields.md. PR #10670 by @ArtemKhymenko.
    ğŸŒ Add Hungarian translation for /docs/hu/docs/index.md. PR #10812 by @takacs.
    ğŸŒ Add Turkish translation for docs/tr/docs/newsletter.md. PR #10550 by @hasansezertasan.
    ğŸŒ Add Spanish translation for docs/es/docs/help/index.md. PR #10907 by @pablocm83.
    ğŸŒ Add Spanish translation for docs/es/docs/about/index.md. PR #10908 by @pablocm83.
    ğŸŒ Add Spanish translation for docs/es/docs/resources/index.md. PR #10909 by @pablocm83.

InternalÂ¶

    ğŸ‘¥ Update FastAPI People. PR #10871 by @tiangolo.
    ğŸ‘· Upgrade custom GitHub Action comment-docs-preview-in-pr. PR #10916 by @tiangolo.
    â¬†ï¸ Upgrade GitHub Action latest-changes. PR #10915 by @tiangolo.
    ğŸ‘· Upgrade GitHub Action label-approved. PR #10913 by @tiangolo.
    â¬†ï¸ Upgrade GitHub Action label-approved. PR #10905 by @tiangolo.

0.108.0Â¶
UpgradesÂ¶

    â¬†ï¸ Upgrade Starlette to >=0.29.0,<0.33.0, update docs and usage of templates with new Starlette arguments. Remove pin of AnyIO >=3.7.1,<4.0.0, add support for AnyIO 4.x.x. PR #10846 by @tiangolo.

0.107.0Â¶
UpgradesÂ¶

    â¬†ï¸ Upgrade Starlette to 0.28.0. PR #9636 by @adriangb.

DocsÂ¶

    ğŸ“ Add docs: Node.js script alternative to update OpenAPI for generated clients. PR #10845 by @alejsdev.
    ğŸ“ Restructure Docs section in Contributing page. PR #10844 by @alejsdev.

0.106.0Â¶
Breaking ChangesÂ¶

Using resources from dependencies with yield in background tasks is no longer supported.

This change is what supports the new features, read below. ğŸ¤“
Dependencies with yield, HTTPException and Background TasksÂ¶

Dependencies with yield now can raise HTTPException and other exceptions after yield. ğŸ‰

Read the new docs here: Dependencies with yield and HTTPException.

from fastapi import Depends, FastAPI, HTTPException
from typing_extensions import Annotated

app = FastAPI()


data = {
    "plumbus": {"description": "Freshly pickled plumbus", "owner": "Morty"},
    "portal-gun": {"description": "Gun to create portals", "owner": "Rick"},
}


class OwnerError(Exception):
    pass


def get_username():
    try:
        yield "Rick"
    except OwnerError as e:
        raise HTTPException(status_code=400, detail=f"Owner error: {e}")


@app.get("/items/{item_id}")
def get_item(item_id: str, username: Annotated[str, Depends(get_username)]):
    if item_id not in data:
        raise HTTPException(status_code=404, detail="Item not found")
    item = data[item_id]
    if item["owner"] != username:
        raise OwnerError(username)
    return item

Before FastAPI 0.106.0, raising exceptions after yield was not possible, the exit code in dependencies with yield was executed after the response was sent, so Exception Handlers would have already run.

This was designed this way mainly to allow using the same objects "yielded" by dependencies inside of background tasks, because the exit code would be executed after the background tasks were finished.

Nevertheless, as this would mean waiting for the response to travel through the network while unnecessarily holding a resource in a dependency with yield (for example a database connection), this was changed in FastAPI 0.106.0.

Additionally, a background task is normally an independent set of logic that should be handled separately, with its own resources (e.g. its own database connection).

If you used to rely on this behavior, now you should create the resources for background tasks inside the background task itself, and use internally only data that doesn't depend on the resources of dependencies with yield.

For example, instead of using the same database session, you would create a new database session inside of the background task, and you would obtain the objects from the database using this new session. And then instead of passing the object from the database as a parameter to the background task function, you would pass the ID of that object and then obtain the object again inside the background task function.

The sequence of execution before FastAPI 0.106.0 was like this diagram:

Time flows from top to bottom. And each column is one of the parts interacting or executing code.
Background tasksPath OperationDep with yieldException handlerClientBackground tasksPath OperationDep with yieldException handlerClientCan raise exception for dependency, handled after response is sentCan raise HTTPException and can change the responseRun code up to yieldopt[raise]opt[raise]Response is already sent, can't change it anymoreopt[Tasks]opt[Raise other exception]After yieldopt[Handle other exception]Start requestRaise HTTPExceptionHTTP error responseRaise other exceptionRun dependency, e.g. DB sessionRaise HTTPExceptionAuto forward exceptionHTTP error responseRaise other exceptionAuto forward exceptionReturn response to clientSend background tasksRaise other exceptionHandle exception, can't change response. E.g. close DB session.

The new execution flow can be found in the docs: Execution of dependencies with yield.
FeaturesÂ¶

    âœ¨ Add support for raising exceptions (including HTTPException) in dependencies with yield in the exit code, do not support them in background tasks. PR #10831 by @tiangolo.

InternalÂ¶

    ğŸ‘¥ Update FastAPI People. PR #10567 by @tiangolo.

0.105.0Â¶
FeaturesÂ¶

    âœ¨ Add support for multiple Annotated annotations, e.g. Annotated[str, Field(), Query()]. PR #10773 by @tiangolo.

RefactorsÂ¶

    ğŸ”¥ Remove unused NoneType. PR #10774 by @tiangolo.

DocsÂ¶

    ğŸ“ Tweak default suggested configs for generating clients. PR #10736 by @tiangolo.

InternalÂ¶

    ğŸ”§ Update sponsors, add Scalar. PR #10728 by @tiangolo.
    ğŸ”§ Update sponsors, add PropelAuth. PR #10760 by @tiangolo.
    ğŸ‘· Update build docs, verify README on CI. PR #10750 by @tiangolo.
    ğŸ”§ Update sponsors, remove Fern. PR #10729 by @tiangolo.
    ğŸ”§ Update sponsors, add Codacy. PR #10677 by @tiangolo.
    ğŸ”§ Update sponsors, add Reflex. PR #10676 by @tiangolo.
    ğŸ“ Update release notes, move and check latest-changes. PR #10588 by @tiangolo.
    ğŸ‘· Upgrade latest-changes GitHub Action. PR #10587 by @tiangolo.

0.104.1Â¶
FixesÂ¶

    ğŸ“Œ Pin Swagger UI version to 5.9.0 temporarily to handle a bug crashing it in 5.9.1. PR #10529 by @alejandraklachquin.
        This is not really a bug in FastAPI but in Swagger UI, nevertheless pinning the version will work while a solution is found on the Swagger UI side.

DocsÂ¶

    ğŸ“ Update data structure and render for external-links. PR #10495 by @tiangolo.
    âœï¸ Fix link to SPDX license identifier in docs/en/docs/tutorial/metadata.md. PR #10433 by @worldworm.
    ğŸ“ Update example validation error from Pydantic v1 to match Pydantic v2 in docs/en/docs/tutorial/path-params.md. PR #10043 by @giuliowaitforitdavide.
    âœï¸ Fix typos in emoji docs and in some source examples. PR #10438 by @afuetterer.
    âœï¸ Fix typo in docs/en/docs/reference/dependencies.md. PR #10465 by @suravshresth.
    âœï¸ Fix typos and rewordings in docs/en/docs/tutorial/body-nested-models.md. PR #10468 by @yogabonito.
    ğŸ“ Update docs, remove references to removed pydantic.Required in docs/en/docs/tutorial/query-params-str-validations.md. PR #10469 by @yogabonito.
    âœï¸ Fix typo in docs/en/docs/reference/index.md. PR #10467 by @tarsil.
    ğŸ”¥ Remove unnecessary duplicated docstrings. PR #10484 by @tiangolo.

InternalÂ¶

    âœï¸ Update Pydantic links to dotenv support. PR #10511 by @White-Mask.
    âœï¸ Update links in docs/en/docs/async.md and docs/zh/docs/async.md to make them relative. PR #10498 by @hasnatsajid.
    âœï¸ Fix links in docs/em/docs/async.md. PR #10507 by @hasnatsajid.
    âœï¸ Fix typo in docs/em/docs/index.md, Python 3.8. PR #10521 by @kerriop.
    â¬† Bump pillow from 9.5.0 to 10.1.0. PR #10446 by @dependabot[bot].
    â¬† Update mkdocs-material requirement from <9.0.0,>=8.1.4 to >=8.1.4,<10.0.0. PR #5862 by @dependabot[bot].
    â¬† Bump mkdocs-material from 9.1.21 to 9.4.7. PR #10545 by @dependabot[bot].
    ğŸ‘· Install MkDocs Material Insiders only when secrets are available, for Dependabot. PR #10544 by @tiangolo.
    ğŸ”§ Update sponsors badges, Databento. PR #10519 by @tiangolo.
    ğŸ‘· Adopt Ruff format. PR #10517 by @tiangolo.
    ğŸ”§ Add CITATION.cff file for academic citations. PR #10496 by @tiangolo.
    ğŸ› Fix overriding MKDocs theme lang in hook. PR #10490 by @tiangolo.
    ğŸ”¥ Drop/close Gitter chat. Questions should go to GitHub Discussions, free conversations to Discord.. PR #10485 by @tiangolo.

0.104.0Â¶
FeaturesÂ¶

    âœ¨ Add reference (code API) docs with PEP 727, add subclass with custom docstrings for BackgroundTasks, refactor docs structure. PR #10392 by @tiangolo. New docs at FastAPI Reference - Code API.

UpgradesÂ¶

    â¬†ï¸ Drop support for Python 3.7, require Python 3.8 or above. PR #10442 by @tiangolo.

InternalÂ¶

    â¬† Bump dawidd6/action-download-artifact from 2.27.0 to 2.28.0. PR #10268 by @dependabot[bot].
    â¬† Bump actions/checkout from 3 to 4. PR #10208 by @dependabot[bot].
    â¬† Bump pypa/gh-action-pypi-publish from 1.8.6 to 1.8.10. PR #10061 by @dependabot[bot].
    ğŸ”§ Update sponsors, Bump.sh images. PR #10381 by @tiangolo.
    ğŸ‘¥ Update FastAPI People. PR #10363 by @tiangolo.

0.103.2Â¶
RefactorsÂ¶

    â¬†ï¸ Upgrade compatibility with Pydantic v2.4, new renamed functions and JSON Schema input/output models with default values. PR #10344 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/extra-data-types.md. PR #10132 by @ArtemKhymenko.
    ğŸŒ Fix typos in French translations for docs/fr/docs/advanced/path-operation-advanced-configuration.md, docs/fr/docs/alternatives.md, docs/fr/docs/async.md, docs/fr/docs/features.md, docs/fr/docs/help-fastapi.md, docs/fr/docs/index.md, docs/fr/docs/python-types.md, docs/fr/docs/tutorial/body.md, docs/fr/docs/tutorial/first-steps.md, docs/fr/docs/tutorial/query-params.md. PR #10154 by @s-rigaud.
    ğŸŒ Add Chinese translation for docs/zh/docs/async.md. PR #5591 by @mkdir700.
    ğŸŒ Update Chinese translation for docs/tutorial/security/simple-oauth2.md. PR #3844 by @jaystone776.
    ğŸŒ Add Korean translation for docs/ko/docs/deployment/cloud.md. PR #10191 by @Sion99.
    ğŸŒ Add Japanese translation for docs/ja/docs/deployment/https.md. PR #10298 by @tamtam-fitness.
    ğŸŒ Fix typo in Russian translation for docs/ru/docs/tutorial/body-fields.md. PR #10224 by @AlertRED.
    ğŸŒ Add Polish translation for docs/pl/docs/help-fastapi.md. PR #10121 by @romabozhanovgithub.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/header-params.md. PR #10226 by @AlertRED.
    ğŸŒ Add Chinese translation for docs/zh/docs/deployment/versions.md. PR #10276 by @xzmeng.

InternalÂ¶

    ğŸ”§ Update sponsors, remove Flint. PR #10349 by @tiangolo.
    ğŸ”§ Rename label "awaiting review" to "awaiting-review" to simplify search queries. PR #10343 by @tiangolo.
    ğŸ”§ Update sponsors, enable Svix (revert #10228). PR #10253 by @tiangolo.
    ğŸ”§ Update sponsors, remove Svix. PR #10228 by @tiangolo.
    ğŸ”§ Update sponsors, add Bump.sh. PR #10227 by @tiangolo.

0.103.1Â¶
FixesÂ¶

    ğŸ“Œ Pin AnyIO to < 4.0.0 to handle an incompatibility while upgrading to Starlette 0.31.1. PR #10194 by @tiangolo.

DocsÂ¶

    âœï¸ Fix validation parameter name in docs, from regex to pattern. PR #10085 by @pablodorrio.
    âœï¸ Fix indent format in docs/en/docs/deployment/server-workers.md. PR #10066 by @tamtam-fitness.
    âœï¸ Fix Pydantic examples in tutorial for Python types. PR #9961 by @rahulsalgare.
    âœï¸ Fix link to Pydantic docs in docs/en/docs/tutorial/extra-data-types.md. PR #10155 by @hasnatsajid.
    âœï¸ Fix typo in docs/en/docs/tutorial/handling-errors.md. PR #10170 by @poupapaa.
    âœï¸ Fix typo in docs/en/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md. PR #10172 by @ragul-kachiappan.

TranslationsÂ¶

    ğŸŒ Remove duplicate line in translation for docs/pt/docs/tutorial/path-params.md. PR #10126 by @LecoOliveira.
    ğŸŒ Add Yoruba translation for docs/yo/docs/index.md. PR #10033 by @AfolabiOlaoluwa.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/python-types.md. PR #10080 by @rostik1410.
    ğŸŒ Add Vietnamese translations for docs/vi/docs/tutorial/first-steps.md and docs/vi/docs/tutorial/index.md. PR #10088 by @magiskboy.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/alternatives.md. PR #10060 by @whysage.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/index.md. PR #10079 by @rostik1410.
    âœï¸ Fix typos in docs/en/docs/how-to/separate-openapi-schemas.md and docs/en/docs/tutorial/schema-extra-example.md. PR #10189 by @xzmeng.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/generate-clients.md. PR #9883 by @funny-cat-happy.

RefactorsÂ¶

    âœï¸ Fix typos in comment in fastapi/applications.py. PR #10045 by @AhsanSheraz.
    âœ… Add missing test for OpenAPI examples, it was missing in coverage. PR #10188 by @tiangolo.

InternalÂ¶

    ğŸ‘¥ Update FastAPI People. PR #10186 by @tiangolo.

0.103.0Â¶
FeaturesÂ¶

    âœ¨ Add support for openapi_examples in all FastAPI parameters. PR #10152 by @tiangolo.
        New docs: OpenAPI-specific examples.

DocsÂ¶

    ğŸ“ Add note to docs about Separate Input and Output Schemas with FastAPI version. PR #10150 by @tiangolo.

0.102.0Â¶
FeaturesÂ¶

    âœ¨ Add support for disabling the separation of input and output JSON Schemas in OpenAPI with Pydantic v2 with separate_input_output_schemas=False. PR #10145 by @tiangolo.
        New docs Separate OpenAPI Schemas for Input and Output or Not.
        This PR also includes a new setup (internal tools) for generating screenshots for the docs.

RefactorsÂ¶

    â™»ï¸ Refactor tests for new Pydantic 2.2.1. PR #10115 by @tiangolo.

DocsÂ¶

    ğŸ“ Add new docs section, How To - Recipes, move docs that don't have to be read by everyone to How To. PR #10114 by @tiangolo.
    ğŸ“ Update Advanced docs, add links to sponsor courses. PR #10113 by @tiangolo.
    ğŸ“ Update docs for generating clients. PR #10112 by @tiangolo.
    ğŸ“ Tweak MkDocs and add redirects. PR #10111 by @tiangolo.
    ğŸ“ Restructure docs for cloud providers, include links to sponsors. PR #10110 by @tiangolo.

InternalÂ¶

    ğŸ”§ Update sponsors, add Speakeasy. PR #10098 by @tiangolo.

0.101.1Â¶
FixesÂ¶

    âœ¨ Add ResponseValidationError printable details, to show up in server error logs. PR #10078 by @tiangolo.

RefactorsÂ¶

    âœï¸ Fix typo in deprecation warnings in fastapi/params.py. PR #9854 by @russbiggs.
    âœï¸ Fix typos in comments on internal code in fastapi/concurrency.py and fastapi/routing.py. PR #9590 by @ElliottLarsen.

DocsÂ¶

    âœï¸ Fix typo in release notes. PR #9835 by @francisbergin.
    ğŸ“ Add external article: Build an SMS Spam Classifier Serverless Database with FaunaDB and FastAPI. PR #9847 by @adejumoridwan.
    ğŸ“ Fix typo in docs/en/docs/contributing.md. PR #9878 by @VicenteMerino.
    ğŸ“ Fix code highlighting in docs/en/docs/tutorial/bigger-applications.md. PR #9806 by @theonlykingpin.

TranslationsÂ¶

    ğŸŒ Add Japanese translation for docs/ja/docs/deployment/concepts.md. PR #10062 by @tamtam-fitness.
    ğŸŒ Add Japanese translation for docs/ja/docs/deployment/server-workers.md. PR #10064 by @tamtam-fitness.
    ğŸŒ Update Japanese translation for docs/ja/docs/deployment/docker.md. PR #10073 by @tamtam-fitness.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/fastapi-people.md. PR #10059 by @rostik1410.
    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/cookie-params.md. PR #10032 by @rostik1410.
    ğŸŒ Add Russian translation for docs/ru/docs/deployment/docker.md. PR #9971 by @Xewus.
    ğŸŒ Add Vietnamese translation for docs/vi/docs/python-types.md. PR #10047 by @magiskboy.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/dependencies/global-dependencies.md. PR #9970 by @dudyaosuplayer.
    ğŸŒ Add Urdu translation for docs/ur/docs/benchmarks.md. PR #9974 by @AhsanSheraz.

InternalÂ¶

    ğŸ”§ Add sponsor Porter. PR #10051 by @tiangolo.
    ğŸ”§ Update sponsors, add Jina back as bronze sponsor. PR #10050 by @tiangolo.
    â¬† Bump mypy from 1.4.0 to 1.4.1. PR #9756 by @dependabot[bot].
    â¬† Bump mkdocs-material from 9.1.17 to 9.1.21. PR #9960 by @dependabot[bot].

0.101.0Â¶
FeaturesÂ¶

    âœ¨ Enable Pydantic's serialization mode for responses, add support for Pydantic's computed_field, better OpenAPI for response models, proper required attributes, better generated clients. PR #10011 by @tiangolo.

RefactorsÂ¶

    âœ… Fix tests for compatibility with pydantic 2.1.1. PR #9943 by @dmontagu.
    âœ… Fix test error in Windows for jsonable_encoder. PR #9840 by @iudeen.

UpgradesÂ¶

    ğŸ“Œ Do not allow Pydantic 2.1.0 that breaks (require 2.1.1). PR #10012 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/security/index.md. PR #9963 by @eVery1337.
    ğŸŒ Remove Vietnamese note about missing translation. PR #9957 by @tiangolo.

InternalÂ¶

    ğŸ‘· Add GitHub Actions step dump context to debug external failures. PR #10008 by @tiangolo.
    ğŸ”§ Restore MkDocs Material pin after the fix. PR #10001 by @tiangolo.
    ğŸ”§ Update the Question template to ask for the Pydantic version. PR #10000 by @tiangolo.
    ğŸ“ Update MkDocs Material dependencies. PR #9986 by @tiangolo.
    ğŸ‘¥ Update FastAPI People. PR #9999 by @tiangolo.
    ğŸ³ Update Dockerfile with compatibility versions, to upgrade later. PR #9998 by @tiangolo.
    â• Add pydantic-settings to FastAPI People dependencies. PR #9988 by @tiangolo.
    â™»ï¸ Update FastAPI People logic with new Pydantic. PR #9985 by @tiangolo.
    ğŸ± Update sponsors, Fern badge. PR #9982 by @tiangolo.
    ğŸ‘· Deploy docs to Cloudflare Pages. PR #9978 by @tiangolo.
    ğŸ”§ Update sponsor Fern. PR #9979 by @tiangolo.
    ğŸ‘· Update CI debug mode with Tmate. PR #9977 by @tiangolo.

0.100.1Â¶
FixesÂ¶

    ğŸ› Replace MultHostUrl to AnyUrl for compatibility with older versions of Pydantic v1. PR #9852 by @Kludex.

DocsÂ¶

    ğŸ“ Update links for self-hosted Swagger UI, point to v5, for OpenAPI 31.0. PR #9834 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Add Ukrainian translation for docs/uk/docs/tutorial/body.md. PR #4574 by @ss-o-furda.
    ğŸŒ Add Vietnamese translation for docs/vi/docs/features.md and docs/vi/docs/index.md. PR #3006 by @magiskboy.
    ğŸŒ Add Korean translation for docs/ko/docs/async.md. PR #4179 by @NinaHwang.
    ğŸŒ Add Chinese translation for docs/zh/docs/tutorial/background-tasks.md. PR #9812 by @wdh99.
    ğŸŒ Add French translation for docs/fr/docs/tutorial/query-params-str-validations.md. PR #4075 by @Smlep.
    ğŸŒ Add French translation for docs/fr/docs/tutorial/index.md. PR #2234 by @JulianMaurin.
    ğŸŒ Add French translation for docs/fr/docs/contributing.md. PR #2132 by @JulianMaurin.
    ğŸŒ Add French translation for docs/fr/docs/benchmarks.md. PR #2155 by @clemsau.
    ğŸŒ Update Chinese translations with new source files. PR #9738 by @mahone3297.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/request-forms.md. PR #9841 by @dedkot01.
    ğŸŒ Update Chinese translation for docs/zh/docs/tutorial/handling-errors.md. PR #9485 by @Creat55.

InternalÂ¶

    ğŸ”§ Update sponsors, add Fern. PR #9956 by @tiangolo.
    ğŸ‘· Update FastAPI People token. PR #9844 by @tiangolo.
    ğŸ‘¥ Update FastAPI People. PR #9775 by @tiangolo.
    ğŸ‘· Update MkDocs Material token. PR #9843 by @tiangolo.
    ğŸ‘· Update token for latest changes. PR #9842 by @tiangolo.

0.100.0Â¶

âœ¨ Support for Pydantic v2 âœ¨

Pydantic version 2 has the core re-written in Rust and includes a lot of improvements and features, for example:

    Improved correctness in corner cases.
    Safer types.
    Better performance and less energy consumption.
    Better extensibility.
    etc.

...all this while keeping the same Python API. In most of the cases, for simple models, you can simply upgrade the Pydantic version and get all the benefits. ğŸš€

In some cases, for pure data validation and processing, you can get performance improvements of 20x or more. This means 2,000% or more. ğŸ¤¯

When you use FastAPI, there's a lot more going on, processing the request and response, handling dependencies, executing your own code, and particularly, waiting for the network. But you will probably still get some nice performance improvements just from the upgrade.

The focus of this release is compatibility with Pydantic v1 and v2, to make sure your current apps keep working. Later there will be more focus on refactors, correctness, code improvements, and then performance improvements. Some third-party early beta testers that ran benchmarks on the beta releases of FastAPI reported improvements of 2x - 3x. Which is not bad for just doing pip install --upgrade fastapi pydantic. This was not an official benchmark and I didn't check it myself, but it's a good sign.
MigrationÂ¶

Check out the Pydantic migration guide.

For the things that need changes in your Pydantic models, the Pydantic team built bump-pydantic.

A command line tool that will process your code and update most of the things automatically for you. Make sure you have your code in git first, and review each of the changes to make sure everything is correct before committing the changes.
Pydantic v1Â¶

This version of FastAPI still supports Pydantic v1. And although Pydantic v1 will be deprecated at some point, it will still be supported for a while.

This means that you can install the new Pydantic v2, and if something fails, you can install Pydantic v1 while you fix any problems you might have, but having the latest FastAPI.

There are tests for both Pydantic v1 and v2, and test coverage is kept at 100%.
ChangesÂ¶

    There are new parameter fields supported by Pydantic Field() for:
        Path()
        Query()
        Header()
        Cookie()
        Body()
        Form()
        File()

    The new parameter fields are:
        default_factory
        alias_priority
        validation_alias
        serialization_alias
        discriminator
        strict
        multiple_of
        allow_inf_nan
        max_digits
        decimal_places
        json_schema_extra

...you can read about them in the Pydantic docs.

    The parameter regex has been deprecated and replaced by pattern.
        You can read more about it in the docs for Query Parameters and String Validations: Add regular expressions.
    New Pydantic models use an improved and simplified attribute model_config that takes a simple dict instead of an internal class Config for their configuration.
        You can read more about it in the docs for Declare Request Example Data.
    The attribute schema_extra for the internal class Config has been replaced by the key json_schema_extra in the new model_config dict.
        You can read more about it in the docs for Declare Request Example Data.
    When you install "fastapi[all]" it now also includes:
        pydantic-settings - for settings management.
        pydantic-extra-types - for extra types to be used with Pydantic.

    Now Pydantic Settings is an additional optional package (included in "fastapi[all]"). To use settings you should now import from pydantic_settings import BaseSettings instead of importing from pydantic directly.
        You can read more about it in the docs for Settings and Environment Variables.

    PR #9816 by @tiangolo, included all the work done (in multiple PRs) on the beta branch (main-pv2).

0.99.1Â¶
FixesÂ¶

    ğŸ› Fix JSON Schema accepting bools as valid JSON Schemas, e.g. additionalProperties: false. PR #9781 by @tiangolo.

DocsÂ¶

    ğŸ“ Update source examples to use new JSON Schema examples field. PR #9776 by @tiangolo.

0.99.0Â¶
FeaturesÂ¶

    âœ¨ Add support for OpenAPI 3.1.0. PR #9770 by @tiangolo.
        New support for documenting webhooks, read the new docs here: Advanced User Guide: OpenAPI Webhooks.
        Upgrade OpenAPI 3.1.0, this uses JSON Schema 2020-12.
        Upgrade Swagger UI to version 5.x.x, that supports OpenAPI 3.1.0.
        Updated examples field in Query(), Cookie(), Body(), etc. based on the latest JSON Schema and OpenAPI. Now it takes a list of examples and they are included directly in the JSON Schema, not outside. Read more about it (including the historical technical details) in the updated docs: Tutorial: Declare Request Example Data.

    âœ¨ Add support for deque objects and children in jsonable_encoder. PR #9433 by @cranium.

DocsÂ¶

    ğŸ“ Fix form for the FastAPI and friends newsletter. PR #9749 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Add Persian translation for docs/fa/docs/advanced/sub-applications.md. PR #9692 by @mojtabapaso.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/response-model.md. PR #9675 by @glsglsgls.

InternalÂ¶

    ğŸ”¨ Enable linenums in MkDocs Material during local live development to simplify highlighting code. PR #9769 by @tiangolo.
    â¬† Update httpx requirement from <0.24.0,>=0.23.0 to >=0.23.0,<0.25.0. PR #9724 by @dependabot[bot].
    â¬† Bump mkdocs-material from 9.1.16 to 9.1.17. PR #9746 by @dependabot[bot].
    ğŸ”¥ Remove missing translation dummy pages, no longer necessary. PR #9751 by @tiangolo.
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #9259 by @pre-commit-ci[bot].
    âœ¨ Add Material for MkDocs Insiders features and cards. PR #9748 by @tiangolo.
    ğŸ”¥ Remove languages without translations. PR #9743 by @tiangolo.
    âœ¨ Refactor docs for building scripts, use MkDocs hooks, simplify (remove) configs for languages. PR #9742 by @tiangolo.
    ğŸ”¨ Add MkDocs hook that renames sections based on the first index file. PR #9737 by @tiangolo.
    ğŸ‘· Make cron jobs run only on main repo, not on forks, to avoid error notifications from missing tokens. PR #9735 by @tiangolo.
    ğŸ”§ Update MkDocs for other languages. PR #9734 by @tiangolo.
    ğŸ‘· Refactor Docs CI, run in multiple workers with a dynamic matrix to optimize speed. PR #9732 by @tiangolo.
    ğŸ”¥ Remove old internal GitHub Action watch-previews that is no longer needed. PR #9730 by @tiangolo.
    â¬†ï¸ Upgrade MkDocs and MkDocs Material. PR #9729 by @tiangolo.
    ğŸ‘· Build and deploy docs only on docs changes. PR #9728 by @tiangolo.

0.98.0Â¶
FeaturesÂ¶

    âœ¨ Allow disabling redirect_slashes at the FastAPI app level. PR #3432 by @cyberlis.

DocsÂ¶

    ğŸ“ Update docs on Pydantic using ujson internally. PR #5804 by @mvasilkov.
    âœ Rewording in docs/en/docs/tutorial/debugging.md. PR #9581 by @ivan-abc.
    ğŸ“ Add german blog post (Domain-driven Design mit Python und FastAPI). PR #9261 by @msander.
    âœï¸ Tweak wording in docs/en/docs/tutorial/security/index.md. PR #9561 by @jyothish-mohan.
    ğŸ“ Update Annotated notes in docs/en/docs/tutorial/schema-extra-example.md. PR #9620 by @Alexandrhub.
    âœï¸ Fix typo Annotation -> Annotated in docs/en/docs/tutorial/query-params-str-validations.md. PR #9625 by @mccricardo.
    ğŸ“ Use in memory database for testing SQL in docs. PR #1223 by @HarshaLaxman.

TranslationsÂ¶

    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/metadata.md. PR #9681 by @TabarakoAkula.
    ğŸŒ Fix typo in Spanish translation for docs/es/docs/tutorial/first-steps.md. PR #9571 by @lilidl-nft.
    ğŸŒ Add Russian translation for docs/tutorial/path-operation-configuration.md. PR #9696 by @TabarakoAkula.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/security/index.md. PR #9666 by @lordqyxz.
    ğŸŒ Add Chinese translations for docs/zh/docs/advanced/settings.md. PR #9652 by @ChoyeonChern.
    ğŸŒ Add Chinese translations for docs/zh/docs/advanced/websockets.md. PR #9651 by @ChoyeonChern.
    ğŸŒ Add Chinese translation for docs/zh/docs/tutorial/testing.md. PR #9641 by @wdh99.
    ğŸŒ Add Russian translation for docs/tutorial/extra-models.md. PR #9619 by @ivan-abc.
    ğŸŒ Add Russian translation for docs/tutorial/cors.md. PR #9608 by @ivan-abc.
    ğŸŒ Add Polish translation for docs/pl/docs/features.md. PR #5348 by @mbroton.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/body-nested-models.md. PR #9605 by @Alexandrhub.

InternalÂ¶

    â¬† Bump ruff from 0.0.272 to 0.0.275. PR #9721 by @dependabot[bot].
    â¬† Update uvicorn[standard] requirement from <0.21.0,>=0.12.0 to >=0.12.0,<0.23.0. PR #9463 by @dependabot[bot].
    â¬† Bump mypy from 1.3.0 to 1.4.0. PR #9719 by @dependabot[bot].
    â¬† Update pre-commit requirement from <3.0.0,>=2.17.0 to >=2.17.0,<4.0.0. PR #9251 by @dependabot[bot].
    â¬† Bump pypa/gh-action-pypi-publish from 1.8.5 to 1.8.6. PR #9482 by @dependabot[bot].
    âœï¸ Fix tooltips for light/dark theme toggler in docs. PR #9588 by @pankaj1707k.
    ğŸ”§ Set minimal hatchling version needed to build the package. PR #9240 by @mgorny.
    ğŸ“ Add repo link to PyPI. PR #9559 by @JacobCoffee.
    âœï¸ Fix typos in data for tests. PR #4958 by @ryanrussell.
    ğŸ”§ Update sponsors, add Flint. PR #9699 by @tiangolo.
    ğŸ‘· Lint in CI only once, only with one version of Python, run tests with all of them. PR #9686 by @tiangolo.

0.97.0Â¶
FeaturesÂ¶

    âœ¨ Add support for dependencies in WebSocket routes. PR #4534 by @paulo-raca.
    âœ¨ Add exception handler for WebSocketRequestValidationError (which also allows to override it). PR #6030 by @kristjanvalur.

RefactorsÂ¶

    â¬†ï¸ Upgrade and fully migrate to Ruff, remove isort, includes a couple of tweaks suggested by the new version of Ruff. PR #9660 by @tiangolo.
    â™»ï¸ Update internal type annotations and upgrade mypy. PR #9658 by @tiangolo.
    â™»ï¸ Simplify AsyncExitStackMiddleware as without Python 3.6 AsyncExitStack is always available. PR #9657 by @tiangolo.

UpgradesÂ¶

    â¬†ï¸ Upgrade Black. PR #9661 by @tiangolo.

InternalÂ¶

    ğŸ’š Update CI cache to fix installs when dependencies change. PR #9659 by @tiangolo.
    â¬‡ï¸ Separate requirements for development into their own requirements.txt files, they shouldn't be extras. PR #9655 by @tiangolo.

0.96.1Â¶
FixesÂ¶

    ğŸ› Fix HTTPException header type annotations. PR #9648 by @tiangolo.
    ğŸ› Fix OpenAPI model fields int validations, gte to ge. PR #9635 by @tiangolo.

UpgradesÂ¶

    ğŸ“Œ Update minimum version of Pydantic to >=1.7.4. This fixes an issue when trying to use an old version of Pydantic. PR #9567 by @Kludex.

RefactorsÂ¶

    â™» Remove media_type from ORJSONResponse as it's inherited from the parent class. PR #5805 by @Kludex.
    â™» Instantiate HTTPException only when needed, optimization refactor. PR #5356 by @pawamoy.

DocsÂ¶

    ğŸ”¥ Remove link to Pydantic's benchmark, as it was removed there. PR #5811 by @Kludex.

TranslationsÂ¶

    ğŸŒ Fix spelling in Indonesian translation of docs/id/docs/tutorial/index.md. PR #5635 by @purwowd.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/index.md. PR #5896 by @Wilidon.
    ğŸŒ Add Chinese translations for docs/zh/docs/advanced/response-change-status-code.md and docs/zh/docs/advanced/response-headers.md. PR #9544 by @ChoyeonChern.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/schema-extra-example.md. PR #9621 by @Alexandrhub.

InternalÂ¶

    ğŸ”§ Add sponsor Platform.sh. PR #9650 by @tiangolo.
    ğŸ‘· Add custom token to Smokeshow and Preview Docs for download-artifact, to prevent API rate limits. PR #9646 by @tiangolo.
    ğŸ‘· Add custom tokens for GitHub Actions to avoid rate limits. PR #9647 by @tiangolo.

0.96.0Â¶
FeaturesÂ¶

    âš¡ Update create_cloned_field to use a global cache and improve startup performance. PR #4645 by @madkinsz and previous original PR by @huonw.

DocsÂ¶

    ğŸ“ Update Deta deployment tutorial for compatibility with Deta Space. PR #6004 by @mikBighne98.
    âœï¸ Fix typo in Deta deployment tutorial. PR #9501 by @lemonyte.

TranslationsÂ¶

    ğŸŒ Add Russian translation for docs/tutorial/body.md. PR #3885 by @solomein-sv.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/static-files.md. PR #9580 by @Alexandrhub.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/query-params.md. PR #9584 by @Alexandrhub.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/first-steps.md. PR #9471 by @AGolicyn.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/debugging.md. PR #9579 by @Alexandrhub.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/path-params.md. PR #9519 by @AGolicyn.
    ğŸŒ Add Chinese translation for docs/zh/docs/tutorial/static-files.md. PR #9436 by @wdh99.
    ğŸŒ Update Spanish translation including new illustrations in docs/es/docs/async.md. PR #9483 by @andresbermeoq.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/path-params-numeric-validations.md. PR #9563 by @ivan-abc.
    ğŸŒ Add Russian translation for docs/ru/docs/deployment/concepts.md. PR #9577 by @Xewus.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/body-multiple-params.md. PR #9586 by @Alexandrhub.

InternalÂ¶

    ğŸ‘¥ Update FastAPI People. PR #9602 by @github-actions[bot].
    ğŸ”§ Update sponsors, remove InvestSuite. PR #9612 by @tiangolo.

0.95.2Â¶

    â¬†ï¸ Upgrade Starlette version to >=0.27.0 for a security release. PR #9541 by @tiangolo. Details on Starlette's security advisory.

TranslationsÂ¶

    ğŸŒ Add Portuguese translation for docs/pt/docs/advanced/events.md. PR #9326 by @oandersonmagalhaes.
    ğŸŒ Add Russian translation for docs/ru/docs/deployment/manually.md. PR #9417 by @Xewus.
    ğŸŒ Add setup for translations to Lao. PR #9396 by @TheBrown.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/testing.md. PR #9403 by @Xewus.
    ğŸŒ Add Russian translation for docs/ru/docs/deployment/https.md. PR #9428 by @Xewus.
    âœ Fix command to install requirements in Windows. PR #9445 by @MariiaRomanuik.
    ğŸŒ Add French translation for docs/fr/docs/advanced/response-directly.md. PR #9415 by @axel584.
    ğŸŒ Initiate Czech translation setup. PR #9288 by @3p1463k.
    âœ Fix typo in Portuguese docs for docs/pt/docs/index.md. PR #9337 by @lucasbalieiro.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/response-status-code.md. PR #9370 by @nadia3373.

InternalÂ¶

    ğŸ› Fix flask.escape warning for internal tests. PR #9468 by @samuelcolvin.
    âœ… Refactor 2 tests, for consistency and simplification. PR #9504 by @tiangolo.
    âœ… Refactor OpenAPI tests, prepare for Pydantic v2. PR #9503 by @tiangolo.
    â¬† Bump dawidd6/action-download-artifact from 2.26.0 to 2.27.0. PR #9394 by @dependabot[bot].
    ğŸ’š Disable setup-python pip cache in CI. PR #9438 by @tiangolo.
    â¬† Bump pypa/gh-action-pypi-publish from 1.6.4 to 1.8.5. PR #9346 by @dependabot[bot].

0.95.1Â¶
FixesÂ¶

    ğŸ› Fix using Annotated in routers or path operations decorated multiple times. PR #9315 by @sharonyogev.

DocsÂ¶

    ğŸŒ ğŸ”  ğŸ“„ ğŸ¢ Translate docs to Emoji ğŸ¥³ ğŸ‰ ğŸ’¥ ğŸ¤¯ ğŸ¤¯. PR #5385 by @LeeeeT.
    ğŸ“ Add notification message warning about old versions of FastAPI not supporting Annotated. PR #9298 by @grdworkin.
    ğŸ“ Fix typo in docs/en/docs/advanced/behind-a-proxy.md. PR #5681 by @Leommjr.
    âœ Fix wrong import from typing module in Persian translations for docs/fa/docs/index.md. PR #6083 by @Kimiaattaei.
    âœï¸ Fix format, remove unnecessary asterisks in docs/en/docs/help-fastapi.md. PR #9249 by @armgabrielyan.
    âœ Fix typo in docs/en/docs/tutorial/query-params-str-validations.md. PR #9272 by @nicornk.
    âœ Fix typo/bug in inline code example in docs/en/docs/tutorial/query-params-str-validations.md. PR #9273 by @tim-habitat.
    âœ Fix typo in docs/en/docs/tutorial/path-params-numeric-validations.md. PR #9282 by @aadarsh977.
    âœ Fix typo: 'wll' to 'will' in docs/en/docs/tutorial/query-params-str-validations.md. PR #9380 by @dasstyxx.

TranslationsÂ¶

    ğŸŒ Add French translation for docs/fr/docs/advanced/index.md. PR #5673 by @axel584.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/body-nested-models.md. PR #4053 by @luccasmmg.
    ğŸŒ Add Russian translation for docs/ru/docs/alternatives.md. PR #5994 by @Xewus.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/extra-models.md. PR #5912 by @LorhanSohaky.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/path-operation-configuration.md. PR #5936 by @LorhanSohaky.
    ğŸŒ Add Russian translation for docs/ru/docs/contributing.md. PR #6002 by @stigsanek.
    ğŸŒ Add Korean translation for docs/tutorial/dependencies/classes-as-dependencies.md. PR #9176 by @sehwan505.
    ğŸŒ Add Russian translation for docs/ru/docs/project-generation.md. PR #9243 by @Xewus.
    ğŸŒ Add French translation for docs/fr/docs/index.md. PR #9265 by @frabc.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/query-params-str-validations.md. PR #9267 by @dedkot01.
    ğŸŒ Add Russian translation for docs/ru/docs/benchmarks.md. PR #9271 by @Xewus.

InternalÂ¶

    ğŸ”§ Update sponsors: remove Jina. PR #9388 by @tiangolo.
    ğŸ”§ Update sponsors, add databento, remove Ines's course and StriveWorks. PR #9351 by @tiangolo.

0.95.0Â¶
HighlightsÂ¶

This release adds support for dependencies and parameters using Annotated and recommends its usage. âœ¨

This has several benefits, one of the main ones is that now the parameters of your functions with Annotated would not be affected at all.

If you call those functions in other places in your code, the actual default values will be kept, your editor will help you notice missing required arguments, Python will require you to pass required arguments at runtime, you will be able to use the same functions for different things and with different libraries (e.g. Typer will soon support Annotated too, then you could use the same function for an API and a CLI), etc.

Because Annotated is standard Python, you still get all the benefits from editors and tools, like autocompletion, inline errors, etc.

One of the biggest benefits is that now you can create Annotated dependencies that are then shared by multiple path operation functions, this will allow you to reduce a lot of code duplication in your codebase, while keeping all the support from editors and tools.

For example, you could have code like this:

def get_current_user(token: str):
    # authenticate user
    return User()


@app.get("/items/")
def read_items(user: User = Depends(get_current_user)):
    ...


@app.post("/items/")
def create_item(*, user: User = Depends(get_current_user), item: Item):
    ...


@app.get("/items/{item_id}")
def read_item(*, user: User = Depends(get_current_user), item_id: int):
    ...


@app.delete("/items/{item_id}")
def delete_item(*, user: User = Depends(get_current_user), item_id: int):
    ...

There's a bit of code duplication for the dependency:

user: User = Depends(get_current_user)

...the bigger the codebase, the more noticeable it is.

Now you can create an annotated dependency once, like this:

CurrentUser = Annotated[User, Depends(get_current_user)]

And then you can reuse this Annotated dependency:

CurrentUser = Annotated[User, Depends(get_current_user)]


@app.get("/items/")
def read_items(user: CurrentUser):
    ...


@app.post("/items/")
def create_item(user: CurrentUser, item: Item):
    ...


@app.get("/items/{item_id}")
def read_item(user: CurrentUser, item_id: int):
    ...


@app.delete("/items/{item_id}")
def delete_item(user: CurrentUser, item_id: int):
    ...

...and CurrentUser has all the typing information as User, so your editor will work as expected (autocompletion and everything), and FastAPI will be able to understand the dependency defined in Annotated. ğŸ˜

Roughly all the docs have been rewritten to use Annotated as the main way to declare parameters and dependencies. All the examples in the docs now include a version with Annotated and a version without it, for each of the specific Python versions (when there are small differences/improvements in more recent versions). There were around 23K new lines added between docs, examples, and tests. ğŸš€

The key updated docs are:

    Python Types Intro:
        Type Hints with Metadata Annotations.
    Tutorial:
        Query Parameters and String Validations - Additional validation
            Advantages of Annotated
        Path Parameters and Numeric Validations - Order the parameters as you need, tricks
            Better with Annotated
        Dependencies - First Steps - Share Annotated dependencies

Special thanks to @nzig for the core implementation and to @adriangb for the inspiration and idea with Xpresso! ğŸš€
FeaturesÂ¶

    âœ¨Add support for PEP-593 Annotated for specifying dependencies and parameters. PR #4871 by @nzig.

DocsÂ¶

    ğŸ“ Tweak tip recommending Annotated in docs. PR #9270 by @tiangolo.
    ğŸ“ Update order of examples, latest Python version first, and simplify version tab names. PR #9269 by @tiangolo.
    ğŸ“ Update all docs to use Annotated as the main recommendation, with new examples and tests. PR #9268 by @tiangolo.

0.94.1Â¶
FixesÂ¶

    ğŸ¨ Fix types for lifespan, upgrade Starlette to 0.26.1. PR #9245 by @tiangolo.

0.94.0Â¶
UpgradesÂ¶

    â¬† Upgrade python-multipart to support 0.0.6. PR #9212 by @musicinmybrain.
    â¬†ï¸ Upgrade Starlette version, support new lifespan with state. PR #9239 by @tiangolo.

DocsÂ¶

    ğŸ“ Update Sentry link in docs. PR #9218 by @smeubank.

TranslationsÂ¶

    ğŸŒ Add Russian translation for docs/ru/docs/history-design-future.md. PR #5986 by @Xewus.

InternalÂ¶

    â• Add pydantic to PyPI classifiers. PR #5914 by @yezz123.
    â¬† Bump black from 22.10.0 to 23.1.0. PR #5953 by @dependabot[bot].
    â¬† Bump types-ujson from 5.6.0.0 to 5.7.0.1. PR #6027 by @dependabot[bot].
    â¬† Bump dawidd6/action-download-artifact from 2.24.3 to 2.26.0. PR #6034 by @dependabot[bot].
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #5709 by @pre-commit-ci[bot].

0.93.0Â¶
FeaturesÂ¶

    âœ¨ Add support for lifespan async context managers (superseding startup and shutdown events). Initial PR #2944 by @uSpike.

Now, instead of using independent startup and shutdown events, you can define that logic in a single function with yield decorated with @asynccontextmanager (an async context manager).

For example:

from contextlib import asynccontextmanager

from fastapi import FastAPI


def fake_answer_to_everything_ml_model(x: float):
    return x * 42


ml_models = {}


@asynccontextmanager
async def lifespan(app: FastAPI):
    # Load the ML model
    ml_models["answer_to_everything"] = fake_answer_to_everything_ml_model
    yield
    # Clean up the ML models and release the resources
    ml_models.clear()


app = FastAPI(lifespan=lifespan)


@app.get("/predict")
async def predict(x: float):
    result = ml_models["answer_to_everything"](x)
    return {"result": result}

Note: This is the recommended way going forward, instead of using startup and shutdown events.

Read more about it in the new docs: Advanced User Guide: Lifespan Events.
DocsÂ¶

    âœ Fix formatting in docs/en/docs/tutorial/metadata.md for ReDoc. PR #6005 by @eykamp.

TranslationsÂ¶

    ğŸŒ Tamil translations - initial setup. PR #5564 by @gusty1g.
    ğŸŒ Add French translation for docs/fr/docs/advanced/path-operation-advanced-configuration.md. PR #9221 by @axel584.
    ğŸŒ Add French translation for docs/tutorial/debugging.md. PR #9175 by @frabc.
    ğŸŒ Initiate Armenian translation setup. PR #5844 by @har8.
    ğŸŒ Add French translation for deployment/manually.md. PR #3693 by @rjNemo.

InternalÂ¶

    ğŸ‘· Update translation bot messages. PR #9206 by @tiangolo.
    ğŸ‘· Update translations bot to use Discussions, and notify when a PR is done. PR #9183 by @tiangolo.
    ğŸ”§ Update sponsors-badges. PR #9182 by @tiangolo.
    ğŸ‘¥ Update FastAPI People. PR #9181 by @github-actions[bot].
    ğŸ”Š Log GraphQL errors in FastAPI People, because it returns 200, with a payload with an error. PR #9171 by @tiangolo.
    ğŸ’š Fix/workaround GitHub Actions in Docker with git for FastAPI People. PR #9169 by @tiangolo.
    â™»ï¸ Refactor FastAPI Experts to use only discussions now that questions are migrated. PR #9165 by @tiangolo.
    â¬†ï¸ Upgrade analytics. PR #6025 by @tiangolo.
    â¬†ï¸ Upgrade and re-enable installing Typer-CLI. PR #6008 by @tiangolo.

0.92.0Â¶

ğŸš¨ This is a security fix. Please upgrade as soon as possible.
UpgradesÂ¶

    â¬†ï¸ Upgrade Starlette to 0.25.0. PR #5996 by @tiangolo.
        This solves a vulnerability that could allow denial of service attacks by using many small multipart fields/files (parts), consuming high CPU and memory.
        Only applications using forms (e.g. file uploads) could be affected.
        For most cases, upgrading won't have any breaking changes.

0.91.0Â¶
UpgradesÂ¶

    â¬†ï¸ Upgrade Starlette version to 0.24.0 and refactor internals for compatibility. PR #5985 by @tiangolo.
        This can solve nuanced errors when using middlewares. Before Starlette 0.24.0, a new instance of each middleware class would be created when a new middleware was added. That normally was not a problem, unless the middleware class expected to be created only once, with only one instance, that happened in some cases. This upgrade would solve those cases (thanks @adriangb! Starlette PR #2017). Now the middleware class instances are created once, right before the first request (the first time the app is called).
        If you depended on that previous behavior, you might need to update your code. As always, make sure your tests pass before merging the upgrade.

0.90.1Â¶
UpgradesÂ¶

    â¬†ï¸ Upgrade Starlette range to allow 0.23.1. PR #5980 by @tiangolo.

DocsÂ¶

    âœ Tweak wording to clarify docs/en/docs/project-generation.md. PR #5930 by @chandra-deb.
    âœ Update Pydantic GitHub URLs. PR #5952 by @yezz123.
    ğŸ“ Add opinion from Cisco. PR #5981 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/cookie-params.md. PR #5890 by @bnzone.

InternalÂ¶

    âœ Update zip-docs.sh internal script, remove extra space. PR #5931 by @JuanPerdomo00.

0.90.0Â¶
UpgradesÂ¶

    â¬†ï¸ Bump Starlette from 0.22.0 to 0.23.0. Initial PR #5739 by @Kludex.

DocsÂ¶

    ğŸ“ Add article "Tortoise ORM / FastAPI æ•´åˆå¿«é€Ÿç­†è¨˜" to External Links. PR #5496 by @Leon0824.
    ğŸ‘¥ Update FastAPI People. PR #5954 by @github-actions[bot].
    ğŸ“ Micro-tweak help docs. PR #5960 by @tiangolo.
    ğŸ”§ Update new issue chooser to direct to GitHub Discussions. PR #5948 by @tiangolo.
    ğŸ“ Recommend GitHub Discussions for questions. PR #5944 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/body-fields.md. PR #5898 by @simatheone.
    ğŸŒ Add Russian translation for docs/ru/docs/help-fastapi.md. PR #5970 by @tiangolo.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/static-files.md. PR #5858 by @batlopes.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/encoder.md. PR #5525 by @felipebpl.
    ğŸŒ Add Russian translation for docs/ru/docs/contributing.md. PR #5870 by @Xewus.

InternalÂ¶

    â¬†ï¸ Upgrade Ubuntu version for docs workflow. PR #5971 by @tiangolo.
    ğŸ”§ Update sponsors badges. PR #5943 by @tiangolo.
    âœ¨ Compute FastAPI Experts including GitHub Discussions. PR #5941 by @tiangolo.
    â¬†ï¸ Upgrade isort and update pre-commit. PR #5940 by @tiangolo.
    ğŸ”§ Add template for questions in Discussions. PR #5920 by @tiangolo.
    ğŸ”§ Update Sponsor Budget Insight to Powens. PR #5916 by @tiangolo.
    ğŸ”§ Update GitHub Sponsors badge data. PR #5915 by @tiangolo.

0.89.1Â¶
FixesÂ¶

    ğŸ› Ignore Response classes on return annotation. PR #5855 by @Kludex. See the new docs in the PR below.

DocsÂ¶

    ğŸ“ Update docs and examples for Response Model with Return Type Annotations, and update runtime error. PR #5873 by @tiangolo. New docs at Response Model - Return Type: Other Return Type Annotations.
    ğŸ“ Add External Link: FastAPI lambda container: serverless simplified. PR #5784 by @rafrasenberg.

TranslationsÂ¶

    ğŸŒ Add Turkish translation for docs/tr/docs/tutorial/first_steps.md. PR #5691 by @Kadermiyanyedi.

0.89.0Â¶
FeaturesÂ¶

    âœ¨ Add support for function return type annotations to declare the response_model. Initial PR #1436 by @uriyyo.

Now you can declare the return type / response_model in the function return type annotation:

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    price: float


@app.get("/items/")
async def read_items() -> list[Item]:
    return [
        Item(name="Portal Gun", price=42.0),
        Item(name="Plumbus", price=32.0),
    ]

FastAPI will use the return type annotation to perform:

    Data validation
    Automatic documentation
        It could power automatic client generators
    Data filtering

Before this version it was only supported via the response_model parameter.

Read more about it in the new docs: Response Model - Return Type.
DocsÂ¶

    ğŸ“ Add External Link: Authorization on FastAPI with Casbin. PR #5712 by @Xhy-5000.
    âœ Fix typo in docs/en/docs/async.md. PR #5785 by @Kingdageek.
    âœ Fix typo in docs/en/docs/deployment/concepts.md. PR #5824 by @kelbyfaessler.

TranslationsÂ¶

    ğŸŒ Add Russian translation for docs/ru/docs/fastapi-people.md. PR #5577 by @Xewus.
    ğŸŒ Fix typo in Chinese translation for docs/zh/docs/benchmarks.md. PR #4269 by @15027668g.
    ğŸŒ Add Korean translation for docs/tutorial/cors.md. PR #3764 by @NinaHwang.

InternalÂ¶

    â¬† Update coverage[toml] requirement from <7.0,>=6.5.0 to >=6.5.0,<8.0. PR #5801 by @dependabot[bot].
    â¬† Update uvicorn[standard] requirement from <0.19.0,>=0.12.0 to >=0.12.0,<0.21.0 for development. PR #5795 by @dependabot[bot].
    â¬† Bump dawidd6/action-download-artifact from 2.24.2 to 2.24.3. PR #5842 by @dependabot[bot].
    ğŸ‘¥ Update FastAPI People. PR #5825 by @github-actions[bot].
    â¬† Bump types-ujson from 5.5.0 to 5.6.0.0. PR #5735 by @dependabot[bot].
    â¬† Bump pypa/gh-action-pypi-publish from 1.5.2 to 1.6.4. PR #5750 by @dependabot[bot].
    ğŸ‘· Add GitHub Action gate/check. PR #5492 by @webknjaz.
    ğŸ”§ Update sponsors, add Svix. PR #5848 by @tiangolo.
    ğŸ”§ Remove Doist sponsor. PR #5847 by @tiangolo.
    â¬† Update sqlalchemy requirement from <=1.4.41,>=1.3.18 to >=1.3.18,<1.4.43. PR #5540 by @dependabot[bot].
    â¬† Bump nwtgck/actions-netlify from 1.2.4 to 2.0.0. PR #5757 by @dependabot[bot].
    ğŸ‘· Refactor CI artifact upload/download for docs previews. PR #5793 by @tiangolo.
    â¬† Bump pypa/gh-action-pypi-publish from 1.5.1 to 1.5.2. PR #5714 by @dependabot[bot].
    ğŸ‘¥ Update FastAPI People. PR #5722 by @github-actions[bot].
    ğŸ”§ Update sponsors, disable course bundle. PR #5713 by @tiangolo.
    â¬† Update typer[all] requirement from <0.7.0,>=0.6.1 to >=0.6.1,<0.8.0. PR #5639 by @dependabot[bot].

0.88.0Â¶
UpgradesÂ¶

    â¬† Bump Starlette to version 0.22.0 to fix bad encoding for query parameters in new TestClient. PR #5659 by @azogue.

DocsÂ¶

    âœï¸ Fix typo in docs for docs/en/docs/advanced/middleware.md. PR #5376 by @rifatrakib.

TranslationsÂ¶

    ğŸŒ Add Portuguese translation for docs/pt/docs/deployment/docker.md. PR #5663 by @ayr-ton.

InternalÂ¶

    ğŸ‘· Tweak build-docs to improve CI performance. PR #5699 by @tiangolo.
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #5566 by @pre-commit-ci[bot].
    â¬†ï¸ Upgrade Ruff. PR #5698 by @tiangolo.
    ğŸ‘· Remove pip cache for Smokeshow as it depends on a requirements.txt. PR #5700 by @tiangolo.
    ğŸ’š Fix pip cache for Smokeshow. PR #5697 by @tiangolo.
    ğŸ‘· Fix and tweak CI cache handling. PR #5696 by @tiangolo.
    ğŸ‘· Update setup-python action in tests to use new caching feature. PR #5680 by @madkinsz.
    â¬† Bump black from 22.8.0 to 22.10.0. PR #5569 by @dependabot[bot].

0.87.0Â¶

Highlights of this release:

    Upgraded Starlette
        Now the TestClient is based on HTTPX instead of Requests. ğŸš€
        There are some possible breaking changes in the TestClient usage, but @Kludex built bump-testclient to help you automatize migrating your tests. Make sure you are using Git and that you can undo any unnecessary changes (false positive changes, etc) before using bump-testclient.
    New WebSocketException (and docs), re-exported from Starlette.
    Upgraded and relaxed dependencies for package extras all (including new Uvicorn version), when you install "fastapi[all]".
    New docs about how to Help Maintain FastAPI.

FeaturesÂ¶

    â¬†ï¸ Upgrade and relax dependencies for extras "all". PR #5634 by @tiangolo.
    âœ¨ Re-export Starlette's WebSocketException and add it to docs. PR #5629 by @tiangolo.
    ğŸ“ Update references to Requests for tests to HTTPX, and add HTTPX to extras. PR #5628 by @tiangolo.
    â¬† Upgrade Starlette to 0.21.0, including the new TestClient based on HTTPX. PR #5471 by @pawelrubin.

DocsÂ¶

    âœï¸ Tweak Help FastAPI from PR review after merging. PR #5633 by @tiangolo.
    âœï¸ Clarify docs on CORS. PR #5627 by @paxcodes.
    ğŸ“ Update Help FastAPI: Help Maintain FastAPI. PR #5632 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Fix highlight lines for Japanese translation for docs/tutorial/query-params.md. PR #2969 by @ftnext.
    ğŸŒ Add French translation for docs/fr/docs/advanced/additional-status-code.md. PR #5477 by @axel584.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/request-forms-and-files.md. PR #5579 by @batlopes.
    ğŸŒ Add Japanese translation for docs/ja/docs/advanced/websockets.md. PR #4983 by @xryuseix.

InternalÂ¶

    âœ¨ Use Ruff for linting. PR #5630 by @tiangolo.
    ğŸ›  Add Arabic issue number to Notify Translations GitHub Action. PR #5610 by @tiangolo.
    â¬† Bump dawidd6/action-download-artifact from 2.24.1 to 2.24.2. PR #5609 by @dependabot[bot].
    â¬† Bump dawidd6/action-download-artifact from 2.24.0 to 2.24.1. PR #5603 by @dependabot[bot].
    ğŸ“ Update coverage badge to use Samuel Colvin's Smokeshow. PR #5585 by @tiangolo.

0.86.0Â¶
FeaturesÂ¶

    â¬† Add Python 3.11 to the officially supported versions. PR #5587 by @tiangolo.
    âœ… Enable tests for Python 3.11. PR #4881 by @tiangolo.

FixesÂ¶

    ğŸ› Close FormData (uploaded files) after the request is done. PR #5465 by @adriangb.

DocsÂ¶

    âœ Fix typo in docs/en/docs/tutorial/security/oauth2-jwt.md. PR #5584 by @vivekashok1221.

TranslationsÂ¶

    ğŸŒ Update wording in Chinese translation for docs/zh/docs/python-types.md. PR #5416 by @supercaizehua.
    ğŸŒ Add Russian translation for docs/ru/docs/deployment/index.md. PR #5336 by @Xewus.
    ğŸŒ Update Chinese translation for docs/tutorial/security/oauth2-jwt.md. PR #3846 by @jaystone776.

InternalÂ¶

    ğŸ‘· Update FastAPI People to exclude bots: pre-commit-ci, dependabot. PR #5586 by @tiangolo.
    ğŸ¨ Format OpenAPI JSON in test_starlette_exception.py. PR #5379 by @iudeen.
    ğŸ‘· Switch from Codecov to Smokeshow plus pytest-cov to pure coverage for internal tests. PR #5583 by @tiangolo.
    ğŸ‘¥ Update FastAPI People. PR #5571 by @github-actions[bot].

0.85.2Â¶
DocsÂ¶

    âœ Fix grammar and add helpful links to dependencies in docs/en/docs/async.md. PR #5432 by @pamelafox.
    âœ Fix broken link in alternatives.md. PR #5455 by @su-shubham.
    âœ Fix typo in docs about contributing, for compatibility with pip in Zsh. PR #5523 by @zhangbo2012.
    ğŸ“ Fix typo in docs with examples for Python 3.10 instead of 3.9. PR #5545 by @feliciss.

TranslationsÂ¶

    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/request-forms.md. PR #4934 by @batlopes.
    ğŸŒ Add Chinese translation for docs/zh/docs/tutorial/dependencies/classes-as-dependencies.md. PR #4971 by @Zssaer.
    ğŸŒ Add French translation for deployment/deta.md. PR #3692 by @rjNemo.
    ğŸŒ Update Chinese translation for docs/zh/docs/tutorial/query-params-str-validations.md. PR #5255 by @hjlarry.
    ğŸŒ Add Chinese translation for docs/zh/docs/tutorial/sql-databases.md. PR #4999 by @Zssaer.
    ğŸŒ Add Chinese translation for docs/zh/docs/advanced/wsgi.md. PR #4505 by @ASpathfinder.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/body-multiple-params.md. PR #4111 by @lbmendes.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/path-params-numeric-validations.md. PR #4099 by @lbmendes.
    ğŸŒ Add French translation for deployment/versions.md. PR #3690 by @rjNemo.
    ğŸŒ Add French translation for docs/fr/docs/help-fastapi.md. PR #2233 by @JulianMaurin.
    ğŸŒ Fix typo in Chinese translation for docs/zh/docs/tutorial/security/first-steps.md. PR #5530 by @yuki1sntSnow.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/response-status-code.md. PR #4922 by @batlopes.
    ğŸ”§ Add config for Tamil translations. PR #5563 by @tiangolo.

InternalÂ¶

    â¬† Bump internal dependency mypy from 0.971 to 0.982. PR #5541 by @dependabot[bot].
    â¬† Bump nwtgck/actions-netlify from 1.2.3 to 1.2.4. PR #5507 by @dependabot[bot].
    â¬† Bump internal dependency types-ujson from 5.4.0 to 5.5.0. PR #5537 by @dependabot[bot].
    â¬† Bump dawidd6/action-download-artifact from 2.23.0 to 2.24.0. PR #5508 by @dependabot[bot].
    â¬† Update internal dependency pytest-cov requirement from <4.0.0,>=2.12.0 to >=2.12.0,<5.0.0. PR #5539 by @dependabot[bot].
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #5536 by @pre-commit-ci[bot].
    ğŸ› Fix internal Trio test warnings. PR #5547 by @samuelcolvin.
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #5408 by @pre-commit-ci[bot].
    â¬†ï¸ Upgrade Typer to include Rich in scripts for docs. PR #5502 by @tiangolo.
    ğŸ› Fix calling mkdocs for languages as a subprocess to fix/enable MkDocs Material search plugin. PR #5501 by @tiangolo.

0.85.1Â¶
FixesÂ¶

    ğŸ› Fix support for strings in OpenAPI status codes: default, 1XX, 2XX, 3XX, 4XX, 5XX. PR #5187 by @JarroVGIT.

DocsÂ¶

    ğŸ“ Add WayScript x FastAPI Tutorial to External Links section. PR #5407 by @moneeka.

InternalÂ¶

    ğŸ‘¥ Update FastAPI People. PR #5447 by @github-actions[bot].
    ğŸ”§ Disable Material for MkDocs search plugin. PR #5495 by @tiangolo.
    ğŸ”‡ Ignore Trio warning in tests for CI. PR #5483 by @samuelcolvin.

0.85.0Â¶
FeaturesÂ¶

    â¬† Upgrade version required of Starlette from 0.19.1 to 0.20.4. Initial PR #4820 by @Kludex.
        This includes several bug fixes in Starlette.
    â¬†ï¸ Upgrade Uvicorn max version in public extras: all. From >=0.12.0,<0.18.0 to >=0.12.0,<0.19.0. PR #5401 by @tiangolo.

InternalÂ¶

    â¬†ï¸ Upgrade dependencies for doc and dev internal extras: Typer, Uvicorn. PR #5400 by @tiangolo.
    â¬†ï¸ Upgrade test dependencies: Black, HTTPX, databases, types-ujson. PR #5399 by @tiangolo.
    â¬†ï¸ Upgrade mypy and tweak internal type annotations. PR #5398 by @tiangolo.
    ğŸ”§ Update test dependencies, upgrade Pytest, move dependencies from dev to test. PR #5396 by @tiangolo.

0.84.0Â¶
Breaking ChangesÂ¶

This version of FastAPI drops support for Python 3.6. ğŸ”¥ Please upgrade to a supported version of Python (3.7 or above), Python 3.6 reached the end-of-life a long time ago. ğŸ˜…â˜ 

    ğŸ”§ Update package metadata, drop support for Python 3.6, move build internals from Flit to Hatch. PR #5240 by @ofek.

0.83.0Â¶

ğŸš¨ This is probably the last release (or one of the last releases) to support Python 3.6. ğŸ”¥

Python 3.6 reached the end-of-life and is no longer supported by Python since around a year ago.

You hopefully updated to a supported version of Python a while ago. If you haven't, you really should.
FeaturesÂ¶

    âœ¨ Add support in jsonable_encoder for include and exclude with dataclasses. PR #4923 by @DCsunset.

FixesÂ¶

    ğŸ› Fix RuntimeError raised when HTTPException has a status code with no content. PR #5365 by @iudeen.
    ğŸ› Fix empty reponse body when default status_code is empty but the a Response parameter with response.status_code is set. PR #5360 by @tmeckel.

DocsÂ¶

    ğŸ“ Update SECURITY.md. PR #5377 by @Kludex.

InternalÂ¶

    â¬† [pre-commit.ci] pre-commit autoupdate. PR #5352 by @pre-commit-ci[bot].

0.82.0Â¶

ğŸš¨ This is probably the last release (or one of the last releases) to support Python 3.6. ğŸ”¥

Python 3.6 reached the end-of-life and is no longer supported by Python since around a year ago.

You hopefully updated to a supported version of Python a while ago. If you haven't, you really should.
FeaturesÂ¶

    âœ¨ Export WebSocketState in fastapi.websockets. PR #4376 by @matiuszka.
    âœ¨ Support Python internal description on Pydantic model's docstring. PR #3032 by @Kludex.
    âœ¨ Update ORJSONResponse to support non str keys and serializing Numpy arrays. PR #3892 by @baby5.

FixesÂ¶

    ğŸ› Allow exit code for dependencies with yield to always execute, by removing capacity limiter for them, to e.g. allow closing DB connections without deadlocks. PR #5122 by @adriangb.
    ğŸ› Fix FastAPI People GitHub Action: set HTTPX timeout for GraphQL query request. PR #5222 by @iudeen.
    ğŸ› Make sure a parameter defined as required is kept required in OpenAPI even if defined as optional in another dependency. PR #4319 by @cd17822.
    ğŸ› Fix support for path parameters in WebSockets. PR #3879 by @davidbrochart.

DocsÂ¶

    âœ Update Hypercorn link, now pointing to GitHub. PR #5346 by @baconfield.
    âœ Tweak wording in docs/en/docs/advanced/dataclasses.md. PR #3698 by @pfackeldey.
    ğŸ“ Add note about Python 3.10 X | Y operator in explanation about Response Models. PR #5307 by @MendyLanda.
    ğŸ“ Add link to New Relic article: "How to monitor FastAPI application performance using Python agent". PR #5260 by @sjyothi54.
    ğŸ“ Update docs for ORJSONResponse with details about improving performance. PR #2615 by @falkben.
    ğŸ“ Add docs for creating a custom Response class. PR #5331 by @tiangolo.
    ğŸ“ Add tip about using alias for form data fields. PR #5329 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Add Russian translation for docs/ru/docs/features.md. PR #5315 by @Xewus.
    ğŸŒ Update Chinese translation for docs/zh/docs/tutorial/request-files.md. PR #4529 by @ASpathfinder.
    ğŸŒ Add Chinese translation for docs/zh/docs/tutorial/encoder.md. PR #4969 by @Zssaer.
    ğŸŒ Fix MkDocs file line for Portuguese translation of background-task.md. PR #5242 by @ComicShrimp.

InternalÂ¶

    ğŸ‘¥ Update FastAPI People. PR #5347 by @github-actions[bot].
    â¬† Bump dawidd6/action-download-artifact from 2.22.0 to 2.23.0. PR #5321 by @dependabot[bot].
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #5318 by @pre-commit-ci[bot].
    âœ Fix a small code highlight line error. PR #5256 by @hjlarry.
    â™» Internal small refactor, move operation_id parameter position in delete method for consistency with the code. PR #4474 by @hiel.
    ğŸ”§ Update sponsors, disable ImgWhale. PR #5338 by @tiangolo.

0.81.0Â¶
FeaturesÂ¶

    âœ¨ Add ReDoc <noscript> warning when JS is disabled. PR #5074 by @evroon.
    âœ¨ Add support for FrozenSet in parameters (e.g. query). PR #2938 by @juntatalor.
    âœ¨ Allow custom middlewares to raise HTTPExceptions and propagate them. PR #2036 by @ghandic.
    âœ¨ Preserve json.JSONDecodeError information when handling invalid JSON in request body, to support custom exception handlers that use its information. PR #4057 by @UKnowWhoIm.

FixesÂ¶

    ğŸ› Fix jsonable_encoder for dataclasses with pydantic-compatible fields. PR #3607 by @himbeles.
    ğŸ› Fix support for extending openapi_extras with parameter lists. PR #4267 by @orilevari.

DocsÂ¶

    âœ Fix a simple typo in docs/en/docs/python-types.md. PR #5193 by @GlitchingCore.
    âœ Fix typos in tests/test_schema_extra_examples.py. PR #5126 by @supraaxdd.
    âœ Fix typos in docs/en/docs/tutorial/path-params-numeric-validations.md. PR #5142 by @invisibleroads.
    ğŸ“ Add step about upgrading pip in the venv to avoid errors when installing dependencies docs/en/docs/contributing.md. PR #5181 by @edisnake.
    âœ Reword and clarify text in tutorial docs/en/docs/tutorial/body-nested-models.md. PR #5169 by @papb.
    âœ Fix minor typo in docs/en/docs/features.md. PR #5206 by @OtherBarry.
    âœ Fix minor typos in docs/en/docs/async.md. PR #5125 by @Ksenofanex.
    ğŸ“ Add external link to docs: "Fastapi, Docker(Docker compose) and Postgres". PR #5033 by @krishnardt.
    ğŸ“ Simplify example for docs for Additional Responses, remove unnecessary else. PR #4693 by @adriangb.
    ğŸ“ Update docs, compare enums with identity instead of equality. PR #4905 by @MicaelJarniac.
    âœ Fix typo in docs/en/docs/python-types.md. PR #4886 by @MicaelJarniac.
    ğŸ¨ Fix syntax highlighting in docs for OpenAPI Callbacks. PR #4368 by @xncbf.
    âœ Reword confusing sentence in docs file typo-fix-path-params-numeric-validations.md. PR #3219 by @ccrenfroe.
    ğŸ“ Update docs for handling HTTP Basic Auth with secrets.compare_digest() to account for non-ASCII characters. PR #3536 by @lewoudar.
    ğŸ“ Update docs for testing, fix examples with relative imports. PR #5302 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Add Russian translation for docs/ru/docs/index.md. PR #5289 by @impocode.
    ğŸŒ Add Russian translation for docs/ru/docs/deployment/versions.md. PR #4985 by @emp7yhead.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/header-params.md. PR #4921 by @batlopes.
    ğŸŒ Update ko/mkdocs.yml for a missing link. PR #5020 by @dalinaum.

InternalÂ¶

    â¬† Bump dawidd6/action-download-artifact from 2.21.1 to 2.22.0. PR #5258 by @dependabot[bot].
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #5196 by @pre-commit-ci[bot].
    ğŸ”¥ Delete duplicated tests in tests/test_tutorial/test_sql_databases/test_sql_databases.py. PR #5040 by @raccoonyy.
    â™» Simplify internal RegEx in fastapi/utils.py. PR #5057 by @pylounge.
    ğŸ”§ Fix Type hint of auto_error which does not need to be Optional[bool]. PR #4933 by @DavidKimDY.
    ğŸ”§ Update mypy config, use strict = true instead of manual configs. PR #4605 by @michaeloliverx.
    â™» Change a dict() for {} in fastapi/utils.py. PR #3138 by @ShahriyarR.
    â™» Move internal variable for errors in jsonable_encoder to put related code closer. PR #4560 by @GuilleQP.
    â™» Simplify conditional assignment in fastapi/dependencies/utils.py. PR #4597 by @cikay.
    â¬† Upgrade version pin accepted for Flake8, for internal code, to flake8 >=3.8.3,<6.0.0. PR #4097 by @jamescurtin.
    ğŸ± Update Jina banner, fix typo. PR #5301 by @tiangolo.

0.80.0Â¶
Breaking Changes - FixesÂ¶

    ğŸ› Fix response_model not invalidating None. PR #2725 by @hukkin.

If you are using response_model with some type that doesn't include None but the function is returning None, it will now raise an internal server error, because you are returning invalid data that violates the contract in response_model. Before this release it would allow breaking that contract returning None.

For example, if you have an app like this:

from fastapi import FastAPI
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    price: Optional[float] = None
    owner_ids: Optional[List[int]] = None

app = FastAPI()

@app.get("/items/invalidnone", response_model=Item)
def get_invalid_none():
    return None

...calling the path /items/invalidnone will raise an error, because None is not a valid type for the response_model declared with Item.

You could also be implicitly returning None without realizing, for example:

from fastapi import FastAPI
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    price: Optional[float] = None
    owner_ids: Optional[List[int]] = None

app = FastAPI()

@app.get("/items/invalidnone", response_model=Item)
def get_invalid_none():
    if flag:
        return {"name": "foo"}
    # if flag is False, at this point the function will implicitly return None

If you have path operations using response_model that need to be allowed to return None, make it explicit in response_model using Union[Something, None]:

from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    price: Optional[float] = None
    owner_ids: Optional[List[int]] = None

app = FastAPI()

@app.get("/items/invalidnone", response_model=Union[Item, None])
def get_invalid_none():
    return None

This way the data will be correctly validated, you won't have an internal server error, and the documentation will also reflect that this path operation could return None (or null in JSON).
FixesÂ¶

    â¬† Upgrade Swagger UI copy of oauth2-redirect.html to include fixes for flavors of authorization code flows in Swagger UI. PR #3439 initial PR by @koonpeng.
    â™» Strip empty whitespace from description extracted from docstrings. PR #2821 by @and-semakin.
    ğŸ› Fix cached dependencies when using a dependency in Security() and other places (e.g. Depends()) with different OAuth2 scopes. PR #2945 by @laggardkernel.
    ğŸ¨ Update type annotations for response_model, allow things like Union[str, None]. PR #5294 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Fix typos in German translation for docs/de/docs/features.md. PR #4533 by @0xflotus.
    ğŸŒ Add missing navigator for encoder.md in Korean translation. PR #5238 by @joonas-yoon.
    (Empty PR merge by accident) #4913.

0.79.1Â¶
FixesÂ¶

    ğŸ› Fix jsonable_encoder using include and exclude parameters for non-Pydantic objects. PR #2606 by @xaviml.
    ğŸ› Fix edge case with repeated aliases names not shown in OpenAPI. PR #2351 by @klaa97.
    ğŸ“ Add misc dependency installs to tutorial docs. PR #2126 by @TeoZosa.

DocsÂ¶

    ğŸ“ Add note giving credit for illustrations to Ketrina Thompson. PR #5284 by @tiangolo.
    âœ Fix typo in python-types.md. PR #5116 by @Kludex.
    âœ Fix typo in docs/en/docs/python-types.md. PR #5007 by @atiabbz.
    ğŸ“ Remove unneeded Django/Flask references from async topic intro. PR #5280 by @carltongibson.
    âœ¨ Add illustrations for Concurrent burgers and Parallel burgers. PR #5277 by @tiangolo. Updated docs at: Concurrency and Burgers.

TranslationsÂ¶

    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/query-params.md. PR #4775 by @batlopes.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/security/first-steps.md. PR #4954 by @FLAIR7.
    ğŸŒ Add translation for docs/zh/docs/advanced/response-cookies.md. PR #4638 by @zhangbo2012.
    ğŸŒ Add French translation for docs/fr/docs/deployment/index.md. PR #3689 by @rjNemo.
    ğŸŒ Add Portuguese translation for tutorial/handling-errors.md. PR #4769 by @frnsimoes.
    ğŸŒ Add French translation for docs/fr/docs/history-design-future.md. PR #3451 by @rjNemo.
    ğŸŒ Add Russian translation for docs/ru/docs/tutorial/background-tasks.md. PR #4854 by @AdmiralDesu.
    ğŸŒ Add Chinese translation for docs/tutorial/security/first-steps.md. PR #3841 by @jaystone776.
    ğŸŒ Add Japanese translation for docs/ja/docs/advanced/nosql-databases.md. PR #4205 by @sUeharaE4.
    ğŸŒ Add Indonesian translation for docs/id/docs/tutorial/index.md. PR #4705 by @bas-baskara.
    ğŸŒ Add Persian translation for docs/fa/docs/index.md and tweak right-to-left CSS. PR #2395 by @mohsen-mahmoodi.

InternalÂ¶

    ğŸ”§ Update Jina sponsorship. PR #5283 by @tiangolo.
    ğŸ”§ Update Jina sponsorship. PR #5272 by @tiangolo.
    ğŸ”§ Update sponsors, Striveworks badge. PR #5179 by @tiangolo.

0.79.0Â¶
Fixes - Breaking ChangesÂ¶

    ğŸ› Fix removing body from status codes that do not support it. PR #5145 by @tiangolo.
        Setting status_code to 204, 304, or any code below 200 (1xx) will remove the body from the response.
        This fixes an error in Uvicorn that otherwise would be thrown: RuntimeError: Response content longer than Content-Length.
        This removes fastapi.openapi.constants.STATUS_CODES_WITH_NO_BODY, it is replaced by a function in utils.

TranslationsÂ¶

    ğŸŒ Start of Hebrew translation. PR #5050 by @itay-raveh.
    ğŸ”§ Add config for Swedish translations notification. PR #5147 by @tiangolo.
    ğŸŒ Start of Swedish translation. PR #5062 by @MrRawbin.
    ğŸŒ Add Japanese translation for docs/ja/docs/advanced/index.md. PR #5043 by @wakabame.
    ğŸŒğŸ‡µğŸ‡± Add Polish translation for docs/pl/docs/tutorial/first-steps.md. PR #5024 by @Valaraucoo.

InternalÂ¶

    ğŸ”§ Update translations notification for Hebrew. PR #5158 by @tiangolo.
    ğŸ”§ Update Dependabot commit message. PR #5156 by @tiangolo.
    â¬† Bump actions/upload-artifact from 2 to 3. PR #5148 by @dependabot[bot].
    â¬† Bump actions/cache from 2 to 3. PR #5149 by @dependabot[bot].
    ğŸ”§ Update sponsors badge configs. PR #5155 by @tiangolo.
    ğŸ‘¥ Update FastAPI People. PR #5154 by @tiangolo.
    ğŸ”§ Update Jina sponsor badges. PR #5151 by @tiangolo.
    â¬† Bump actions/checkout from 2 to 3. PR #5133 by @dependabot[bot].
    â¬† [pre-commit.ci] pre-commit autoupdate. PR #5030 by @pre-commit-ci[bot].
    â¬† Bump nwtgck/actions-netlify from 1.1.5 to 1.2.3. PR #5132 by @dependabot[bot].
    â¬† Bump codecov/codecov-action from 2 to 3. PR #5131 by @dependabot[bot].
    â¬† Bump dawidd6/action-download-artifact from 2.9.0 to 2.21.1. PR #5130 by @dependabot[bot].
    â¬† Bump actions/setup-python from 2 to 4. PR #5129 by @dependabot[bot].
    ğŸ‘· Add Dependabot. PR #5128 by @tiangolo.
    â™»ï¸ Move from Optional[X] to Union[X, None] for internal utils. PR #5124 by @tiangolo.
    ğŸ”§ Update sponsors, remove Dropbase, add Doist. PR #5096 by @tiangolo.
    ğŸ”§ Update sponsors, remove Classiq, add ImgWhale. PR #5079 by @tiangolo.

0.78.0Â¶
FeaturesÂ¶

    âœ¨ Add support for omitting ... as default value when declaring required parameters with:

    Path()
    Query()
    Header()
    Cookie()
    Body()
    Form()
    File()

New docs at Tutorial - Query Parameters and String Validations - Make it required. PR #4906 by @tiangolo.

Up to now, declaring a required parameter while adding additional validation or metadata needed using ... (Ellipsis).

For example:

from fastapi import Cookie, FastAPI, Header, Path, Query

app = FastAPI()


@app.get("/items/{item_id}")
def main(
    item_id: int = Path(default=..., gt=0),
    query: str = Query(default=..., max_length=10),
    session: str = Cookie(default=..., min_length=3),
    x_trace: str = Header(default=..., title="Tracing header"),
):
    return {"message": "Hello World"}

...all these parameters are required because the default value is ... (Ellipsis).

But now it's possible and supported to just omit the default value, as would be done with Pydantic fields, and the parameters would still be required.

âœ¨ For example, this is now supported:

from fastapi import Cookie, FastAPI, Header, Path, Query

app = FastAPI()


@app.get("/items/{item_id}")
def main(
    item_id: int = Path(gt=0),
    query: str = Query(max_length=10),
    session: str = Cookie(min_length=3),
    x_trace: str = Header(title="Tracing header"),
):
    return {"message": "Hello World"}

To declare parameters as optional (not required), you can set a default value as always, for example using None:

from typing import Union
from fastapi import Cookie, FastAPI, Header, Path, Query

app = FastAPI()


@app.get("/items/{item_id}")
def main(
    item_id: int = Path(gt=0),
    query: Union[str, None] = Query(default=None, max_length=10),
    session: Union[str, None] = Cookie(default=None, min_length=3),
    x_trace: Union[str, None] = Header(default=None, title="Tracing header"),
):
    return {"message": "Hello World"}

DocsÂ¶

    ğŸ“ Add docs recommending Union over Optional and migrate source examples. New docs at Python Types Intro - Using Union or Optional. PR #4908 by @tiangolo.
    ğŸ¨ Fix default value as set in tutorial for Path Operations Advanced Configurations. PR #4899 by @tiangolo.
    ğŸ“ Add documentation for redefined path operations. PR #4864 by @madkinsz.
    ğŸ“ Updates links for Celery documentation. PR #4736 by @sammyzord.
    âœ Fix example code with sets in tutorial for body nested models. PR #3030 by @hitrust.
    âœ Fix links to Pydantic docs. PR #4670 by @kinuax.
    ğŸ“ Update docs about Swagger UI self-hosting with newer source links. PR #4813 by @Kastakin.
    ğŸ“ Add link to external article: Building the Poll App From Django Tutorial With FastAPI And React. PR #4778 by @jbrocher.
    ğŸ“ Add OpenAPI warning to "Body - Fields" docs with extra schema extensions. PR #4846 by @ml-evs.

TranslationsÂ¶

    ğŸŒ Fix code examples in Japanese translation for docs/ja/docs/tutorial/testing.md. PR #4623 by @hirotoKirimaru.

InternalÂ¶

    â™» Refactor dict value extraction to minimize key lookups fastapi/utils.py. PR #3139 by @ShahriyarR.
    âœ… Add tests for required nonable parameters and body fields. PR #4907 by @tiangolo.
    ğŸ‘· Fix installing Material for MkDocs Insiders in CI. PR #4897 by @tiangolo.
    ğŸ‘· Add pre-commit CI instead of custom GitHub Action. PR #4896 by @tiangolo.
    ğŸ‘· Add pre-commit GitHub Action workflow. PR #4895 by @tiangolo.
    ğŸ“ Add dark mode auto switch to docs based on OS preference. PR #4869 by @ComicShrimp.
    ğŸ”¥ Remove un-used old pending tests, already covered in other places. PR #4891 by @tiangolo.
    ğŸ”§ Add Python formatting hooks to pre-commit. PR #4890 by @tiangolo.
    ğŸ”§ Add pre-commit with first config and first formatting pass. PR #4888 by @tiangolo.
    ğŸ‘· Disable CI installing Material for MkDocs in forks. PR #4410 by @dolfinus.

0.77.1Â¶
UpgradesÂ¶

    â¬† Upgrade Starlette from 0.19.0 to 0.19.1. PR #4819 by @Kludex.

DocsÂ¶

    ğŸ“ Add link to german article: REST-API Programmieren mittels Python und dem FastAPI Modul. PR #4624 by @fschuermeyer.
    ğŸ“ Add external link: PyCharm Guide to FastAPI. PR #4512 by @mukulmantosh.
    ğŸ“ Add external link to article: Building an API with FastAPI and Supabase and Deploying on Deta. PR #4440 by @aUnicornDev.
    âœ Fix small typo in docs/en/docs/tutorial/security/first-steps.md. PR #4515 by @KikoIlievski.

TranslationsÂ¶

    ğŸŒ Add Polish translation for docs/pl/docs/tutorial/index.md. PR #4516 by @MKaczkow.
    âœ Fix typo in deployment. PR #4629 by @raisulislam541.
    ğŸŒ Add Portuguese translation for docs/pt/docs/help-fastapi.md. PR #4583 by @mateusjs.

InternalÂ¶

    ğŸ”§ Add notifications in issue for Uzbek translations. PR #4884 by @tiangolo.

0.77.0Â¶
UpgradesÂ¶

    â¬† Upgrade Starlette from 0.18.0 to 0.19.0. PR #4488 by @Kludex.
        When creating an explicit JSONResponse the content argument is now required.

DocsÂ¶

    ğŸ“ Add external link to article: Seamless FastAPI Configuration with ConfZ. PR #4414 by @silvanmelchior.
    ğŸ“ Add external link to article: 5 Advanced Features of FastAPI You Should Try. PR #4436 by @kaustubhgupta.
    âœ Reword to improve legibility of docs about TestClient. PR #4389 by @rgilton.
    ğŸ“ Add external link to blog post about Kafka, FastAPI, and Ably. PR #4044 by @Ugbot.
    âœ Fix typo in docs/en/docs/tutorial/sql-databases.md. PR #4875 by @wpyoga.
    âœ Fix typo in docs/en/docs/async.md. PR #4726 by @Prezu.

TranslationsÂ¶

    ğŸŒ Update source example highlights for docs/zh/docs/tutorial/query-params-str-validations.md. PR #4237 by @caimaoy.
    ğŸŒ Remove translation docs references to aiofiles as it's no longer needed since AnyIO. PR #3594 by @alonme.
    âœ ğŸŒ Fix typo in Portuguese translation for docs/pt/docs/tutorial/path-params.md. PR #4722 by @CleoMenezesJr.
    ğŸŒ Fix live docs server for translations for some languages. PR #4729 by @wakabame.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/cookie-params.md. PR #4112 by @lbmendes.
    ğŸŒ Fix French translation for docs/tutorial/body.md. PR #4332 by @Smlep.
    ğŸŒ Add Japanese translation for docs/ja/docs/advanced/conditional-openapi.md. PR #2631 by @sh0nk.
    ğŸŒ Fix Japanese translation of docs/ja/docs/tutorial/body.md. PR #3062 by @a-takahashi223.
    ğŸŒ Add Portuguese translation for docs/pt/docs/tutorial/background-tasks.md. PR #2170 by @izaguerreiro.
    ğŸŒ Add Portuguese translation for docs/deployment/deta.md. PR #4442 by @lsglucas.
    ğŸŒ Add Russian translation for docs/async.md. PR #4036 by @Winand.
    ğŸŒ Add Portuguese translation for docs/tutorial/body.md. PR #3960 by @leandrodesouzadev.
    ğŸŒ Add Portuguese translation of tutorial/extra-data-types.md. PR #4077 by @luccasmmg.
    ğŸŒ Update German translation for docs/features.md. PR #3905 by @jomue.

0.76.0Â¶
UpgradesÂ¶

    â¬† Upgrade Starlette from 0.17.1 to 0.18.0. PR #4483 by @Kludex.

InternalÂ¶

    ğŸ‘¥ Update FastAPI People. PR #4847 by @github-actions[bot].
    ğŸ”§ Add Budget Insight sponsor. PR #4824 by @tiangolo.
    ğŸ± Update sponsor, ExoFlare badge. PR #4822 by @tiangolo.
    ğŸ”§ Update sponsors, enable Dropbase again, update TalkPython link. PR #4821 by @tiangolo.

0.75.2Â¶

This release includes upgrades to third-party packages that handle security issues. Although there's a chance these issues don't affect you in particular, please upgrade as soon as possible.
FixesÂ¶

    âœ… Fix new/recent tests with new fixed ValidationError JSON Schema. PR #4806 by @tiangolo.
    ğŸ› Fix JSON Schema for ValidationError at field loc. PR #3810 by @dconathan.
    ğŸ› Fix support for prefix on APIRouter WebSockets. PR #2640 by @Kludex.

UpgradesÂ¶

    â¬†ï¸ Update ujson ranges for CVE-2021-45958. PR #4804 by @tiangolo.
    â¬†ï¸ Upgrade dependencies upper range for extras "all". PR #4803 by @tiangolo.
    â¬† Upgrade Swagger UI - swagger-ui-dist@4. This handles a security issue in Swagger UI itself where it could be possible to inject HTML into Swagger UI. Please upgrade as soon as you can, in particular if you expose your Swagger UI (/docs) publicly to non-expert users. PR #4347 by @RAlanWright.

InternalÂ¶

    ğŸ”§ Update sponsors, add: ExoFlare, Ines Course; remove: Dropbase, Vim.so, Calmcode; update: Striveworks, TalkPython and TestDriven.io. PR #4805 by @tiangolo.
    â¬†ï¸ Upgrade Codecov GitHub Action. PR #4801 by @tiangolo.

0.75.1Â¶
TranslationsÂ¶

    ğŸŒ Start Dutch translations. PR #4703 by @tiangolo.
    ğŸŒ Start Persian/Farsi translations. PR #4243 by @aminalaee.
    âœ Reword sentence about handling errors. PR #1993 by @khuhroproeza.

InternalÂ¶

    ğŸ‘¥ Update FastAPI People. PR #4752 by @github-actions[bot].
    â– Temporarily remove typer-cli from dependencies and upgrade Black to unblock Pydantic CI. PR #4754 by @tiangolo.
    ğŸ”§ Add configuration to notify Dutch translations. PR #4702 by @tiangolo.
    ğŸ‘¥ Update FastAPI People. PR #4699 by @github-actions[bot].
    ğŸ› Fix FastAPI People generation to include missing file in commit. PR #4695 by @tiangolo.
    ğŸ”§ Update Classiq sponsor links. PR #4688 by @tiangolo.
    ğŸ”§ Add Classiq sponsor. PR #4671 by @tiangolo.
    ğŸ“ Add Jina's QA Bot to the docs to help people that want to ask quick questions. PR #4655 by @tiangolo based on original PR #4626 by @hanxiao.

0.75.0Â¶
FeaturesÂ¶

    âœ¨ Add support for custom generate_unique_id_function and docs for generating clients. New docs: Advanced - Generate Clients. PR #4650 by @tiangolo.

0.74.1Â¶
FeaturesÂ¶

    âœ¨ Include route in scope to allow middleware and other tools to extract its information. PR #4603 by @tiangolo.

0.74.0Â¶
Breaking ChangesÂ¶

    âœ¨ Update internal AsyncExitStack to fix context for dependencies with yield. PR #4575 by @tiangolo.

Dependencies with yield can now catch HTTPException and custom exceptions. For example:

async def get_database():
    with Session() as session:
        try:
            yield session
        except HTTPException:
            session.rollback()
            raise
        finally:
            session.close()

After the dependency with yield handles the exception (or not) the exception is raised again. So that any exception handlers can catch it, or ultimately the default internal ServerErrorMiddleware.

If you depended on exceptions not being received by dependencies with yield, and receiving an exception breaks the code after yield, you can use a block with try and finally:

async def do_something():
    try:
        yield something
    finally:
        some_cleanup()

...that way the finally block is run regardless of any exception that might happen.
FeaturesÂ¶

    The same PR #4575 from above also fixes the contextvars context for the code before and after yield. This was the main objective of that PR.

This means that now, if you set a value in a context variable before yield, the value would still be available after yield (as you would intuitively expect). And it also means that you can reset the context variable with a token afterwards.

For example, this works correctly now:

from contextvars import ContextVar
from typing import Any, Dict, Optional


legacy_request_state_context_var: ContextVar[Optional[Dict[str, Any]]] = ContextVar(
    "legacy_request_state_context_var", default=None
)

async def set_up_request_state_dependency():
    request_state = {"user": "deadpond"}
    contextvar_token = legacy_request_state_context_var.set(request_state)
    yield request_state
    legacy_request_state_context_var.reset(contextvar_token)

...before this change it would raise an error when resetting the context variable, because the contextvars context was different, because of the way it was implemented.

Note: You probably don't need contextvars, and you should probably avoid using them. But they are powerful and useful in some advanced scenarios, for example, migrating from code that used Flask's g semi-global variable.

Technical Details: If you want to know more of the technical details you can check out the PR description #4575.
InternalÂ¶

    ğŸ”§ Add Striveworks sponsor. PR #4596 by @tiangolo.
    ğŸ’š Only build docs on push when on master to avoid duplicate runs from PRs. PR #4564 by @tiangolo.
    ğŸ‘¥ Update FastAPI People. PR #4502 by @github-actions[bot].

0.73.0Â¶
FeaturesÂ¶

    âœ¨ Add support for declaring UploadFile parameters without explicit File(). PR #4469 by @tiangolo. New docs: Request Files - File Parameters with UploadFile.
    âœ¨ Add support for tags with Enums. PR #4468 by @tiangolo. New docs: Path Operation Configuration - Tags with Enums.
    âœ¨ Allow hiding from OpenAPI (and Swagger UI) Query, Cookie, Header, and Path parameters. PR #3144 by @astraldawn. New docs: Query Parameters and String Validations - Exclude from OpenAPI.

DocsÂ¶

    ğŸ“ Tweak and improve docs for Request Files. PR #4470 by @tiangolo.

FixesÂ¶

    ğŸ› Fix bug preventing to use OpenAPI when using tuples. PR #3874 by @victorbenichoux.
    ğŸ› Prefer custom encoder over defaults if specified in jsonable_encoder. PR #2061 by @viveksunder.
        ğŸ’š Duplicate PR to trigger CI. PR #4467 by @tiangolo.

InternalÂ¶

    ğŸ› Fix docs dependencies cache, to get the latest Material for MkDocs. PR #4466 by @tiangolo.
    ğŸ”§ Add sponsor Dropbase. PR #4465 by @tiangolo.

0.72.0Â¶
FeaturesÂ¶

    âœ¨ Enable configuring Swagger UI parameters. Original PR #2568 by @jmriebold. Here are the new docs: Configuring Swagger UI.

DocsÂ¶

    ğŸ“ Update Python Types docs, add missing 3.6 / 3.9 example. PR #4434 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Update Chinese translation for docs/help-fastapi.md. PR #3847 by @jaystone776.
    ğŸŒ Fix Korean translation for docs/ko/docs/index.md. PR #4195 by @kty4119.
    ğŸŒ Add Polish translation for docs/pl/docs/index.md. PR #4245 by @MicroPanda123.
    ğŸŒ Add Chinese translation for docs\tutorial\path-operation-configuration.md. PR #3312 by @jaystone776.

InternalÂ¶

    ğŸ”§ Enable MkDocs Material Insiders' content.tabs.link. PR #4399 by @tiangolo.

0.71.0Â¶
FeaturesÂ¶

    âœ¨ Add docs and tests for Python 3.9 and Python 3.10. PR #3712 by @tiangolo.
        You can start with Python Types Intro, it explains what changes between different Python versions, in Python 3.9 and in Python 3.10.
        All the FastAPI docs are updated. Each code example in the docs that could use different syntax in Python 3.9 or Python 3.10 now has all the alternatives in tabs.
    â¬†ï¸ Upgrade Starlette to 0.17.1. PR #4145 by @simondale00.

InternalÂ¶

    ğŸ‘¥ Update FastAPI People. PR #4354 by @github-actions[bot].
    ğŸ”§ Add FastAPI Trove Classifier for PyPI as now there's one ğŸ¤·ğŸ˜. PR #4386 by @tiangolo.
    â¬† Upgrade MkDocs Material and configs. PR #4385 by @tiangolo.

0.70.1Â¶

There's nothing interesting in this particular FastAPI release. It is mainly to enable/unblock the release of the next version of Pydantic that comes packed with features and improvements. ğŸ¤©
FixesÂ¶

    ğŸ› Fix JSON Schema for dataclasses, supporting the fixes in Pydantic 1.9. PR #4272 by @PrettyWood.

TranslationsÂ¶

    ğŸŒ Add Korean translation for docs/tutorial/request-forms-and-files.md. PR #3744 by @NinaHwang.
    ğŸŒ Add Korean translation for docs/tutorial/request-files.md. PR #3743 by @NinaHwang.
    ğŸŒ Add portuguese translation for docs/tutorial/query-params-str-validations.md. PR #3965 by @leandrodesouzadev.
    ğŸŒ Add Korean translation for docs/tutorial/response-status-code.md. PR #3742 by @NinaHwang.
    ğŸŒ Add Korean translation for Tutorial - JSON Compatible Encoder. PR #3152 by @NEONKID.
    ğŸŒ Add Korean translation for Tutorial - Path Parameters and Numeric Validations. PR #2432 by @hard-coders.
    ğŸŒ Add Korean translation for docs/ko/docs/deployment/versions.md. PR #4121 by @DevDae.
    ğŸŒ Fix Korean translation for docs/ko/docs/tutorial/index.md. PR #4193 by @kimjaeyoonn.
    ğŸ”§ Add CryptAPI sponsor. PR #4264 by @tiangolo.
    ğŸ“ Update docs/tutorial/dependencies/classes-as-dependencies: Add type of query parameters in a description of Classes as dependencies. PR #4015 by @0417taehyun.
    ğŸŒ Add French translation for Tutorial - First steps. PR #3455 by @Smlep.
    ğŸŒ Add French translation for docs/tutorial/path-params.md. PR #3548 by @Smlep.
    ğŸŒ Add French translation for docs/tutorial/query-params.md. PR #3556 by @Smlep.
    ğŸŒ Add Turkish translation for docs/python-types.md. PR #3926 by @BilalAlpaslan.

InternalÂ¶

    ğŸ‘¥ Update FastAPI People. PR #4274 by @github-actions[bot].

0.70.0Â¶

This release just upgrades Starlette to the latest version, 0.16.0, which includes several bug fixes and some small breaking changes.

These last three consecutive releases are independent so that you can migrate gradually:

    First to FastAPI 0.68.2, with no breaking changes, but upgrading all the sub-dependencies.
    Next to FastAPI 0.69.0, which upgrades Starlette to 0.15.0, with AnyIO support, and a higher chance of having breaking changes in your code.
    Finally to FastAPI 0.70.0, just upgrading Starlette to the latest version 0.16.0 with additional bug fixes.

This way, in case there was a breaking change for your code in one of the releases, you can still benefit from the previous upgrades. âœ¨
Breaking Changes - UpgradeÂ¶

    â¬†ï¸ Upgrade Starlette to 0.16.0. PR #4016 by @tiangolo.

Also upgrades the ranges of optional dependencies:

    "jinja2 >=2.11.2,<4.0.0"
    "itsdangerous >=1.1.0,<3.0.0"

0.69.0Â¶
Breaking Changes - UpgradeÂ¶

This release adds support for Trio. âœ¨

It upgrades the version of Starlette to 0.15.0, now based on AnyIO, and the internal async components in FastAPI are now based on AnyIO as well, making it compatible with both asyncio and Trio.

You can read the docs about running FastAPI with Trio using Hypercorn.

This release also removes graphene as an optional dependency for GraphQL. If you need to work with GraphQL, the recommended library now is Strawberry. You can read the new FastAPI with GraphQL docs.
FeaturesÂ¶

    âœ¨ Add support for Trio via AnyIO, upgrading Starlette to 0.15.0. PR #3372 by @graingert.
    â– Remove graphene as an optional dependency. PR #4007 by @tiangolo.

DocsÂ¶

    ğŸ“ Add docs for using Trio with Hypercorn. PR #4014 by @tiangolo.
    âœ Fix typos in Deployment Guide. PR #3975 by @ghandic.
    ğŸ“ Update docs with pip install calls when using extras with brackets, use quotes for compatibility with Zsh. PR #3131 by @tomwei7.
    ğŸ“ Add external link to article: Deploying ML Models as API Using FastAPI and Heroku. PR #3904 by @kaustubhgupta.
    âœ Fix typo in file paths in docs/en/docs/contributing.md. PR #3752 by @NinaHwang.
    âœ Fix a typo in docs/en/docs/advanced/path-operation-advanced-configuration.md and docs/en/docs/release-notes.md. PR #3750 by @saintmalik.
    âœï¸ Add a missing comma in the security tutorial. PR #3564 by @jalvaradosegura.
    âœ Fix typo in docs/en/docs/help-fastapi.md. PR #3760 by @jaystone776.
    âœ Fix typo about file path in docs/en/docs/tutorial/bigger-applications.md. PR #3285 by @HolyDorus.
    âœ Re-word to clarify test client in docs/en/docs/tutorial/testing.md. PR #3382 by @Bharat123rox.
    ğŸ“ Fix incorrect highlighted code. PR #3325 by @paxcodes.
    ğŸ“ Add external link to article: How-to deploy FastAPI app to Heroku. PR #3241 by @Jarmos-san.
    âœ Fix typo (mistranslation) in docs/en/docs/advanced/templates.md. PR #3211 by @oerpli.
    ğŸ“ Remove note about (now supported) feature from Swagger UI in docs/en/docs/tutorial/request-files.md. PR #2803 by @gsganden.
    âœ Fix typo re-word in docs/tutorial/handling-errors.md. PR #2700 by @graue70.

TranslationsÂ¶

    ğŸŒ Initialize Azerbaijani translations. PR #3941 by @madatbay.
    ğŸŒ Add Turkish translation for docs/fastapi-people.md. PR #3848 by @BilalAlpaslan.

InternalÂ¶

    ğŸ“ Add supported Python versions badge. PR #2794 by @hramezani.
    âœ Fix link in Japanese docs for docs/ja/docs/deployment/docker.md. PR #3245 by @utamori.
    ğŸ”§ Correct DeprecationWarning config and comment in pytest settings. PR #4008 by @graingert.
    ğŸ”§ Swap light/dark theme button icon. PR #3246 by @eddsalkield.
    ğŸ”§ Lint only in Python 3.7 and above. PR #4006 by @tiangolo.
    ğŸ”§ Add GitHub Action notify-translations config for Azerbaijani. PR #3995 by @tiangolo.

0.68.2Â¶

This release has no breaking changes. ğŸ‰

It upgrades the version ranges of sub-dependencies to allow applications using FastAPI to easily upgrade them.

Soon there will be a new FastAPI release upgrading Starlette to take advantage of recent improvements, but as that has a higher chance of having breaking changes, it will be in a separate release.
FeaturesÂ¶

    â¬†Increase supported version of aiofiles to suppress warnings. PR #2899 by @SnkSynthesis.
    â– Do not require backports in Python >= 3.7. PR #1880 by @FFY00.
    â¬† Upgrade required Python version to >= 3.6.1, needed by typing.Deque, used by Pydantic. PR #2733 by @hukkin.
    â¬†ï¸ Bump Uvicorn max range to 0.15.0. PR #3345 by @Kludex.

DocsÂ¶

    ğŸ“ Update GraphQL docs, recommend Strawberry. PR #3981 by @tiangolo.
    ğŸ“ Re-write and extend Deployment guide: Concepts, Uvicorn, Gunicorn, Docker, Containers, Kubernetes. PR #3974 by @tiangolo.
    ğŸ“ Upgrade HTTPS guide with more explanations and diagrams. PR #3950 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Add Turkish translation for docs/features.md. PR #1950 by @ycd.
    ğŸŒ Add Turkish translation for docs/benchmarks.md. PR #2729 by @Telomeraz.
    ğŸŒ Add Turkish translation for docs/index.md. PR #1908 by @ycd.
    ğŸŒ Add French translation for docs/tutorial/body.md. PR #3671 by @Smlep.
    ğŸŒ Add French translation for deployment/docker.md. PR #3694 by @rjNemo.
    ğŸŒ Add Portuguese translation for docs/tutorial/path-params.md. PR #3664 by @FelipeSilva93.
    ğŸŒ Add Portuguese translation for docs/deployment/https.md. PR #3754 by @lsglucas.
    ğŸŒ Add German translation for docs/features.md. PR #3699 by @mawassk.

InternalÂ¶

    âœ¨ Update GitHub Action: notify-translations, to avoid a race conditions. PR #3989 by @tiangolo.
    â¬†ï¸ Upgrade development autoflake, supporting multi-line imports. PR #3988 by @tiangolo.
    â¬†ï¸ Increase dependency ranges for tests and docs: pytest-cov, pytest-asyncio, black, httpx, sqlalchemy, databases, mkdocs-markdownextradata-plugin. PR #3987 by @tiangolo.
    ğŸ‘¥ Update FastAPI People. PR #3986 by @github-actions[bot].
    ğŸ’š Fix badges in README and main page. PR #3979 by @ghandic.
    â¬† Upgrade internal testing dependencies: mypy to version 0.910, add newly needed type packages. PR #3350 by @ArcLightSlavik.
    âœ¨ Add Deepset Sponsorship. PR #3976 by @tiangolo.
    ğŸ¨ Tweak CSS styles for shell animations. PR #3888 by @tiangolo.
    ğŸ”§ Add new Sponsor Calmcode.io. PR #3777 by @tiangolo.

0.68.1Â¶

    âœ¨ Add support for read_with_orm_mode, to support SQLModel relationship attributes. PR #3757 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Add Portuguese translation of docs/fastapi-people.md. PR #3461 by @ComicShrimp.
    ğŸŒ Add Chinese translation for docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md. PR #3492 by @jaystone776.
    ğŸ”§ Add new Translation tracking issues for German and Indonesian. PR #3718 by @tiangolo.
    ğŸŒ Add Chinese translation for docs/tutorial/dependencies/sub-dependencies.md. PR #3491 by @jaystone776.
    ğŸŒ Add Portuguese translation for docs/advanced/index.md. PR #3460 by @ComicShrimp.
    ğŸŒ Portuguese translation of docs/async.md. PR #1330 by @Serrones.
    ğŸŒ Add French translation for docs/async.md. PR #3416 by @Smlep.

InternalÂ¶

    âœ¨ Add GitHub Action: Notify Translations. PR #3715 by @tiangolo.
    âœ¨ Update computation of FastAPI People and sponsors. PR #3714 by @tiangolo.
    âœ¨ Enable recent Material for MkDocs Insiders features. PR #3710 by @tiangolo.
    ğŸ”¥ Remove/clean extra imports from examples in docs for features. PR #3709 by @tiangolo.
    â• Update docs library to include sources in Markdown. PR #3648 by @tiangolo.
    â¬† Enable tests for Python 3.9. PR #2298 by @Kludex.
    ğŸ‘¥ Update FastAPI People. PR #3642 by @github-actions[bot].

0.68.0Â¶
FeaturesÂ¶

    âœ¨ Add support for extensions and updates to the OpenAPI schema in each path operation. New docs: FastAPI Path Operation Advanced Configuration - OpenAPI Extra. Initial PR #1922 by @edouardlp.
    âœ¨ Add additional OpenAPI metadata parameters to FastAPI class, shown on the automatic API docs UI. New docs: Metadata and Docs URLs. Initial PR #1812 by @dkreeft.
    âœ¨ Add description parameter to all the security scheme classes, e.g. APIKeyQuery(name="key", description="A very cool API key"). PR #1757 by @hylkepostma.
    âœ¨ Update OpenAPI models, supporting recursive models and extensions. PR #3628 by @tiangolo.
    âœ¨ Import and re-export data structures from Starlette, used by Request properties, on fastapi.datastructures. Initial PR #1872 by @jamescurtin.

DocsÂ¶

    ğŸ“ Update docs about async and response-model with more gender neutral language. PR #1869 by @Edward-Knight.

TranslationsÂ¶

    ğŸŒ Add Russian translation for docs/python-types.md. PR #3039 by @dukkee.
    ğŸŒ Add Chinese translation for docs/tutorial/dependencies/index.md. PR #3489 by @jaystone776.
    ğŸŒ Add Russian translation for docs/external-links.md. PR #3036 by @dukkee.
    ğŸŒ Add Chinese translation for docs/tutorial/dependencies/global-dependencies.md. PR #3493 by @jaystone776.
    ğŸŒ Add Portuguese translation for docs/deployment/versions.md. PR #3618 by @lsglucas.
    ğŸŒ Add Japanese translation for docs/tutorial/security/oauth2-jwt.md. PR #3526 by @sattosan.

InternalÂ¶

    âœ… Add the docs_src directory to test coverage and update tests. Initial PR #1904 by @Kludex.
    ğŸ”§ Add new GitHub templates with forms for new issues. PR #3612 by @tiangolo.
    ğŸ“ Add official FastAPI Twitter to docs: @fastapi. PR #3578 by @tiangolo.

0.67.0Â¶
FeaturesÂ¶

    âœ¨ Add support for dataclasses in request bodies and response_model. New documentation: Advanced User Guide - Using Dataclasses. PR #3577 by @tiangolo.
    âœ¨ Support dataclasses in responses. PR #3576 by @tiangolo, continuation from initial PR #2722 by @amitlissack.

DocsÂ¶

    ğŸ“ Add external link: How to Create A Fake Certificate Authority And Generate TLS Certs for FastAPI. PR #2839 by @aitoehigie.
    âœ Fix code highlighted line in: body-nested-models.md. PR #3463 by @jaystone776.
    âœ Fix typo in body-nested-models.md. PR #3462 by @jaystone776.
    âœ Fix typo "might me" -> "might be" in docs/en/docs/tutorial/schema-extra-example.md. PR #3362 by @dbrakman.
    ğŸ“ Add external link: Building simple E-Commerce with NuxtJS and FastAPI. PR #3271 by @ShahriyarR.
    ğŸ“ Add external link: Serve a machine learning model using Sklearn, FastAPI and Docker. PR #2974 by @rodrigo-arenas.
    âœï¸ Fix typo on docstring in datastructures file. PR #2887 by @Kludex.
    ğŸ“ Add External Link: Deploy FastAPI on Ubuntu and Serve using Caddy 2 Web Server. PR #3572 by @tiangolo.
    ğŸ“ Add External Link, replaces #1898. PR #3571 by @tiangolo.

InternalÂ¶

    ğŸ¨ Improve style for sponsors, add radius border. PR #2388 by @Kludex.
    ğŸ‘· Update GitHub Action latest-changes. PR #3574 by @tiangolo.
    ğŸ‘· Update GitHub Action latest-changes. PR #3573 by @tiangolo.
    ğŸ‘· Rename and clarify CI workflow job names. PR #3570 by @tiangolo.
    ğŸ‘· Update GitHub Action latest-changes, strike 2 âš¾. PR #3575 by @tiangolo.
    ğŸ”§ Sort external links in docs to have the most recent at the top. PR #3568 by @tiangolo.

0.66.1Â¶
TranslationsÂ¶

    ğŸŒ Add basic setup for German translations. PR #3522 by @0x4Dark.
    ğŸŒ Add Portuguese translation for docs/tutorial/security/index.md. PR #3507 by @oandersonmagalhaes.
    ğŸŒ Add Portuguese translation for docs/deployment/index.md. PR #3337 by @lsglucas.

InternalÂ¶

    ğŸ”§ Configure strict pytest options and update/refactor tests. Upgrade pytest to >=6.2.4,<7.0.0 and pytest-cov to >=2.12.0,<3.0.0. Initial PR #2790 by @graingert.
    â¬†ï¸ Upgrade python-jose dependency to >=3.3.0,<4.0.0 for tests. PR #3468 by @tiangolo.

0.66.0Â¶
FeaturesÂ¶

    âœ¨ Allow setting the response_class to RedirectResponse or FileResponse and returning the URL from the function. New and updated docs are in the tutorial section Custom Response - HTML, Stream, File, others, in RedirectResponse and in FileResponse. PR #3457 by @tiangolo.

FixesÂ¶

    ğŸ› Fix include/exclude for dicts in jsonable_encoder. PR #2016 by @Rubikoid.
    ğŸ› Support custom OpenAPI / JSON Schema fields in the generated output OpenAPI. PR #1429 by @jmagnusson.

TranslationsÂ¶

    ğŸŒ Add Spanish translation for tutorial/query-params.md. PR #2243 by @mariacamilagl.
    ğŸŒ Add Spanish translation for advanced/response-directly.md. PR #1253 by @jfunez.
    ğŸŒ Add Spanish translation for advanced/additional-status-codes.md. PR #1252 by @jfunez.
    ğŸŒ Add Spanish translation for advanced/path-operation-advanced-configuration.md. PR #1251 by @jfunez.

0.65.3Â¶
FixesÂ¶

    â™» Assume request bodies contain JSON when no Content-Type header is provided. This fixes a breaking change introduced by 0.65.2 with PR #2118. It should allow upgrading FastAPI applications with clients that send JSON data without a Content-Type header. And there's still protection against CSRFs. PR #3456 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Initialize Indonesian translations. PR #3014 by @pace-noge.
    ğŸŒ Add Spanish translation of Tutorial - Path Parameters. PR #2219 by @mariacamilagl.
    ğŸŒ Add Spanish translation of Tutorial - First Steps. PR #2208 by @mariacamilagl.
    ğŸŒ Portuguese translation of Tutorial - Body - Fields. PR #3420 by @ComicShrimp.
    ğŸŒ Add Chinese translation for Tutorial - Request - Forms - and - Files. PR #3249 by @jaystone776.
    ğŸŒ Add Chinese translation for Tutorial - Handling - Errors. PR #3299 by @jaystone776.
    ğŸŒ Add Chinese translation for Tutorial - Form - Data. PR #3248 by @jaystone776.
    ğŸŒ Add Chinese translation for Tutorial - Body - Updates. PR #3237 by @jaystone776.
    ğŸŒ Add Chinese translation for FastAPI People. PR #3112 by @hareru.
    ğŸŒ Add French translation for Project Generation. PR #3197 by @Smlep.
    ğŸŒ Add French translation for Python Types Intro. PR #3185 by @Smlep.
    ğŸŒ Add French translation for External Links. PR #3103 by @Smlep.
    ğŸŒ Add French translation for Alternatives, Inspiration and Comparisons. PR #3020 by @rjNemo.
    ğŸŒ Fix Chinese translation code snippet mismatch in Tutorial - Python Types Intro. PR #2573 by @BoYanZh.
    ğŸŒ Add Portuguese translation for Development Contributing. PR #1364 by @Serrones.
    ğŸŒ Add Chinese translation for Tutorial - Request - Files. PR #3244 by @jaystone776.

InternalÂ¶

    ğŸ‘¥ Update FastAPI People. PR #3450 by @github-actions[bot].
    ğŸ‘¥ Update FastAPI People. PR #3319 by @github-actions[bot].
    â¬† Upgrade docs development dependency on typer-cli to >=0.0.12 to fix conflicts. PR #3429 by @tiangolo.

0.65.2Â¶
Security fixesÂ¶

    ğŸ”’ Check Content-Type request header before assuming JSON. Initial PR #2118 by @patrickkwang.

This change fixes a CSRF security vulnerability when using cookies for authentication in path operations with JSON payloads sent by browsers.

In versions lower than 0.65.2, FastAPI would try to read the request payload as JSON even if the content-type header sent was not set to application/json or a compatible JSON media type (e.g. application/geo+json).

So, a request with a content type of text/plain containing JSON data would be accepted and the JSON data would be extracted.

But requests with content type text/plain are exempt from CORS preflights, for being considered Simple requests. So, the browser would execute them right away including cookies, and the text content could be a JSON string that would be parsed and accepted by the FastAPI application.

See CVE-2021-32677 for more details.

Thanks to Dima Boger for the security report! ğŸ™‡ğŸ”’
InternalÂ¶

    ğŸ”§ Update sponsors badge, course bundle. PR #3340 by @tiangolo.
    ğŸ”§ Add new gold sponsor Jina ğŸ‰. PR #3291 by @tiangolo.
    ğŸ”§ Add new banner sponsor badge for FastAPI courses bundle. PR #3288 by @tiangolo.
    ğŸ‘· Upgrade Issue Manager GitHub Action. PR #3236 by @tiangolo.

0.65.1Â¶
Security fixesÂ¶

    ğŸ“Œ Upgrade pydantic pin, to handle security vulnerability CVE-2021-29510. PR #3213 by @tiangolo.

0.65.0Â¶
Breaking Changes - UpgradeÂ¶

    â¬†ï¸ Upgrade Starlette to 0.14.2, including internal UJSONResponse migrated from Starlette. This includes several bug fixes and features from Starlette. PR #2335 by @hanneskuettner.

TranslationsÂ¶

    ğŸŒ Initialize new language Polish for translations. PR #3170 by @neternefer.

InternalÂ¶

    ğŸ‘· Add GitHub Action cache to speed up CI installs. PR #3204 by @tiangolo.
    â¬†ï¸ Upgrade setup-python GitHub Action to v2. PR #3203 by @tiangolo.
    ğŸ› Fix docs script to generate a new translation language with overrides boilerplate. PR #3202 by @tiangolo.
    âœ¨ Add new Deta banner badge with new sponsorship tier ğŸ™‡. PR #3194 by @tiangolo.
    ğŸ‘¥ Update FastAPI People. PR #3189 by @github-actions[bot].
    ğŸ”Š Update FastAPI People to allow better debugging. PR #3188 by @tiangolo.

0.64.0Â¶
FeaturesÂ¶

    âœ¨ Add support for adding multiple examples in request bodies and path, query, cookie, and header params. New docs: Declare Request Example Data. Initial PR #1267 by @austinorr.

FixesÂ¶

    ğŸ“Œ Pin SQLAlchemy range for tests, as it doesn't use SemVer. PR #3001 by @tiangolo.
    ğŸ¨ Add newly required type annotations for mypy. PR #2882 by @tiangolo.
    ğŸ¨ Remove internal "type: ignore", now unnecessary. PR #2424 by @AsakuraMizu.

DocsÂ¶

    ğŸ“ Add link to article in Russian "FastAPI: Ğ·Ğ½Ğ°ĞºĞ¾Ğ¼Ğ¸Ğ¼ÑÑ Ñ Ñ„Ñ€ĞµĞ¹Ğ¼Ğ²Ğ¾Ñ€ĞºĞ¾Ğ¼". PR #2564 by @trkohler.
    ğŸ“ Add external link to blog post "Authenticate Your FastAPI App with Auth0". PR #2172 by @dompatmore.
    ğŸ“ Fix broken link to article: Machine learning model serving in Python using FastAPI and Streamlit. PR #2557 by @davidefiocco.
    ğŸ“ Add FastAPI Medium Article: Deploy a dockerized FastAPI application to AWS. PR #2515 by @vjanz.
    âœ Fix typo in Tutorial - Handling Errors. PR #2486 by @johnthagen.
    âœ Fix typo in Security OAuth2 scopes. PR #2407 by @jugmac00.
    âœ Fix typo/clarify docs for SQL (Relational) Databases. PR #2393 by @kangni.
    ğŸ“ Add external link to "FastAPI for Flask Users". PR #2280 by @amitness.

TranslationsÂ¶

    ğŸŒ Fix Chinese translation of Tutorial - Query Parameters, remove obsolete content. PR #3051 by @louis70109.
    ğŸŒ Add French translation for Tutorial - Background Tasks. PR #3098 by @Smlep.
    ğŸŒ Fix Korean translation for docs/ko/docs/index.md. PR #3159 by @SueNaEunYang.
    ğŸŒ Add Korean translation for Tutorial - Query Parameters. PR #2390 by @hard-coders.
    ğŸŒ Add French translation for FastAPI People. PR #2232 by @JulianMaurin.
    ğŸŒ Add Korean translation for Tutorial - Path Parameters. PR #2355 by @hard-coders.
    ğŸŒ Add French translation for Features. PR #2157 by @Jefidev.
    ğŸ‘¥ Update FastAPI People. PR #3031 by @github-actions[bot].
    ğŸŒ Add Chinese translation for Tutorial - Debugging. PR #2737 by @blt232018.
    ğŸŒ Add Chinese translation for Tutorial - Security - OAuth2 with Password (and hashing), Bearer with JWT tokens. PR #2642 by @waynerv.
    ğŸŒ Add Korean translation for Tutorial - Header Parameters. PR #2589 by @mode9.
    ğŸŒ Add Chinese translation for Tutorial - Metadata and Docs URLs. PR #2559 by @blt232018.
    ğŸŒ Add Korean translation for Tutorial - First Steps. PR #2323 by @hard-coders.
    ğŸŒ Add Chinese translation for Tutorial - CORS (Cross-Origin Resource Sharing). PR #2540 by @blt232018.
    ğŸŒ Add Chinese translation for Tutorial - Middleware. PR #2334 by @lpdswing.
    ğŸŒ Add Korean translation for Tutorial - Intro. PR #2317 by @hard-coders.
    ğŸŒ Add Chinese translation for Tutorial - Bigger Applications - Multiple Files. PR #2453 by @waynerv.
    ğŸŒ Add Chinese translation for Tutorial - Security - Security Intro. PR #2443 by @waynerv.
    ğŸŒ Add Chinese translation for Tutorial - Header Parameters. PR #2412 by @maoyibo.
    ğŸŒ Add Chinese translation for Tutorial - Extra Data Types. PR #2410 by @maoyibo.
    ğŸŒ Add Japanese translation for Deployment - Docker. PR #2312 by @tokusumi.
    ğŸŒ Add Japanese translation for Deployment - Versions. PR #2310 by @tokusumi.
    ğŸŒ Add Chinese translation for Tutorial - Cookie Parameters. PR #2261 by @alicrazy1947.
    ğŸŒ Add Japanese translation for Tutorial - Static files. PR #2260 by @tokusumi.
    ğŸŒ Add Japanese translation for Tutorial - Testing. PR #2259 by @tokusumi.
    ğŸŒ Add Japanese translation for Tutorial - Debugging. PR #2256 by @tokusumi.
    ğŸŒ Add Japanese translation for Tutorial - Middleware. PR #2255 by @tokusumi.
    ğŸŒ Add Japanese translation for Concurrency and async / await. PR #2058 by @tokusumi.
    ğŸŒ Add Chinese translation for Tutorial - Security - Simple OAuth2 with Password and Bearer. PR #2514 by @waynerv.
    ğŸŒ Add Japanese translation for Deployment - Deta. PR #2314 by @tokusumi.
    ğŸŒ Add Chinese translation for Tutorial - Security - Get Current User. PR #2474 by @waynerv.
    ğŸŒ Add Japanese translation for Deployment - Manually. PR #2313 by @tokusumi.
    ğŸŒ Add Japanese translation for Deployment - Intro. PR #2309 by @tokusumi.
    ğŸŒ Add Japanese translation for FastAPI People. PR #2254 by @tokusumi.
    ğŸŒ Add Japanese translation for Advanced - Path Operation Advanced Configuration. PR #2124 by @Attsun1031.
    ğŸŒ Add Japanese translation for External Links. PR #2070 by @tokusumi.
    ğŸŒ Add Japanese translation for Tutorial - Body - Updates. PR #1956 by @SwftAlpc.
    ğŸŒ Add Japanese translation for Tutorial - Form Data. PR #1943 by @SwftAlpc.
    ğŸŒ Add Japanese translation for Tutorial - Cookie Parameters. PR #1933 by @SwftAlpc.

InternalÂ¶

    ğŸ”§ Update top banner, point to newsletter. PR #3003 by @tiangolo.
    ğŸ”§ Disable sponsor WeTransfer. PR #3002 by @tiangolo.
    ğŸ‘¥ Update FastAPI People. PR #2880 by @github-actions[bot].
    ğŸ‘¥ Update FastAPI People. PR #2739 by @github-actions[bot].
    ğŸ”§ Add new Gold Sponsor Talk Python ğŸ‰. PR #2673 by @tiangolo.
    ğŸ”§ Add new Gold Sponsor vim.so ğŸ‰. PR #2669 by @tiangolo.
    ğŸ”§ Add FastAPI user survey banner. PR #2623 by @tiangolo.
    ğŸ”§ Add new Bronze Sponsor(s) ğŸ¥‰ğŸ‰. PR #2622 by @tiangolo.
    ğŸ“ Update social links: add Discord, fix GitHub. PR #2621 by @tiangolo.
    ğŸ”§ Update FastAPI People GitHub Sponsors order. PR #2620 by @tiangolo.
    ğŸ”§ Update InvestSuite sponsor data. PR #2608 by @tiangolo.
    ğŸ‘¥ Update FastAPI People. PR #2590 by @github-actions[bot].

0.63.0Â¶
FeaturesÂ¶

    âœ¨ Improve type annotations, add support for mypy --strict, internally and for external packages. PR #2547 by @tiangolo.

Breaking changesÂ¶

    â¬†ï¸ Upgrade Uvicorn when installing fastapi[all] to the latest version including uvloop, the new range is uvicorn[standard] >=0.12.0,<0.14.0. PR #2548 by @tiangolo.

FixesÂ¶

    ğŸ› PR #2547 (read above) also fixes some false-positive mypy errors with callbacks parameters and when using the OAuth2 class.

DocsÂ¶

    ğŸ“ Update Uvicorn installation instructions to use uvicorn[standard] (includes uvloop). PR #2543 by @tiangolo.
    ğŸ“ Update title for Deta tutorial. PR #2466 by @tiangolo.
    ğŸ‘¥ Update FastAPI People. PR #2454 by @github-actions[bot].

TranslationsÂ¶

    ğŸŒ Add docs lang selector widget. PR #2542 by @tiangolo.
    ğŸŒ Add Chinese translation for Tutorial - Response Status Code. PR #2442 by @waynerv.
    ğŸŒ Start translation of the documentation for the Albanian language. PR #2516 by @vjanz.
    ğŸŒ Add Chinese translation for Tutorial - Extra Models. PR #2416 by @waynerv.
    ğŸŒ Add Chinese translation for Tutorial - Response Model. PR #2414 by @waynerv.
    ğŸŒ Add Chinese translation for Tutorial - Schema Extra Example. PR #2411 by @maoyibo.
    ğŸŒ Add Korean translation for Index. PR #2192 by @hard-coders.
    ğŸŒ Add Japanese translation for Advanced User Guide - Additional Status Codes. PR #2145 by @Attsun1031.

InternalÂ¶

    ğŸ› Fix docs overrides directory for translations. PR #2541 by @tiangolo.
    â– Remove Typer as a docs building dependency (covered by typer-cli) to fix pip resolver conflicts. PR #2539 by @tiangolo.
    âœ¨ Add newsletter: FastAPI and friends. PR #2509 by @tiangolo.
    âœ¨ Add new Gold Sponsor: InvestSuite ğŸ‰. PR #2508 by @tiangolo.
    ğŸ”§ Add issue template configs. PR #2476 by @tiangolo.

0.62.0Â¶
FeaturesÂ¶

    âœ¨ Add support for shared/top-level parameters (dependencies, tags, etc). PR #2434 by @tiangolo.

Up to now, for several options, the only way to apply them to a group of path operations was in include_router. That works well, but the call to app.include_router() or router.include_router() is normally done in another file.

That means that, for example, to apply authentication to all the path operations in a router it would end up being done in a different file, instead of keeping related logic together.

Setting options in include_router still makes sense in some cases, for example, to override or increase configurations from a third party router included in an app. But in a router that is part of a bigger application, it would probably make more sense to add those settings when creating the APIRouter.

In FastAPI

This allows setting the (mostly new) parameters (additionally to the already existing parameters):

    default_response_class: updated to handle defaults in APIRouter and include_router.
    dependencies: to include âœ¨ top-level dependencies âœ¨ that apply to the whole application. E.g. to add global authentication.
    callbacks: OpenAPI callbacks that apply to all the path operations.
    deprecated: to mark all the path operations as deprecated. ğŸ¤·
    include_in_schema: to allow excluding all the path operations from the OpenAPI schema.
    responses: OpenAPI responses that apply to all the path operations.

For example:

from fastapi import FastAPI, Depends


async def some_dependency():
    return


app = FastAPI(dependencies=[Depends(some_dependency)])

In APIRouter

This allows setting the (mostly new) parameters (additionally to the already existing parameters):

    default_response_class: updated to handle defaults in APIRouter and include_router. For example, it's not needed to set it explicitly when creating callbacks.
    dependencies: to include âœ¨ router-level dependencies âœ¨ that apply to all the path operations in a router. Up to now, this was only possible with include_router.
    callbacks: OpenAPI callbacks that apply to all the path operations in this router.
    deprecated: to mark all the path operations in a router as deprecated.
    include_in_schema: to allow excluding all the path operations in a router from the OpenAPI schema.
    responses: OpenAPI responses that apply to all the path operations in a router.
    prefix: to set the path prefix for a router. Up to now, this was only possible when calling include_router.
    tags: OpenAPI tags to apply to all the path operations in this router.

For example:

from fastapi import APIRouter, Depends


async def some_dependency():
    return


router = APIRouter(prefix="/users", dependencies=[Depends(some_dependency)])

In include_router

Most of these settings are now supported in APIRouter, which normally lives closer to the related code, so it is recommended to use APIRouter when possible.

But include_router is still useful to, for example, adding options (like dependencies, prefix, and tags) when including a third party router, or a generic router that is shared between several projects.

This PR allows setting the (mostly new) parameters (additionally to the already existing parameters):

    default_response_class: updated to handle defaults in APIRouter and FastAPI.
    deprecated: to mark all the path operations in a router as deprecated in OpenAPI.
    include_in_schema: to allow disabling all the path operations from showing in the OpenAPI schema.
    callbacks: OpenAPI callbacks that apply to all the path operations in this router.

Note: all the previous parameters are still there, so it's still possible to declare dependencies in include_router.
Breaking ChangesÂ¶

    PR #2434 includes several improvements that shouldn't affect normal use cases, but could affect in advanced scenarios:
        If you are testing the generated OpenAPI (you shouldn't, FastAPI already tests it extensively for you): the order for tags in include_router and path operations was updated for consistency, but it's a simple order change.
        If you have advanced custom logic to access each route's route.response_class, or the router.default_response_class, or the app.default_response_class: the default value for response_class in APIRoute and for default_response_class in APIRouter and FastAPI is now a DefaultPlaceholder used internally to handle and solve default values and overrides. The actual response class inside the DefaultPlaceholder is available at route.response_class.value.

DocsÂ¶

    PR #2434 (above) includes new or updated docs:
        Advanced User Guide - OpenAPI Callbacks.
        Tutorial - Bigger Applications.
        Tutorial - Dependencies - Dependencies in path operation decorators.
        Tutorial - Dependencies - Global Dependencies.

    ğŸ“ Add FastAPI monitoring blog post to External Links. PR #2324 by @louisguitton.
    âœï¸ Fix typo in Deta tutorial. PR #2320 by @tiangolo.
    âœ¨ Add Discord chat. PR #2322 by @tiangolo.
    ğŸ“ Fix image links for sponsors. PR #2304 by @tiangolo.

TranslationsÂ¶

    ğŸŒ Add Japanese translation for Advanced - Custom Response. PR #2193 by @Attsun1031.
    ğŸŒ Add Chinese translation for Benchmarks. PR #2119 by @spaceack.
    ğŸŒ Add Chinese translation for Tutorial - Body - Nested Models. PR #1609 by @waynerv.
    ğŸŒ Add Chinese translation for Advanced - Custom Response. PR #1459 by @RunningIkkyu.
    ğŸŒ Add Chinese translation for Advanced - Return a Response Directly. PR #1452 by @RunningIkkyu.
    ğŸŒ Add Chinese translation for Advanced - Additional Status Codes. PR #1451 by @RunningIkkyu.
    ğŸŒ Add Chinese translation for Advanced - Path Operation Advanced Configuration. PR #1447 by @RunningIkkyu.
    ğŸŒ Add Chinese translation for Advanced User Guide - Intro. PR #1445 by @RunningIkkyu.

InternalÂ¶

    ğŸ”§ Update TestDriven link to course in sponsors section. PR #2435 by @tiangolo.
    ğŸ± Update sponsor logos. PR #2418 by @tiangolo.
    ğŸ’š Fix disabling install of Material for MkDocs Insiders in forks, strike 1 âš¾. PR #2340 by @tiangolo.
    ğŸ› Fix disabling Material for MkDocs Insiders install in forks. PR #2339 by @tiangolo.
    âœ¨ Add silver sponsor WeTransfer. PR #2338 by @tiangolo.
    âœ¨ Set up and enable Material for MkDocs Insiders for the docs. PR #2325 by @tiangolo.

0.61.2Â¶
FixesÂ¶

    ğŸ“Œ Relax Swagger UI version pin. PR #2089 by @jmriebold.
    ğŸ› Fix bug overriding custom HTTPException and RequestValidationError from exception_handlers. PR #1924 by @uriyyo.
    âœï¸ Fix typo on dependencies utils and cleanup unused variable. PR #1912 by @Kludex.

DocsÂ¶

    âœï¸ Fix typo in Tutorial - Path Parameters. PR #2231 by @mariacamilagl.
    âœ Fix a stylistic error in docs. PR #2206 by @ddobrinskiy.
    âœ Fix capitalizaiton typo in docs. PR #2204 by @imba-tjd.
    âœ Fix typo in docs. PR #2179 by @ammarasmro.
    ğŸ“ Update/fix links in docs to use HTTPS. PR #2165 by @imba-tjd.
    âœ Fix typos and add rewording in docs. PR #2159 by @nukopy.
    ğŸ“ Fix code consistency in examples for Tutorial - User Guide - Path Parameters. PR #2158 by @nukopy.
    ğŸ“ Fix renamed parameter content_type typo. PR #2135 by @TeoZosa.
    âœ Fix minor typos in docs. PR #2122 by @TeoZosa.
    âœ Fix typos in docs and source examples. PR #2102 by @AdrianDeAnda.
    âœ Fix incorrect Celery URLs in docs. PR #2100 by @CircleOnCircles.
    ğŸ“ Simplify intro to Python Types, all currently supported Python versions include type hints ğŸ‰. PR #2085 by @ninjaaron.
    ğŸ“ Fix example code with sets in Tutorial - Body - Nested Models 3. PR #2054 by @hitrust.
    ğŸ“ Fix example code with sets in Tutorial - Body - Nested Models 2. PR #2053 by @hitrust.
    ğŸ“ Fix example code with sets in Tutorial - Body - Nested Models. PR #2052 by @hitrust.
    âœ Fix typo in Benchmarks. PR #1995 by @AlejoAsd.
    ğŸ“ Add note in CORS tutorial about allow_origins with ["*"] and allow_credentials. PR #1895 by @dsmurrell.
    ğŸ“ Add deployment to Deta, the first gold sponsor ğŸ‰. PR #2303 by @tiangolo.
    ğŸ‘¥ Update FastAPI People. PR #2282 by @github-actions[bot].
    âœï¸ Fix uppercase in Tutorial - Query parameters. PR #2245 by @mariacamilagl.
    ğŸ“ Add articles to External Links. PR #2247 by @tiangolo.
    âœ Fix typo in Spanish tutorial index. PR #2020 by @aviloncho.

TranslationsÂ¶

    ğŸŒ Add Japanese translation for Advanced Tutorial - Response Directly. PR #2191 by @Attsun1031.
    ğŸ“ Add Japanese translation for Tutorial - Security - First Steps. PR #2153 by @komtaki.
    ğŸŒ Add Japanese translation for Tutorial - Query Parameters and String Validations. PR #1901 by @SwftAlpc.
    ğŸŒ Add Portuguese translation for External Links. PR #1443 by @Serrones.
    ğŸŒ Add Japanese translation for Tutorial - CORS. PR #2125 by @tokusumi.
    ğŸŒ Add Japanese translation for Contributing. PR #2067 by @komtaki.
    ğŸŒ Add Japanese translation for Project Generation. PR #2050 by @tokusumi.
    ğŸŒ Add Japanese translation for Alternatives. PR #2043 by @Attsun1031.
    ğŸŒ Add Japanese translation for History Design and Future. PR #2002 by @komtaki.
    ğŸŒ Add Japanese translation for Benchmarks. PR #1992 by @komtaki.
    ğŸŒ Add Japanese translation for Tutorial - Header Parameters. PR #1935 by @SwftAlpc.
    ğŸŒ Add Portuguese translation for Tutorial - First Steps. PR #1861 by @jessicapaz.
    ğŸŒ Add Portuguese translation for Python Types. PR #1796 by @izaguerreiro.
    ğŸŒ Add Japanese translation for Help FastAPI. PR #1692 by @tokusumi.
    ğŸŒ Add Japanese translation for Tutorial - Body. PR #1683 by @tokusumi.
    ğŸŒ Add Japanese translation for Tutorial - Query Params. PR #1674 by @tokusumi.
    ğŸŒ Add Japanese translation for tutorial/path-params.md. PR #1671 by @tokusumi.
    ğŸŒ Add Japanese translation for tutorial/first-steps.md. PR #1658 by @tokusumi.
    ğŸŒ Add Japanese translation for tutorial/index.md. PR #1656 by @tokusumi.
    ğŸŒ Add translation to Portuguese for Project Generation. PR #1602 by @Serrones.
    ğŸŒ Add Japanese translation for Features. PR #1625 by @tokusumi.
    ğŸŒ Initialize new language Korean for translations. PR #2018 by @hard-coders.
    ğŸŒ Add Portuguese translation of Deployment. PR #1374 by @Serrones.

InternalÂ¶

    ğŸ”¥ Cleanup after upgrade for Docs Previews GitHub Action. PR #2248 by @tiangolo.
    ğŸ› Fix CI docs preview, unzip docs. PR #2246 by @tiangolo.
    âœ¨ Add instant docs deploy previews for PRs from forks. PR #2244 by @tiangolo.
    âš¡ï¸ Build docs for languages in parallel in subprocesses to speed up CI. PR #2242 by @tiangolo.
    ğŸ› Fix docs order generation for partial translations. PR #2238 by @tiangolo.
    ğŸ‘¥ Update FastAPI People. PR #2202 by @github-actions[bot].
    â™»ï¸ Update FastAPI People GitHub Action to send the PR as github-actions. PR #2201 by @tiangolo.
    ğŸ”§ Update FastAPI People GitHub Action config, run monthly. PR #2199 by @tiangolo.
    ğŸ› Fix FastAPI People GitHub Action Docker dependency, strike 1 âš¾. PR #2198 by @tiangolo.
    ğŸ› Fix FastAPI People GitHub Action Docker dependencies. PR #2197 by @tiangolo.
    ğŸ› Fix FastAPI People GitHub Action when there's nothing to change. PR #2196 by @tiangolo.
    ğŸ‘¥ Add new section FastAPI People. PR #2195 by @tiangolo.
    â¬†ï¸ Upgrade GitHub Action Latest Changes. PR #2190 by @tiangolo.
    â¬†ï¸ Upgrade GitHub Action Label Approved. PR #2189 by @tiangolo.
    ğŸ”§ Update GitHub Action Label Approved, run at 12:00. PR #2185 by @tiangolo.
    ğŸ‘· Upgrade GitHub Action Latest Changes. PR #2184 by @tiangolo.
    ğŸ‘· Set GitHub Action Label Approved to run daily, not every minute. PR #2163 by @tiangolo.
    ğŸ”¥ Remove pr-approvals GitHub Action as it's not compatible with forks. Use the new one. PR #2162 by @tiangolo.
    ğŸ‘· Add GitHub Action Latest Changes. PR #2160.
    ğŸ‘· Add GitHub Action Label Approved. PR #2161.

0.61.1Â¶
FixesÂ¶

    Fix issues using jsonable_encoder with SQLAlchemy models directly. PR #1987.

DocsÂ¶

    Fix typo in NoSQL docs. PR #1980 by @facundojmaero.

TranslationsÂ¶

    Add translation for main page to Japanese PR #1571 by @ryuckel.
    Initialize French translations. PR #1975 by @JulianMaurin-BM.
    Initialize Turkish translations. PR #1905 by @ycd.

InternalÂ¶

    Improve docs maintainability by updating hl_lines syntax to use ranges. PR #1863 by @la-mar.

0.61.0Â¶
FeaturesÂ¶

    Add support for injecting HTTPConnection (as Request and WebSocket). Useful for sharing app state in dependencies. PR #1827 by @nsidnev.
    Export WebSocketDisconnect and add example handling WebSocket disconnections to docs. PR #1822 by @rkbeatss.

Breaking ChangesÂ¶

    Require Pydantic > 1.0.0.
        Remove support for deprecated Pydantic 0.32.2. This improves maintainability and allows new features.
        In FastAPI and APIRouter:
            Remove path operation decorators related/deprecated parameter response_model_skip_defaults (use response_model_exclude_unset instead).
            Change path operation decorators parameter default for response_model_exclude from set() to None (as is in Pydantic).
        In encoders.jsonable_encoder:
            Remove deprecated skip_defaults, use instead exclude_unset.
            Set default of exclude from set() to None (as is in Pydantic).
        PR #1862.
    In encoders.jsonable_encoder remove parameter sqlalchemy_safe.
        It was an early hack to allow returning SQLAlchemy models, but it was never documented, and the recommended way is using Pydantic's orm_mode as described in the tutorial: SQL (Relational) Databases.
        PR #1864.

DocsÂ¶

    Add link to the course by TestDriven.io: Test-Driven Development with FastAPI and Docker. PR #1860.
    Fix empty log message in docs example about handling errors. PR #1815 by @manlix.
    Reword text to reduce ambiguity while not being gender-specific. PR #1824 by @Mause.

InternalÂ¶

    Add Flake8 linting. Original PR #1774 by @MashhadiNima.
    Disable Gitter bot, as it's currently broken, and Gitter's response doesn't show the problem. PR #1853.

0.60.2Â¶

    Fix typo in docs for query parameters. PR #1832 by @ycd.
    Add docs about Async Tests. PR #1619 by @empicano.
    Raise an exception when using form data (Form, File) without having python-multipart installed.
        Up to now the application would run, and raise an exception only when receiving a request with form data, the new behavior, raising early, will prevent from deploying applications with broken dependencies.
        It also detects if the correct package python-multipart is installed instead of the incorrect multipart (both importable as multipart).
        PR #1851 based on original PR #1627 by @chrisngyn, @YKo20010, @kx-chen.
    Re-enable Gitter releases bot. PR #1831.
    Add link to async SQL databases tutorial from main SQL tutorial. PR #1813 by @short2strings.
    Fix typo in tutorial about behind a proxy. PR #1807 by @toidi.
    Fix typo in Portuguese docs. PR #1795 by @izaguerreiro.
    Add translations setup for Ukrainian. PR #1830.
    Add external link Build And Host Fast Data Science Applications Using FastAPI. PR #1786 by @Kludex.
    Fix encoding of Pydantic models that inherit from others models with custom json_encoders. PR #1769 by @henrybetts.
    Simplify and improve jsonable_encoder. PR #1754 by @MashhadiNima.
    Simplify internal code syntax in several points. PR #1753 by @uriyyo.
    Improve internal typing, declare Optional parameters. PR #1731 by @MashhadiNima.
    Add external link Deploy FastAPI on Azure App Service to docs. PR #1726 by @windson.
    Add link to Starlette docs about WebSocket testing. PR #1717 by @hellocoldworld.
    Refactor generating dependant, merge for loops. PR #1714 by @Bloodielie.
    Update example for templates with Jinja to include HTML media type. PR #1690 by @frafra.
    Fix typos in docs for security. PR #1678 by @nilslindemann.
    Fix typos in docs for dependencies. PR #1675 by @nilslindemann.
    Fix type annotation for **extra parameters in FastAPI. PR #1659 by @bharel.
    Bump MkDocs Material to fix docs in browsers with dark mode. PR #1789 by @adriencaccia.
    Remove docs preview comment from each commit. PR #1826.
    Update GitHub context extraction for Gitter notification bot. PR #1766.

0.60.1Â¶

    Add debugging logs for GitHub actions to introspect GitHub hidden context. PR #1764.
    Use OS preference theme for online docs. PR #1760 by @adriencaccia.
    Upgrade Starlette to version 0.13.6 to handle a vulnerability when using static files in Windows. PR #1759 by @jamesag26.
    Pin Swagger UI temporarily, waiting for a fix for swagger-api/swagger-ui#6249. PR #1763.
    Update GitHub Actions, use commit from PR for docs preview, not commit from pre-merge. PR #1761.
    Update GitHub Actions, refactor Gitter bot. PR #1746.

0.60.0Â¶

    Add GitHub Action to watch for missing preview docs and trigger a preview deploy. PR #1740.
    Add custom GitHub Action to get artifact with docs preview. PR #1739.
    Add new GitHub Actions to preview docs from PRs. PR #1738.
    Add XML test coverage to support GitHub Actions. PR #1737.
    Update badges and remove Travis now that GitHub Actions is the main CI. PR #1736.
    Add GitHub Actions for CI, move from Travis. PR #1735.
    Add support for adding OpenAPI schema for GET requests with a body. PR #1626 by @victorphoenix3.

0.59.0Â¶

    Fix typo in docstring for OAuth2 utils. PR #1621 by @tomarv2.
    Update JWT docs to use Python-jose instead of PyJWT. Initial PR #1610 by @asheux.
    Fix/re-enable search bar in docs. PR #1703.
    Auto-generate a "server" in OpenAPI servers when there's a root_path instead of prefixing all the paths:
        Add a new parameter for FastAPI classes: root_path_in_servers to disable the auto-generation of servers.
        New docs about root_path and servers in Additional Servers.
        Update OAuth2 examples to use a relative URL for tokenUrl="token" to make sure those examples keep working as-is even when behind a reverse proxy.
        Initial PR #1596 by @rkbeatss.
    Fix typo/link in External Links. PR #1702.
    Update handling of External Links to use a data file and allow translating the headers without becoming obsolete quickly when new links are added. PR #https://github.com/tiangolo/fastapi/pull/1701.
    Add external link Machine learning model serving in Python using FastAPI and Streamlit to docs. PR #1669 by @davidefiocco.
    Add note in docs on order in Pydantic Unions. PR #1591 by @kbanc.
    Improve support for tests in editor. PR #1699.
    Pin dependencies. PR #1697.
    Update isort to version 5.x.x. PR #1670 by @asheux.

0.58.1Â¶

    Add link in docs to Pydantic data types. PR #1612 by @tayoogunbiyi.
    Fix link in warning logs for openapi_prefix. PR #1611 by @bavaria95.
    Fix bad link in docs. PR #1603 by @molto0504.
    Add Vim temporary files to .gitignore for contributors using Vim. PR #1590 by @asheux.
    Fix typo in docs for sub-applications. PR #1578 by @schlpbch.
    Use Optional in all the examples in the docs. Original PR #1574 by @chrisngyn, @kx-chen, @YKo20010. Updated and merged PR #1644.
    Update tests and handling of response_model_by_alias. PR #1642.
    Add translation to Chinese for Body - Fields - è¯·æ±‚ä½“ - å­—æ®µ. PR #1569 by @waynerv.
    Update Chinese translation of main page. PR #1564 by @waynerv.
    Add translation to Chinese for Body - Multiple Parameters - è¯·æ±‚ä½“ - å¤šä¸ªå‚æ•°. PR #1532 by @waynerv.
    Add translation to Chinese for Path Parameters and Numeric Validations - è·¯å¾„å‚æ•°å’Œæ•°å€¼æ ¡éªŒ. PR #1506 by @waynerv.
    Add GitHub action to auto-label approved PRs (mainly for translations). PR #1638.

0.58.0Â¶

    Deep merge OpenAPI responses to preserve all the additional metadata. PR #1577.
    Mention in docs that only main app events are run (not sub-apps). PR #1554 by @amacfie.
    Fix body validation error response, do not include body variable when it is not embedded. PR #1553 by @amacfie.
    Fix testing OAuth2 security scopes when using dependency overrides. PR #1549 by @amacfie.
    Fix Model for JSON Schema keyword not as a JSON Schema instead of a list. PR #1548 by @v-do.
    Add support for OpenAPI servers. PR #1547 by @mikaello.

0.57.0Â¶

    Remove broken link from "External Links". PR #1565 by @victorphoenix3.
    Update/fix docs for WebSockets with dependencies. Original PR #1540 by @ChihSeanHsu.
    Add support for Python's http.HTTPStatus in status_code parameters. PR #1534 by @retnikt.
    When using Pydantic models with __root__, use the internal value in jsonable_encoder. PR #1524 by @patrickkwang.
    Update docs for path parameters. PR #1521 by @yankeexe.
    Update docs for first steps, links and rewording. PR #1518 by @yankeexe.
    Enable showCommonExtensions in Swagger UI to show additional validations like maxLength, etc. PR #1466 by @TiewKH.
    Make OAuth2PasswordRequestFormStrict importable directly from fastapi.security. PR #1462 by @RichardHoekstra.
    Add docs about Default response class. PR #1455 by @TezRomacH.
    Add note in docs about additional parameters response_model_exclude_defaults and response_model_exclude_none in Response Model. PR #1427 by @wshayes.
    Add note about PyCharm Pydantic plugin to docs. PR #1420 by @koxudaxi.
    Update and clarify testing function name. PR #1395 by @chenl.
    Fix duplicated headers created by indirect dependencies that use the request directly. PR #1386 by @obataku from tests by @scottsmith2gmail.
    Upgrade Starlette version to 0.13.4. PR #1361 by @rushton.
    Improve error handling and feedback for requests with invalid JSON. PR #1354 by @aviramha.
    Add support for declaring metadata for tags in OpenAPI. New docs at Tutorial - Metadata and Docs URLs - Metadata for tags. PR #1348 by @thomas-maschler.
    Add basic setup for Russian translations. PR #1566.
    Remove obsolete Chinese articles after adding official community translations. PR #1510 by @waynerv.
    Add __repr__ for path operation function parameter helpers (like Query, Depends, etc) to simplify debugging. PR #1560 by @rkbeatss and @victorphoenix3.

0.56.1Â¶

    Add link to advanced docs from tutorial. PR #1512 by @kx-chen.
    Remove internal unnecessary f-strings. PR #1526 by @kotamatsuoka.
    Add translation to Chinese for Query Parameters and String Validations - æŸ¥è¯¢å‚æ•°å’Œå­—ç¬¦ä¸²æ ¡éªŒ. PR #1500 by @waynerv.
    Add translation to Chinese for Request Body - è¯·æ±‚ä½“. PR #1492 by @waynerv.
    Add translation to Chinese for Help FastAPI - Get Help - å¸®åŠ© FastAPI - è·å–å¸®åŠ©. PR #1465 by @waynerv.
    Add translation to Chinese for Query Parameters - æŸ¥è¯¢å‚æ•°. PR #1454 by @waynerv.
    Add translation to Chinese for Contributing - å¼€å‘ - è´¡çŒ®. PR #1460 by @waynerv.
    Add translation to Chinese for Path Parameters - è·¯å¾„å‚æ•°. PR #1453 by @waynerv.
    Add official Microsoft project generator for serving spaCy with FastAPI and Azure Cognitive Skills to Project Generators. PR #1390 by @kabirkhan.
    Update docs in Python Types Intro to include info about Optional. Original PR #1377 by @yaegassy.
    Fix support for callable class dependencies with yield. PR #1365 by @mrosales.
    Fix/remove incorrect error logging when a client sends invalid payloads. PR #1351 by @dbanty.
    Add translation to Chinese for First Steps - ç¬¬ä¸€æ­¥. PR #1323 by @waynerv.
    Fix generating OpenAPI for apps using callbacks with routers including Pydantic models. PR #1322 by @nsidnev.
    Optimize internal regex performance in get_path_param_names(). PR #1243 by @heckad.
    Remove *, from functions in docs where it's not needed. PR #1239 by @pankaj-giri.
    Start translations for Italian. PR #1557 by @csr.

0.56.0Â¶

    Add support for ASGI root_path:
        Use root_path internally for mounted applications, so that OpenAPI and the docs UI works automatically without extra configurations and parameters.
        Add new root_path parameter for FastAPI applications to provide it in cases where it can be set with the command line (e.g. for Uvicorn and Hypercorn, with the parameter --root-path).
        Deprecate openapi_prefix parameter in favor of the new root_path parameter.
        Add new/updated docs for Sub Applications - Mounts, without openapi_prefix (as it is now handled automatically).
        Add new/updated docs for Behind a Proxy, including how to setup a local testing proxy with Traefik and using root_path.
        Update docs for Extending OpenAPI with the new openapi_prefix parameter passed (internally generated from root_path).
        Original PR #1199 by @iksteen.
    Update new issue templates and docs: Help FastAPI - Get Help. PR #1531.
    Update GitHub action issue-manager. PR #1520.
    Add new links:
        English articles:
            Real-time Notifications with Python and Postgres by Guillermo Cruz.
            Microservice in Python using FastAPI by Paurakh Sharma Humagain.
            Build simple API service with Python FastAPI â€” Part 1 by cuongld2.
            FastAPI + Zeit.co = ğŸš€ by Paul Sec.
            Build a web API from scratch with FastAPI - the workshop by SebastiÃ¡n RamÃ­rez (tiangolo).
            Build a Secure Twilio Webhook with Python and FastAPI by Twilio.
            Using FastAPI with Django by Stavros Korokithakis.
            Introducing Dispatch by Netflix.
        Podcasts:
            Build The Next Generation Of Python Web Applications With FastAPI - Episode 259 - interview to SebastÃ­an RamÃ­rez (tiangolo) by Podcast.__init__.
        Talks:
            PyConBY 2020: Serve ML models easily with FastAPI by SebastiÃ¡n RamÃ­rez (tiangolo).
            [VIRTUAL] Py.Amsterdam's flying Software Circus: Intro to FastAPI by SebastiÃ¡n RamÃ­rez (tiangolo).
        PR #1467.
    Add translation to Chinese for Python Types Intro - Python ç±»å‹æç¤ºç®€ä»‹. PR #1197 by @waynerv.

0.55.1Â¶

    Fix handling of enums with their own schema in path parameters. To support pydantic/pydantic#1432 in FastAPI. PR #1463.

0.55.0Â¶

    Allow enums to allow them to have their own schemas in OpenAPI. To support pydantic/pydantic#1432 in FastAPI. PR #1461.
    Add links for funding through GitHub sponsors. PR #1425.
    Update issue template for for questions. PR #1344 by @retnikt.
    Update warning about storing passwords in docs. PR #1336 by @skorokithakis.
    Fix typo. PR #1326 by @chenl.
    Add translation to Portuguese for Alternatives, Inspiration and Comparisons - Alternativas, InspiraÃ§Ã£o e ComparaÃ§Ãµes. PR #1325 by @Serrones.
    Fix 2 typos in docs. PR #1324 by @waynerv.
    Update CORS docs, fix correct default of max_age=600. PR #1301 by @derekbekoe.
    Add translation of main page to Portuguese. PR #1300 by @Serrones.
    Re-word and clarify docs for extra info in fields. PR #1299 by @chris-allnutt.
    Make sure the * in short features in the docs is consistent (after .) in all languages. PR #1424.
    Update order of execution for get_db in SQLAlchemy tutorial. PR #1293 by @bcb.
    Fix typos in Async docs. PR #1423.

0.54.2Â¶

    Add translation to Spanish for Concurrency and async / await - Concurrencia y async / await. PR #1290 by @alvaropernas.
    Remove obsolete vote link. PR #1289 by @donhui.
    Allow disabling docs UIs by just disabling OpenAPI with openapi_url=None. New example in docs: Advanced: Conditional OpenAPI. PR #1421.
    Add translation to Portuguese for Benchmarks - ComparaÃ§Ãµes. PR #1274 by @Serrones.
    Add translation to Portuguese for Tutorial - User Guide - Intro - Tutorial - Guia de UsuÃ¡rio - IntroduÃ§Ã£o. PR #1259 by @marcosmmb.
    Allow using Unicode in MkDocs for translations. PR #1419.
    Add translation to Spanish for Advanced User Guide - Intro - GuÃ­a de Usuario Avanzada - IntroducciÃ³n. PR #1250 by @jfunez.
    Add translation to Portuguese for History, Design and Future - HistÃ³ria, Design e Futuro. PR #1249 by @marcosmmb.
    Add translation to Portuguese for Features - Recursos. PR #1248 by @marcosmmb.
    Add translation to Spanish for Tutorial - User Guide - Intro - Tutorial - GuÃ­a de Usuario - IntroducciÃ³n. PR #1244 by @MartinEliasQ.
    Add translation to Chinese for Deployment - éƒ¨ç½². PR #1203 by @RunningIkkyu.
    Add translation to Chinese for Tutorial - User Guide - Intro - æ•™ç¨‹ - ç”¨æˆ·æŒ‡å— - ç®€ä»‹. PR #1202 by @waynerv.
    Add translation to Chinese for Features - ç‰¹æ€§. PR #1192 by @Dustyposa.
    Add translation for main page to Chinese PR #1191 by @waynerv.
    Update docs for project generation. PR #1287.
    Add Spanish translation for IntroducciÃ³n a los Tipos de Python (Python Types Intro). PR #1237 by @mariacamilagl.
    Add Spanish translation for CaracterÃ­sticas (Features). PR #1220 by @mariacamilagl.

0.54.1Â¶

    Update database test setup. PR #1226.
    Improve test debugging by showing response text in failing tests. PR #1222 by @samuelcolvin.

0.54.0Â¶

    Fix grammatical mistakes in async docs. PR #1188 by @mickeypash.
    Add support for response_model_exclude_defaults and response_model_exclude_none:
        Deprecate the parameter include_none in jsonable_encoder and add the inverted exclude_none, to keep in sync with Pydantic.
        PR #1166 by @voegtlel.
    Add example about Testing a Database. Initial PR #1144 by @duganchen.
    Update docs for Development - Contributing: Translations including note about reviewing translation PRs. #1215.
    Update log style in README.md for GitHub Markdown compatibility. PR #1200 by #geekgao.
    Add Python venv env to .gitignore. PR #1212 by @cassiobotaro.
    Start Portuguese translations. PR #1210 by @cassiobotaro.
    Update docs for Pydantic's Settings using a dependency with @lru_cache(). PR #1214.
    Add first translation to Spanish FastAPI. PR #1201 by @mariacamilagl.
    Add docs about Settings and Environment Variables. Initial PR 1118 by @alexmitelman.

0.53.2Â¶

    Fix automatic embedding of body fields for dependencies and sub-dependencies. Original PR #1079 by @Toad2186.
    Fix dependency overrides in WebSocket testing. PR #1122 by @amitlissack.
    Fix docs script to ensure languages are always sorted. PR #1189.
    Start translations for Chinese. PR #1187 by @RunningIkkyu.
    Add docs for Schema Extra - Example. PR #1185.

0.53.1Â¶

    Fix included example after translations refactor. PR #1182.
    Add docs example for example in Field. Docs at Body - Fields: JSON Schema extras. PR #1106 by @JohnPaton.
    Fix using recursive models in response_model. PR #1164 by @voegtlel.
    Add docs for Pycharm Debugging. PR #1096 by @youngquan.
    Fix typo in docs. PR #1148 by @PLNech.
    Update Windows development environment instructions. PR #1179.

0.53.0Â¶

    Update test coverage badge. PR #1175.
    Add orjson to pip install fastapi[all]. PR #1161 by @michael0liver.
    Fix included example for GZipMiddleware. PR #1138 by @arimbr.
    Fix class name in docstring for OAuth2PasswordRequestFormStrict. PR #1126 by @adg-mh.
    Clarify function name in example in docs. PR #1121 by @tmsick.
    Add external link Apache Kafka producer and consumer with FastAPI and aiokafka to docs. PR #1112 by @iwpnd.
    Fix serialization when using by_alias or exclude_unset and returning data with Pydantic models. PR #1074 by @juhovh-aiven.
    Add Gitter chat to docs. PR #1061 by @aakashnand.
    Update and simplify translations docs. PR #1171.
    Update development of FastAPI docs, set address to 127.0.0.1 to improve Windows support. PR #1169 by @mariacamilagl.
    Add support for docs translations. New docs: Development - Contributing: Docs: Translations. PR #1168.
    Update terminal styles in docs and add note about Typer, the FastAPI of CLIs. PR #1139.

0.52.0Â¶

    Add new high-performance JSON response class using orjson. New docs: Custom Response - HTML, Stream, File, others: ORJSONResponse. PR #1065.

0.51.0Â¶

    Re-export utils from Starlette:
        This allows using things like from fastapi.responses import JSONResponse instead of from starlette.responses import JSONResponse.
        It's mainly syntax sugar, a convenience for developer experience.
        Now Request, Response, WebSocket, status can be imported directly from fastapi as in from fastapi import Response. This is because those are frequently used, to use the request directly, to set headers and cookies, to get status codes, etc.
        Documentation changes in many places, but new docs and noticeable improvements:
            Custom Response - HTML, Stream, File, others.
            Advanced Middleware.
            Including WSGI - Flask, Django, others.
        PR #1064.

0.50.0Â¶

    Add link to Release Notes from docs about pinning versions for deployment. PR #1058.
    Upgrade code to use the latest version of Starlette, including:
        Several bug fixes.
        Optional redirects of slashes, with or without ending in /.
        Events for routers, "startup", and "shutdown".
        PR #1057.
    Add docs about pinning FastAPI versions for deployment: Deployment: FastAPI versions. PR #1056.

0.49.2Â¶

    Fix links in release notes. PR #1052 by @sattosan.
    Fix typo in release notes. PR #1051 by @sattosan.
    Refactor/clarify serialize_response parameter name to avoid confusion. PR #1031 by @patrickmckenna.
    Refactor calling each a path operation's handler function in an isolated function, to simplify profiling. PR #1027 by @sm-Fifteen.
    Add missing dependencies for testing. PR #1026 by @sm-Fifteen.
    Fix accepting valid types for response models, including Python types like List[int]. PR #1017 by @patrickmckenna.
    Fix format in SQL tutorial. PR #1015 by @vegarsti.

0.49.1Â¶

    Fix path operation duplicated parameters when used in dependencies and the path operation function. PR #994 by @merowinger92.
    Update Netlify previews deployment GitHub action as the fix is already merged and there's a new release. PR #1047.
    Move mypy configurations to config file. PR #987 by @hukkinj1.
    Temporary fix to Netlify previews not deployable from PRs from forks. PR #1046 by @mariacamilagl.

0.49.0Â¶

    Fix encoding of pathlib paths in jsonable_encoder. PR #978 by @patrickmckenna.
    Add articles to External Links: Pythonã®Web frameworkã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒ (Django, Flask, responder, FastAPI, japronto) and [FastAPI] Pythonè£½ã®ASGI Web ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ FastAPIã«å…¥é–€ã™ã‚‹. PR #974 by @tokusumi.
    Fix broken links in docs. PR #949 by @tsotnikov.
    Fix small typos. PR #941 by @NikitaKolesov.
    Update and clarify docs for dependencies with yield. PR #986.
    Add Mermaid JS support for diagrams in docs. Add first diagrams to Dependencies: First Steps and Dependencies with yield and HTTPException. PR #985.
    Update CI to run docs deployment in GitHub actions. PR #983.
    Allow callables in path operation functions, like functions modified with functools.partial. PR #977.

0.48.0Â¶

    Run linters first in tests to error out faster. PR #948.
    Log warning about email-validator only when used. PR #946.
    Simplify Peewee docs with double dependency with yield. PR #947.
    Add article External Links: Create and Deploy FastAPI app to Heroku. PR #942 by @windson.
    Update description of Sanic, as it is now ASGI too. PR #932 by @raphaelauv.
    Fix typo in main page. PR #920 by @mMarzeta.
    Fix parsing of possibly invalid bodies. PR #918 by @dmontagu.
    Fix typo #916 by @adursun.
    Allow Any type for enums in OpenAPI. PR #906 by @songzhi.
    Add article to External Links: How to continuously deploy a FastAPI to AWS Lambda with AWS SAM. PR #901 by @iwpnd.
    Add note about using Body parameters without Pydantic. PR #900 by @pawamoy.
    Fix Pydantic field clone logic. PR #899 by @deuce2367.
    Fix link in middleware docs. PR #893 by @linchiwei123.
    Rename default API title from "Fast API" to "FastAPI" for consistency. PR #890.

0.47.1Â¶

    Fix model filtering in response_model, cloning sub-models. PR #889.
    Fix FastAPI serialization of Pydantic models using ORM mode blocking the event loop. PR #888.

0.47.0Â¶

    Refactor documentation to make a simpler and shorter Tutorial - User Guide and an additional Advanced User Guide with all the additional docs. PR #887.
    Tweak external links, Markdown format, typos. PR #881.
    Fix bug in tutorial handling HTTP Basic Auth username and password. PR #865 by @isaevpd.
    Fix handling form path operation parameters declared with pure classes like list, tuple, etc. PR #856 by @nsidnev.
    Add request body to RequestValidationError, new docs: Use the RequestValidationError body. Initial PR #853 by @aviramha.
    Update External Links with new links and dynamic GitHub projects with fastapi topic. PR #850.
    Fix Peewee contextvars handling in docs: SQL (Relational) Databases with Peewee. PR #879.
    Setup development environment with Python's Venv and Flit, instead of requiring the extra Pipenv duplicating dependencies. Updated docs: Development - Contributing. PR #877.
    Update docs for HTTP Basic Auth to improve security against timing attacks. Initial PR #807 by @zwass.

0.46.0Â¶

    Fix typos and tweak configs. PR #837.
    Add link to Chinese article in External Links. PR 810 by @wxq0309.
    Implement OAuth2AuthorizationCodeBearer class. PR #797 by @kuwv.
    Update example upgrade in docs main page. PR #795 by @cdeil.
    Fix callback handling for sub-routers. PR #792 by @jekirl.
    Fix typos. PR #784 by @kkinder.
    Add 4 Japanese articles to External Links. PR #783 by @HymanZHAN.
    Add support for subtypes of main types in jsonable_encoder, e.g. asyncpg's UUIDs. PR #756 by @RmStorm.
    Fix usage of Pydantic's HttpUrl in docs. PR #832 by @Dustyposa.
    Fix Twitter links in docs. PR #813 by @justindujardin.
    Add docs for correctly using FastAPI with Peewee ORM. Including how to overwrite parts of Peewee to correctly handle async threads. PR #789.

0.45.0Â¶

    Add support for OpenAPI Callbacks:
        New docs: OpenAPI Callbacks.
        Refactor generation of operationIds to be valid Python names (also valid variables in most languages).
        Add default_response_class parameter to APIRouter.
        Original PR #722 by @booooh.
    Refactor logging to use the same logger everywhere, update log strings and levels. PR #781.
    Add article to External Links: ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ Ğ’Ñ‹ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ FastAPI?. PR #766 by @prostomarkeloff.
    Remove gender bias in docs for handling errors. PR #780. Original idea in PR #761 by @classywhetten.
    Rename docs and references to body-schema to body-fields to keep in line with Pydantic. PR #746 by @prostomarkeloff.

0.44.1Â¶

    Add GitHub social preview images to git. PR #752.
    Update PyPI "trove classifiers". PR #751.
    Add full support for Python 3.8. Enable Python 3.8 in full in Travis. PR 749.
    Update "new issue" templates. PR #749.
    Fix serialization of errors for exotic Pydantic types. PR #748 by @dmontagu.

0.44.0Â¶

    Add GitHub action Issue Manager. PR #742.
    Fix typos in docs. PR 734 by @bundabrg.
    Fix usage of custom_encoder in jsonable_encoder. PR #715 by @matrixise.
    Fix invalid XML example. PR 710 by @OcasoProtal.
    Fix typos and update wording in deployment docs. PR #700 by @marier-nico.
    Add note about dependencies in APIRouter docs. PR #698 by @marier-nico.
    Add support for async class methods as dependencies #681 by @frankie567.
    Add FastAPI with Swagger UI cheatsheet to external links. PR #671 by @euri10.
    Fix typo in HTTP protocol in CORS example. PR #647 by @forestmonster.
    Add support for Pydantic versions 1.0.0 and above, with temporary (deprecated) backwards compatibility for Pydantic 0.32.2. PR #646 by @dmontagu.

0.43.0Â¶

    Update docs to reduce gender bias. PR #645 by @ticosax.
    Add docs about overriding the operationId for all the path operations based on their function name. PR #642 by @SKalt.
    Fix validators in models generating an incorrect key order. PR #637 by @jaddison.
    Generate correct OpenAPI docs for responses with no content. PR #621 by @brotskydotcom.
    Remove $ from Bash code blocks in docs for consistency. PR #613 by @nstapelbroek.
    Add docs for self-serving docs' (Swagger UI) static assets, e.g. to use the docs offline, or without Internet. Initial PR #557 by @svalouch.
    Fix black linting after upgrade. PR #682 by @frankie567.

0.42.0Â¶

    Add dependencies with yield, a.k.a. exit steps, context managers, cleanup, teardown, ...
        This allows adding extra code after a dependency is done. It can be used, for example, to close database connections.
        Dependencies with yield can be normal or async, FastAPI will run normal dependencies in a threadpool.
        They can be combined with normal dependencies.
        It's possible to have arbitrary trees/levels of dependencies with yield and exit steps are handled in the correct order automatically.
        It works by default in Python 3.7 or above. For Python 3.6, it requires the extra backport dependencies:
            async-exit-stack
            async-generator
        New docs at Dependencies with yield.
        Updated database docs SQL (Relational) Databases: Main FastAPI app.
        PR #595.
    Fix sitemap.xml in website. PR #598 by @samuelcolvin.

0.41.0Â¶

    Upgrade required Starlette to 0.12.9, the new range is >=0.12.9,<=0.12.9.
        Add State to FastAPI apps at app.state.
        PR #593.
    Improve handling of custom classes for Requests and APIRoutes.
        This helps to more easily solve use cases like:
            Reading a body before and/or after a request (equivalent to a middleware).
            Run middleware-like code only for a subset of path operations.
            Process a request before passing it to a path operation function. E.g. decompressing, deserializing, etc.
            Processing a response after being generated by path operation functions but before returning it. E.g. adding custom headers, logging, adding extra metadata.
        New docs section: Custom Request and APIRoute class.
        PR #589 by @dmontagu.
    Fix preserving custom route class in routers when including other sub-routers. PR #538 by @dmontagu.

0.40.0Â¶

    Add notes to docs about installing python-multipart when using forms. PR #574 by @sliptonic.
    Generate OpenAPI schemas in alphabetical order. PR #554 by @dmontagu.
    Add support for truncating docstrings from path operation functions.
        New docs at Advanced description from docstring.
        PR #556 by @svalouch.
    Fix DOCTYPE in HTML files generated for Swagger UI and ReDoc. PR #537 by @Trim21.
    Fix handling 4XX responses overriding default 422 validation error responses. PR #517 by @tsouvarev.
    Fix typo in documentation for Simple HTTP Basic Auth. PR #514 by @prostomarkeloff.
    Fix incorrect documentation example in first steps. PR #511 by @IgnatovFedor.
    Add support for Swagger UI initOauth settings with the parameter swagger_ui_init_oauth. PR #499 by @zamiramir.

0.39.0Â¶

    Allow path parameters to have default values (e.g. None) and discard them instead of raising an error.
        This allows declaring a parameter like user_id: str = None that can be taken from a query parameter, but the same path operation can be included in a router with a path /users/{user_id}, in which case will be taken from the path and will be required.
        PR #464 by @jonathanunderwood.
    Add support for setting a default_response_class in the FastAPI instance or in include_router. Initial PR #467 by @toppk.
    Add support for type annotations using strings and from __future__ import annotations. PR #451 by @dmontagu.

0.38.1Â¶

    Fix incorrect Request class import. PR #493 by @kamalgill.

0.38.0Â¶

    Add recent articles to External Links and recent opinions. PR #490.
    Upgrade support range for Starlette to include 0.12.8. The new range is >=0.11.1,<=0.12.8". PR #477 by @dmontagu.
    Upgrade support to Pydantic version 0.32.2 and update internal code to use it (breaking change). PR #463 by @dmontagu.

0.37.0Â¶

    Add support for custom route classes for advanced use cases. PR #468 by @dmontagu.
    Allow disabling Google fonts in ReDoc. PR #481 by @b1-luettje.
    Fix security issue: when returning a sub-class of a response model and using skip_defaults it could leak information. PR #485 by @dmontagu.
    Enable tests for Python 3.8-dev. PR #465 by @Jamim.
    Add support and tests for Pydantic dataclasses in response_model. PR #454 by @dconathan.
    Fix typo in OAuth2 JWT tutorial. PR #447 by @pablogamboa.
    Use the media_type parameter in Body() params to set the media type in OpenAPI for requestBody. PR #439 by @divums.
    Add article Deploying a scikit-learn model with ONNX and FastAPI by Nico Axtmann. PR #438 by @naxty.
    Allow setting custom 422 (validation error) response/schema in OpenAPI.
        And use media type from response class instead of fixed application/json (the default).
        PR #437 by @divums.
    Fix using "default" extra response with status codes at the same time. PR #489.
    Allow additional responses to use status code ranges (like 5XX and 4XX) and "default". PR #435 by @divums.

0.36.0Â¶

    Fix implementation for skip_defaults when returning a Pydantic model. PR #422 by @dmontagu.
    Fix OpenAPI generation when using the same dependency in multiple places for the same path operation. PR #417 by @dmontagu.
    Allow having empty paths in path operations used with include_router and a prefix.
        This allows having a router for /cats and all its path operations, while having one of them for /cats.
        Now it doesn't have to be only /cats/ (with a trailing slash).
        To use it, declare the path in the path operation as the empty string ("").
        PR #415 by @vitalik.
    Fix mypy error after merging PR #415. PR #462.

0.35.0Â¶

    Fix typo in routing assert. PR #419 by @pablogamboa.
    Fix typo in docs. PR #411 by @bronsen.
    Fix parsing a body type declared with Union. PR #400 by @koxudaxi.

0.34.0Â¶

    Upgrade Starlette supported range to include the latest 0.12.7. The new range is 0.11.1,<=0.12.7. PR #367 by @dedsm.

    Add test for OpenAPI schema with duplicate models from PR #333 by @dmontagu. PR #385.

0.33.0Â¶

    Upgrade Pydantic version to 0.30.0. PR #384 by @jekirl.

0.32.0Â¶

    Fix typo in docs for features. PR #380 by @MartinoMensio.

    Fix source code limit for example in Query Parameters. PR #366 by @Smashman.

    Update wording in docs about OAuth2 scopes. PR #371 by @cjw296.

    Update docs for Enums to inherit from str and improve Swagger UI rendering. PR #351.

    Fix regression, add Swagger UI deep linking again. PR #350.

    Add test for having path templates in prefix of .include_router. PR #349.

    Add note to docs: Include the same router multiple times with different prefix. PR #348.

    Fix OpenAPI/JSON Schema generation for two functions with the same name (in different modules) with the same composite bodies.
        Composite bodies' IDs are now based on path, not only on route name, as the auto-generated name uses the function names, that can be duplicated in different modules.
        The same new ID generation applies to response models.
        This also changes the generated title for those models.
        Only composite bodies and response models are affected because those are generated dynamically, they don't have a module (a Python file).
        This also adds the possibility of using .include_router() with the same APIRouter multiple times, with different prefixes, e.g. /api/v2 and /api/latest, and it will now work correctly.
        PR #347.

0.31.0Â¶

    Upgrade Pydantic supported version to 0.29.0.
        New supported version range is "pydantic >=0.28,<=0.29.0".
        This adds support for Pydantic Generic Models, kudos to @dmontagu.
        PR #344.

0.30.1Â¶

    Add section in docs about External Links and Articles. PR #341.

    Remove Pipfile.lock from the repository as it is only used by FastAPI contributors (developers of FastAPI itself). See the PR for more details. PR #340.

    Update section about Help FastAPI - Get Help. PR #339.

    Refine internal type declarations to improve/remove Mypy errors in users' code. PR #338.

    Update and clarify SQL tutorial with SQLAlchemy. PR #331 by @mariacamilagl.

    Add SQLite online viewers to the docs. PR #330 by @cyrilbois.

0.30.0Â¶

    Add support for Pydantic's ORM mode:
        Updated documentation about SQL with SQLAlchemy, using Pydantic models with ORM mode, SQLAlchemy models with relations, separation of files, simplification of code and other changes. New docs: SQL (Relational) Databases.
        The new support for ORM mode fixes issues/adds features related to ORMs with lazy-loading, hybrid properties, dynamic/getters (using @property decorators) and several other use cases.
        This applies to ORMs like SQLAlchemy, Peewee, Tortoise ORM, GINO ORM and virtually any other.
        If your path operations return an arbitrary object with attributes (e.g. my_item.name instead of my_item["name"]) AND you use a response_model, make sure to update the Pydantic models with orm_mode = True as described in the docs (link above).
        New documentation about receiving plain dicts as request bodies: Bodies of arbitrary dicts.
        New documentation about returning arbitrary dicts in responses: Response with arbitrary dict.
        Technical Details:
            When declaring a response_model it is used directly to generate the response content, from whatever was returned from the path operation function.
            Before this, the return content was first passed through jsonable_encoder to ensure it was a "jsonable" object, like a dict, instead of an arbitrary object with attributes (like an ORM model). That's why you should make sure to update your Pydantic models for objects with attributes to use orm_mode = True.
            If you don't have a response_model, the return object will still be passed through jsonable_encoder first.
            When a response_model is declared, the same response_model type declaration won't be used as is, it will be "cloned" to create an new one (a cloned Pydantic Field with all the submodels cloned as well).
            This avoids/fixes a potential security issue: as the returned object is passed directly to Pydantic, if the returned object was a subclass of the response_model (e.g. you return a UserInDB that inherits from User but contains extra fields, like hashed_password, and User is used in the response_model), it would still pass the validation (because UserInDB is a subclass of User) and the object would be returned as-is, including the hashed_password. To fix this, the declared response_model is cloned, if it is a Pydantic model class (or contains Pydantic model classes in it, e.g. in a List[Item]), the Pydantic model class(es) will be a different one (the "cloned" one). So, an object that is a subclass won't simply pass the validation and returned as-is, because it is no longer a sub-class of the cloned response_model. Instead, a new Pydantic model object will be created with the contents of the returned object. So, it will be a new object (made with the data from the returned one), and will be filtered by the cloned response_model, containing only the declared fields as normally.
        PR #322.

    Remove/clean unused RegEx code in routing. PR #314 by @dmontagu.

    Use default response status code descriptions for additional responses. PR #313 by @duxiaoyao.

    Upgrade Pydantic support to 0.28. PR #320 by @jekirl.

0.29.1Â¶

    Fix handling an empty-body request with a required body param. PR #311.

    Fix broken link in docs: Return a Response directly. PR #306 by @dmontagu.

    Fix docs discrepancy in docs for Response Model. PR #288 by @awiddersheim.

0.29.0Â¶

    Add support for declaring a Response parameter:
        This allows declaring:
            Response Cookies.
            Response Headers.
            An HTTP Status Code different than the default: Response - Change Status Code.
        All of this while still being able to return arbitrary objects (dict, DB model, etc).
        Update attribution to Hug, for inspiring the response parameter pattern.
        PR #294.

0.28.0Â¶

    Implement dependency cache per request.
        This avoids calling each dependency multiple times for the same request.
        This is useful while calling external services, performing costly computation, etc.
        This also means that if a dependency was declared as a path operation decorator dependency, possibly at the router level (with .include_router()) and then it is declared again in a specific path operation, the dependency will be called only once.
        The cache can be disabled per dependency declaration, using use_cache=False as in Depends(your_dependency, use_cache=False).
        Updated docs at: Using the same dependency multiple times.
        PR #292.

    Implement dependency overrides for testing.
        This allows using overrides/mocks of dependencies during tests.
        New docs: Testing Dependencies with Overrides.
        PR #291.

0.27.2Â¶

    Fix path and query parameters receiving dict as a valid type. It should be mapped to a body payload. PR #287. Updated docs at: Query parameter list / multiple values with defaults: Using list.

0.27.1Â¶

    Fix auto_error=False handling in HTTPBearer security scheme. Do not raise when there's an incorrect Authorization header if auto_error=False. PR #282.

    Fix type declaration of HTTPException. PR #279.

0.27.0Â¶

    Fix broken link in docs about OAuth 2.0 with scopes. PR #275 by @dmontagu.

    Refactor param extraction using Pydantic Field:
        Large refactor, improvement, and simplification of param extraction from path operations.
        Fix/add support for list query parameters with list defaults. New documentation: Query parameter list / multiple values with defaults.
        Add support for enumerations in path operation parameters. New documentation: Path Parameters: Predefined values.
        Add support for type annotations using Optional as in param: Optional[str] = None. New documentation: Optional type declarations.
        PR #278.

0.26.0Â¶

    Separate error handling for validation errors.
        This will allow developers to customize the exception handlers.
        Document better how to handle exceptions and use error handlers.
        Include RequestValidationError and WebSocketRequestValidationError (this last one will be useful once encode/starlette#527 or equivalent is merged).
        New documentation about exceptions handlers:
            Install custom exception handlers.
            Override the default exception handlers.
            Reuse FastAPI's exception handlers.
        PR #273.

    Fix support for paths in path parameters without needing explicit Path(...).
        PR #256.
        Documented in PR #272 by @wshayes.
        New documentation at: Path Parameters containing paths.

    Update docs for testing FastAPI. Include using POST, sending JSON, testing headers, etc. New documentation: Testing. PR #271.

    Fix type declaration of response_model to allow generic Python types as List[Model]. Mainly to fix mypy for users. PR #266.

0.25.0Â¶

    Add support for Pydantic's include, exclude, by_alias.
        Update documentation: Response Model.
        Add docs for: Body - updates, using Pydantic's skip_defaults.
        Add method consistency tests.
        PR #264.

    Add CONTRIBUTING.md file to GitHub, to help new contributors. PR #255 by @wshayes.

    Add support for Pydantic's skip_defaults:
        There's a new path operation decorator parameter response_model_skip_defaults.
            The name of the parameter will most probably change in a future version to response_skip_defaults, model_skip_defaults or something similar.
        New documentation section about using response_model_skip_defaults.
        PR #248 by @wshayes.

0.24.0Â¶

    Add support for WebSockets with dependencies and parameters.
        Support included for:
            Depends
            Security
            Cookie
            Header
            Path
            Query
            ...as these are compatible with the WebSockets protocol (e.g. Body is not).
        Updated documentation for WebSockets.
        PR #178 by @jekirl.

    Upgrade the compatible version of Pydantic to 0.26.0.
        This includes JSON Schema support for IP address and network objects, bug fixes, and other features.
        PR #247 by @euri10.

0.23.0Â¶

    Upgrade the compatible version of Starlette to 0.12.0.
        This includes support for ASGI 3 (the latest version of the standard).
        It's now possible to use Starlette's StreamingResponse with iterators, like file-like objects (as those returned by open()).
        It's now possible to use the low level utility iterate_in_threadpool from starlette.concurrency (for advanced scenarios).
        PR #243.

    Add OAuth2 redirect page for Swagger UI. This allows having delegated authentication in the Swagger UI docs. For this to work, you need to add {your_origin}/docs/oauth2-redirect to the allowed callbacks in your OAuth2 provider (in Auth0, Facebook, Google, etc).
        For example, during development, it could be http://localhost:8000/docs/oauth2-redirect.
        Keep in mind that this callback URL is independent of whichever one is used by your frontend. You might also have another callback at https://yourdomain.com/login/callback.
        This is only to allow delegated authentication in the API docs with Swagger UI.
        PR #198 by @steinitzu.

    Make Swagger UI and ReDoc route handlers (path operations) be async functions instead of lambdas to improve performance. PR #241 by @Trim21.

    Make Swagger UI and ReDoc URLs parameterizable, allowing to host and serve local versions of them and have offline docs. PR #112 by @euri10.

0.22.0Â¶

    Add support for dependencies parameter:
        A parameter in path operation decorators, for dependencies that should be executed but the return value is not important or not used in the path operation function.
        A parameter in the .include_router() method of FastAPI applications and routers, to include dependencies that should be executed in each path operation in a router.
            This is useful, for example, to require authentication or permissions in specific group of path operations.
            Different dependencies can be applied to different routers.
        These dependencies are run before the normal parameter dependencies. And normal dependencies are run too. They can be combined.
        Dependencies declared in a router are executed first, then the ones defined in path operation decorators, and then the ones declared in normal parameters. They are all combined and executed.
        All this also supports using Security with scopes in those dependencies parameters, for more advanced OAuth 2.0 security scenarios with scopes.
        New documentation about dependencies in path operation decorators.
        New documentation about dependencies in the include_router() method.
        PR #235.

    Fix OpenAPI documentation of Starlette URL convertors. Specially useful when using path convertors, to take a whole path as a parameter, like /some/url/{p:path}. PR #234 by @euri10.

    Make default parameter utilities exported from fastapi be functions instead of classes (the new functions return instances of those classes). To be able to override the return types and fix mypy errors in FastAPI's users' code. Applies to Path, Query, Header, Cookie, Body, Form, File, Depends, and Security. PR #226 and PR #231.

    Separate development scripts test.sh, lint.sh, and format.sh. PR #232.

    Re-enable black formatting checks for Python 3.7. PR #229 by @zamiramir.

0.21.0Â¶

    On body parsing errors, raise from previous exception, to allow better introspection in logging code. PR #192 by @ricardomomm.

    Use Python logger named "fastapi" instead of root logger. PR #222 by @euri10.

    Upgrade Pydantic to version 0.25. PR #225 by @euri10.

    Fix typo in routing. PR #221 by @djlambert.

0.20.1Â¶

    Add typing information to package including file py.typed. PR #209 by @meadsteve.

    Add FastAPI bot for Gitter. To automatically announce new releases. PR #189.

0.20.0Â¶

    Upgrade OAuth2:
        Upgrade Password flow using Bearer tokens to use the correct HTTP status code 401 UNAUTHORIZED, with WWW-Authenticate headers.
        Update, simplify, and improve all the security docs.
        Add new scope_str to SecurityScopes and update docs: OAuth2 scopes.
        Update docs, images, tests.
        PR #188.

    Include Hypercorn as an alternative ASGI server in the docs. PR #187.

    Add docs for Static Files and Templates. PR #186.

    Add docs for handling Response Cookies and Response Headers. PR #185.

    Fix typos in docs. PR #176 by @chdsbd.

0.19.0Â¶

    Rename path operation decorator parameter content_type to response_class. PR #183.

    Add docs:
        How to use the jsonable_encoder in JSON compatible encoder.
        How to Return a Response directly.
        Update how to use a Custom Response Class.
        PR #184.

0.18.0Â¶

    Add docs for HTTP Basic Auth. PR #177.

    Upgrade HTTP Basic Auth handling with automatic headers (automatic browser login prompt). PR #175.

    Update dependencies for security. PR #174.

    Add docs for Middleware. PR #173.

0.17.0Â¶

    Make Flit publish from CI. PR #170.

    Add documentation about handling CORS (Cross-Origin Resource Sharing). PR #169.

    By default, encode by alias. This allows using Pydantic alias parameters working by default. PR #168.

0.16.0Â¶

    Upgrade path operation docstring parsing to support proper Markdown descriptions. New documentation at Path Operation Configuration. PR #163.

    Refactor internal usage of Pydantic to use correct data types. PR #164.

    Upgrade Pydantic to version 0.23. PR #160 by @euri10.

    Fix typo in Tutorial about Extra Models. PR #159 by @danielmichaels.

    Fix Query Parameters URL examples in docs. PR #157 by @hayata-yamamoto.

0.15.0Â¶

    Add support for multiple file uploads (as a single form field). New docs at: Multiple file uploads. PR #158.

    Add docs for: Additional Status Codes. PR #156.

0.14.0Â¶

    Improve automatically generated names of path operations in OpenAPI (in API docs). A function read_items instead of having a generated name "Read Items Get" will have "Read Items". PR #155.

    Add docs for: Testing FastAPI. PR #151.

    Update /docs Swagger UI to enable deep linking. This allows sharing the URL pointing directly to the path operation documentation in the docs. PR #148 by @wshayes.

    Update development dependencies, Pipfile.lock. PR #150.

    Include Falcon and Hug in: Alternatives, Inspiration and Comparisons.

0.13.0Â¶

    Improve/upgrade OAuth2 scopes support with SecurityScopes:
        SecurityScopes can be declared as a parameter like Request, to get the scopes of all super-dependencies/dependants.
        Improve Security handling, merging scopes when declaring SecurityScopes.
        Allow using SecurityBase (like OAuth2) classes with Depends and still document them. Security now is needed only to declare scopes.
        Updated docs about: OAuth2 with Password (and hashing), Bearer with JWT tokens.
        New docs about: OAuth2 scopes.
        PR #141.

0.12.1Â¶

    Fix bug: handling additional responses in APIRouter.include_router(). PR #140.

    Fix typo in SQL tutorial. PR #138 by @mostaphaRoudsari.

    Fix typos in section about nested models and OAuth2 with JWT. PR #127 by @mmcloud.

0.12.0Â¶

    Add additional responses parameter to path operation decorators to extend responses in OpenAPI (and API docs).
        It also allows extending existing responses generated from response_model, declare other media types (like images), etc.
        The new documentation is here: Additional Responses.
        responses can also be added to .include_router(), the updated docs are here: Bigger Applications.
        PR #97 originally initiated by @barsi.
    Update scripts/test-cov-html.sh to allow passing extra parameters like -vv, for development.

0.11.0Â¶

    Add auto_error parameter to security utility functions. Allowing them to be optional. Also allowing to have multiple alternative security schemes that are then checked in a single dependency instead of each one verifying and returning the error to the client automatically when not satisfied. PR #134.

    Update SQL Tutorial to close database sessions even when there are exceptions. PR #89 by @alexiri.

    Fix duplicate dependency in pyproject.toml. PR #128 by @zxalif.

0.10.3Â¶

    Add Gitter chat, badge, links, etc. https://gitter.im/tiangolo/fastapi . PR #117.

    Add docs about Extending OpenAPI. PR #126.

    Make Travis run Ubuntu Xenial (newer version) and Python 3.7 instead of Python 3.7-dev. PR #92 by @blueyed.

    Fix duplicated param variable creation. PR #123 by @yihuang.

    Add note in Response Model docs about why using a function parameter instead of a function return type annotation. PR #109 by @JHSaunders.

    Fix event docs (startup/shutdown) function name. PR #105 by @stratosgear.

0.10.2Â¶

    Fix OpenAPI (JSON Schema) for declarations of Python Union (JSON Schema additionalProperties). PR #121.

    Update Background Tasks with a note on Celery.

    Document response models using unions and lists, updated at: Extra Models. PR #108.

0.10.1Â¶

    Add docs and tests for encode/databases. New docs at: Async SQL (Relational) Databases. PR #107.

0.10.0Â¶

    Add support for Background Tasks in path operation functions and dependencies. New documentation about Background Tasks is here. PR #103.

    Add support for .websocket_route() in APIRouter. PR #100 by @euri10.

    New docs section about Events: startup - shutdown. PR #99.

0.9.1Â¶

    Document receiving Multiple values with the same query parameter and Duplicate headers. PR #95.

0.9.0Â¶

    Upgrade compatible Pydantic version to 0.21.0. PR #90.

    Add documentation for: Application Configuration.

    Fix typo in docs. PR #76 by @matthewhegarty.

    Fix link in "Deployment" to "Bigger Applications".

0.8.0Â¶

    Make development scripts executable. PR #76 by @euri10.

    Add support for adding tags in app.include_router(). PR #55 by @euri10. Documentation updated in the section: Bigger Applications.

    Update docs related to Uvicorn to use new --reload option from version 0.5.x. PR #74.

    Update isort imports and scripts to be compatible with newer versions. PR #75.

0.7.1Â¶

    Update technical details about async def handling with respect to previous frameworks. PR #64 by @haizaar.

    Add deployment documentation for Docker in Raspberry Pi and other architectures.

    Trigger Docker images build on Travis CI automatically. PR #65.

0.7.0Â¶

    Add support for UploadFile in File parameter annotations.
        This includes a file-like interface.
        Here's the updated documentation for declaring File parameters with UploadFile.
        And here's the updated documentation for using Form parameters mixed with File parameters, supporting bytes and UploadFile at the same time.
        PR #63.

0.6.4Â¶

    Add technical details about async def handling to docs. PR #61.

    Add docs for Debugging FastAPI applications in editors.

    Clarify Bigger Applications deployed with Docker.

    Fix typos in docs.

    Add section about History, Design and Future.

    Add docs for using WebSockets with FastAPI. PR #62.

0.6.3Â¶

    Add Favicons to docs. PR #53.

0.6.2Â¶

    Introduce new project generator based on FastAPI and PostgreSQL: https://github.com/tiangolo/full-stack-fastapi-postgresql. PR #52.

    Update SQL tutorial with SQLAlchemy, using Depends to improve editor support and reduce code repetition. PR #52.

    Improve middleware naming in tutorial for SQL with SQLAlchemy https://fastapi.tiangolo.com/tutorial/sql-databases/.

0.6.1Â¶

    Add docs for GraphQL: https://fastapi.tiangolo.com/advanced/graphql/. PR #48.

0.6.0Â¶

    Update SQL with SQLAlchemy tutorial at https://fastapi.tiangolo.com/tutorial/sql-databases/ using the new official request.state. PR #45.

    Upgrade Starlette to version 0.11.1 and add required compatibility changes. PR #44.

0.5.1Â¶

    Add section about helping and getting help with FastAPI.

    Add note about path operations order in docs.

    Update section about error handling with more information and make relation with Starlette error handling utilities more explicit. PR #41.

    Add Development - Contributing section to the docs. PR #42.

0.5.0Â¶

    Add new HTTPException with support for custom headers. With new documentation for handling errors at: https://fastapi.tiangolo.com/tutorial/handling-errors/. PR #35.

    Add documentation to use Starlette Request object directly. Check #25 by @euri10.

    Add issue templates to simplify reporting bugs, getting help, etc: #34.

    Update example for the SQLAlchemy tutorial at https://fastapi.tiangolo.com/tutorial/sql-databases/ using middleware and database session attached to request.

0.4.0Â¶

    Add openapi_prefix, support for reverse proxy and mounting sub-applications. See the docs at https://fastapi.tiangolo.com/advanced/sub-applications-proxy/: #26 by @kabirkhan.

    Update docs/tutorial for SQLAlchemy including note about DB Browser for SQLite.

0.3.0Â¶

    Fix/add SQLAlchemy support, including ORM, and update docs for SQLAlchemy: #30.

0.2.1Â¶

    Fix jsonable_encoder for Pydantic models with Config but without json_encoders: #29.

0.2.0Â¶

    Fix typos in Security section: #24 by @kkinder.

    Add support for Pydantic custom JSON encoders: #21 by @euri10.

0.1.19Â¶

    Upgrade Starlette version to the current latest 0.10.1: #17 by @euri10.

Previous
Repository Management
The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions
Made with Material for MkDocs



